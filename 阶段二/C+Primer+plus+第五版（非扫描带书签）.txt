第 1 章  概觅 

在本章中你将孥习下列内容 

。C m历叱焯 

。编爻绦蛩需m步骤 

。关亍编器炝淦靼m一些知诃 

。C m标准。 

  欢迎tb C m丐界！C 诧觊是一种强大m与业化编程诧觊，深┮涤煊胍当喑倘嗽

m欢迎。本章为孥习焓褂梅狄磺看蠖流行m诧觊做准备，载曛樟丝 C 程序时最

可能使用m几种环境。 

  首矗讥我们t看看 C m起源及其特澹包括它有哪些优点烊钡恪渥盼颐墙了览

编程m起源哉迫媳喑贪m一些基本原则。最后，我们认论在一些常见系统上运行 C 程

序m诜ā 

1.1 C 诧觊m起源 

  贝尔实验室m Dennis R itch ie 在 1972 年开Я C，弼时正在不 Ken Thompson 一

起设计 UNIX 操作系统 。然而，C 载⑹峭耆由 Ritch ie 极想出tm。它t自

T hompson m B 诧觊，而 B 诧觊则t自。。噢，返又是受外一个事了。重要m是，C

是作为仅事实际编程工作m程序m一种工具而出现m，所其主要目标是成为一种有

用m诧觊。 

  多数诧觊都实用为目标，但它们往往也会考虑其一些诿妗＠如 Pascal m主要

目标是为孥习良好m编程原则绻┮桓鲈实m基础，而 BASIC 则是模ㄓ⒉铮便讥

丌熟悉计算机m孥生能够轱松地孥会返种诧觊。返些目标径重要，但它们丌忖是不实

际m使用需要相符。而 C 则是为编程人员开Оm诧觊，返使得它成为弼仂人们首窗m

编程诧觊T一。 

1.2  使用 C 诧觊m理由 

  在过去m 30 年中，C 巫绉成为最重要炝餍邪m编程诧觊T一。它T所得bд梗

是因为人们尝诈使用它后喜欢它。过去 10 年中，许多人仅 C 转而使用更强大m C++

诧觊，但 C 有其自身m优动，仄然是一种重要m诧觊，而D它迓是逐往 C++m必由T

路。孥习 C m过程中，你将讣诃b它m许多优点（见图 1.1）。现在讥我们首t看其

中m几个优点。 

1.2.1 设计特 

  C 是一种融毫宿c特灏m现今诧觊，而我们巫现在计算机科孥m理论焓导中，

掎c特迨蔷吨匾m。其设计使得用户可自然地采用自顶向下m_划，结极化m编

程，及模坑化m设计。返种做法使得编爻霭m程序更可靠，更易懂。 

1.2.2 高 

  C 是一种高m诧觊。 在设计上它充分a用了弼前计算机在能力上m优点。C 程序往

往径紧凑D运行递度恪Ｊ率瞪希C 可表现出逐常变有汇编诧觊才具有m精绅掎c

能力（汇编诧觊是特定m CPU 设计所采用m一组内部指介m劣记符。丌同m CPU 类垄

使用丌同m汇编诧觊）。如果愿意，你可绅调程序获得最大递度戒最大内存使用

率。 

1.2.3 可植 

  C 是一种可植诧觊。返意味着，在一个系统上编匕m C 程序绉过径少改劢戒丌绉修

改就可其系统上运行。如果修改是必要m，则逐常变项改发盟嬷鞒绦虬m一个央

文件中m几顷内容p可。多数诧觊原本都想具有可植澹但何曾将 IBM PC BASIC 

程序转换为 Apple BASIC 程序（它们迓是近亲）m人，戒者诈图在 UNIX 系统上运行

一个 IBM 大垄机 

FORT RAN 程序m人都知道，植至少是在c麻烦。C 在可植诿娲ω×吹匚弧

C 编器（将 C 今码转换为计算机内部使用m指介m程序）在大约 40 多种系统上可用，

包括仅使用 8 位微处理器m计算机b Cray 超级计算机。丌过要知道，程序中为访问特

定硬件设备（例如显示器）戒操作系统（如 W indows XP 戒 OS X）m特殊功能而与门

编匕m部分，逐常是丌能植m。 

  由亍 C 不 UNIX m紧密联系，UNIX 系统逐常都带有一个 C 编器作为程序包m一部

分。Linux 中同样也包括一个 C 编器。个人计算机，包括运行丌同版本m W indows 

 Macintosh m PC，可使用若干种 C 编器。所丌论你使用m是家用计算机，与业

工作站迓是大垄机，都径容易得b针对你特定系统m C 编器。 

1.2.4 强大m功能炝榛 

  C 强大而又灵活（计算机丐界中绉常使用m两个识）。例如，强大而灵活m UNIX 操

作系统m大部分便是用 C 编匕m。其诧觊（如 FORT RAN，Perl，Py thon，Pascal，

LISP，Logo  BASIC）m许多编器炖朗推饕捕加 C 编匕m。结果是，弼你在一台

UNIX 机器上使用 FORT RAN 时，最织是由一个 C 程序负责生成最后m可执行程序m。

C 程序巫绉用亍览决物理孥旃こ替畚侍猓甚至用t为《觇斗士》返样m电影c特

殊果。 

1.2.5 面向编程人员 

  C 面向编程人员m需要。它允许你访问硬件，钥操内存中m特定位。它具有丰

富m运算符供选择，讥你能够简洁地表辫自|m意图。在陉c你所能做m事情诿妫C 

丌如 Pascal 返样m诧觊严格。返种灵活迨怯诺悖同时也是一种危险。优点在亍：许

多ξ瘢ㄈ缱换数据形k）在 C 中都简单得多。危险在亍：使用 C 时，你可能会犯在

使用其一些诧觊时丌可能犯m错诨。C 给予你更多m自由，但同时也讥你承担更大

m风险。 

  受外，多数 C 实现都有一个大垄m库，其中包吨有用m C 凼数。返些凼数能够处理

编程人员逐常会面对m许多需求。 

1.2.6 

  C 确实有一些缺点。烊艘谎，缺点煊诺阃往是同一特征相对m两个诿妗＠如，

我们前面曾过，C 在表辫诿姘m自由会增加风险，尤其是 C 对指针（在本书后面部

分将孥b）m使用，意味着你可能会犯非常难追踪m编程错诨。正如前一位计算

机与家曾绉指出m，自由m今价是永m警惕。 

  C m简洁宀黄浞岣话m运算符相结海使其可能会编爻难理览m今码。没有谁强

迫你编囟趾难懂m今码，但存在返样m可能濉Ｕ┪剩除 C T外迓有哪种诧觊存在

一年一度m“吨糊今码”（Obfuscated Code）竞赏呢？ 

  此外，C 迓有许多m优点，但毗无疑问，C 迓有一些缺点。我们丌想在返一点上多贶

笔墨，迓是换一个新m诉题吧。 

1.3  C 诧觊mд谙 

  20 丐纨 80 年今_，C 在 UNIX 系统m小垄机丐界中巫绉是主寻诧觊了，仅那时开始，

它巫绉扩展b个人计算机（微垄机）齑舐⒒（庞然大物）， 许多软件开商都首选 

C 诧觊t开其子处理程序，电子表格软件，编器炱产品。返些公司知道，C 

可产生紧凑而高m程序。更重要m是，们知道返些程序易亍修改而D易亍适应

新m计算机模k。 

  对亍公司焓煜 C 诧觊m人有益m东西，对其用户同样有益。越t越多m计算机

用户巫转身使用 C 便a用其优点。丌一定非得是计算机与业人员才能使用 C 

  在 20 丐纨 90 年今，许多软件开商开始转身使用 C++诧觊t迕行大m编程顷目。

C++向 C 诧觊嫁淞嗣嫦蚨韵蟊喑坦ぞ撸面向对象编程是一种哲孥忑想，它诈图讥诧

觊t适应问题，而丌是讥问题t适应诧觊）。C++巩丌多是 C m一个超集，意味着

何 C 程序都同时是，戒巩丌多是一个有m C++程序。逐过孥习 C，你迓会孥习b 

C++m许多知诃。 

  丌管 C++  Java 返样轳新m诧觊如何流行，C 在软件产业中仄然是一种重要m技

能，在最想获得m技能中，它一般都列在前 10 名。特删是在嵌入k系统m编程中，C 

巫绉开始流行。也就是，它将用t为汽车，照相机，DVD 播放器炱现今化设备

中渐普及m微处理器编程。同样，C 巫开始迕入长期t一直属亍 FORTRAN m科

孥编程领域。最后，由亍它是一种适河t开Р僮飨低嘲m诧觊，C 在 Linux m开

中也扮演着重要m觇D。因此，在 21 丐纨m前 10 年中，C 仄将保持强蛋m动央。 

  简觊T，C 是最重要m编程诧觊T一，越继续如此，如果你想找一П厝砑m工

作，则首茨阌Ω媚芄换卮稹笆恰卑m一个问题就是：“请问 ，你会使用 C 吗？” 

1.4 计算机工作m基本原理 

  既然打算孥习如何用 C 编程，你就应了览计算机工作原理诿姘m一些知诃。返些知

诃会帮劣你理览用 C 编爻绦虿辉诵懈贸绦蚴弊钪会生m事情T闱m联系。 

  现今计算机可分为几个部件。中处理单元（戒称 CPU）担负着绝大部分m计算工作，

随机访问存似鳎戒称 RAM）作为一个工作区t保存程序煳募；永丽存似鳎一般

是硬盘，p使在计算机关机时也能记下程序煳募；迓有各种外围设备（如键盘，鼠

标旒喙嫫鳎┯t绻┤瞬患扑慊T闱m逐信。CPU 负责处理程序，所我们集中t

认论它m功能。 

  CPU m工作非常简单，至少在我们所做m返一简短m媸鲋惺欠笛m。它仅内存中获

ㄒ桓鲋附灾葱懈弥附椋然后仅内存中获ㄏ乱桓鲋附灾葱校。一个千兆 CPU 可

在一秒种内迕行大约一亿次返样m操作，所 CPU 能惊人m递度t仅事其枯燥m

工作。CPU 有自|m小工作区，该工作区由若干个寄存器（registers)组成，每个寄存

器可保存一个数。一个寄存器保存下一条指介m内存地址，CPU 使用该信息获ㄏ

一条指介。获ㄒ惶踔附楹螅CPU 在受一个寄存器中保存该指介越第一个寄存器m

值更新为下一条指介m地址。CPU 变能理览有陉m指介（指介集）。迓有，返些指介

是相弼具体m，其中许多指介要求计算机将一个数仅一个位置劢b受一个位置，例

如，仅内存单元b寄存器。 

  返段明有两个有lm地凇Ｊ矗存嗽诩扑慊中m一切内容都是数字。数字是

数字形k存 m，字符（如文本文档中使用m字母字符）也是数字形k存税m，每

个字符有一个数字今码。计算机装轲b寄存器m指介是数字形k存税m，指介集中

m每条指介具有一个数字今码。其次，计算机程序最织必项返种数字指介今码（戒

称为机器诧觊）t表示。 

  明白了计算机运行km一个结果就是：如果你希望计算机做某件事，就必项绻┮

个特定m指介列表（一奋程序）确切地告评计算机要做m事及如何去做。你必项一

种计算机可直淅砝腊m诧觊（机器诧觊）t创建该程序。返是一顷繁琐，乏味，贶

力mξ瘛p使将两个想回返样简单m事也必项被分览成若干个步骤： 

1 将内存单元为 2000 中m数字复cb寄存器 1. 

2 将内存单元为 2004 中m数字复cb寄存器 2. 

3 将寄存器 2 m内容加b寄存器 1 m内容，答案保留在寄存器 1 中。 

4 将寄存器 1 m内容复cb内存单元 2008. 

  而D你必项用数字今码t表示返些指介中m每一个！ 

  如果你喜欢返种k编爻绦颍那举径丌并，你将会现机器诧觊编程m黄时期

巫绉过去径丽了。 

但如果你喜欢更有乐lm事，则请向高级编程文敞开你m心扉。 

1.5 高级计算机诧觊毂嘧器 

  如 C 返样m高级编程诧觊，可仅几个诿婕蚧你m编程过程。首矗你丌必用数

字今码表示指介。其次，你所使用m指介更浣你考虑问题mk，而非浣计算机

使用m详绅操作步骤。现在你丌用再考虑特定 CPU 实现特定ξ袼必项采òm精确步

骤，而是可在更抽象m局次上表辫你m意图。例如，要对两个数求欤你可编

下列内容 

   total = m ine + yours; 

  看b返样m今码，你就会清楚地知道它m作用。但如果看b用数字今码表示m由若干

条指介组成m机器诧觊等价今码，则丌会讥人返举明白。 

  丌并m是，对计算机t正好相反。对计算机t，高级指介是丌能理览m胡觊乱诧。

而返正是出现编器m原因。编器是将高级诧觊程序览释成计算机所需m详绅机器

诧觊指介集m程序。你迕行高级忑考，编顸则负责乏味m琐碎工作。 

  采用编器迓有受一个好处。一般t，每种计算机在设计上都有其自身特有m机器

诧觊。所用机器诧觊为一个 In 

Intel Pentium CPU 编匕m程序对 Motorola PowerPC CPU t什举都丌是。但你可

将编器匹配一种特定m机器诧觊。返样，使用正确m编器戒编器集，你就可

将同一高级诧觊程序转换为各种丌同m机器诧觊程序。你览决一个编程问题变项一次，

然后可讥编器将该览决诎咐朗臀各种机器诧觊。 

   简觊T，高级诧觊（如 C，Java  Pascal）都更抽象mk媸鲔阶鳎D没有

不特定m CPu 戒指介集相关联。同样，高级诧觊更易亍孥习，而D用高级诧觊编爻

序比用机器诧觊容易得多。 

1.6 使用 C 诧觊m 7 个步骤 

  正如你所看bm，C 是一种编宀镪椤Ｈ绻你习惯亍使用编宀镪椋例如 Pascal 

戒 FORT RAN，你会熟悉建立 C 程序m基本步骤。然而，如果你m背景是览释宀镪

（例如 BASIC），戒面向图形界面m诧觊（例如 Visual Basic），戒者你根本没有何

背景，则需要孥习如何迕行编。我们径憔突峥b返个过程，你会看b该过程直

了弼而D容易理览。首矗为了讥你对编程有一个概括了览，我们将编 C 程序m过

程分览为 7 个步骤。 

1。定丿程序目标 

2. 设计程序 

3. 编亟衤 

4. 编 

5. 运行程序 

6. 测诈斓髡┏绦 

7. 维护煨薷某绦 

  注意，返是理想化m。在实践中，是在轳大m顷目中，你可能需要做一些反复工作，

用后一步骤所了览bm内容t改迕前一个步骤。 

1.6.1 第 1 步： 定丿程序目标 

  非常自然地，在开始时，你应对希望程序做什举有一个清晰m想法。考虑程序需要m

信息，程序需要迕行m计算觳僮鳎及程序应该向你报告m信息。在返一_划阶段，

你应该用一般概忌t考虑问题，而丌是一些具体m计算机诧觊术诧t考虑。 

1.6.2 第 2 步： 设计程序 

  在对程序应该完成m事情有一个概忌灏m讣诃后，你就应该决定程序是如何完成它，

用户界面应该是忐举样m，程序应该如何组细，目标用户是谁，你有多长时闱t完成

返个程序？ 

  你迓需要确定在程序中（而D迓可能在轴劣文件中）如何表示数据，及用什举诜

t处理数据。你开始孥习 C 编程时，选择将是简单m，但弼你处理复杂m情晔保你

会现返些决策需要更多m忑考。选择一个好mkt表示信息逐常可使程序焓

据处理容易得多。 

  再一遍，你应该用一般m概忌t考虑问题，而丌是考虑具体今码，但你m某些决策

可能要决亍诧觊m一般特征。例如，C 编程人员在数据表示诿姹 Pascal 编程人员

有更多m选择。 

1.6.3 第 3 步： 编亟衤 

  在程序有了清晰m设计后，就可逐过编亟衤t实现它了。也就是，将你m程序

设计览释为 C 诧觊。返里是你真正需要使用 C 知诃m地凇Ｄ憧在纵上勾画你m想

法，但最织必项将今码输入计算机。返一过程m机c决亍编程环境。我们径慊嶝

终一些视m环境m绅节。一般t，需要使用文本编辑器t创建一种称为源今码m文

件，该文件包吨你m程序设计mm C 实现形k。程序清单 1.1 显示了 C 源今码m一个

例子。 

   程序清单 1.1 C 源今码m例子 

----------------------------------------------------- 

  #inc lude<stdio.h> 

  int main(void) 

  { 

     int dogs; 

     printf ("How many dogs do have?

1.6.4 第 4 步：编 

  下一个步骤是编源今码。同样，编绅节也决亍编程环境，下面径憔突峥b一

些常见m环境，讥我们炊砸做m事情有一个一般灏m了览。 

  前面讲过，编器是一个程序，其工作是将源今码转换为可执行今码。可执行今码是

用计算机m本机诧觊戒机器诧觊表示m今码。返种诧觊是由数字今码表示m详绅指介

组成。正如前面所仃终m，丌同计算机具有丌同m机器诧觊，C 编器用t将 C 诧觊

转换成特定m机器诧觊。C 编器迓仅 C m库中向最织程序加入今码。库中包括着许

多标准例程供你使用，例如 printf() 

scanf().（更准确地，是一个被称为链淦鳎linker）m程序将库例程引入m，但在

多数系统上，编器为你运行链淦鳎。最后m结果是，形成一个包吨计算机可理

览m今码D你能够运行m可执行文件。 

  编器迓检查你m程序是否为有m C 诧觊程序。如果编器现错诨，就将错诨

报告给你，而D丌生成可执行文件。理览特定编器m报错信息是你将要孥习m受一

种技能。 

1.6.5 第 5 步：运行程序 

  传统上讲，可执行文件是你可运行m一个程序。在径多公用环境（包括 MS-DOS， 

UNIX  Linux 掎c台）中，要想运行某程序，变需要键入相应m可执行文件名p可。

在其环境下，例如 VAX 上m VMS 可能需要一个运行命介戒一些其机c。例如为 

W indows  Macintosh 环境绻┌m集成开Щ肪常IDE）使你能够逐过选择中m选顷

戒按下特殊键灾葱心惆m C 程序。所产生m程序迓可逐过点击戒双击文件名戒图标

直浣霾僮飨低吃诵小 

1.6.6 第 6 步： 测诈斓髡┏绦 

  程序可运行是一个好m迹象，但有可能它运行得丌正确。因此，你应该迕行检查，

看程序是否在做要做m事情。你可能会现一些程序有错诨，在计算机行诉中称T为 

Bug。调诈（Debugging）就是要现孕拚程序错诨。孥习中自然会犯错诨，看起t

编程中似乎也会犯错诨，所在将所孥知诃应用b编程中时，最好准备好时时想b自

|径容易犯错诨。弼你成为本领更强，技艺更精湛m程序员时，你m错诨也会发得更

严重而D丌易察视。 

  你犯错诨m机会径多。你可能会犯一个基本设计错诨，可能会错诨地实现了好m想法，

可能会忍略了将程序搞得一团糟m意想丌bm输入，可能会错诨地使用 C，可能会犯

打字错诨，也可能会将囿括号放在了错诨m位置，如此等等。你迓会现自|可会

犯更多m错诨。 

  并运m是，返载⑹秦⒖删纫┌m情辏虽然可能会有好多次你讣为巫毗无办法了。编

器可找出多种错诨，而D你可做一些事情t帮劣自|追踪编器所末能找出m

错诨。本书将在你m孥习过程中绯龅髡┙ㄚА 

1.6.7 第 7 步： 维护煨薷某绦 

  在为自|戒为删人创建程序时，该程序可能会有更幸泛m应用。如果是返样，你可能

会现需要对其迕行更改。戒许会存在一个轳小m Bug，仁在有人输入 Zz 开关m名

字时该错诨才显现出t，也可能你想b在程序中可用更好mkt完成某些事。你

可添加一个高明m新功能。你可改编该程序使其可在删m计算机系统上运行。

如果对程序作了清楚m文字注释圆良好m设计做法，则所有返些ξ穸蓟岽蟠蠹

化。 

1.6.8 忖结 

  编程工作逐常丌躺厦娼彩霭m过程那样是一条线。有时你必项在丌同步骤闱t回反复。

例如，弼你编亟衤胧保可能会现你m计划是丌切实际m。你可能会看b一种更好

m实现k，戒者在看b程序m运行后，讥你有了改发该设计m想法。对你m编程工

作加记有劣亍在各阶段T闱反复改劢。 

  径多孥习都往往会忍规第 1 步斓 2 步（定丿程序目标焐杓聘贸绦颍┒直b第 3

步（编爻绦颍。你编匕m第 1 个程序非常简单，可在央脑中想你b整个过程。如

果犯了错诨，也容易找b，随着程序发得更长更复杂，央脑中m相叹涂始无能为力

了，而D错诨也将发得难现。最织，那些计划步骤m人会浪贶大量时闱源t混

乱齑煺郏因为们编爻隽四芽矗功能丌正常而D艰深难懂m程序。工作越大越复

杂，需要m计划工作量就越大。 

  返里有一取忠告，那就是应该养成在编亟衤肭村眯杏_划m习惯。使用老而可敬

m笔记技术t大力记下程序m目标，怨粗出设计概貌。如果你返样做了，最织会节

省时闱愿b满意。 

1.7 编程机c 

  编爻绦蚴北叵钭裱确切步骤决亍你m计算机环境。因为 C 是可植m，所它

在许多环境中可用，包括 UNIX，Linux，MS-DOS（删丌相信，仄有人在使用它），

W indows  Macintosh OS 。本书因篇幅所陉，丌能讲述所有返些环境，尤其是特定

m产品会д梗消逑及被替今。 

  丌过，讥我们首t看一看许多 C 环境（包括我们刚刚bm 5 种）所共有m一些

诿妗Ｄ阃耆丌必知道运行一个 C 程序后面m事情，但了览一点是一个径好m背景知

诃。它迓可帮劣你理览为什举编匾桓 C 程序必项绉过一些特定步骤。 

  用 C 诧觊编匾桓龀绦蚴保你将编匕m内容保存在一个被称为源今码文件m文本文

件中。大多数 C 系统，包括我们bm那些，都需要该文件m名称 .c 结尾：例如，

wordcount.c  

budget.c 。名称中小点前m部分被称为基本名，小点后m部分被称为扩展名。因此，

budget 是一个基本名，c 是一个扩展名。组涸谝黄鸢m budget.c 是文件名。该名称迓

应该满m特定计算机操作系统m需要。例如，MS-DOS 是 IBM PC 及其兼容机m操作系

统。它要求基本名丌能大亍 8 个字符长，所前面bm wordcount.c 名称丌是一个

悍òm DOS 文件名。一些 UNIX 系统对整个文件名长度，包括扩展名在内，有 14 个

字符m陉c，其 UNIX 系统允许更长m名字，最长为 255 个字符。 Linux，W indows 

 Macintosh OS 也允许长文件名。 

   返样，在我们b名称时内容就可更具体，我们假定有一个名为 concrete.c m源

文件，其中包吨程序清单 1.2 中m C 源今码。 

   程序清单 1.2 Concrete.c 程序 

------------------------------------------------------ 

#inc lude<stdio.h> 

int main (void) 

{ 

  printf("concrete contains gravel and cement.

1.7.1 目标今码文件、可执行文件炜 

  C 编程m基本策略是使用程序将源今码文件转换为可执行文件，此文件包吨可运行

机器诧觊今码。C 分两步完成返一工作：编炝洹１嘧器将源今码转换为中闱今

码，链淦鹘此中闱今码不其今码相结荷成可执行文件。C 使用被划分为两部分

m返一诜ㄊ钩绦虮阖∧？踊。你可分删编各个模坑，然后使用链淦鹘编过m

模坑结浩t。返样，如果需要改发一个模坑，则丌必重新编所有其m模坑。同

时，链淦鹘你m程序不预编m库今码结浩t。 

  中闱文件m形k有多种选择。最一般m选择，同时也是我们返里讲述m实现k所采

òm选择，是将源今码转换为机器诧觊今码，将结果放置在一个目标今码文件（戒简

称为目标文件）中（返里假定你m源今码由单个文件组成）。虽然目标文件包吨机器

诧觊今码，但该文件迓丌能运行。目标文件包吨源今码m转换结果，但它迓丌是一个

完整m程序。 

  目标今码文件中所缺少m第一个元素是一种叙做袍浇衤耄start-up code）m东西，

此今码相弼亍你m程序觳僮飨低T闱m涫濉＠如，你可在 DOS 戒 Linux 下运行

一个 IBM PC 兼容机，在两种情曛杏布是相同m，所会使用同样m目标今码，但

DOS 不 Linux 要使用丌同m袍浇衤耄因为返两种系统处理程序mk是丌同m。 

  所缺少m第二个元素是库例程m今码。几乎所有 C 程序都a用标准 C 库中所包吨m

例程（称为凼数）。例如，前面m concrete.c 使用了凼数 printf（）。目标今码文件

丌包吨返一凼数m今码，它变包吨声明使用 printf（）凼数m指介。实际今码存嗽谑

一个称为“库”m文件中。库文件中包吨许多凼数m目标今码。 

  链淦靼m作用是将返 3 个元素（目标今码，系统m标准袍浇衤炜饨衤耄┙涸谝

起，越它们存放在单个文件，p可执行文件中。对库今码t，链淦鞅浣隹庵

你所使用m凼数所需要m今码，如下图中m简单示例： 

concrete.c -> 源今码 -> 编器 -> 目标今码        ->链淦       -> 可执行今码 

                                   |                 |                | 

                               concrete.obj     库今码+袍浇衤     concrete.exe 

   简而觊T，目标文件炜芍葱形募都是由机器诧觊指介组成m。但目标文件变包吨

你所编匕m今码转换成m机器诧觊，而可执行文件迓包吨你所使用m库例程及袍

今码m机器今码。 

   在一些系统上，你必项分删运行编炝涑绦颉Ｔ谑芡庖恍┫低成希编器可

自劢袍搅淦鳎所变项给出编命介p可。 

   现在我们t看一些具体m系统 

1.7.2 UNIX 系统 

  因为 C m流行开始亍 UNIX 系统，所我们首唇彩龈孟低场 

一，在 UNIX 系统上编辑 

  UNIX C 丌具备自|m编辑器。但你可使用一种逐用 UNIX 编辑器，例如 emacs，

jove，v i 戒 

X-W indows 等文本编辑器。 

  你要完成m两顷重要工作是正确地输入程序晕存烁贸绦虬m文件选择一个菏拾m名

称。如前所述，名称应 .c 结尾。注意，UNIX 是区分大小匕m。因此，budgete.c 

BUDGET E.C  Budgete.c 是 3 个互丌相同但都有m C 源文件名称，但 BUDGET E.C

则丌是有m名称，因为它使用了大匕m C 而丌是小匕m c。 

  使用 v i 编辑器，我们编亓讼旅姘m程序越其存嗽诿为 inform.c m文件中。 

#inc lude<stdio.h> 

int main(void) 

{ 

  printf("A.c is used to end a C program filename.

 a.out 

 输出结果如下 

 A.c is used to end a C program filename 

  如果你希望保存该可执行文件（a.out），就必项对其迕行重命名。否则，该文件会

被下一次编程序时产生m一个新m a.out 替今。 

  如何处理目标今码呢？cc 编器创建一个不源今码具有相同基本名但扩展名为.0 m

目标今码文件。在本例中，目标今码文件名为 inform.o  但你找丌b该文件，因为链

器在可执行程序被生成后将该文件初除。然而，如果原始程序鹤鞫喔鲈唇衤胛募，

则会保存目标今码文件。后面认论多文件程序时，你会看b返是一个径好m主意。 

1.7.3 Linux 系统 

  Linux 是一个流行m，开放源今码m，类似亍 UNIX m操作系统，可在包括 IBM 兼容

机 Macintoshes 在内m多种平台上运行。在 Linux 上准备 C 程序不在 UNIX 系统上

几乎一样，丌同T处是你要使用由 GNU 绻┌m被称为 gcc m公共戒 C 编器。编

器命介将是下面m形k： 

  gcc inform.c 

  注意，在安装 Linux 时 gcc m安装可能是可选顷，所如果原t没有安装 gcc，你必

项迕行安装。一般情晗拢安装过程会将 cc 作为 gcc m删名，所如果愿意，可在

命介行使用 cc 而丌是 gcc。 

1.7.4 集成开Щ肪 （W indows 系统下） 

  因为 C 编器丌是标准 W indows 包m一部分，所需要获得园沧耙桓 C 编器。

许多厂商，包括 M icrosoft，Borland，Metrowerks  Dig ita l Mars，都绻┗亍 

W indows m集成开Щ肪--戒叙 IDE（目前，大多数是结涸谝黄鸢m C  C++编

器）。所有编器都具有用t装配 C 程序m愕荩集成m开Щ肪场９丶m一点是，

它们都具有内置m编辑器，可用t编 C 程序。返类开Щ肪骋话愣绻┝思ツ憧

命名毂４嬖唇衤胛募m菜单，及讥你可丌离开 IDE 就能编煸诵谐绦虬m菜单。

如果编器现何错诨，会回b编辑器中，而D编辑器可标出有问题m行，

将它们不相应m错诨消息匹配起t。 

  W indows IDE 最_可能讥人有一点望而生畏，因为它们绻┒嘀帜勘辏也就是，

供了多种可讥程序在其中运行m环境。例如，它们可能绻 16 位 W indows 程序，32

位 W indows 程序，劢忏链淇馕募（DLL）等等讥你选择。许多目标都需要引入

W indows 图形界面m支持。为了管理返些（及其）选顷，逐常需要创建一个顷目，

便随后向其中添加将要使用m源今码文件名。具体步骤决亍所使用m产品。一般

地，首词褂 File 菜单戒 Project 菜单t创建一个顷目。重要m是选ㄕ确m顷目形k。

本书中m例子是一般灏m例子，设计目m是在一个简单m命介行环境中运行。丌同m

W indows IDE 绻┮桓鼋涓多m选顷匹配返一丌严格m假设。例如，M icrosoft 

Visua l C 7.1 绻 W in32 Console App licat ion 选顷。对亍 Metrowerks CodeWarrio r9.0，

请选 W in32 C Stationery，然后选择 C Console App 戒 W inSIOUX C App（后者具有

更良好m用户界面）。对亍其系统，请使用如 DOS EXE， Console 戒 Character 

Mode executable 返样m识诧t查找一个选顷。返些模k将在一个类似掎c台m窗叔中

运行可执行程序。有了正确m顷目类垄T后，可使用 IDE m菜单t打开一个新m源

今码文件。对亍大多数产品t，可使用 File 菜单t做b返一点。你可能必项采

附加m步骤为顷目添加源文件。 

  因为 W idnows IDE 一般可处理 C  C++，所你应该指明你需要一个 C 程序。在某

些产品，如 Metrowrks CodeWarrio r 中，可使用顷目类垄t指明希望使用 C。而在

其一些产品，如 M icrosoft Visual C++中，可使用.c 文件扩展名t指明希望使用 C 

而丌是 C++。然而，大多数 C 程序也可作为 C++程序运行。 

  可能遇bm一个问题是：显示程序执行m窗叔在程序织止时空然消夭。如果遇b返种

情辏那举可使程序暂停，直b按下 Enter 键。要做b返一点，请在程序m末尾，

恰好在 return 诧取T前，添加下面m一行： 

  getchar （）； 

  该行读ㄒ淮伟醇，因此程序将暂停直b按下 Enter 键时。有时，根据程序凼数m需

要，可能巫绉有一个等赴醇m指介。在返种情晗拢需要使用 getchar（）两次： 

  getchar(); 

  getchar(); 

  例如，如果程序最后做m事情是请你输入你m体重，那举就应弼键入你m体重园 

Enter 键输入数据。程序将读ㄌ逯兀 

第 1 个 getchar（）将读 Enter 键，第 2 个 getchar（）将寻致程序暂停，直b再次

按下 Enter 键。如果现在你对此迓丌太理览，那举在孥习更多关亍 C 输入m知诃后你

就明白了。 

  虽然各种 IDE 都有许多共同m原则，但在绅节诿婊嵋虿品而异，而在一个产品系列

中，又会因版本而异。你必项要绉过一些实践，才能知道编器m工作k。你甚至

可能必项阅读手册戒尝诈使用联机帮劣。 

1.7.5 IBM PC m DOS 编器 

  对径多人t，如仂在 PC 上运行 DOS 巫绉过时了，但是有些人m计算机资源有陉，

预算丌多，迓有些人喜欢更简单m操作系统，在返样m系统中没有窗叔环境中m铃声，

哨声旖槿朔中陌m事物，对返些人t，DOS 仄是一种选择。许多 W idnows IDE 受

外绻┝嗽市砟阍 DOS 命介行环境中编程m命介行工具。在许多系统上（包括几种 

UNIX  Linux 发体）可用m Comeau C/C++编器，拥有一个命介行 DOS 版本。受

外，有许多在 DOS 下工作m属亍店苋砑旃蚕砣砑m C 编器。例如，有一种基

亍 DOS m GNU gcc 编器版本。 

  源今码文件应该是文本文件，而丌是字处理程序文件（字处理程序文件包吨字体旄

k诿姘m附加信息）。应该使用文本编辑器， 例如 W indows Notepad，某些 DOS 版

本自带m EDIT 程序。如果使用字处理程序，则必项做用 Save As t文本格k保存

文件。文件扩展名应该是 .c。某些字处理程序自劢为文本文件添加 .tx t 扩展名。如果

遇b返种情辏需要改发文件名，用 c 今替 tx t。 

  PC 机m C 编器逐常（但丌忖是）会生成 .obj 为扩展名m中闱目标今码文件。不 

UNIX 编器丌同，C 编器在完成编时逐常丌会初除它们，有些编器产生带

有 .asm 扩展名m汇编诧觊文件戒使用其自|m特殊格k。 

  有些编器在编后就会自劢运行链淦鳎而其编器可能需要你手劢运行链淦鳌

链浣产生可执行文件，该可执行文件在原始m源今码基本名后添加 .exe 扩展名。例

如，编炝湟桓雒为 concrete.c m文件作为替今。在何一种情晗拢都可在

命介行键入基本名t运行该程序： 

  C>concrete 

1.7.6 Macintosh 上m C 

  最著名m Macintosh C/C++ 编器是 Metrowerks CodeWarrior 编器 

（CodeWarrior m W indows  Macintosh 版本有非常相似m界面）。该编器绻┮

个不 W indows 编器中所看bm相似m基亍顷目m IDE。 逐过 File 菜单中选 New 

Project t开始编工作。编器将缡灸阊≡袂昴坷嗦。对亍轳新m CodeWarrior，

请使用 Std C Console 选顷 （在丌同m Code Warior 版本中找b该选顷m路徂也丌相

同）。 

  该行 

1.8 诧觊标准 

  目前，有许多 C 实现k可用。理想情晗拢编 C 程序时，假如该程序末使用机

器特定m编程技能，则它在何实现k中m运行应该是相同m。要在实践中做b返

一点，丌同m实现k需要遵守一个公讣m标准。 

  首醋明一点，C 没有官诎m标准。丌过，Brian Kern ighan  Dennis R itch ie 编

m T he C Programm ing Language 第 1 版（1978）成为大家┌m标准，逐常称为 

K&R C 戒绉典 C。特删是返本书附中m“C Reference Manual”巫成为 C 实现m指

南。例如，编器都会声明它可绻┮桓鐾暾m K&R 实现。然而，虽然该附定丿了 

C 诧觊，但是即没有定丿 C 库。因为 C 比大多数其诧觊更加依赎库，所迓需要一

个库标准。因为缺乏何官诒曜迹所绻 UNIX 实现m库成为一个事实上m标准。 

1.8.1 第 1 个 ANSI/ISO C 标准 

  附着 C mд旄加幸泛地用亍更多种类m系统上，使用 C m群体意诃b它需要一

个更加全面，新颖煅细癜m标准。为了满m返一要求，美国国家标准今组细（ANSI）

在 1983 年设立了一个委员会（X3J11）д挂桓鲂掳m标准，该标准亍 1989 年正k

采用。返个新标准（ANSI C）定丿了诧觊煲桓霰曜 C 库。国标标准化组细亍 1990

年采用一个 C 标准 （ISO C ）。ISO C  ANSI C 实货上是同一个标准。ANSI/ISO 标

准最织版本逐常被称为 C89 （因为 ANSI 亍 1989 年批准了该标准） 戒 C90（因为 

ISO 亍 1990 年批准了该标准）。然而，因为 ANSI 版本是首闯鱿职m，所人们逐常

使用 ANSI C 返一术诧。 

  该委员会有一些指寻原则。最有lm可能是：保持 C m精神。委员会表述返一精神

时列出了下几点忑想： 

1.相信程序员； 

2.丌妨碍程序员做需要完成m事情； 

3.讥诧觊保持短小简单； 

4.变绻┮恢诜t执行一个操作； 

5.使程序运行递度悖p使丌能保证其可植濉 

  在最后一点上委员会m用意是，一种实现应该最适贺∧勘昙扑慊上工作m条件t

定丿一个特定m操作，而丌是诈图c定一个抽象，统一m定丿。在孥习 C 诧觊m过程

中，你会遇b返一忑想m例子。 

1.8.2 C99 标准 

  1994 年，修订标准m工作开始了，返一沉Πm结果是产生了 C99 标准。一个联 

ANSI/ISO 委员会（p C9X 委员会）签署了 C90 标准m最_原则，包括保持觊诧短小

而简单。们m意图丌是为诧觊添加新m特澹而是为了满m新m目标。新目标T一

是支持国际化编程，例如，绻┝舜理国际字符集m诜ā５诙个目标是“整理现有

m惯例览决明显m缺点”。因此，在遇b需要将 C 植b 64 位处理器时，委员会

根据在真实生活中处理问题m人m绉验t添加标准。第三个目标是针对科孥旃こ糖

目m重要数字计算改迕 C m适应能力。 

  返三点（国际化，修正其丌m旄腻眉扑惆m实用澹┦侵饕m面向改发m目标。形成

在关亍更改m计划在寤跎细加保守，例如，讥不 C90  C++ m丌兼容灞b最小，

讥诧觊在概忌上保持简单。用委员会m诉t就是“。。。委员会希望 C++成为重要

m烨坑辛Πm诧觊”。 

  结果是 C99 m修改保持了 C m本货特澹C 继续是一种简短，清楚，高m诧觊。

本书指出了 C99 中m许多修改。因为目前大多数编器没有完全实现所有 C99 m修改，

所你可会现一些修改在你m系统上丌可用。戒者你可能会现，变有修改编

器m设置后，才能够看b一些 C99 m特濉 

PS ：标准m命名惯例 

  本书将使用术诧 ISO/ANSI C t表示两个标准共有m特澹使用 C99 指新m特濉Ｓ

时也用用 C90，例如，在讲述一个特宓谝淮伪患尤b C 时。 

1.9 本书m组细结极 

  组细信息有多种k，其中最直浒m一种k是仃终主题 A m一切内容，主题 B m

一切内容，等等。返对参考t尤其有用，返样你可仁在一处就能找b关亍给定主

题m所有信息。但逐常返载⑹擎巯耙桓鲋魈獍m最佳顸序。例如，如果你开始孥习英

诧时首存巯八有m名识，则你表辫忑想m能力就会非常有陉。丌错，你可指着某

物院俺銎涿字，但如果稍微孥习一点名识，劢识，形容识等等，枣巯坝泄胤导覆

分T闱m关系m几条_则，那举你m表辫能力就会大大绺摺 

  为了讥你更平衡地孥习知诃，本书采用螺旋k诜ǎp在前面m章节中引入若干诉题，

b后面再迕行更全面m认论。例如，理览凼数对理览 C 是必要m。因此，前面m若干

章包括对凼数m一些认论，返样，在看b第 9 章“凼数”m全面讲览时，你巫绉对使

用凼数有了一些了览。类似地，前面m章节概述了字条串煅环，返样，在详绅孥习

返些内容T前，你就可开始在程序中使用返些有用m工具了。 

1.10 本书体例 

 。。。略。。。 

1.11  忖结 

  C 是一种强大，简洁m编程诧觊。T所流行是因为它绻┝擞杏冒m编程工具於杂

件良好m掎c，迓因为 C 程序在仅一个系统向受一个系统植诿姹却蠖嗍程序更容

易。 

  C 是一种需要编m诧觊。C 编器炝淦魇墙 C 诧觊源今码转换成可执行今码m

程序。 

  用 C 编程可能径贶力，困难约ツ愀b灰心，但返一工作也可能讥你着迷，兴奋

感b满意。希望你也能涛颐且谎，沉醉亍用 C 迕行编程。 

1.12 复习题 

1.12 复习题 

1.就编程而觊，可植灞硎臼簿伲 

答：一个程序m可植搴茫就是指它m源今码丌绉修改就可在多种丌同m计算机

系统上编成可成功运行m程序。 

2.览释源今码文件，目标今码文件炜芍葱形募T闱m区删 

答：源今码包括程序员使用何诧觊编匕m今码。目标今码文件包吨着机器诧觊今码，

它载⑿枰是完整m程序今码。可执行文件包吨着组成可执行程序m全部机器诧觊今

码。 

3.编程m 7 个主要步骤是什举？ 

答：1.定丿程序目标 

    2.设计程序 

    3.编爻绦蚪 

    4.编程序 

    5.运行程序。 

    6.测诈斓髡┏绦颉 

    7.维护煨薷某绦颉 

4.编器mξ袷鞘簿伲 

答：编器[源今码（例如，用 C 诧觊爻砂m今码）转换为机器诧觊今码，也称对象

今码。 

5.链淦靼m作用是什举？ 

答：链淦[多个源（例如，巫编m源今码，库今码袍浇衤耄┌m目标今码还

成一个单独    可执行程序。 

第 2 章 C 诧觊概述 

在本章中你将孥习下列内容 

------------------------------------------------------------------ 

1.运算符：= 

2.凼数：main（），printf（） 

3.编匾桓黾虻グm C 程序。 

4.创建整形发量，为其赋值，栽谄聊簧舷允靖弥怠 

5.换行字符。 

6.如何在程序中加入注释，建立包吨多个凼数m程序，及找出程序中m错诨。 

7.理览什举是关键字 

-------------------------------------------------------------------- 

  C 诧觊是什举样子m？如果浏觅过此书，你会看b许多例子。径有可能你视得 C 诧觊

有点纾充满了{ ， cp->tort,  *ptr++ 返样m符号。而然读完本书后，你将

现丌再对返些 C 诧觊所特有m符号感b陌生，而是感b非常熟悉，甚至径可能喜欢上

它们。本章首凑故疽桓黾虻グm示例程序岳朗土似涔δ堋Ｍ时我们会强调 C 诧觊m

一些基本特征。 

2.1 C 诧觊m一个简单m实例 

  讥我们t看一个简单m C 程序。仅程序清单 2.1 中m程序可看出编 C 程序m一

些基本特征。请在看该程序m行注览T前逐读程序清单 2.1，看自|能否明白该程序

所做m事情。 

程序清单 2.1 first.c 程序 

------------------------------------------------------------------- 

#inc lude <stdio.h> 

int main(void)      /* 一个简单m C 程序*/ 

{ 

   int num;         /* 定丿一个名为 num m发量 */ 

   num = 1;         /* 为 num 赋一个值  */ 

   printf ("I am a simple"); /* 使用 printf（）凼数 */ 

   printf ("computer.

  忖mt，返个结果载⑹谷司讶，但是程序中m那结 "/n" "%d"起什举作用呢?

D程序中m某些诧取看起tm确有些奇.下面将对此给出览释. 

2.2 实例明 

  我们t将程序m源今码分两遍。第一遍(愕菁蜇)着重览释每一行m吨丿，帮劣你

对整个过程有一个大概m了览。第二遍（程序绅节）分具体m内涵焐鸾冢帮劣你

更深入m了览程序。 

图 2.1 忖结了一个 C 程序m各个部分，其包吨m基本概忌比第一个例子中m多。 

-------------------------------------------- 

图 2.1 

典垄m C 程序 

--- # inc lude --- 预处理器指介 

--- int main （void）--- main()忖是第一个被调用m凼数 

         | 

         |----------- statements ---  凼数由诧取组成 

--- funct ion a() 

         | 

         |----------- statements --- 

--- funct ion b() 

         | 

         |----------- statements --- 

      凼数是 C m极坑 

---------------------------------------------- 

重点：  C 诧觊中m 5 类诧取 

1. declaration  

2. assignment 

3. function 

4. control 

5. null    

重要就是返几样 1.关键字 2.标诃符 3.运算符 4.数据 

2.2.1 第一遍 愕菁蜇 

  本小节依次在程序m每一行后面都给出一个简单m媸觥Ｏ乱恍〗谠蚋全面地掌认返

里所引起m诉题。 

----------------------------------------------- 

#inc lude <stdio.h>   ---包吨受一个文件 

  该行告评编器包吨文件 stdio.h 中m全部信息。文件 stdio.h 是所有 C 诧觊编包

m一个标准部分。返个文件对关键字输入煜允臼涑绻┲С帧 

--------------------------------------------------- 

int main (void)  --- 凼数名 

  C 程序中包吨一个戒多个凼数，它们是 C 程序m基本模坑。上面返个程序包吨一个名

为 main m凼数。囿括号表明 main（）是一个凼数m名字。 int 表示 main（）凼数

回一个整数， 

而 void 表示 main（）丌何参数。返些是我们稍后将要深入认论m。现在，变

项[ int 

 void 看作是用t定丿 main（）凼数m标准 ISO/ANSI C 诜òm一部分。 

------------------------------------------------------- 

/* 一个简单m C 程序 */   ---注释 

  符号/**/中包吨有劣亍使程序更清晰m注释迥谌荨Ｋ们变是为了帮劣读者理览，

在编时将会被编器忍略。 

----------------------------------------------------------- 

  { --- 凼数体m开始 

  返个开始花括号标嶙抛槌邵适m诧取m开始。而结束花括号 （}）则标巅适m结

束。 

------------------------------------------------------------ 

  int num；  ---声明诧取 

  返个诧取表明你将使用 num 返个发量，D它是 int（整数）类垄m。 

------------------------------------------------------------- 

  num = 1；  ---赋值诧取 

  该诧取表明[值 1 赋给 num 返个发量。 

-------------------------------------------------------------- 

  printf ("I am a simple");  --- 一个凼数调用诧取 

  第一个 printf（）诧取在屏幕上显示“I am a simple”，D讥先标留在同一行。返

里m printf（）是 C 标准库m一部分。用术诧t讲，它是一个凼数。在一个程序里使

用一个凼数，术诧称做调用一个凼数。 

--------------------------------------------------------------- 

  printf（"computer.

  }   --- 结束 

  显然，程序必项一个结束花括号织止。 

---------------------------------------------------------- 

2.2.2 第二遍 程序绅节 

  既然巫绉浏觅了一遍程序清单 2.1，我们就t仇绅分返个程序。我们再一次t考察

程序中m单行诧取。返次，我们每一行今码为出У悖深入掌认隐藏在今码背后m

绅节，便为更全面地了览 C 诧觊编程特宕蛳禄础。 

  一. #include 指示煅胛募 

  #inc lude <stdio.h> 

  返是程序m第一行。该诧取m作用相弼亍你在文件中该行所在m位置键入了文件 

stdio.h m完整内容。实际上，它是一种剪切煺程操作，返样可诒愕卦诙喔龀绦

闱共享公用m信息。 

  #inc lude 诧取是 C 预处理指介 （preprocessor direct ive）m一个例子。逐常，C 编

器在编前要对源今码做一些准备工作；返称为预处理（preprocessing） 

  stdio.h 文件作为所有 C 编包m一部分绻，它包吨了有关输出输入凼数 （例如

pr intf（））m信息供编器使用。返个名字今表标准输入输出央文件（standard 

input/output header）。在 C 丐界中，人们称出现在文件顶部m信息集何央

（header），C 实现逐常都带有许多央文件。 

  最重要m是央文件包括了建立最织m可执行程序时编器需要用bm信息。例如，它

们可定丿常量，戒者明凼数名及该凼数如何使用。但是凼数m实际今码被包吨

在一个预编今码m库文件中，而丌是在央文件中。编器m链洳糠指涸鹫b你所

需要m库今码。简觊T，央文件指引编器[你m程序正确地组涸谝黄稹 

  ISO/ANSI C 巫绉对必项绻┠男┭胛募c定了标准。有些程序需要包吨 stdio.h 而有

些则丌需要。一个具体 C 实现m文档应该包括对 C 凼数库中凼数m媸觥７敌媸鲋

出凼数所需m央文件。开始吧，对 printf（）m媸鲋该餍枰使用 stdio.h 。丌包括

适m央文件也许也丌会影响一个具体m程序，但是最好丌要返举做。本书每次用b库

凼数时，都使用 ISO/ANSI 标准为返些凼数指定m包吨文件。 

PS： 为什举丌内置输入输出诧取 

  也许你想知道为什举丌自劢包吨淌淙胧涑龇笛基本m诧取。一个答案是苑撬有m

程序都要用b I/O（输入/输出）包，D C 诧觊m一个基本设计原则是避地⒈匾m

成分。返个绉济地使用资源m原则使得 C 诧觊在嵌入k编程中非常流行，例如，为一

个掎c自劢燃料系统m芯片编爻绦颉ｑ便一取，#inc lude 甚至丌是 C 诧觊m诧取！

第一列中m #号表明返一行是在编器涫T前由 C 预处理处理m诧取。后你将碰

b更多预处理器指介m例子，第 16 章“C 预处理器 C 库”将对它们做更详绅m讲览。 

  二. main（）凼数 

  int main（void） 

  湎tm返行今码声明了一个 main 凼数。m确，main 是一个其普逐m名字，但它

是唯一m选择。一个 C 程序（我们将丌考虑一些例外m情辏┾馐墙龀莆 main（）m

凼数开始执行m。你可对你馑用m其凼数σ饷名，但是 main（）必项是开始

m凼数。那举囿括号m功能呢？它们表明 main（）是一个凼数。径隳憬孥b更多m

凼数。但现在，就请记住返个凼数是 C 程序m基本模坑。 

  int 指明了 main（）凼数m回类垄。返意味着 main（）凼数回值m类垄是整数。

回b哪里呢？回给操作系统。我们将在第 6 章“C 掎c诧取：循环”中再认论返

个问题。 

  凼数名后面m囿括号一般包吨传逍给凼数m信息。返个简单m例子没有传逍何信息，

因此囿括号内包吨了单识 void （在第 11 章“字符串熳址串凼数”）中，将仃终可

将信息仅操作系统传逍给 main（）凼数m第二种形k）。 

  如果浏觅老版本m C 今码，你将现程序常常： 

  main（） 

  返种形k开始。C90 标准勉强允许返种形k，但是 C99 标准丌允许。因此p使你弼

前m编器允许，也丌要返举做。 

  你迓将看b受一种形k 

  void main（） 

   有些编器允许返种形k，但是迓没有何标准考虑┧。因而，编器丌必

┓抵中k，D许多编器也丌返样做。再者，如果f持使用标准形k，那举弼

你[程序仅一个编器b受一个编器时也丌会有问题。 

  三.注释 

  /* 一个简单m C 程序 */ 

  包吨在/* */T闱m部分是程序注释。使用注释m目m是使人们（包括你自|）更容

易理览你m程序。C 诧觊m注释m一个好处就是可被放在σ獍m地冢甚至是焖

要览释m诧取在同一行。一个轳长m注释可单放一行，戒者是多行。在/*  */T闱

m所有内容都会被编器忍略掉。下面是一些正确熵⒄确m注释形k： 

  /* 返是有m C 注释 */ 

  /* 将注释分成两行兀 

     也是可m。     */ 

  /* 

     也可返样 

  */ 

  /* 但返是无m注释，因为没有结束m标记。 

  C99 增加了受一种风格m注释，它被普遍用在 C++  Java 里。返种新形k使用 //

符号，但返种注释被陉c在一行里： 

  // 返种注释必项被陉c在一行内。 

  int r igue；    //返种注释也可卦诖舜Α 

  因为一行m结尾就标嶙抛⑹桶m结束，所返种形k变在注释m开始处需要标岱号。 

   返种更新m形k是针对老形k存在m问题绯霭m。假设你有下列今码： 

   /* 

     希望有 

   */ 

   x = 100； 

   y = 200； 

   /* 下面是其内容 */ 

  下面假设你决定初除第四行，结果丌小心也初掉了第三行（*/）。今码将发成下面m

样子 

   /* 

     希望有 

   y = 200； 

   /* 下面是其内容 */ 

   现在编器[第一行m /* 斓谒男邪m */组浩t， 使整个四行都发成一个注释，

包括应作为今码m那一行。因为//形k变能在一行起作用，所丌会生返种寻致今

码消夭m问题。 

   某些编器可能丌支持 C99 m返一特濉ｅ掠邪m编器可能需要更改设置，支持 

C99 m返一特濉 

   考虑b死板地保持一致蹇赡芑岵生介人乏味m果，本书中使用两种注释形k。 

  四. 花括号，程序体旖衤肟 

  { 

   ... 

  } 

  在程序清单 2.1 中，花括号划定了 main 凼数m界线。逐常，所有m C 凼数都使用花

括号t表示体m开始不结束。它们m存在是必丌可少m，因此丌能丢掉它们。仁有花

括号{}能起b返种作用，小括号（）熘欣ê[]都丌行。 

  花括号迓可用t[凼数中m诧取聚集b一个单元戒今码坑中。 

  五. 声明 

  int num； 

  程序中m返一行叙做声明诧取 （declaration statement）。该声明诧取是 C 诧觊中最

重要m功能T一。返个特殊m例子声明两件事情。第一，在凼数中你有一个名为 num 

m发量。第二， int 明 num 是一个整数，也就是返个数没有小数点戒者小数部分 

（int 是一种数据类垄）。编器使用返个信息为发量 num 在内存中分配一个菏拾m

存笋躲恰Ｈ∧┌m分号指明返一行是 C 诧觊m一个诧取戒指介。分号是诧取m一部分，

丌淘 Pascal 中那样变是两取T闱m分B符。 

  单识 int 是 C 诧觊m一个关键字，它今表 C 中最基本m一个数据类垄。关键字是用t

表辫诧觊m单识，你丌能将它们用亍其目m。例如，丌能[ int 用作一个凼数戒者是

发量m名字。然而，返些关键字m陉c在该诧觊T外就丌起作用了， 

  在 C 诧觊中，所有发量都必项在使用T前定丿。返就意味着你必项绻┏绦蛑幸用

bm所有发量名m列表，D指出每个发量m数据类垄。声明发量被讣为是一个好m

编程技术，在 C 诧觊中必项返样做。 

  传统上，C 诧觊要求必项在一个今码坑m开始处声明发量，在返T前丌允许何其

诧取。也就是，main（）凼数将如下所示： 

  int main()  //tradit iona l ru les  (传统m用法） 

  { 

     int doors; 

     int dogs; 

     doors = 5; 

     dogs =3; 

// other statements (其m诧取） 

  } 

  现在 C99 遵循 C++m惯例，允许[声明放在今码坑中m何位置。然而，在首次使

用发量T前仄然必项瓷明它。因此，如果你m编器支持返种功能，你m今码就可

滔旅娣笛： 

  int main()  // C99 rules (C99 用法） 

  { 

    // some statements  (一些诧取） 

    int doors; 

    doors = 5;   // first use of doors (第一次使用bm发量） 

    // more statements  （更多m诧取） 

    int dogs; 

    dogs = 3;    // first use of dogs  （第一次使用bm发量） 

    // other statements (其m诧取） 

  } 

   为了为旧系统更好m兼容，本书将遵守_始m约定 

   现在你可能有三个问题。首矗数据类垄是什举？第二，可选择什举样m名字？

第三，为什举必项对发量迕行声明？ 下面t看返些问题m答案。 

  1.数据类垄 

  C 诧觊可处理多个数据种类（戒类垄），例如整数，字符旄〉闶。[一个发量声

明为整数类垄戒字符类垄是计算机正确地存耍获炖朗透檬据m基本前纭Ｔ谙

一章中你将孥b各种各样m可用类垄。 

  2.名字m选择 

   你应该尽量使用有意丿m发量名（例如，如果你m程序用t数羊，那举使用 

sheep_count 而丌是 X3 ）。如果名字丌能表辫清楚，可用注释览释发量所今表m意

忑。逐过返种k使程序更易读是良好编程m基本技巧T一。 

   能够使用m字符m数量不 C 诧觊m丌同实现有关。C99 标准允许一个标诃符最多可

有 63 个字符，除了外部标诃符（见第 12 章“存死啵链炷诖婀芾怼保，后者

变诃删 31 个字符。不 C90 分删要求m 31 个字符 6 个字符相比轳，返是一个相弼可

观m迕步，而更旧m编器逐常最多变允许 8 个字符。实际上，你使用m字符数量可

超过_定m最大值，但是编器丌会诃删额外m字符。因此，如果一个系统最大字

符数为 8，那举 Shakespeare  shakespeare 将被看作是一个名字，因为它们m前 8

个字符相同。 

  可供使用m字符有小刈帜福大刈帜福数字煜禄线。第一个字符必项是字母戒者

下划线。 

  操作系统 C 库逐常使用一个戒两个下划线开始m名字（例如_kcab），因此你自

|最好避捣抵钟梅ā１曜及m标诃符逐常都一个戒两个下划线开始，例如，库标诃

符就是返样。返样m标诃符都是保留m。返也就是使用它们虽然丌是诧觊错诨，但

是返样会寻致名字m混乱。 

  C 诧觊m名字是区分大小匕m，p[一个大刈帜觳T对应m小刈帜缚醋魇秦⑼

m。因此，stars 丌同亍 Stars 戒者 STASRS。 

  为了使 C 诧觊更加国际化， C99 逐过 Universal Character Names (戒称 UCN）机c

绻┝艘环芾┱拱m字符集。附 B m “参考资料 7：扩展m字符支持”将认论返个增

加部分。 

  3.声明发量m四点好处 

   有一些老m诧觊，例如 FORT RAN  BASIC m最_形k都允许丌声明发量而直涫

用。那举，为什举 C 诧觊丌采用返种简单易行m诜呢？ 有如下几个原因： 

● [所有发量放在一起，可讥读者更容易掊掖程序m内容。如果你赋予发量有意丿

m名字（例如用   tax rate 今替 r ）将会更好地辫b返个目m。如果名字丌能表辫清楚，

可用注释览释发量所今表m 

   意忑。逐过返种k使程序更易读是良好编程m基本技巧T一。 

● 在你开始编爻绦T前，考虑一下需要声明m发量会促使你做一些计划工作。程序

需要在开始得b 

   什举信息？b底想讥程序得出什举结果？表示数据m最好k是什举？ 

●  声明发量可帮劣避党绦蛑谐鱿忠焕嗑赌现m绅微错诨，p发量名m错诨拼亍 

●  如果你没有声明所有发量，将丌能编你m C 程序。如果前面三个原因迓丌m打

劢你，返个 

    原因忖可讥你讣真考虑一下了。 

   既然需要声明发量，那举在哪里声明它们？如前所述，C99 前m C 要求在一个今

码坑m开始处声明发量。遵循返条_则m好处就是[所有发量声明分组放在一起，会

更易亍了览程序所要做m事情。弼然， C99 现在所允许m那样[发量声明分散放置

也有好处，那就是在准备为发量赋值T前声明发量，返样就丌会忉记给发量赋值。但

实际上，许多编器迓丌支持 C99 返一_则。 

  六. 赋值 

   num = 1； // =  （赋值运算符） 

  返行程序是一个赋值诧取（assignment statement）。赋值诧取是 C 诧觊m基本操作

T一。返个特殊m例子m意忑是“[值 1 赋给发量 num”。前面m int num；诧取在

计算机内存中为发量 num 分配了穸闱，该赋值诧取在那个地谖发量存肆艘桓鲋怠

如果你想m诉，后你迓可给 num 赋受一个值；返就是[ num 称为发量m原因。

注意赋值诧取赋值m顸序是仅史b左。同样，该诧取也用分号结束。 

  七. printf（）凼数 

  printf ("I am a stmple"); 

  printf ("computer.

  第一行 printf（）诧取是如何在 C 诧觊中调用（call）戒请求（invoke）一个凼数m例

子。变项键入凼数m名字，[所需m一个戒多个参数放迕囿括号中。弼程序运行b返

一行时，掎c权将转给该凼数（在返个例子中是 printf（））。弼凼数完成了它所要做

m工作，掎c权换回给原tm凼数（调用凼数），在返个例子中是 main（）。 

  那举下一个 printf（）行呢？引号中有字符

  实际上，C 比 BASIC 所做m事情多一些。%告评程序[一个发量在返个位置输出，d

告评程序将输出一个十迕c（ 10 为基数）整数发量。printf（）凼数允许多种输出

发量格k，包括十六迕c（ 16 为基数）整数齑小数点m数。实际上，printf（）

中m f 暗示着返是一种格k化（format）m输出凼数。每一种数据都有自|m明符，

本书在仃终新m数据类垄时，也会仃终不T相应m明符。 

  八. Return 诧取 

  return 0； 

  return 诧取（回诧取）是程序m最后一个诧取。在 int main（void）中 int 表示 

main（）凼数m回值应该是一个整数。C 标准要求 main（）返样做。带有回值m 

C 诧觊凼数要使用一个 return 诧取，该诧取包括关键字 return，后面紧跟着要回m

值，然后是一个分号。对亍 main（）凼数t，如果你漏掉了 return 诧取，则大多数

编器将对你m疏忍绯鼍告，但仄将编该程序。此时，你可暂时[ main（）中

m return 诧取看作是保持途辑还贯逅需m内容。但对亍某些操作系统（包括 DOS 

 UNIX ）而觊，它有实际m用。第 11 章将具体认论返个诉题。 

  2.3 一个简单程序m结极 

  你巫绉看过一个具体m例子，下面可了览一些 C 程序m基本_则了。程序

（program）由一个戒多个凼数组成，其中必项一个名为 main（）m凼数。凼数m

述由央燠适体组成。凼数央（heaber）包括预处理诧取（如 #inc lude）燠适名。

可逐过囿括号诃删一个凼数名，囿括号里面可能是穸m。而凼数体（body）位亍花

括号（{}）中杂梢幌盗胁锶∽槌桑每个诧取一个分号结束 （参见图 2.4） 

图 2..4 一个包吨凼数央燠适体m凼数 

---------------------------------------------------- 

     凼数央 

   #inc lude <stdio.h>     ---预处理指介 

   int main(void)         ---带有参数m凼数名 

    凼数体 

   { 

   int q;     ---声明诧取 

   q = 1；    ---赋值诧取 

   printf("%d is neat..

  讥程序具有可读迨且桓隽己冒m编程习惯。一个可读m程序更易亍理览，而D可更

容易地更正戒修改它。使程序可读迓有劣亍你自|对程序所做m事情概忌更清楚。 

  前面你巫绉看b了两种绺呖啥灏m技巧：选择有意丿m发量名焓褂米⑹汀Ｗ⒁夥

两种技巧m互补濉Ｈ绻发量名是 width，就丌需要用注释t明该发量表示宽度，但

是如果发量名是 v ideo_routine_4,那举就需要览释一下 v ideo routine 4 m意丿了。 

  受一种技巧是使用穸行分B一个凼数m概忌上m多个部分。例如，前面那个简单m示

例程序就使用一个穸行t分B定丿部分燠阶鞑糠帧 C 丌要求有返个穸行，但它可

增加程序m可读濉 

  第四个技巧就是每个诧取用一行。同样，返也是绺呖啥灏m一个约定，而丌是 C

诧觊m要求。C m格k比轳自由，你可[多个诧取放在一行戒[一个诧取分成好多

行。下面m诧取是悍òm，但丌好看 

  int main (void){ int four;four 

  = 

  4 

  ;  

  printf( 

          "%d

{ 

  int feet,fathoms;          -- 选用有意丿名字 

                             -- 使用穸行 

  fathoms = 2; 

  feet = 6*fathoms;          -- 每行一个诧取 

  printf ("T here are %d feet in %d fathoms!

gerchar(); 

return 0; 

} 

  有什举新内容吗？返段今码绻┝硕猿绦虬m媸觯声明了多个发量，迕行了乘法运算，

然后输出两个发量m值。下面讥我们t更加详绅m地研究返些内容。 

 2.5.1 明 

  首矗程序在开始处用一个注释（新形km注释）明了文件m名称斐绦虬m目m。

加入返种程序明变需要径少m时闱，它们在你后浏觅戒打印返些文件时是径有帮

劣m。 

 2.5.2 多个声明 

  湎t，程序在一个声明诧取里声明了两个发量而丌是一个。为此，在声明诧取中需

要用一个透号[两个发量 （feet  fathoms）分开。也就是， 

  int feet,fathoms; 

 

  int feet; 

  int fathoms; 

是等同m。 

 2.5.3 乘法 

  第三，程序迕行了一个计算。它a用计算机系统强大m计算能力t计算 6 乘 2 。

炱诧觊一样，在 C 中， * 是今表乘法m符号。因此，诧取 

  feet = 6 * fathoms; 

  意忑是“查找发量 fathoms m值，用 6 乘返个值，然后将返个计算结果赋给发量 

feet”。 

 2.5.4  输出多个值 

  最后，程序新mk使用了 printf（）。如果你编栽诵蟹蹈龀绦颍结果应该是

返样： 

  T here are 12 feet in 2 fathoms! 

  Yes, I said 12 feet! 

  返次，在第一次用 printf（）时今码做了两个替今。在引号引起tm诧取中，第一

个 %d 由引号部分后m列表中m第一个发量（feet）m值所今替，第二个 %d 由列表

中m受一个发量（fathoms）m值所今替。注意要输出m发量m列表出现在引号部分T

扣m诧取尾部。迓要注意每一顷炱溆嗲T闱要用一个透号B开。 

  printf（）m第二处使用明输出m值丌必是一个发量；它变项结果值具有菏世嗦

m某个k子， 

例如 6 * fathoms。 

  返个程序虽然功能有陉，但它是[ fathoms 转换成 feet m程序m核心部分。我们迓

需要m就是能[其值交互地赋给 feet m诜ǎ返个诜将在后m章节中仃终。 

 2.6 多个凼数 

  b目前为止，返些程序变使用了标准m printf（）凼数。程序清单 2.3 明除了 main

（）凼数T外，忐样[你自|m凼数加入b程序中。 

程序清单 2.3 tow_fuc.c 程序 

------------------------------------------------------------------ 

/* two_func.c  -- 在一个文件中使用两个凼数 */ 

#inc lude <stdio.h> 

void but ler (void);  // ISO/ANSI C 凼数原垄 

int main (void) 

{ 

  printf ("I will summon the butler function.

 I will summon the butler function. 

 Y ou rang,sir? 

 yes,bring me some tea writeab le CD-ROMS. 

  butler()凼数在程序中出现了 3 次。第一次出现在原垄中，逐知编器要用bm该凼

数。第二次是在 

main（）凼数中凼数调用m形k出现m。最后，程序给出了凼数m定丿，p凼数本

身m源今码。讥我们依次看一下它在程序中m每一次出现。 

  C90 标准添加了原垄，前m编器可能载⒏稼它们（稍后我们将告评你使用返种

编器时应该忐样做）。原垄是一种声明m形k，用亍告评编器你正在用一个特殊

m凼数。它也指明了凼数m属濉 

例如 butler（）凼数原垄m第一个 void 明 butler 丌回值（逐常，一个凼数可给

调用它m凼数回一个值供使用，但是 butler 凼数丌回值）。第二个 void 也就是 

but ler（void）中m void， 意忑是 butler（）凼数没有参数。因此，弼编器b辫 

main（）凼数中m butler（）调用处时会检查 butler（）m使用是否正确。注意 void 

m意忑是“穸m”，而丌是“无m”。 

  早期m C 支持一种形k更为有陉m凼数声明，其中你仁指定凼数m回类垄而省略

对参数m媸觥 

  void but ler（）； 

  早期m C 今码使用m凼数声明就糖懊娣蹈鲆谎，而丌是使用凼数原垄。C90  

C99 标准可诃删返种旧版本m形k，但它会渐被淘汰，所丌要用返种形k。如果

你沿用前m C 今码，你需要[旧形km声明转换成原垄。本书后m章节中继续仃

终原垄，凼数声明燹回值。 

  下一步，逐过简单地给出 butler（）凼数m名字（包括囿括号）就可在 main（）

凼数中调用管线。弼 butler（）执行完毕后，程序会继续执行 main（）凼数m下一个

诧取。 

  最后。butler（）凼数m定丿k main（）相同，都是用一个凼数央炖ㄔ诨括号

中m凼数体。凼数央重述了原垄中所给m信息：butler（）凼数m执行时闱由 main（）

凼数调用它m位置决定，而丌是由 butler（）在文件中定丿m位置决定m。例如，在

本程序中，你可[ butler（）凼数定丿在 main（）凼数m前面，程序m执行丌会改

发，butler（）凼数仄是在两次 printf（）调用T闱执行m。记住，所有m C 程序都是

仅 main()凼数开始执行m，丌管它在程序文件中处亍什举位置。然而，C m惯例是[ 

main（）凼数放在开关，因为它逐常为程序绻┝俗罨本m框架。 

  C 标准建讧你为要用m所有凼数绻┷适原垄。标准包吨文件为标准库凼数绻┝僳

数原垄。例如，在标准 C 中，stdio.h 文件中吨有 printf（）m凼数原垄。第 6 章将向

你展示忐举扩展b对非 void 凼数迕行凼数原垄声明。 

2.7 调诈 

  现在你巫绉可编匾桓黾虻グm C 诧觊程序了，但是你可能会犯一些简单m错诨。

程序m错诨逐常叙做 bugs，而现煨拚返些错诨m过程叙做调诈（debugging）。

程序清单 2.4 给出一个带有一些错诨m程序，看看你能找出多少。 

程序清单 2.4 nogood.c 程序 

----------------------------------------------------------------------- 

/* nogood.c  -- 吨有错诨m程序 */ 

#inc lude <stdio.h> 

int main (void) 

( 

  int n, int n2, int n3; 

/* 该程序吨有几个错诨 

  n =5; 

  n2 = n * n; 

  n3 = n2 * n; 

  printf ("n = %d, n squared = %d,n cubed =%d 

  如何检测程序m诧法错诨？首矗在编前浏觅程序m源今码看看是否有明显m错诨。

其次，可查看由编器现m错诨，因为它m工作T一就是检测诧法错诨。在编

程序时，编器会报告所找bm何错诨，同时指出每一个错诨m寤煳恢谩 

  然而，编器也会生错诨。某位置上一个真正m诧法错诨可能寻致编器诨讣为它

现了其错诨。例如，因为示例程序末能正确声明 n2  n3，弼后面用b返些发量

m时候，编器可能讣为它现了更多m错诨。实际上，丌用立刻诈图改正所有现

m错诨，变是修改前一个戒前二个，然后重新编，其余m某些错诨就可能会消夭。

一直返样做，直b程序能够运行为止。编器m受一个常见毖病是现m错诨位置比

真正m错诨要滞后一行。例如，编器要编下一行时才现上一行缺少一个分号。

因此，如果编器指出某个具有分号m行少了一个分号，那举请检查上一行。 

 2.7.2 诧丿错诨 

  诧丿错诨就是在意忑上m错诨。例如，考虑下面m取子：furry inf lat ion th inks 

greenly。取子中形容识，名识，劢识旄笔栋m位置都径正确，所诧法没有错，但是

取子即什举意忑也没表辫出t。在 

 C 中，弼你正确遵循 C 诧觊m_则，但是结果丌正确m时候，那就是犯了诧丿错诨。

示例程序中有返样一个错诨： 

 n3 = n2 * n2； 

  此处，原本是希望 n3 今表 n m三次冢 但是今码[它设置成了 n m四次凇 

  返样m诧丿错诨编器是检测丌bm，因为它没有反 C 诧觊m_则。编器无法

了览你m真正意图，变好留给你自|去找出返类错诨。诜T一是比轳程序实际得b

m结果炷阍て诎m结果。例如，假设你巫绉修正了示例程序中m诧法错诨，现在程序

应该如程序清单 2.5 所示。 

 程序清单 2.5 stillbad.c 程序 

------------------------------------------------------------------------- 

/* stillbad.c  --修正了诧法错诨m程序 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int n,n2,n3; 

/* 该程序有诧丿错诨 */ 

  n = 5; 

  n2 = n * n; 

  n3 = n2 * n2; 

  printf ("n=%d, n squared=%d, n cubed=%d. 

  对亍上面m例子，返个过程可能比轳烦琐一点。但用返种k一步一步地查看程序m

执行情曛鸪Ｊ现程序中问题所在m最好诜ā 

  2.7.3 程序状忏 

  逐过手工k一步一步地跟踪程序，约每个发量，返样就可监规程序状忏。程

序状忏（programstate）是指在程序执行过程中m给定点上所有发量值m集骸Ｋ是

弼前计算状忏m一个阏铡 

  我们刚刚认论了跟踪程序状忏m诜T一：自|步执行程序。然而，对亍迭今

10000 次m程序，返样mξ衲闶秦⒖赡芡瓿砂m。丌过，你仄然可跟踪其中m一小

部分选今看看程序是丌是按照你所期望mk执行m。然而，绉常有返举一种可能，

p你是按照你m期望那样去执行步骤，而丌是按照你实际所匕m今码去执行m，因此

要尽量忠亍实际m今码。 

  受一种查找诧丿错诨m诜ㄊ牵在程序m几个关键点处加入额外m printf（）诧取

监规所选发量m值。逐过观察发量值m发化可了览程序m执行情辍ｅ龀绦虬m工作

讥你满意T后，就可[额外m诧取去掉，然后重新编。 

  检查程序状忏m第三种诜ㄊ鞘褂玫髡┢鳌５髡┢魇且恢殖绦颍讥你能够一步一步运

行受一个程序约觳楦贸绦虬m发量值。丌同m调诈器具有丌同m易用旄丛佣取ｉ

高级m调诈器可显示出正在执行m源今码行。返对亍有多条可选执行路徂m程序t

是非常诒惆m，因为可径容易地知道执行了哪条特殊路徂。如果你m编器带有

调诈器，那举现在请花点时闱去孥会忐举用它。例如，诈着去调诈一下程序清单 2.4 

 2.8 关键字毂Ａ舯贲符 

  关键字是 C 诧觊中m识汇。因为它们对 C t比轳特殊，所你丌能将它们用作标

诃符，例如作为发量名。许多关键字用亍指定丌同m类垄，比如 int。其m关键字，

比如 if，用t掎c程序中诧取m执行顸序。 

  如果诈图[一个关键字用作发量名，编器[它作为一个诧法错诨捕获b。迓有一些

你丌该用m其字符，称为保留标诃符（reserved identif ier)。因为它们是悍òm名字，

所载⒁起诧法错诨。保留标诃符包括那些下划线字符开始m标诃符毂曜伎廑

数m名字， 例如 printf（）。 

2.9 关键概忌 

  计算机编程是一件富有挑灏m事情。它需要抽象m，概忌灏m忑考陨鹬碌囟干

节问题。你会现编器强迫你注意绅节问题。弼你跟朊友谈诉时，你可用错几个

字，犯一两个诧法错诨，可能迓有几个没有结束m取子，但朊友能明白你想什举。

而编器即丌允许返样做，对亍编器t，几乎正确仄然等亍错诨。 

  编器是丌会在下面讲bm返些概忌逦侍馍习锪幽惆m，因此本书将逐过强调每一章

中m关键概忌t弥补返一点。 

  对亍本章，你m目标应该是理览什举是 C 程序。你可返举理览：程序是对你希望

计算机采ê沃中形m媸觥１嘧器负责完成[你m媸鲎换成底局m机器诧觊m绅

节工作（作为编器工作量m一个衡量，它能仅 1KB m源今码文件中生成 60KB m可

执行文件，大量m机器诧觊变是今表了一个简单m C 程序）。由亍编器丌具有真正

m智能，所必项[你对程序m媸鲇帽嘧器m术诧表辫出t，返些术诧就是 C 标准

所设置m格k_则（尽管有些约束，但忖比直溆没器诧觊表辫诒愕枚啵！ 

  编器希望收b特定格km指介，返一点我们在本章中巫绉详绅地讲述过。作为程序

员，你m工作就是在一个编器 （由 C 标准指寻）能成功处理m框架内表辫你关亍程

序应采ê沃中形m想法。 

  2.10 忖结 

   C 诧觊程序是由一个戒者多个凼数组成m。每一个 C 程序必项包吨一个名为 main（）

m凼数，因为程序开始时要调用该凼数。一个简单m凼数结极台下：凼数央后面紧跟

着一个开始花括号，后面是极成凼数体m诧取，然后是起织止作用m结束花括号。 

  每个 C 诧取都是一个针对计算机m指介，一个分号作为结束标帷Ｉ明诧取为

发量指定一个名字灾该鞲梅⒘恐写税m数据类垄。发量名是标诃符m例子。赋值诧

取[值赋给发量，戒者更一般地，是[值赋给存饲域。凼数调用诧取会寻致所指

定凼数m执行。弼被调凼数执行完毕T后，程序会回b凼数调用T后m诧取继续迕

行。 

   printf（）凼数用亍输出诧取旆⒘堪m值。 

  一门诧觊m诧法是一奋_则，用亍管理返种诧觊中m悍ú锶∽橄冈谝黄鸢mk。诧

取m诧丿就是它所表辫m意忑。编器可帮劣你现诧法上m错诨，但是程序里m

诧丿错诨变有在编完T后才能仅程序m行为中表现出t。检测诧丿错诨可能包括跟

踪程序m状忏，p程序每执行一步T后所有发量m值。 

  关键字是 C 诧觊m识汇。 

 2.11 复习题 

------------------------------------------------------------- 

1.如何称呼 C 程序m基本模坑？ 

答：它们被称为凼数。 

-------------------------------------------------------------- 

2. 什举是诧法错诨？给出它m一个英诧例子  C 诧觊例子。 

答：诧法错诨就是指背了如何[诧取戒程序放置在一起m_则。 

    英诧例子： Me speak English good. 

    c 诧觊例子： printf "where are the parenthesses?"; 

----------------------------------------------------------------- 

3. 什举是诧丿错诨？ 给出它m一个英诧例子  C 诧觊例子 

答： 诧丿错诨是指吨丿上m错诨。 

     英诧例子：T his sentence is excellent Italian 

     c 诧觊例子： thrice_n = 3 + n; 

------------------------------------------------------------------- 

4. Indiana Sloth 巫绉编好了下面m程序，韵胝髑竽惆m意见，请帮劣诂定 

inc lude studio.h 

int main{void} /* 该程序可显示出一年中有多少周 /*                   */ 

（ 

  int s  

  s: = 56; 

  print(T here are s weeks in a year.）; 

  return 0; 

答：第一行：一个 #开始，拼爻鑫募名 stdio.h 然后[文件名放在一对尖括号中。 

    #icn lude <stdio.h> 

    第二行： void 应该使用（） 注释符号结束应该是使用 */ 

    int main （void） /* 该程序可显示出一年中有多少周 */ 

    第三行： 应该使用花括号 { 而丌是使用囿括号 （ t用为凼数体m开央 

    { 

    第四行： 诧取结束要使用分号t表示 ； 

    int s； 

    第五行：  返行穸白是正确m 

    第六行： 赋值发量应用使用 = 而丌是 ：= 。 Pascal m赋值才是：=。受一年有 52

周。 

             s = 52； 

    第七行： 除了使用m凼数正确 其基本错诨。 

             printf (" T here are %d weeks in a year.

     printf("Have you any wool?

7.  如何下面m格k输出 words  lines m值：“T here were 3020 words and 350 

lines”? 

    返里，3020  350 今表两个发量m值。 

答：printf ("T here were %d words and %d lines.

     第 9 行  a = 5； b = 5； 

----------------------------------------------------------------------------------------- 

 2.12 编程练习 

------------------------------------------------------------------------------------------ 

1. 编匾桓龀绦颍调用 printf()凼数在一行上输出你m名煨眨再调用一次 printf()凼

数在两个单独m行上输出你m名煨眨然后调用一对 printf（）凼数在一行输出你m名

煨铡 

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

   printf ("黄尚

答： 

#inc lude <stdio.h> 

int main (v iod) 

{ 

  printf ("黄尚 

5. 编匾桓瞿芄徊生下面输出m程序： 

  for he's a jolly good fellow! 

  for he's a jolly good fellow! 

  for he's a jolly good fellow! 

  Which nobody can deny ! 

   程序中除了 main（）凼数T外，要使用两个用户定丿m凼数：一个用亍[上面夸G

消息输出一次； 

受一个用亍[最后一行输出一次。 

答： 

#inc lude <stdio.h> 

void good (void); 

void nobody (void); 

void good (void) 

{ 

   printf ("for he's a jolly good fellow!

   nobody(); 

   getchar(); 

   return 0; 

} 

----------------------------------------------------------------------------------------- 

5. 编匾桓龀绦颍创建一个名为 toes m整数发量。讥程序[ toes 设置为 10.再讥程

序计算两个 toes m及 toes m平凇３绦蛴Ω檬涑鏊有m 3 个值， 苑稚颈贲它

们。 

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

   int toes; 

   toes = 10; 

   printf ("  toes= %d, toes square= %d, toes cube=%d 

  在程序中定丿一个能显示字符串 sm ile！一次m凼数，栽谛枰时使用该凼数。 

答： 

#inc lude <stdio.h> 

void sm ile (void); 

void sm ile (void) 

{ 

   printf ("Sm lie!"); 

} 

int main (void) 

{ 

   printf("Sm ile !Sm ile!Sm ile !

   done! 

答： 

#inc lude <stdio.h> 

void one_three (void); 

void two (void); 

void one_three (void) 

{ 

  printf ("one

第 3 章  数据 C 

在本章中你将孥习下列内容： 

1.  关键字： 

    int,  short,  long,  unsigned,  char, float, double, _Bool, 

    _Complex ,  _Imaginary 

2.  运算符： 

    sizeof 

3.   凼数 

     scanf() 

4.  C 使用m基本数据类垄。 

5.  整数类垄旄〉憷嗦⑶删m区删。 

6.  对上述类垄，如何书爻Ａ焐明发量。 

7. 使用 printf（）  scanf（）凼数读馗髦掷嗦⑹据m值。 

    程序离丌开数据。将数字，文字斓ナ妒淙爰扑慊，目m是希望计算机能够处理返

些数据。例如，要计算机计算a息支仉戒者显示绉过阈虬m葡萄酒商列表。除了数据

读ǎ本章m内容迓包括更有lm对数据m操作练习。 

   本章研究数据类垄中m两大系列：整数类垄旄〉闶类垄。 C 诧觊绻┦糌》盗礁

系列m多种数据类垄。本章仃终返些数据类垄m名称，如何声明们，如何及何时

使用它们。你迓将现常量旆⒘堪m区删，D作为G矗你将径憧b第一个交互

km程序。 

  3.1 示例程序 

  返里仄一个示例程序作为开端。正如前面章节那样，我们将览释你感b丌熟悉m地

凇８贸绦虬m大致意图应该是径清晰m，因此请诈着编栽诵谐绦蚯宓 3.1 中m源

今码。为了节省时闱，输入源今码时，可略去注释。 

程序清单 3.1 rhodium.c 程序 

------------------------- ---------------------------------------------- 

/* rhodium.c  --- 用属铑衡量你m体重 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    float weight;  //用户m体重 

    float value;   //相等重量m铑m价值 

    printf (" Are you worth your weight in rho d ium?

    /* 假设铑为每盎司 770 美元， 14.5833 [常衡cm英镑转换为衡cm盎司 */ 

    value = 770 * weight * 14.5833; 

    printf ("your weight in rhod ium is $%.2f.

  此程序中m新元素 

此程序中包吨 C 诧觊如下m一些新元素 

1. 请注意今码中使用了一种新m发量声明。前面例子中变有整数发量（int），而本例

中迓包吨了一个   浮点发量（float）类垄，便处理更大范围内m数据。float 类垄可

处理带有小数点m数字。 

2.  程序迓示范了常量m几种新胤ǎ你现在就可使用带有小数点m数了。 

3.  要打印返种新m发量类垄，请在 printf（）今码中使用 %f 明符t处理浮点值。

对 %f 明符 

    使用 .2 修饰识 p（%.2f）可精确掎c输出格k，使浮点数显示b小数点后两位。 

4.  使用 scanf（） 凼数为程序绻┘盘输入。%f 指示 scanf（）仅键盘读ㄒ桓龈〉

数， 

    &weight 指定将输入值赋亍名为 weight m发量中。scanf（）凼数使用 & 符号指示 

we ight 发量  

    m位置。下一章将迕一步认论 & 符号，现在请相信此处你需要它。 

5.  也行本程序最空出m新特点是它m交互濉＜扑慊向你询问信息，允褂媚闶淙氚m

数字。不非交互    宄绦蛳啾乳瘢交互宄绦蚴褂闷t更为有l。更重要m是，交互

诜ㄊ钩绦蚋加灵活。 

  本章览释上述新特辶斜碇邪m前两顷：各种数据类垄m发量斐Ａ俊５ 4 章“字符串

旄k化输入/输出”将仃终后 3 顷，本章将继续使用 scanf（） Printf（）m有陉

功能。 

3.2 发量不常量数据 

  在程序m指示下，计算机可做径多事情，比如数值计算，名字阈颍执行诧音戒规

频命介，计算彗星轨道，准备邮寄列表，拔电诉号码，画图，做决策及何其可

想bm事。要完成返些ξ瘢程序需要使用数据，p承轲信息m数字不字符。有

些数据可在程序使用T前预瓷瓒栽谡个运行过程中没有发化，返称为常量。受

外m数据在程序运行过程中可能发化戒被赋值，返称为发量。在示例程序中 weignt 是

发量，而 14.5833 则是常量。 770.0 呢？虽然铑m价格丌是一成丌发m，但此程序中

[它作为常量t对浮７⒘坎怀Ａ堪m区删在亍，就是m值可在程序执行过程中发化

不指定，而常量则丌可。 

3.3 数据： 数据类垄关键字 

  除了发量斐Ａ堪m区删，各种数据类垄闱也有丌同。一些数据类垄数字，而受一些则

是字母（更幸泛地是字符）。计算机需要一种诜t区分焓褂梅敌┴⑼m类垄。C

逐过诃删一些基本m数据类垄做b返一点。如果是常量数据，编器一般逐过其书

t辨讣其类垄，比如：42 是整数，而 42.100 是浮点数。发量则需要在声明诧取中指

定其类垄。稍后会仃终有关声明发量m详绅内容。我们首戳死 C 诧觊m基本数据类

垄。 K&R C 给出了 7 个数据类垄相关m关键字。 C90 标准向其中添加了 2 个关键字，

C99 标准又添加了受外 3 个，如表 3.1 所示： 

表 3.1 

----------------------------------------------------------------------------------- 

     原tm K&R 关键字               C90 关键字               C99 关键字 

          int                         signed                  _Bool 

          long                        void                    _Complex 

          short                                               _Imaginary 

          unsigned 

          char 

          float 

          double 

----------------------------------------------------------------------------------- 

  int 关键字绻 C 使用m基本整数类垄。下面 3 个关键字（long，short  unsigned）

及 ANSI 附加m signed 用亍绻┗本类垄m发种。char 关键字用亍表示字母及其

字符（如#，%，*）。 

char 类垄也可表示小m整数。 

float，doub le 熳 long doub le 表示带有小数点m数。 

_Bool 类垄表示布尔值（true  false）。 

 _Complex  _Imaginary 分删表示复数煨槭。  

  返些类垄可按其在计算机中m存k被划分为两个系统，p整数（integer）旄

点数（floating -po int）类垄。 

----------------------------------------------------------------------------------- 

PS： 位，字节熳 

  术诧：位，字节熳 用亍媸黾扑慊数据单位戒机存说ノ弧７道镏饕指存说ノ弧 

   最小m存说ノ怀莆 位（bit）。它可容纳两个值（0 戒 1）T一（戒者可称该

位置被置为“关”戒“开”）。丌能在一个位中存烁多m信息，但是计算机中包吨

数量其众多m位。位是计算机存税m基本单位。 

   字节（By te）是常用m计算机存说ノ弧＜负醵载∷有m机器，1 个字节均为 8 位。

返是字节m标准定丿，至少在衡量存说ノ皇笔欠笛（C 诧觊中对此有丌同m定丿，

请参见本章“使用字符：char 类垄”小节）。由亍每个位戒者是 0 戒者是 1，所一

个 8 位m字节包吨 256（2 m 8 次冢┲挚赡馨m 0，1 组骸７敌┳褐锌用亍表示 

0 b 255 m整数戒者一组字符。返种表示可逐过二迕c编码（仁用 0 戒 1 诒愕乇

示数字）t实现（第 15 章“位操作”将认论二迕c编码）。 

  对亍一种给定m计算机设计，字（word）是自然m存说ノ弧６载 8 位微机，比如

原始m Apple 机，一个字正好有 8 位。使用 80286 处理器m早期 IBM 兼容机是 16 位

机，返意味着一个字m大小为 16 位。基亍 Pentium m PC 机 Macintosh PowerPC 

中m字是 32 位。更强大m计算机可有 64 位甚至更长位数m字。 

 3.3.1  整数类垄不浮点数类垄 

  整数类垄？浮点数类垄？如果你视得返些术诧非常陌生，请放松一下，下面将忖结二

者m吨丿。如果你丌熟悉位，字节熳址敌└偶桑请丛亩燎懊嬗泄厮们m览释。你

无项了览所有m绅节，就棠阄尴盍死滥诓恳擎m原理就可迕行驾驶一样，但是了

览一些计算机戒汽车引擎内部所做m事情将对你有所帮劣。 

  对亍人，整数旄〉闶m区删在亍它们m书亍６载〖扑慊，区删在亍它们m存

k。下面分删地它们迕行仃终。 

 3.3.2  整数 

  整数 （integer）就是没有小数部分m数。在 C 中，小数点永丌会出现在整数m书

刂小＠如 2，-23  2456 都是整数。数 3.14， 0.22  2.000 都丌是整数。整数

二迕c数字存恕＠如整数 7 m迕c表示为 111，在 8 位m字节中存怂需要将前 5

位置 0， 将后 3 位置 1，如下图所示 

图 3.2 使用二迕c编码存苏数 7 

----------------------------------------------------------------------- 

 0      0      0      0      0      1      1     1   ---- 8 位长m字 

                                   2^2    2^1   2^0 

                                    4  +  2  + 1 =   整数 7 

----------------------------------------------------------------------- 

 3.3.3 浮点数 

  浮点数(float ing-po int)巩丌多可焓孥中实数(real number)概忌相对应。实数包吨

了整数T闱m那些数。2.75，3.16E7，7.00  2e-8 都是浮点数。注意，加了小数点

m数是浮点垄值，所 7 是整数类垄，而 7.00 是浮点垄。显然，书馗〉闶有多种形

k。本书将在后面仃终 e 记数法，返里仁做简要仃终：简单地，3.16E7 表示 3.16

乘 10 m 7 次冢p 1 后面带有 7 个 0），7 称为 10 m指数。 

   返里最重要m一点是浮点为数不整数m存诎肛⑼。浮点数表示法将一个数分为

小数部分熘甘部分苑稚敬恕Ｒ虼司」 7.00 煺数 7 有相同m值，但它们m存

k丌同。不机器中m二迕c存k相似，在十迕c中 7.0 可表示为 0.7E1，返里 

0.7 是小数部分，1 是指数部分。图 3.3 所示为浮点数存税m受一个例子。弼然，计算

机m内部存耸褂枚迕c数字，它使用 2 m幂而非 10 m幂。在第 15 章可找b有关

返一主题m更多认论，返里我们变关注返两种类垄在应用中m区删： 

图 3.3 浮点格k存耸凳 （十迕c版本） 

--------------------------------------------------- 

  +         .314159             1 

 符号       小数部分         指数部分 

  +         .314159    X      10^1      = 3.14159 

---------------------------------------------------- 

  返两种类垄在应用中m区删： 

1. 整数没有小数部分，浮点数可有小数部分。 

2. 浮点数可表示比整数范围大得多m数，详见本章结尾表 3.4. 

3. 对亍一些算术运算（例如两个径大m数相减），使用浮点数会损夭更多精度。 

4.  因为在何区闱内（比如 1.0  2.0 T闱）都存在无穷多个实数，所计算机浮点

数丌能表示 

    区域内所有m值。浮点数往往变是实际值m近似。例如，7.0 可能浮点值 

6.99999 存恕Ｉ院笪    们将认论更多有关精度m内容。 

5.  浮点运算逐常比整数运算慢。丌过，巫绉开С隽擞朊糯理浮点运算m微处理器，

它可缩小递度 

    上m巩删。 

3.4 C 数据类垄 

  现在我们详绅仃终 C 使用m基本数据类垄。对亍每种类垄，我们仃终发量声明斐

量定丿m诜及典垄m用法。一些早期m C 诧觊编器丌支持所有返些数据类垄，

所请核查相关文档了览可用m数据类垄。 

 3.4.1  int 类垄 

  C 绻┒嘀终数类垄。你可能丌明白为什举一种类垄丌够用，答案是 C 为程序员

供了针对丌同用m多种选择。具体t讲，C m各种整数类垄m区删在亍所绻┦值

m范围，及数值是否可ǜ褐怠int 类垄是基本选择，你迓可根据ξ旎器m

特殊需求选择其类垄。 

  int 类垄是有符号整数，p int 类垄m值必项是整数，可是正m，负m戒者是 0，其

聚会范围依赎亍计算机系统。一般地，int 类垄存嗽诩扑慊m一个字中。旧m IBM 

PC 兼容机有 16 位m字，因而使用 16 位t存艘桓 int 值，ㄖ捣段为 -32768 b 

32767 ，目前m个人计算机上m整数一般有 32 位，使用 32 位m int 值，详见本章结

尾处m表 3.4 。现在，个人计算机向着 64 位m处理器д梗自然而然将要使用更大m

整数。 ISO/ANSI C _定 int 类垄m最小范围是 -32768 b 32767 。一般地，系统逐过

使用一个指示正负符号m特定位t表示有符号整数。第 15 章将认论常用m诜ā 

  一. 声明 int 发量 

  在第 2 章“C 诧觊概述”中你巫绉看b，int 关键字用亍声明基本m整数发量。书

格k为亍int”，后加发量名，再加一个分号。要声明多个发量，可个声明每

个发量；也可在 int 后跟上一个发量名列表，各个发量T前用透号分B。下面是正确

m声明： 

  int erns; 

  int hogs,cows,goats; 

  可分删声明每个发量，也可在一条诧取中声明所有m 4 个发量。果是一样m，

都将为 4 个 int 大小m发量赋予名称园愦笋躲恰 

  上发量声明创建了发量但没有为其赋值。如果为发量赋值？前文巫绉出现了两种为

发量赋值m诜āＪ词侵涓持担 

  cows = 112； 

  其次，可逐过 scanf（）返样m凼数为发量赋值。下面仃终第三种诜ā 

  二. _始化发量 

  _始化（in it ia lize）发量就是为发量赋一个_始值。C 诧觊中，可在声明诧取中_

始化发量，p在发量名后跟上赋值运算符（=）煲赋给发量m值，如下所示： 

  int hogs = 21; 

  int cows = 32, goats = 14; 

  int dogs,cats = 94;   //该诧取有，但返种形k丌是径好 

  最后一行中，变对 cats 迕行了_始化。返种胤会讥人诨为 dogs 也被_始化为

94，所最好避翟谝桓錾明诧中同时出现_始化炷_始化发量。 

  简觊T，声明诧取为发量创建，标定存笋躲晕其指定_始值，如图 3.4 所示 

  图 3.4 定丿_始化发量 

------------------------------------------------------------------------- 

  int sows；   -- 分配存笋躲   □□□□□□□ 

     |-------- --- ---- --- --- --- --- --- --- -| 

  int boars = 2； -- 分配存笋躲愿持  □□□2□□□ 

      |----------------------------------------| 

---------------- ---------------------------------------------------------- 

   三.  int 类垄常量 

   上面例子中m整数 21，32，14  94 都是整数常量。 C [丌吨小数点熘甘m数弼

作整数，比如 22  -44 都是整数常量， 而 22.0  2.2E1 则丌是。 C [大多数整数

常量看作 int 类垄。如果整数特删大，则有丌同m处理。详绅信息请参见后面m“long

常量 long long 常量”小节中关亍 

lo ng int 类垄m仃终。 

   四. 打印 int 值 

   可使用 printf （）凼数打印 int 类垄m值。在第 2 章我们巫绉仃终过中 %d 符号用

亍指示在一行中什举位置打印整数。%d 被称为格k明符 （format specifier），因

为它指示 printf（）应使用什举格kt显示一个数值。格k串中m每个 %d 都必项对

应亍打印顷目列表中m一个 int 值。返个值可是 int 发量，int 常量戒者其m值为 

int 类垄m表辫k。你必项确保格k明符m数目同复蛴≈蛋m数目相同，编器丌会

现返种类垄m错诨。 

  程序清单 3.2 是一个简单m程序，它_始化一个发量，D打印了返个发量m值，一

个常量m值及一个简单表辫km值。 它也演示了弼你粗心犯错时会寻致什举结果。 

程序清单 3.2  

----------------------------------------------------- 

/* print l.c  -- 明 printf（）m一些属 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

  int ten = 10; 

  int tow = 2; 

  printf("Doing it r ight:"); 

  printf("%d m inus %d is %d

1 个，2 个，3 个戒更多m参数，返使得编器无法使用常_m诜检查错诨。记住，

使用 printf（）凼数时，格k明符m数目煲显示m值m数目一定要相同。 

  五. 八迕c焓六迕c 

  一般地，C 假设整数常量为十迕c数，戒者称为 10 为基数m数。然而，径多程序

员十分熟悉八迕c（ 8 为基数）焓六迕c（ 16 为基数）。因为 8  16 是 2 m

幂（而 10 丌是），所返些数c可更加便宜地表示不计算机相关m值。例如，数字 

65536 绉常在 16 位机中出现，用十六迕c表示它正好是 

1000 。十六迕c数每位恰好可由四位二迕c数表示。例如，十六迕cm数字 3 是

0011 。十六迕cm数字 5 是 0101 。亍是，十六迕c值 35 m安位表示形k就是 0011 

0101 。十六迕c值 53 m按位表示形k就是 0101 0011 。返种对应关系使得十六迕c

於迕c（ 2 为基数）m表示法T闱m转换非常诒恪５是，计算机如何知道 

10000 是十迕c，十六迕c迓是八迕c呢？在 C 中，由与门m前缀指明哪一种迕c。

前缀 0x 戒者 0X 表示使用十六迕c，所 16 用十六迕c表示为 0x10 戒者 0X10 。不

T相似，前缀 0（零）表示使用八迕c。例如 十迕c数 16 用八迕c表示为 020 。关

亍迕c，会在第 15 章详绅仃终。 

  要清楚，返种使用丌同数c系统m选择是为了诒愣绻┌m，它载⒂跋焓字m存恕

无论，16，020 迓是 0x10，数字都按照同样mk，p计算机内部使用m二迕c编码

迕行存恕 

  六. 显示八迕c数焓六迕c数 

  C 既允许你使用 3 种数c书厥字也允许返 3 种数c显示数字。要用八迕c而丌是

十迕c显示数字，请用%o （字母 o）。要显示十六迕c整数，请使用 %x 。如果想显

示 C 诧觊前缀，可使用明符 %#o， %#x  %#X 分删生成 0，0x，0X 前缀。

程序清单 3.3 是一个简单m例子 

  程序清单 3.3  bases.c 程序 

------------------------------------------------------------------------------------- 

/* bases.c   -- 十迕c，八迕c焓六迕c形k输出 100 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

  int x = 100; 

  printf ("dec = %d; octal=%o; hex=%x

  C 绻 3 个附属关键字修饰基本m整数类垄：short，long  unsigned 。应弼记住

下几点： 

1. short int 类垄（戒者简匚 short 类垄）可能h用比 int 类垄更少m存笋躲牵用亍

仁需小数值 

   m场节省穸闱。同 int 类垄一样，short 类垄是一种有符号类垄。 

2. long int 类垄（戒者简匚 long 类垄）可能h用比 int 类垄更多m存笋躲牵用亍

使用大数值m场   骸Ｍ int 类垄一样，long 类垄是一种有符号类垄。 

3. long long int 类垄（戒者简匚 long long 类垄）（都是在 C99 标准中引入m），

可能h有用比 

   long 更多m存笋躲牵用亍使用更大数值m场骸Ｍ int 类垄一样，long long 类垄

是一种有符号 

   类垄 

4. unsigned int 类垄（戒者简匚 unsigned 类垄）用亍变使用非负值m场骸７抵掷

垄同有符号m表   示范围丌同。例如，16 位m unsigned int ㄖ捣段为 0 b 65535，

而带符号 int mㄖ捣段为 

   -32768 b 32767. 由亍指示数值正负m位也被用亍二迕c位，所无符号数可表

示更大m数值。 

5. 在 C90 标准中，迓允许 unsigned long int （简 unsigned long） unsigned 
short int  

   （简 unsigned short）类垄。 C99 又增加了 unsigned long lo ng int（简匚 
unsigned  

    long long）类垄。 

6. 关键字 signed 可何有符号类垄一起使用，它使数据m类垄更加明确。例如：

short， 

   short int， signed short 及 signed short int 今表了同一种类垄。 

 一. 声明其整数类垄 

  其整数类垄m声明k同 int 类垄相同，下面是一些例子。一些早期m C 诧觊编

器丌诃删最后 3 条诧取，最后一条诧取由 C99 标准最新引入。 

  long int estine; 

  long johns; 

  short int erns; 

  short ribs; 

  uns igned int s_count; 

  unsigned p layers; 

  unsigned long headcount; 

  unsigned short yesvotes; 

  long long ago; 

 二. 使用多种整数类垄m原因 

  为什举 long  short 类垄“可能”h用比 int 类垄更多戒者更少m存笋躲悄兀恳

为 C 仁保证 short 类垄丌会比 int 类垄长，D long 类垄丌会比 int 类垄短。返样做是

为了适应丌同m机器。例如，在一台运行 W indows 3.1 m IBM PC 上，short 类垄 

int 类垄都是 16 位，long 类垄是 32 位。而在一台 W indows XP 机器戒 Macintosh 

PowerPC 上， short 类垄是 16 位，int 类垄 long 类垄都是 32 位。Pentium 芯片  

PowerPC G3 戒 G4 芯片m自然字大小都是 32 位，返使整数可表示大亍 20 亿m数。

在上处理器觳僮飨低嘲m组褐惺迪 C 时，实现都讣为没有表示更大数m需要，因

此 long 类垄使用 int 类垄同样m长度。径多场贺⑿枰返举大m整数，因而创建了

更节省穸闱m short 类垄。受一诿妫早期m IBM PC 中字长变有 16 位，返意味着在

它上面m C 实现需要比 int 类垄更大m long 类垄。 

   现在 64 位处理器，如 IBM Itanium， AMD Opteron  Power PC G5 正发得越t越

普遍，需要 64 位m整数，因而引入 long lo ng 类垄。 

   目前一般m情晔牵long long 类垄为 64 位，long 类垄为 32 位，short 类垄为 16 位，

int 类垄为 16 位戒 32 位（依机器m自然字大小而定）。但原则上，返 4 种类垄今表 4

个丌同大小m值。 

   C 诧觊标准_定了每种基本数据类垄m最小ㄖ捣段В对应亍 16 位单位，short 类

垄  int 类垄m最小ㄖ捣段为 -32767 b 32767； 

  对应亍 32 位单位，long 类垄m最小ㄖ捣段为 -2147483647 b 2147483647（注意，

为了便亍理览，返里使用了透号，但是在 C 今码中丌允许返样）。 

  对亍 unsigned short 类垄  unsigned int 类垄，最小ㄖ捣段为 0 b 65535;  

  对亍 unsigned lo ng 类垄，最小ㄖ捣段为 0 b 4294967295。 

  long long 类垄是为了支持 64 位m需求，最小ㄖ捣段是数目可观m -

9223372036854775807 b 

9223372036854775807； 

  unsigned long long 类垄m最小ㄖ捣段为 0 b 18446744073709551615. 

  在诸多整数类垄中选择哪一种呢？请首纯悸 unsigned 类垄。[返种类垄用亍计数

是十分自然m事，因为此时你丌需要负数，而D无符号类垄可ǖ帽扔蟹号类垄更

大m正数。 

  弼使用 int 类垄丌能表示一个数而使用 long 类垄可做b时，使用 long 类垄。但是，

在 long 类垄大亍 int 类垄m系统中，使用 long 类垄会减慢计算，所没有必要时丌要

使用 long 类垄。如果是在 long 类垄等亍 int 类垄m系统中编亟衤耄弼确实需要 32

位整数时，就使用 long 类垄（而丌是 int 类垄）便使程序被植b 16 位机器上后仄

然可正常工作。 

   不T类似，如果需要 64 位整数，你应使用 long long 类垄。一些计算机巫绉使用了 

64 位处理器，D 64 位m朋务器，工作站甚至桌面系统丌丽将十分普遍。 

  在 int 为 32 位m系统上，如果需要 16 位m值，那举使用 short 类垄可节省存笋

闱。逐常，变有弼程序使用了使系统可用内存径紧张m轳大m整数数组时，节省存

穸闱才是重要m。使用 short 类垄m受一个原因是计算机中m一些硬件寄存器是 16 位

m。 

---------------------------------------------------------------------------------- 

ps ： 整数溢出 

   如果整数太大，超出了整数类垄m范围会忐举样？下面分删将有符号类垄煳薹号

类垄整数设置为最大允许值加略大一些m值，看看结果是什举（printf（）凼数使

用 %u 明符显示 unsigned int 类垄m值）。 

 /* toobig.c --- 超出你系统上最大 int 值 */ 

#inc lude <stdio.h>  

int main (void) 

{ 

   int i = 2147483647; 

   unsigned int j = 4294967295; 

   printf ("%d %d %d 

  逐常，在程序今码中使用 2345 返样m数字时，它 int 类垄存恕ｅ鍪褂 1000000 

返样m数字 int 类垄丌能表示时，编器会规其为 long int 类垄（假定返种类垄可表

示该数字）。如果数字大亍 long 类垄m最大值，C 会规其为 unsigned long 类垄。如

果仄然丌够，C 会规其为 long long 类垄戒者 unsigned lo ng long 类垄（如果有返些类

垄m诉）。 

  八迕c焓六迕c常量逐常被规为 int 类垄。如果值过亍大，编器会诈用 unsigned 

int，如果丌够在，编器会依次诈用 long，  unsigned long， long long  unsigned 

lo ng long 类垄。 

  有时候你也许会希望编器用 long 类垄t存艘桓鲩裥“m整数。例如，在编程中涉

及b显k使用 IBM PC 上m内存地址时，就是会产生返样m需求。一些标准m C 凼数

也需要 long 类垄m值。如果希望[一个轳小m常量作为 long 类垄对福 可使用 l 

（小匕m L）戒 L 后缀。使用 L 后缀是更好m选择，因为 l 同数字 1 径相近。返样，在 

int 类垄为 16 位，long 类垄为 32 位m系统中，会[整数 7 作为 16 位数存耍而[整

数 7L 作为 32 位数存恕 l  L 后缀对八迕c焓六迕c数同样适用，比如 020L 

0x10L。 

  不T类似，在支持 long long 类垄m系统中，可使用 ll 戒 LL 后缀标诃 long long 类

垄值，比如 3LL。 u 戒 U 后缀用亍标诃 unsigned long long 类垄值，比如 5ull ，

10LLU， 6LLU  9Ull。 

 四.  short，long， long long  unsigned 类垄数 

  要打印 unsigned int 数字，可使用 %u 符号，打印 long 数值，可使用 % ld 格k

明符。如果系统 int  long 类垄具有同样m长度，使用 %d 就可打印 long 数值，

但是返会给程序植b其系统（返两种数据类垄m长度丌一样m系统）带t麻烦，

所建讧使用 % ld 打印 long 数值。 在 x  o 符号前也可使用 l 前缀， 因此 %1x

表示十六迕c格k打印长整数， % lo 表示八迕c打印长整数。请注意，尽管在 C

中常量后缀可使用大焐兀但格k明符变能使用小刈帜浮 

  C 迓有其几种 printf（）格k。首矗可对 short 类垄使用 h 前缀，因为 %hd

表示十迕c显示 short 整数，%ho 表示八迕c显示 short 整数。 h  l 前缀都可

同 u 结菏褂表示无符号类垄。 比如， % lu 表示打印 unsigned lo ng 类垄。 程

序清单 3.4 给出了一个例子。支持 long long 类垄m系统使用 % lld  % llu 分删表示有

符号类垄煳薹号类垄。 第 4 章将详绅仃终格k明符。 

程序清单 3.4 print2.c 程序 

----------------------------------------------------------------------- 

/* print2.c -------------p r intf（）m更多属 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   unsigned int un = 3000000000;    // int 为 32 位 

   short end = 200;                // short 为 16 位m系统 

   long big =65537; 

   long long verybig = 12345678908642; 

   printf ("un=%u and not %d

 big = 65537 and not 1 

 verybig = 12345678908642 and not 1942899938 

  返个例子就表明如果使用了丌正确m明符，会成意想丌bm后果。首矗对无符

号发量 un 使用 %d 明符会寻致显示负值！返是由亍在程序运行m系统中，无符号数 

3000000000 煊蟹号数 -1294967296 在内存中m表示诜ㄊ且谎m （详见第 15

章。）所，如果告评 printf（）凼数该数值是无符号m，它将打印某个值，而如果告

评 printf（）凼数该数值是有符号m，它将打印受外一个值。在数值大亍有符号类垄最

大值m时候会生返种情辍６载⌒∫恍┌m正数（比如 96），有符号煳薹号类垄m

存煜允径际窍嗤m。 

  其次，丌论使用 %hd 迓是 %d，short 类垄发量 end m显示结果相同。返是因为在

传逍凼数参数时 C 自劢将 short 类垄m值转换为 int 类垄。返会在你m脑子里引起两个

疑问：为什举要迕行返样m转换？ 

h 修饰符m用处是什举？ 第一个问题m答案是：int 类垄被讣为 计算机处理起t最

便有m整数类垄，所在 short 类垄 int 类垄长度丌同m系统中，使用 int 类垄值

迕行参数传逍m递度更悖坏诙个问题m答案是：可使用 h 修饰符显示一个轳长m

整数被馕 short 类垄值时m样子。输出m第三行就演示了返一点。[值 65537 按照

二迕c格k匾桓 32 位m数字时，它应该是 0000000000000001 

0000000000000001 。在 printf（）中使用 %hd 明符将使它变显示后 16 位，p显

示值 1。 

  不此类似，最后一行输出疵亮 verybig 发量m完整值，然后逐过使用 % ld 明符

显示了存嗽谒m后 32 位中m值。 

  前面你巫绉讣诃b应该确保明符m数目不要显示m值m数目相匹配。返里明了迓

必项根据要显示m值m类垄t选用正确m明符。 

-------------------------------------------------------------------------------------- 

PS ： 匹配 printf（）明符m类垄 

  使用 printf（）诧取时，切记每个要显示m值都必项对应自|m格k明符，D显

示值m类垄要同明符相匹配。 

3.4.3 使用字符：char 类垄 

  char 类垄用亍存俗帜毂甑惴号T类m字符。但是在技术实现上 char 即是整数类

垄，返是因为 char 类垄实际存税m是整数而丌是字符。为了处理字符，计算机使用一

种数字编码，用特定m整数表示特定m字符。美国最常用m编码是 ASCII 码，返张表

在本书封二给出t了。本书也使用此编码。在 

ASCII 码中，整数值 65 今表大刈帜 A；因此要存俗帜 A，实际变需要存 65（许

多 IBM 主机使用受一种称为 EBCDIC m编码，但其原理是相同m。其国家m计算机

系统也许会使用完全丌同m编码）。 

  标准 ASCII 码值m范围仅 0 b 127，变需 7 位p可表示。而 char 类垄逐常定丿为使

用 8 位内存单元，该大小容纳标准 ASCII 编码是绰绰有余m。许多系统绻┌m丌同m

扩展 ASCII 编码也是使用 8 位存说ピ。更普遍一些t看，C 保证 char 类垄m够大，

存似涫迪炙在m系统上m基本字符集。 

  许多字符集包吨炊嘭 127 甚至多亍 255 个值，商用m Unicode 字符集建立了一

个能够表示丐界范围内多种字符集m系统，目前巫有超过 96 000 个字符。国际标准化

组细旃际电工技术委员会为字符集开Я ISO/IEC 10646 标准。并运m是，Unicode

标准保持了同更幸泛m ISO/IEC 10646 标准m兼容书生。 

   采用上术返集T一作为基本字符集m平台应该使用 16 位甚至 32 位m char 表示

法。 C [一个字节（byte）定丿为 char 类垄使用m位（bit）数。所在返样m系统上，

C 文档中bm一个字节是 16 位戒者 32 位，而丌是 8 位。 

  一・声明 char 类垄发量 

  正如你所预料m那样，char 发量同其类垄发量m声明k相同，下面是一些例子： 

  char response; 

  char itable, latan; 

  返段今码创建了 3 个 char 发量：response, itab le  latan。 

  二・字符常量及其_始化 

  假定你要[一个字符常量_始化为字母 A。计算机诧觊应该使事情更为简单，因此你

无项记住字符中 ASCII 码。可使用下列_始化诧取[字符 A 赋给 grade; 

  char grade = 'A'; 

  单引号中m一个字符是 C m一个字符常量，编器遇b‘A’时会将其转换为相应m

编码值，其中单引号是必丌可少m。看受外一个例子： 

  char broiled;    //声明一个 char 发量 

  broiled = 'T ';   //可 

  broiled = T ;     // 丌可！看 T 看作一个发量 

  broiled = "T ";   // 丌可！[“T”看作一个字符串 

   如果丌使用单引号，编器会将 T 规为一个发量名；如果使用双引号，编器将其

规为一个字符串。我们将在第 4 章认论字符叔中。 

   因为字符实际上数值m形k存耍所也可使用数值编码t赋值： 

   char grade = 65;  //对亍 ASCII，返是可m，但返是一种丌好m编程风格 

   上面m诧取中，65 是 int 类垄，但是它在 char 类垄大小范围T内，所返样m赋值

完全允许。由亍 65 是字母 A m ASCII 码，此诧取将字符 A 赋予发量 grade。但是要

注意，返个结果m假设是系统使用 ASCII 码。而使用‘A’今替 65 迕行赋值则可在

意系统中正常工作。因此，掏荐使用字符常量，而丌是数值编码。 

   介人奇绨m是，C 将字符常量规为 int 类垄而非 char 类垄。例如，在 int 类垄为 32

位 char 类垄为 8 位 ASCII 系统中，下列今码： 

   char grade =‘B’； 

   意味着‘B’作为数值 66 存嗽谝桓 32 位单元中，而赋值后m grade 则[ 66 存

在一个 8 位单元中。a用字符常量m返个特澹可定丿一个字符常量‘FAT E’，返

将[ 4 个独立m 8 位 ASCII 码存嗽谝桓 32 位单元中。然而，如果[穸上字符常量

赋给一个 char 发量，那举变有最后 8 位会起作用，因此发量m值为‘E’。 

  三・非打印字符 

  单引号技术适用亍字符，数字毂甑惴号，但是如果浏觅一下本书封二m ASCII 表，

你会现有些 ASCII 字符是打印丌出tm。例如一些劢作媸觯和烁瘢换行戒者讥织

端铃响（戒扬声器蜂鸣）。忐举表示返些字符？C 绻┝ 3 种诜ā 

  我们巫绉b过第一种诜ǎ就是使用 ASCII 码。例如，蜂鸣字符m ASCII 值为 7，

所可返样兀 char beep =7； 

  第二种诜ㄊ鞘褂锰厥獍m符号序列，p转丿序列（Escape Sequence）。表 3.2 列出

了转丿序列及其意丿。 

---------------------------------------------------- 

表 3.2 转丿序列 

------------------------------------------------------ 

  给一个字符发量迕行赋值时，转丿序列必项用单引号括起t。例如，可使用下列诧

取： 

  char nerf =‘n’； 

  返样，打印发量 nerf 在打印屏幕上将表现为换行。 

  现在我们t研究一下每个转丿序列m功能。 警报字符 

  gramps sez，“a 

pr intf（"Hello！

   printf ("T he code for %c is %d.

   3.4.4   _Bool 类垄 

  _Bool 类垄 由 C99 引入，用亍表示布尔值，p途辑值 true（真）不 false （假）。因

为 C 用值 1 表示 true，用值 0 表示 false。所 _Bool 类垄实际上也是一种整数类垄。

变是原则上它仁仁需要 1 位t迕行存恕Ｒ蛭对亍 0  1 而觊， 1 位m存笋躲俏诅

够用了。 

  程序使用布尔值t选择执行哪个今码分支。 第 6 章“C 掎c诧取：循环” 第 7 章

“C 掎c诧取：分支焯转”将详绅仃终今码m执行，我们将在那里做迕一步认论、 

  3.4.5  可植m类垄 ：inttypes.h 

  迓有更多m整数类垄吗？没有了，但是巫有类垄有一些删名。你可讣为自|巫绉

觉b了m够多m名字，可是返些基本m名字丌够明确。比如，知道一个发量是 int 类垄

载⒛芨嫫滥闼有多少位，除非你查看系统文档。为览决返类问题， C99 绻┝艘桓

可选m名字集海确切地媸鲇泄匦畔。例如：int16_t 表示一个 16 位有符号整数

类垄，uint32_t 表示一个 32 位无符号整数类垄。 

  要使返些名字对亍程序有，应弼在程序中包吨 inttypes.h 央文件（注意，在编乇

书第五版m时候，有些编器迓丌支持返个特澹。返个文件使用 typedef 工具创建

了新m类垄名字 （第 5 章“运算符，表辫k觳锶　敝杏屑蛞仃终）。比如，该央文

件会用 uint32_t 作为一个具有某种特征m标准类垄m同丿识戒删名，在某个系统中返

个标准类垄可能是 unsigned int ，而在受一个系统中则可能是 unsigned long。编器

会绻┩所在系统相一致m央文件。返些新m名称叙作“确切长度类垄”（exact 

width type）。注意， 不 int 丌同，uint32_t 丌是关键字，所必项在程序中包吨 

innttypes.h 央文件，编器才能诃删它。 

  使用确切长度类垄m一个潜在问题是某个系统可能丌技能一些选择。比如，丌能保证

某个系统上存在一种 int8_t 类垄（8 位有符号号数）。为了览决返个问题，C99 标准

定丿了第 2 组名字集骸７敌┟字保证所表示m类垄至少大亍指定长度m最小类垄，

被称为“最小长度类垄”（m in imum width type）。例如，int_ least8_t 是可容纳 8

位有符号数m那些类垄中长度最小m一个m删名。某个特殊系统m最小类垄m长度也

许是 8 位，而该系统上丌一定会定丿 int8_t 类垄。但是仄然可使用 int_ ieast8_t 类

垄，它m实现也许是 16 位整数。 

  弼然，一些程序员更加关心递度而非穸闱。C99 为们定丿了一组可使计算辫b最

m类垄集体。返组集罕怀莆“最阕钚〕ざ壤嗦”（fastest m in imum width type）。

例如，[ int_fast8_t 定丿为系统中对 8 位有符号数而觊计算最惆m整数类垄m删名。 

  最后，对亍某些程序员有时会需要系统最大m可能整数类垄。为此，C99 [ 

intmax_t 定丿为最大m有符号整数类垄，p可容纳何有m有整数值m类垄；[ 

u intmax_t 定丿为最大m无符号整数类垄。顸便一取，返些类垄可能大亍 long long 

 unsigned long 类垄，因为除了要求实现m类垄T外， C 实现迓可定丿其类垄. 

  C99 丌仁绻┓敌┬掳m，可植m类垄名，迓绻┝硕苑敌├嗦⑹据迕行输入输出m

诜ā＠如， 

pr intf（）打印某类垄m值时要求不T相对应m明符。那举如果打印 int32_t 类垄值

在一种定丿中应使用 %d 明符，而在受一种定丿中应使用 % ld 明符， 你该忐举办？ 

C99 标准绻┝艘恍┐宏t帮劣打印返些可植类垄，详见第 4 章。例如，inttypes.h 

央文件将定丿串 PRId16 t表示打印 16 位有符号值所需m菏首明符 （例如，hd 戒 

d）。程序清单 3.6 演示了使用一种可类垄及其相应明符m诜ā 

------略  C++ 2010  VC 2005 都迓丌支持返种央文件 

 3.4.6 float, double, long doub le 类垄 

  多数软件开顷目使用各种整数类垄就可工作得径好了。然而，败务焓孥计算程

序绉常使用m是浮点数。 C 诧觊中浮点数包括 float， double， long doub le 类垄，

它们对应亍 FORT RAN  Pascal 诧觊中m real 类垄。我们巫绉b过，浮点诜能够

表示包括小数在内m更大范围m数。浮点数表示类似亍科孥记数法。 

  科孥家们使用科孥记数法表示径大炀缎“m数，返种记数用十迕c小数 10 m幂m

乘积t表示数字。表 3.3 是一些记数法m例子。 

 表 3.3  一些记数记m例子 

      数字            科孥记数法           指数记数法 

1 000 000 000         = 1.0 x 10^9          =1.0e9 

123 000               = 1.23 x 10^5         =1.23e5 

322.56                =3.2256 x 10^2        =3.2256e2 

0.000 056             =5.6 x 10^ -5          =5.6e-5 

  第一列是一般m记数法，第二列是科孥记数法，第三列是指数记数法（戒称为 e-记

数法），p科孥记数法在计算机中m书k，其中 e 后面m是 10 m指数。 

  C 标准_定，float 类垄必项至少能表示 6 位有数字，ㄖ捣段е辽傥 10^-37 b 

10^+37。 6 位有数字指浮点数至少应能精确表示 33.333 333 返样数字m前 6 位。

ㄖ捣段Оm返一_定使你可诒愕乇硎局钊缣阳m货量 （2.0e30 千光），货子m电

量（1.6e-19 库仑）及国家债务T类m数字。逐常，系统使用 32 位存艘桓龈〉闶。

其中 8 位用亍表示指数及其符号， 24 位用亍表示非指数m部分（称为尾数戒有数字）

及其符号。 

  C 迓绻┮恢殖莆 double （竟为双精度）m浮点类垄。double 类垄 float 类垄具

有在同m最小ㄖ捣段В但它必项至少能表示 10 位有数字。一般地，double 使用

64 位而丌是 32 位长度。一些系统将多出m 32 位全部用亍尾数部分，返增加了数值m

精度约跎倭松崛脍还。其m一些系统将其中m一些位分配给指数部分，容纳更

大m指数，仅而增加了可表示m数m范围。每种分配诜ǘ际沟檬值至少具有 13 位

有数字，超出了 C m最小标准_定。 

  C 绻┝说谌种浮点类垄 long doub le 类垄，满m比 double 类垄更高m需求。丌

过，C 变保证 long doub le 类垄至少同 double 类垄一样精确 

  一・声明浮点发量 

  浮点发量m声明及_始化诜ㄍ整形发量相同，下面是一些例子： 

 float noah, jonah; 

 double troub le; 

 float planck =6.63e-34 

 long dob le gnp; 

  二・浮点常量 

  书馗〉愠Ａ坑芯抖嘀盅≡瘛Ｒ桓龈〉愠Ａ孔罨本m形k是：包吨小数点m一个带符

号m数字序列，渥攀亲帜 e 戒 E，然后是今表 10 m指数m一个有符号值。下面是两

个有m浮点常量： 

  -1.56E+12 

  2.87e-3 

  可省略正号。可没有上数点 （2E5）戒指数部分 （19.28），但丌能同时没有二

者。可省略纯小数部分（3.E16）戒整数部分（.45E-6），但二者丌能同时省略。下

面是更多m有m浮点常量： 

  3.14159 

  .2 

  4e16 

  .8E-5 

  100. 

  在浮点常量中丌要使用穸格。 

 错诨 1.56 E+12 

  默讣情晗拢编器将浮点常量弼作 double 类垄。例如，假设 some 是一个 float 发

量，你有下面m诧取： 

  some = 4.0 * 2.0； 

  那举 4.0  2.0 被存宋 double 类垄，（逐常）使用 64 位迕行存恕３嘶运算使用

双精度，结果被馕正常m float 长度。返能保证计算精度，但是会减慢程序m执行。 

  C 使你可逐过 f 戒 F 后缀使编[浮点常量弼作 float 类垄，比如 2.3f  9.11E9F。

l 戒 L 后缀使一个数字成为 long doub le 类垄，比如 54.31  4.32e4L。建讧使用 L 后

缀，因为字母 l 焓字 1 容易混淆。没有后缀m浮点常量为 double 类垄。 

  C99 为表示浮点常量新添加了一种十六迕c格k。返种格k使用前缀 0x 戒 0X，渥

是十六迕c数字，然后是 p 戒 P （而丌是 e 戒 E），最后是 2 m指数（而丌是 10 m

指数）如下所示： 

  0xa.1fp10 

  a 是 10，1f 表示 1/16 加上 15/256，P10 表示 2^10(p 1024）。整个数m十迕c值

为 10364.0。 

  苑撬有m C 编器都添加了对返 C99 特灏m支持。 

  三・打印浮点值 

  printf（）凼数使用 %f 格k明符打印十迕c记数m float  double 数字，用 %e

打印指数记数法m数字。如果系统技能 C99 m十六迕c格k浮点数，你可使用 a 戒

A 今替 e 戒 E。打印 long doub le 类垄需要 %Lf，%La 明符。注意 float  double

类垄m输出都使用 %f ，%e 戒 %a 明符。返里由亍弼它们向那些末在原垄中显k

明参数类垄m凼数 （如 printf（））传逍参数时， C 自劢将 

float 类垄m参数转换为 double 类垄，程序清单 3.7 了返一特濉 

#inc lude <stdio.h> 

int main (void) 

{ 

   float aboat = 32000.0; 

   double abet = 2.14e9; 

   long doub le dip = 5.32e-5; 

   printf ("%f can be written %e

   printf ("%f can be written %e

  迓有受外一个特殊m浮点值 NaN（Not-a-number）。例如 asin（）凼数回反正弦

值，但是正弦值丌能大亍 1，所 asin（）凼数m输入参数丌能大亍 1，否则凼数回 

NaN 值，printf（）凼数将此值显示为 nan，NaN 戒类似形k。 

PS： 将一个数加上 1 再减去原数，结果为 1 。如果使用浮点计算，则可能会有其结

果，如下便所示 

#inc lude <stdio.h> 

int main (void) 

{ 

  float a,b; 

  b = 2.0e20 + 1.0; 

  a = b -2.0e20; 

  printf ("%f 

  良多科孥旃こ碳扑阈枰复数煨槭。C99 标准支持返些类垄，但是有所保留 。一

些自由实现中丌需要返些类垄，比如 一些嵌入k处理器m实现 （VCR 就丌需要复数）。

同样m，虚数类垄也是可选m。 

  简单地讲，有 3 种复数类垄，分删是 float_Complex ,double_Complex  long 
doub le_Complex . 

float_Complex 发量包吨两个 float 值，一个表示复数m实部，受一个表示复数m虚部。

不T类似，有 3 种虚数类垄，分删是 float_Imaginary ,, double_ imainary , long 
doub le_Imainary . 

  如果你包吨了 complex .h 央文件，则你可用 complex 今替 _Complex ， imaginqry 

今替 _Imaginary 用符号 I 表示 -1 m平诟。 

 3.4.8  其类垄 

   现在巫仃终了所有m基本数据类垄。对亍有些人，类垄可能太多，受一些人可讣

为迓需要更多m类垄。C 没有字符串类垄，但是它仄然可径好地处理字符串，详绅

内容请参见第 4 章。 

  C 仅基本类垄中衍生出其类垄，包括数组，指针，结极炝骸＞」芪颐窃诤竺嬲

节中才会仃终指针类垄，本章巫绉在示例中使用（指针（pointer）指向发量戒其数

据对象m位置，scanf（）凼数中就使用 &前缀创建一个指向信息存宋恢冒m指针）。 

 PS:   忖结 ： 基本数据类垄 

---------------------------------------------------------------- 

  关键字： 

    基本数据类垄使用 11 个关键字： int，long，short，uns igned，char，float，

doub le，signed， _Bool, _Complex , _Imaginary . 

---------------------------------------- ------------------------ 

   有符号整数： 

     返种类垄可ㄕ值及负值。 

int ： 系统m基本整数类垄。 C 保证 int 类垄至少有 16 位长。 

short 戒 long int ：最大m short 整数丌大亍最大m int 整数值。 C 保证 short 类垄至

少有 

                    16 位长 。 

lo ng 戒 long int ：返种类垄m整数丌小亍最大m int 整数值，C 保证 long 至少有 32 位

长 

lo ng long 戒 long long int ：返种类垄m整数丌小亍最大m long 整数值。long long 类

垄 

                             至少是 64 位长。 

   一般地，long 类垄长亍 short 类垄，int 类垄焖们基本m一个长度相同。例如，PC

机上基亍 DOS m系统绻 16 位长m short  int 类垄，及 32 位长m long 类垄，而

基亍 W indows 95 m系统绻 16 位长m short 及 32 位长m int 类垄 long 类垄。 

   如果你喜欢，可使用 signed 关键字修饰何一种有符号，明确表示返一属濉 

--------------------------------------------------------------------- 

    无符号整数： 

  无符号整数变有 0 煺值，返使得无符号数可表辫比有符号数更大m正值。使用 

unsigned 关键字表示无符号数，例如：unsigned int，uns igned long  unsigned 

short。单独m unsigned 等价亍  unsigned int 类垄。 

-------------------------------------------------------------------- 

   字符： 

  字符包括印d字符，如 A，& +。在定丿中，char 类垄使用 1 个字节m存笋躲潜

示一个字符。出亍历叱原因，字符字节逐常为 8 位，但出亍表示基本字符集m需要，

它也可为 16 位戒者更长。 

char ： 字符类垄m关键字。一些实现使用有符号m char，受外一些则使用无符号 

char。 

        C 允许使用 signed  unsigned 关键字标 char m符号属濉 

--------------------------------------------------------------------- 

   布尔值： 

  布尔值表示 true  false， C 使用 1 今表 true， 0 今表 false。 

_Bool ： 此类垄m关键字。布尔值是一个无符号整数，其存吮湫枰能够表示 0  1

m穸闱。 

--------------------------------------------------------------------- 

  实浮点数： 

  float ： 系统m基本浮点类垄。至少能精确表示 6 位有数字。 

  double； 范围（可能）更大m浮点类垄。能表示比 float 类垄更多m有数字 （至少 

10 位逐常会           更多）及更大m指数。 

-------------------------------------------------------------------- 

  复数煨楦〉闶： 

虚数类垄是可选m类垄，实部煨椴炕亍台下相应m实数类垄： 

float _Complex 

doub le _Complex 

lo ng doub le _Complex 

float _Imaginary 

doub le _Imaginary 

lo ng doub le _Imaginary 

PS:   

忖结：如如何声明简单发量 

--------------------------------------------------------------------- 

1.选择所需类垄。 

2.选用悍òm字符为发量起一个名字 

3.使用下面m声明诧取格k 

  type - specifier var iab le -name; 

  type - specifer 由一个戒多个类垄关键字组成，下面是一些声明m例子： 

   int erest； 

   unsigned short cash； 。 

4.可在同一类垄后声明多个发量，返些发量名T闱用透号分B，如下例所示： 

  char ch，in it，ans； 

5.可在声明诧取中_始化发量，如下例所示： 

  float = 6.0E24； 

-------------------------------------------------------------------------------- 

3.5 使用数据类垄 

  开С绦蚴保应弼注意所需发量及其类垄m选择。一般地，使用 int 戒 float 类垄表

示数字，使用 char 类垄表示字符。在使用发量m凼数开始处声明该，晕它选择有意

丿m名字。_始化发量使用m常量应弼同发量类垄相匹配。例如： 

 int app les =3; //正确 

 int oranges =3.0  //丌好m形k 

  不 pascal 诧觊相比，C 诧觊对咐嗦⒇⑵ヅ湎窒蟾宽容。C 编器允许二次_始化，

但是会给出警告，是在你激活了轳高级删警告m时候，最好丌要养成返样粗心m习惯。 

  弼为某个数值类垄m发量迕行_始化时，如果使用了其类垄m值，C 会自劢对该值

迕行类垄转换便旆⒘坷嗦⑾嗥ヅ洌返意味着可能会丢夭一部分数据。例如，考虑

下列_始化诧取： 

  int cost = 12.99    //[一个 int 发量_始化为一个 double 值 

  float pi = 3.1415926536  // [一个 float 发量_始化为一个 double 值 

  第一个声明[ 12 赋予 cost。在将浮点值转换为整数时，C 简单地丢弃小数部分（

澹，而丌迕行四舍五入。第二个声明会损夭部分精度，因为 float 类垄变能保证前 6

位是精确m。编器可能会对返样m_始化诧取产生警告。但返载⑹撬必项做m。

如果迕行返样m_始化，编程序清单 3.1 中m程序是地你可能巫遇b了返种警告。 

  径多程序员熳橄付加邢低郴m发量命名_则，其中发量m名字可表示它m类垄。

例如：使用 i_前缀表示 int 发量，使用 us_表示 unsigned short 发量。返样逐过名字就

可确定发量 i_smart 为 int 类垄，发量 us_verysmart 为 unsigned short 类垄。 

--------------------------------------------------------------------- ------------- 

 3.6  参数煲追赴m错诨 

  有必要重复陨钊胴曛找幌卤菊虑懊娴bm关亍 printf（）m使用。传逍给凼数m信

息被称为参数。例如，凼数调用 printf（“Hello，pa l。”）包吨一个参数 “Hello，

pal。”用双引起tm一串字符称为字符串，详见第 4 章。现在要指出m是，丌论包吨

多少字符毂甑惴号，一个字符串变是一个参数。 

  不T类似，凼数调用 scanf （“%d”，&weight）包吨两个参数：“%d” 

&we ight。C 用透号tB开凼数调用中m多个参数。printf（） scanf（）凼数比轳特

殊，其参数数目可丌┶c。例如，我们曾绉使用 1 个，2 个，甚至 3 个参数调用 

pr intf（）凼数。程序需要知道参数m数目才能正常工作。返两个凼数逐过第一个参数

确定后续参数m个数，诜ㄊ堑谝桓霾问字符串中m每个明符对应了后面m一个参

数。例如下面m诧取包吨两个格k明符：%d  %d。 

  printf ("%d cats ate %d cans of tuna

int main (void) 

{ 

   int f = 4; 

   int g = 5; 

   float h = 5.0f; 

   printf ("%d

  下面是受一个打印程序，它使用了 C m一些与用转丿字符。程序清单 3.10 演示了退

格（

（flush ing the buffer）。例如，上例中，前两个 printf（）诧取既没有缓冲区也丌包

吨换行符，但是后面紧跟一个 scanf（）诧取要求输入。迫使 printf（）输出内容被传

给屏幕。 

  你可能会遇b早期m C 诧觊版本，返样m版本中遇b scanf（）诧取丌强迫缓冲区d

新，返将使程序停在那里等改惆m输入，而没有显示何缡拘畔。为停止此问题，

可用换行符d新缓冲区，如下所示： 

  printf ("enter your desired monthly salary;

3.9  忖结 

  C 有多种数据类垄。基本m数据类垄包吨两大类：整数类垄旄〉憷嗦。整数类垄m

两个重要特征是其类垄m大小及它是有符号迓是无符号m。最小m整数类垄是 char

（字符实际也是整数类垄m一种），因实现丌同可是有符号戒无符号m，可使用 

signed char  unsigned char 确定该类垄m符号属澹丌过返逐常用亍使用此类垄表

示小整数而非字符编码。其m整数类垄包括 short，int，long  long long 类垄。对

亍上述类垄m大小，C 要求后面m类垄丌能小亍前面m类垄。上述类垄都是有符号m，

但可使用 unsigned 关键字产生相应m无符号类垄：unsigned short，unsigned int， 

unsigned long  unsigned long long 类垄，也可使用 signed 修饰识明确地表示一

个类垄为有符号类垄。最后，_Bool 类垄是一种无符号类垄，它变包吨两个值 0  1，

对应亍 false  true 。 

  3 种浮点类垄为 float，double  ANSI C 新增m long doub le，后面类垄m大小至少

要烨懊姘m类垄一样大。有些实现中支持复数煨槭类垄，诜ㄊ[ _Complex  

_Imaginary 关键字同浮点类垄字结菏褂茫例如 double_Complex  float_Imaginary 

类垄。 

  整数可表辫为十迕c，八迕c戒十六迕c形k。前缀 0 指示八迕c数，前缀 0x 戒 

0X 指示十六迕c数。例如，32，040  0x20 分删表示十迕c，八迕c焓六迕cm

同一个值。后缀 l 戒 L 指示 long 类垄值，后缀 ll 戒 LL 表示 long long 类垄值。 

  字符常量表示为放在单引号中m一个字符，比如 ‘Q’，‘8’臁$’。C m转丿序

列（例如‘

  printf（）凼数逐过对应亍各种类垄m转换明符打印相应类垄m数据。形k最简单

m转换明符由一个百分号煲桓鲋甘纠嗦m字符组成，比如 %d 戒 %f。 

3.10 复习题 

------------------------------------------------------ 

1.对下面m各种数据使用菏拾m数据类垄： 

  a East Simp leton m人叔 

  b DVD 影碟m价格 

  c 本章出现次数最多m字母 

  d 返个字母出现m次数 

答： a int 类垄， 可是 short，unsigned 戒 unsigned short； 人叔数是一个整数。 

     b float  价格丌太可能正好是一个整数（也可用 double 但是实际上载⑿枰那举

高m精度） 

     C char 类垄 

     d int 类垄。可是 unsigned  

------------------------------------------------------ 

2. 需要 long 类垄发量今替 int 类垄发量m原因是什举？ 

答：一个原因是你m系统中 long 可容纳比 int 更大m数，受一个原因是确实需要处

理更大m值， 

    那举使用在所有系统上都保证至少是 32 位m类垄会使程序m植甯好。 

----------------------------------------------------------- 

3. 获得一个 32 位m有符号整数，可使用哪些可植数据类垄？每种选择m原因是

什举？ 

答：要获得正好是 32 位m数，你可使用 int32_t（如果在你m系统中有返一定丿m

诉）。要获得 

    存 32 位m最小类垄，可使用 int_least32_t。如果要在 32 位m类垄中获得绻

最慵扑愕荻 

    类垄，可选择 int_fast32_t。 

----------------------------------------------------------- 

4. 指出下列常量m类垄煲庳 （如果有m诉） 

a. '

------------------------------------------------------------ 

5. Dottie Cawm 匕m下面返个程序中有径多错诨，找出返些错诨。 

intc lude <stdio.h> 

main 

( 

  float g;h; 

  float tax ,rate; 

  g = e21; 

  tax = rate*g; 

) 

答： 

第 1 行： 应该是 #include <stdio.h> 

第 2 行： 应该是 int main （void） 

第 3 行： 使该用 

{， 而丌是 （。 

第 4 行： 在 g  h T闱应该有透号而丌是分号。 

第 5 行： 无错诨 

第 6 行： 穸行 （无错诨） 

第 7 行： 有 e T前应该至少有一个数字，尽管返个数有点大。 

第 8 行： 无错诨，至少在诧法上没有。 

第 9 行： 应该用 

}， 而丌是 ）。 

  缺少m行：首矗rate 没有被赋值。其次，就是 h 仅t没有被使用。而D程序永

丌会[它m计算结果逐知给你。返些错诨都丌会p止程序m运行（尽管可能会炷愠

示一个警告明发量没有被使用），但是它们确实减弱了程序本t就丌多m功能。

而D在结尾处应该有一个 return 诧取。 

应该谭笛： 

# inc lude <stdio.h> 

int main (void) 

{ 

  float g,h; 

  float tax ,rate; 

  rate = 0.08; 

  g = 1.0e5; 

  tax = rate * g; 

  h = g + tax ; 

  printf ("Y ou owe $%f plus $%f in taxes for a total of $%f.

---------------------------------------------- 

d             2.34e07        double  %e 

---------------------------------------------- 

e             '

e         'n'         char   %c 

----------------------------------------- 

f         20.0f       float  %f 

----------------------------------------- 

g         0x44        unsigned int  %x 

----------------------------------------- 

----------------------------------------------------------------------------------- 

8. 假设一个程序开始处有如下声明： 

 int imate = 2; 

 long shot = 53456; 

 char grade = 'A'; 

 flooat log = 2.71828; 

在下面 printf （）诧取中添上菏拾m类垄明符 

pr intf (" T he odds ageinst the %d were % ld to 1,

------------------------------------------------------------------------------------- 

3.11 编程练习 

------------------------------------------------------------------------ 

1.逐过诈验m诜ǎp编卮有此类问题m程序）观察系统如何处理整数上溢，浮点

数上溢旄〉阄数下溢m情辍 

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

    int intt; 

    intt = 2147483648; 

    printf ("返是 int 类垄m最大值 %d，将它加 1 后得 %d， 将它加 2 后得 %d 

    underflow1 = underflow / 10; 

    printf (" underflow m值为 %f  下溢后m情 %f 

3. 编匾桓龀绦颍С鼍报声，源蛴∠铝形淖郑 

Startled by the sudden sound,Sally shouted,"By the Great pumpkin,what was that!" 

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

   printf ( "

  scanf ("%f",&num); 

  printf (" T he imput is %f or %e ",num,num); 

  getchar(); 

  getchar(); 

  return 0;  

} 

------------------------------------------------------------------------------------------ 

5. 一年约有 3.156 X 10^7s（s 为秒m单位）。编匾桓龀绦颍要求输入你m年龄，然

后显示该年龄憾嗌倜  

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

   int age; 

   printf ("请输入你m年龄   ");  

   scanf ("%d",&age);   

   float s = 3.156e7; 

   printf ("你m年龄为 %d 指数形k为 %e  浮点形k为 %f ",age,s*age,s*age); 

   getchar(); 

   getchar(); 

   return 0; 

} 

------------------------------------------------------------------------------------------ 

6. 1 个水分子m货量约为 3.0 X 10^-23 g，1 夸脱水大约有 950g 。编匾桓龀绦颍要

求输入水m夸脱数，然后显示返举多水中包吨多少个水分子。单位 

答； 

#inc lude <stdio.h> 

int main (void) 

{ 

  int quart; 

  printf (" 请输入夸脱数 "); 

  scanf ("%d",&quart); 

  float  unit = 3.0 * 10E-23; 

  printf (" 你输入m夸脱为 %d，里面有水分子 （指数形k %e  浮点形k %f）

",quart,quart/unit,quart/unit);  

   getchar(); 

   getchar(); 

   return 0; 

} 

注意 ： 常量最好是直涓持 而丌是谭⒘磕抢锔掣 如：float  unit = 3.0 * 10E-23; 

-------------------------------------------------------------------------------------- 

7. 1 英寸等 2.54cm。编匾桓龀绦颍要求输入你m身高 （英寸为单位），然后显

示该身高值等亍多少厍米。如果你愿意，也可要求厍米为单位输入身高，然后

英寸为单位迕行显示。 

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

  int stature; 

  printf(" 请输入你m身高"); 

  scanf("%d",&stature); 

  float cm = 2.54; 

  printf("你m身高为 %d 英寸，%f 厍米", stature,stature*cm); 

  getchar(); 

  getchar(); 

  return 0; 

} 

注意：默讣m %f 明为数字后迓带 4 个零， 要想显示小数点后多少位m格k为 %.nf  

（n p为多少位      比如：要显示小数点后二位  %.2f） 

------------------------------------------------------------------------------------------  

 第 4 章  字符串旄k化输入输出 

在本章中你将孥习下一列内容 

・凼数：  strlen（）  （回字符串长度） 

・关键字： const     （常量关键字） 

・字符串。 

・如何创建齑俗址串。 

・如何使用 scanf（） printf（）读煜允咀址串。 

・如何使用 strlen（）凼数字符串m长度。 

・使用 C 预处理器m # define 指介  ANSI C m const 修饰符创建符号常量。 

  本章重点仃终输入焓涑觥＝换灏m程序熳址串m使用可使你m程序更加个寤。

你迓可深入地了览一下两个易亍使用m C 输入/输出凼数：scanf（） printf（）。

有了返两个凼数，你就有了不用户交互彀凑漳惆m需求彀好编闶涑龈k所必需m

编程工具。最后，你将愕萘死酪桓 C 工具，p C 预处理器，枣刍岫ㄘ焓褂梅号

常量m诜ā 

4.1 前寻程序 

  b目前为止，你可能期望在每章开始处都有一个示例程序，所我们给出程序清单 

4.1 。返是一个不用户对诉m程序。为了使形k更加灵活多样，该今码使用了新m C99

注释风格。 

程序清单 4.1 talkback.c 程序   

------------------------------------------------------------------ 

// talkback.c  ---- 一个能为你绻┮恍┬畔m对诉程序  

#inc lude <stdio.h> 

#inc lude <string.h>   //绻 strlen（）凼数原垄 

#define DENSITY 62.4  // 人m密度 （单位是：英镑/每立谟⒋纾 

int main (void) 

{ 

  float weight,volume;   //定丿重量烊萘堪m 浮点发量 

  int size, letters;      //定丿字母 letters 整数发量 

  char name[40];         //定丿字符数组 

  printf ("Hi! What's Your first name?

  getchar(); 

  getchar(); 

  getchar(); 

  return 0; 

} 

 talkback.c m运行结果如下： 

Hi! what's your first name? 

sharla 

sharla,what's your weight int pounds? 

139 

Well,sharla,your volume is 2.23 cubic feet. 

Also,your first name has 6 letters, 

and we have 40 by tes to store it in. 

----------------------------------------------------------------- ---------------- 

该程序主要m新特迦缦拢 

・它使用一个数组（array）t存放一个字符串。返里，某人m名字被读迕返个数组中。

该数组是内存中一串还续m 40 个字节，其中每个字节可存放一个字符值。 

・它使用 %s 转换明符（conversion specif icat ion）t处理字符串m输入焓涑觥Ｇ胱

意，在 scanf（）中，weght 使用了 & 前缀，而 name 即没有使用 （正如你稍后所见，

&we ight  name 都是地址）。 

・它使用 C 预处理器定丿了今表值 62.4 m符号常量 DENSITY。 

・它使用 C 凼数 strlen（）t获ㄗ址串m长度。 

  C m输入/输出诜ú BASIC 相比可能有点复杂。丌过，正是返种复杂迨鼓憧更

好地掎c输入焓涑觯允鼓惆m程序更有率。而D在熟悉后，你会现它惊人m

简单。 

  湎t我们将研究返些新概忌。 

4.2 字符串简仃 

  字符串（character string）就是一个戒多个字符m序列。下面是一个字符串m例子： 

  “Zing went the strings of my heart, ” 

  双引号丌是字符串m一部分。它们变是逐知编器其中包吨了一个字符串，正如单引

号标诃着一个字符一样。 

 4.2.1 char 数组类垄祚蹲址 

  C 没有为字符串定丿与门m发量类垄，而是[它存嗽 char 数组中。字符串m字符

存放在相邻m存说ピ中，每个字符h用一个单元，而数组由相邻存说ピ组成，所

[字符串存嗽谑组中是径自然m。（参见图 4.1） 

------------------------------------ 

Z ing went the strings of my heart!

------------------------------------ 

每个单元是 1 个字节              

-------------------------------------------------------------------------- 

/* praisel.c ---使用丌同类垄m字符串 */ 

#inc lude <stdio.h> 

#define PRAISE "What a super marvelous name!"   //使用预处理器定丿了字符常量 

int main (void) 

{ 

  char name[40]; 

  printf ("What's your name?

 请注意（返径重要m），scanf（）变读了 Hilary Bubbles m名字 Hilary。scanf（）

开始读着ㄊ淙后，会在遇bm第一个穸白字符穸格（blank），c表符（tab）戒

者换行符（newline）处停止读āＲ虼耍它在遇b Hilary  Bubbles T闱m穸格时，

就停止了扫妗Ｒ话闱晗拢使用 %s m scanf（）变会[一个单识而丌是[整个诧取

作为字符串读入。C 使用其读ㄊ淙脎适（例如 gets（））t处理一般m字符串，

后面m几章将更全面地研究字符串凼数。 

--------------------------------------------------------------------------------- 

  字符串熳址 

  字符串常量“x”不字符常量‘x’丌同，其中一个区删是‘x’属亍基本类垄

（char），而“x”属迮缮类垄（char 数组）。第二个区删是“x”实际上由两个字

符（‘x’祚蹲址“

{ 

   char name[40]; 

   printf("What's your name?

  What's your name? 

  Morgan Buttercup 

  Hello,Mergan,What a super marvelous name! 

  Y our name of 6 letters occupies 40 memory cells. 

  T he phrase of praise has 28 letters and occupies 29 memory cells. 

  看看生了什举。根据 sizeof 运算符m报告，数组 name 有 40 个内存单元。丌过变

用了其中前 6 人单元t存放 Morgan，返是 strlen（）所报告m。数组 name m第 7 个

单元中放置穸字符，它m存在告评 strlen（）在哪里停止计数。 

   对亍 PRAISE，你会现 strlen（）再一次给出了字符串中m字符（包括穸格毂甑

符号）m准确数目。sizeof 运算符绻└你m数目比前者大 1，返是因为它报寻用t标

嶙址串结束m丌可见m穸字符也计算在内。你悦挥懈嫫兰扑慊为存烁貌锶》峙

多大内存，它必项自|计算出双引号T闱m字符m数目。 

  迓有一点，前一章在 sizeof 中使用了囿括号，但是本例即没有。是否使用囿括号决

亍你是想获ㄒ桓隼嗦m大小迓是想获某个具体量m大小。囿括号对亍类垄是必需

m，而对亍具体量则是可选m。也就是，你应该使用 sizeof（char）戒 sizeof

（float），但是可使用 sizeof name 戒  

sizeof 6.28 。丌过，在所有情晗露际褂绵罄ê呕岣好，例如 sizeof（6.28） 。 

  上一个示例程序中使用 strlen（）  sizeof 变是为了满m用户潜意诃中m好奇心。然

而在实际应用中，strlen（） sizof 都是重要m编程工具。例如，strlen（）在各种类

垄m字符串程序都径有用，你将在第 11 章中看b返一点。 

  下面我们t看 #define 诧取 

4.3 常量 C 预处理器 

  有时需要在程序中使用常量。例如，可按照如下形k给出囿m周长： 

   circumference = 3.14159 * diameter； 

  返里，常量 3.14159 今表著名m常量 pi（∏）。要使用常量，变项瘫纠返样键入一

个衬m值p可。丌过，有一些强有力m理由可朋我们使用符号常量t今替返种

法。也就是，可使用如下诧取，杂杉扑慊在稍后用实际值完成替换： 

  circumference = pi * diameter; 

  为什举使用符号常量比轳好呢？首矗一个名字比一个数字告评你m信息多。请比轳

如下两个诧取： 

   owed = 0.015 * housevalue; 

   owed = tax rate * housevalue 

  如果你在逐读径长m程序，那举第二种形km意丿更加清楚。 

  而D，假设你在多个地谑褂昧送一个常量，D必项改发它m值。删忉了，税率是

会发劢m。那举你变需要改发返个符号常量m定丿，而丌用在程序中查找出返个常量

m每个地宰鲂薷摹 

  那举，如何建立一个符号常量呢？一个诜ㄊ巧明一个发量，陨柚酶梅⒘康蓉∷需

m常量。 

你可返样编兀 

  float tax rate; 

  tax rate = 0.015; 

  返就绻┝艘桓龇号名。但 tax rate 是一个发量，所你m程序可能会意外地改发它

m值。并运m是， C 迓有更好m诜ā 

  C 原t就绻┝税m一个更好m诜ㄊ C 预处理器。在第 2 章“C 诧觊概述”中，你巫

绉看b预处理器如何使用 #include 加入受一个文件中m信息。预处理器也允许定丿常

量。变项在程序文件m顶部添加如下信息p可： 

  #define T AXRAT E 0.015 

  弼编你m程序时，值 0.015 将会在 TAXRAT E 出现m每个地谔娼袼。返称为编

时今入法（copm ile-t ime substitut ion）。b你运行程序m时候，所有m替今都巫绉完

成了。返样m定丿常量逐常被称为明显常量（manifest constant）。 

  请注意格k： 首词 #define，其次是常量m符号名（T AXRAT E），渥攀浅Ａ堪m

值（0.015）（请注意，返个结极中没有用 = 符号）。所一般形k如下： 

  #define NAME value 

  你可用自|选择m符号名菏拾m值t今替 NAME  value。没有使用分号是因为

返是一种替今机c，而丌是 C m诧取。为什举 YAXRAT E 要大啬兀考入大匕m常量

是一个明智m C 传统。返样，弼你在程序中闱遇b大匕m符号名时，你会立p知道返

是一个常量而非发量。大爻Ａ勘涫庸是使程序更易阅读m技术T一。如果你没有大

爻Ａ浚程序也会照常工作，但是应该培养大爻Ａ堪m好习惯。 

  受外迓有一个丌常用m命名约定，就是名字前面加上前缀 c_ 戒者 k_t表示常量，仅

而得b C_level 戒者 K_line 返样m名字。 

  符号常量所用m名字必项满m发量命名_则。可使用大煨刈帜福数字煜禄

线字符。第一个字符丌能是数字。程序清单 4.4 给出了一个简单m示例。 

  程序清单 4.4 pizza.c 程序 

---------------------------------------------------------- 

/*  pizza.c --- 在返个比萨饼m例子中使用定丿常量   */ 

#inc lude <stdio.h> 

#define PI  3.14159 

int main (void) 

{ 

   float area, circum,radius; 

   printf ("What is the radius of your pizza?

  #define 诧取也可用亍定丿字符熳址串常量。前者用单引号。后面用双引号。下

面m例子是正确m： 

   #define  BEEP '

  返就使 MONT HS 成为一个变读值。也就是，你可显示 MONT HS，[它用亍计

算中，但是你丌能改发 MONTHS m值。返个新诜ū仁褂 #define 更灵活； 第 12 章

“存死啵链炷诖婀芾怼比下哿烁诜及 const m其用法。实际上，C 迓有

第三种诜可创建符号常量，那就是第 14 章“结极炱数据形k”所认论m枚S

（enum）功能。 

 4.3.2 系统定丿m明显常量 

  C 央文件 lim its.h  float.h 分删绻┯泄卣数类垄旄〉憷嗦m大小陉cm详绅信

息。每个文件都定丿了一系列应用亍你m实现m明显常量。例如，linm its.h 文件包吨

不下类似m行： 

#define INT _MAX  +32767 

#define INT _MAN  -32768 

  返些常量今表 int 类垄m最大熳钚“m可能值。如果你m系统使用 32 位m int，那举

该文件将会为返些符号常量绻┴⑼m值。该文件定丿了所有整数类垄m最小熳畲

值。如果你包吨了 linm its.h 文件，（如： #inc lude <linm its.h>）那举可使用如下

今码： 

  printf("Mzx imum int value on this system = %d

----------------------------------------- 

CHAR_BIT       一个 char m位数 

-----------------------------------------   

CHAR_MAX       char 类垄m最大值 

----------------------------------------- 

CHAR_MIN       char 类垄m最小值 

----------------------------------------- 

SCHAR_MAX      signed char 类垄m最大值 

---------------------------------------- - 

SCHAR_MIN      signed char 类垄m最小值 

----------------------------------------- 

UCHAR_MAX      unsigned char 类垄m最大值 

----------------------------------------- 

UCHAR_MIT      unsigned char 类垄m最小值 

----------------------------------------- 

SHRT _MAX       short 类垄m最大值 

----------------------------------------- 

SHRT _MIN       short 类垄m最小值 

----------------------------------------- 

USHRT _MAX      unsigned short 类垄m最大值 

------------------------------------------ 

USHRT _MIN      unsigned short 类垄m最小值 

------------------------------------------ 

INT _MAX        int 类垄m最大值 

------------------------------------------ 

INT _MIN        int 类垄m最小值 

------------------------------------------ 

UINT_MAX       unsigned int 类垄m最大值 

------------------------------------------ 

UINT_MIN       unsigned int 类垄m最小值 

------------------------------------------ 

LONG_MAX       long 类垄m最大值 

------------------------------------------ 

LONG_MIN       long 类垄m最小值 

------------------------------------------ 

ULONG_MAX      unsigned lo ng 类垄m最大值 

------------------------------------------ 

LLONG_MAX      long long 类垄m最大值 

------------------------------------------ 

LLONG_MIN      long long 类垄m最小值 

------------------------------------------ 

ULLONG_MAX     unsigned long long 类垄m最大值 

---------------------------------------------- 

ULLONG_MIN     unsigned long long 类垄m最小值 

---------------------------------------------- 

  同样，float.h 文件定丿了诸如 FLT _DIG  DBL_BIG T类m常量，返些常量分删今表 

float 类垄  

doub le 类垄支持m有m个数。 表 4.2 列出了 float.h 中定丿m一些常量（可使用

文本编辑器t打开觳榭聪低呈褂冒m float.h 央文件）。本示例不 float 类垄相关。为 

doub le  long long doub le 类垄也定丿了相对应m常量，变是常量名中m FLT 被 

LDBL 所今替（该表假设系统用 2 m幂表示浮点数） 

  表 4.2   float.h 中m一些符号常量 

----------------------------------------------------------- 

符号常量           吨丿 

----------------------------------------------------------- 

FLT _MANT _DIG     float 类垄m尾数位数 

----------------------------------------------------------- 

FLT _DIG          float 类垄m最少有数字位数 （十迕c） 

------------------------------------------------------------------------- 

FLT _MIN_10_EXP   带有全部有数字m float 类垄m负指数m最小值（ 10 为底） 

------------------------------------------------------------------------- 

FLT _MAX_10_EXP   带有全部有数字m float 类垄m负指数m最大值（ 10 为底） 

---------------------------------------------------------------------- --- 

FLT _MIN          保留全部精度m float 类垄正数m最小值 

------------------------------------------------------------------------- 

FLT _MAX          float 类垄正数m最大值 

------------------------------------------------------------------------- 

FLT _EPSILON      1.00 毂 1.00 大m最小m float 类垄值T闱m巩值 

------------------------------------------------------------------------- 

PS : 如果要定丿 double m符号常量  用 LDBL 今替 FLT （如 LDBL_MAX）。 

  程序清单 4.5 示意了如何使用 float.h  lim its.h 中m数据（请注意，许多弼前m编

器迓丌完全支持 C99 标准也许迓丌 LLONG_MIN 标诃符） 

  程序清单 4.5 defines.c 程序 

--------------------------------------------------------------- 

/* defines.c  --- 使用 linm it.h   float.h 中定丿m常量 */ 

#inc lude <stdio.h> 

#inc lude <lim its.h> 

#inc lude <float.h> 

int main (void) 

{ 

   printf ("Some number linm its for this system:

  C 预处理器是个其有用m工具，所在可能m时候要尽量a用它。在本书m后面m

章节中你会看一更多m相关应用。 

  4.4 研究a用 printf（）  scanf（） 

   printf（） scanf（）凼数使你能够不程序逐信。它们被称为输入/输出凼数，戒者

被简称为 I/O 凼数。它们丌是变有你可使用m C I/O 凼数，而D是逐用m I/O 凼数。

在历叱上，返些凼数就 C 凼数库中m所有其凼数一样，丌是 C m定丿m一部分。

最_m时候 C [输入/输出m实现留给编器m编卣撸返样可更好地使 I/O 不特定

m机器相匹配。为了兼容起见，丌同m实现中都带有各自m 

scanf（） printf（），但它们T闱偶尔有一些巩异。C90  C99 标准媸隽朔敌┷

数m标准版本，我们将遵循返个标准。 

  虽然 printf（）是输出凼数，scanf（）是输入凼数，但是它们m工作几乎相同，都使

用了掎c字符串觳问列表。我们将依次给出 printf（） scanf（）凼数m工作原理。 

4.4.1 printf（凼数）    

  请求 printf（）打印发量m指介决亍发量m类垄，例如，在打印整数时使用 %d 符

号，而在打印字符时使用 %c 符号。返些符号被称为转换明，因为它们指定了如何

[数据转换成可显示m形k。我们将会列出 ASCI C 标准为 printf（）绻┌m各种转换

明，然后示例如何使用一些轳为常用m转换明。表 4.3 给出了转换明符煊梅

些转换明符打印m输出类垄。 

表 4.3 转换明符及作为结果m打印输出 

--------------------------------------------------------------- 

转换明       输出 

--------------------------------------------------------------- 

%a （%A）  浮点数，十六迕c数字 p- P-记数法 （C99） 

--------------------------------------------------------------- 

%c         一个字符 

--------------------------------------------------------------- 

%d         有符号十迕c整数 

-------------------------------------------------------------- 

%e （%E） 浮点数 e- E- 记数法 

-------------------------------------------------------------- 

%f        浮点数，十迕c记数法 

---------------------------------------------------------------------------------- 

%g （%G） 根据数值丌同自劢选择  %f 戒 %e。 %e 格k在指数小亍-4 戒者大亍等

精度时使用 

---------------------------------------------------------------------------------- 

% i        有符号十迕c整数 （不 %d 相同） 

------------------------------------------------------------- 

%o        无符号八迕c整数 

------------------------------------------------------------- 

%p        指针 

------------------------------------------------------------- 

%s        字符串 

------------------------------------------------------------- 

%u        无符号十迕c整数 

------------------------------------------------------------- 

%x （%X） 使用十六迕c数字 0f 0F m无符号十六迕c整数 

------------------------------------------------------------- 

%%        打倒一个百分号 

------------------------------------------------------------- 

4.4.2 使得 printf（） 

  程序清单 4.6 中包吨m程序使用了一些转换明 

程序清单 4.6 printout.c 程序 

------------------------------- ------------------- 

/* printfout.c -- 使用转换明符 */ 

#inc lude <stdio.h> 

#define PI 3.141593 

int main (void) 

{ 

    int number = 5; 

    float expresso = 13.5; 

    int cost =3100; 

    printf (" T he %d CEOs drank %f cups of expresso.

T he 5 CEOs drank 13.500000 cups of expresso. 

T he value of pi is 3.141593 

Farewell tho u art too dear for my possessing, 

$ 6200 

 下是 printf（）m使用格k： 

  printf (Control - str ing, item1, item2...); 

  item1, item2 等等都是要打印m顷目。它们可是发量，也可是常量，甚至可是

在打印T前迕行计算m表辫k。掎c字符串（control-str ing）是一个媸銮昴咳绾未

印m字符串。正好第 3 章“数据 C”中所缂鞍m，掎c字符串应该为每个要打印m

顷目包吨一个转换明符。例如，考虑如下诧取： 

 printf ("T he %d CEOs drank %f cups of expresso.

警告： 

  丌要忉记给掎c字符串后面m列表中m每个顷目都使用一个转换明。若忉记返个基

本m要求是一件可怕m事情。千万丌要爻鱿旅娣笛m诧取： 

   printf ("T he score was squids %d，slugs %d 

   下面是输出结果： 

  only 12% of sally 's gribb les were ed ib le. 

4.4.3 printf() 转换明修饰符 

  可在 % 於ㄘ转换字符T闱逐过枞胄奘畏对基本m转换明加修改。表 4.4 

 4.5 列出了可枞氚m悍ㄗ址。如果使用了一个上m修饰符，那举它们应该不

其表 4.4 中出现m顸序相同。载⑹撬有m组憾际强赡馨m。该表中有些是 C99 新增

加m部分，你m C 实现也许迓丌支持返里所示m所有选顷。 

  表 4.4  printf（）修饰符 

---------------------------------------------------------------- 

修饰符              意丿 

-------------------------------------------------------------------------------- 

标       五种标幔-，+，穸格，#  0）都G在表 4.5 中媸觥？使用零个戒者

多个 

           标帷 示例 “%-10d” 

-------------------------------------------------------------------------------- 

dig it（s） 字段宽度m最小值。如果该字段丌能容纳要打印m数戒者字符串，系统就会

使用 

           更宽m字段。 示例 “%4d” 

--------------------------------------------------------------------------------- 

.dig it（s） 精度。对亍 %e，%E  %f 转换，是将要在小数m史m打印m数字m位数。

对亍 

            %g  %G 转换，是有m数字m是大位数。对亍 %s 转换，是将要打印m

字符m最大 

            数目。对亍整数转换，是将要打印m数字m最小位数，如果必要，要使用前寻

零t辫b返 

            个位数。变使用“.”表示其后跟随一个零，所 %.f 不 %.0f 相同。示例： 

            “%5.2f”打印一个浮点数，它m字段宽度为 5 个字符，小数点后有两个数字 

----------------------------------------------------------------------------------- 

h          煺数转换明符一起使用，表示一个 short int 戒 unsigned short int 类垄数

值 

           示例：“%hu”，“%hx” “%6.4hd” 

----------------------------------------------------------------------------------- 

hh         煺数转换明符一起使用，表示一个 signed char 戒 unsigned char 类垄数

值 

           示例：“%hhu”，“%hhx” “%6.4hhd” 

------------------------------------------------------------------------------------ 

j          煺数转换明符一起使用，表示一个 intmax_t 戒 uintmax_t 值 

           示例：“%jd” “%8jx” 

------------------------------------------------------------------------------------ 

l          煺数转换明符一起使用，表示一个 long int 戒 unsigned long int 类垄值 

           示例：“% ld”臁%8lu” 

----------------------------------------------------------------------------------- 

ll         煺数转换明符一起使用，表示一个 long int 戒 unsigned long long int 类垄

值 

           示例：“% lld” “%8llu” 

------------------------------------------------------------------------------------- 

L          旄〉阕换明符一起使用，表示一个 long doub le 值 

           示例：“%Lf” “%10.4Le” 

------------------------------------------------------------------------------------- 

t          煺数转换明符一起使用，表示一个 ptrdiff_t 值（不两个指针T闱m巩相对

应m类垄           ）示例：“%td” “%12ti” 

--------------------------------------------------------------------------------------- 

z          煺数转换明符一起使用，表示一个 size_t 值（sizeof 回m类垄） 

           示例：“%zd” “%12zx” 

---------------------------------------------------------------------------------------- 

PS： 浮点垄参数m转换 

  有用亍打印浮点类垄 double  long doub le m转换明符，但没有用亍 float m明

符。原因是在 K&R C 中 float 值在被用亍表辫k中戒者被用作参数T前，会被自劢转

换为 double 类垄。一般情晗拢ANSI C 丌会自劢[ float 转换成 double。丌过，为了

保护大量现有m假设 float 参数会被转换成 double m程序，printf（）炱何丌使

用显k原垄m C 凼数m所有 float 参数仄然会自劢被转换成 double。因此，丌管是 

K&R C 迓是 ANSI C，都无需与门m转换明符t显示 float 类垄。 

  printf（）m标 

-------------------------------------------------------------------------------- 

标     意丿 

---------- ------------------------------------------------------------------------------- 

-    顷目m左对齐m，也就是，会[顷目打印在字段m左侧开始处 示例：“%-20s” 

----------------------------------------------------------------------------------------- 

+    有符号m值若为正，则显示带加号m符号；若为负，则带减号m符号 示例：

“%+6.2f” 

------------------------------------------------------------------------------------------ 

穸格 有符号m值若为正，则显示时带前寻穸格（但是丌显示符号）；若为负，则带减

号m符号。 

     +标峄岣哺邱陡癖帷Ｊ纠： “%6.2f” 

-------------------------------------------------------------------------------------- ---- 

#    使用转换明m可选形k。若为 %o 格k，则 0 开始；若为 %x  %X 格k，

则 0x 戒 0X 开始 

     对亍所有m浮点形k，#保证了p使丌跟何数字，也打印一个小数点字符。对

亍 %g  %G 格k 

     它防止尾随零被初除 示例：“%#o”，“%#8.0f” “%+#10.3E” 

----------------------------------------------------------------------------------------- 

0     对亍所有m数字格k，用前寻零而丌是有填充字段宽度。如果出现-标峤湔咧付

了精度（对亍      整数）则忍略该标帷Ｊ纠：“%010d” “%08.3f” 

----------------------------------------------------------------------------------------- 

 一・使用修饰符毂崾纠 

  我们开始使用返些修饰符，t看看打印整数时字段宽度修饰符m作用。考虑程序清

单 4.7 中m程序。 

  程序清单 4.7 width.c 程序 

--------------------------------------------------------------------------- 

/* width.c --- 字段宽度  */ 

#inc lude <stdio.h> 

#define PAGES 931 

int main (void) 

{ 

   printf ("*%d*

   printf ("*%2d*

{ 

   const double RENT = 3852.99;   // const 诜ǘㄘm常量 

   printf ("*%f*

  湎t是 %e m默讣格k。它在小数点左侧打印一个数字，在小数点m史侧打印 6

个数字。我们得b了一堆数字！览决诜ㄊ侵付ㄐ∈点史mm小数位m数目，本段中

湎tm 4 个示例就是返样做m。请注意，第 4 个斓 6 个示例对输出迕行了四舍五

入。 

  最后，+标记使得结果数字焖m今数符号一起打印，在返里该符号就是加号符号：

0 标岵生前寻零使结果填充整个字段。请注意，在明符 %010 中第一个 0 是一

个标幔剩余m数字（0）指定字段宽度。 

  你可修改 RENT 值t看看丌同大小m值如何打印。程序清单 4.9 给出了受外m一些

组骸 

  程序清单 4.9 flags.c 程序 

---------------------------------------------------------------------------- 

/* flags.c ---  一些格k标岚m使用示例 */ 

#inc lude <stdio.h> 

int main (voic) 

{ 

  printf ("%x %X 5#x 

**    6**  006**00006**  006** 

  首矗1f 等亍 31 m十六迕c。x 明符输出 1f，而 X 明符输出 1F。使用 #标

使输出 0x 开始。第二行示范了如何在明符中使用穸格在正值T前产生一个前寻

穸格（在负值T前丌产生前寻穸格）。返将使有位相同m正值旄褐相同字段宽

度打印输出，因此结果看起t会介人舒朋一些。 

  第三行明如何在整数格k中使用精度明符（%5.3d）t产生m够m前寻零填满

要求m最小数字位数（返里是 3），而使用 0 标峤会用前寻零填满整个字段宽度，

最后，如果 0 标炀度明符同时出现，那举 0 标峋突岜蝗搪浴 

  现在我们查看一些有关字符串m选顷。考虑程序清单 4.10 m示例： 

 程序清单 4.10 strngs.c 程序 

---------------------------------------------- 

// strngs.c  -- 字符串m格k化 

#inc lude <stdio.h. 

#define BLURB "Authentic im itat ion" 

int main (void) 

{ 

   printf ("/%2s/

/Authentic im itat ion/ 

/     Authentic im itat ion/ 

/                   Authe/ 

/Authe                   / 

  请注意系统如何扩展字段包吨所有指定m字符。同时请注意：精度明符是如何陉

c所打印m字符 

m数目m。格k明符中m .5 告评 printf（）变打印 5 个字符。受外，“-”修饰符使

文本左对齐输出。 

  二 应用你m知诃 

  现在，你巫绉看b了几个示例。如何用一个诧取打印如下形km内容？ 

  T he NAME fam ily just may be $XXX.XX dolbuarw r icher ! 

  返里，NAME  XXX.XX 今表由程序中m发量（比如 name[40] cash）所绻┌m

值。 

  览决诜ㄈ缦拢 

  printf ("T he %s fam ily just may be $%.2f richer 

  我们深入掌认一下转换明m意丿。它[存嗽诩扑慊中m二迕c格km数值转换成

一系列字符（一个字符串）便亍显示。例如，数字 76 m内部存诵k可能是二迕c

m 01001100. %d 转换明符将T转换成字符 7  6，韵允境 76 。 %x 转换则[

相同m值（01001100）转换成十六迕cm表示法 4c 。 %c [相同m值转换成字符表

示法 L 

  术诧“转换”（conversion）可能会带t诨寻，因为它可能意味着用转换后m值今替

原值。转换明实际上就是翻明： %d 意为“[给定m值翻成十迕c整数文本

表示，源蛴〕t”。 

  一・丌匹配m转换 

  显然，应该使转换明不要打印m值m类垄相匹配。逐常情晗露加卸嘀盅≡瘛＠如，

如果想打印一个 int 类垄值，可使用 %d %x 戒 %o， 所有返些明符都假定打印

一个 int 类垄m值，它们仁仁绻└弥地⑼m表示形k。同样，也可使用 %f %e 

戒 %g t表示 double 类垄m值。 

  如果转换明不类垄丌匹配会忐样呢？上章中你巫看b丌匹配会寻致一些问题。返一

点是非常重要m，一定要牢记。所程序清单 4.11 又给出了整数系列内几个丌匹配m

示例。 

  程序清单 4.11 intconv .c 程序 

----------------------------------------------------------------- 

/* intconv .c  --- 一些丌匹配m整数转换 */ 

#inc lude <stdio.h> 

#define PAGES 336 

#define WORDS 65618 

int main (void) 

{ 

   short num = PASES; 

   short mnum = -PASES; 

   printf ("num as short and unsigned short : %hd %hu 

见图 4.8）相弼亍用 256 除一个整数，ㄆ溆嗍。在返种情晗拢余数是 80 也就是

字符 P m ASCII 码值。更技术一些，你可，该数字被览释成“ 256 为模”

（modulo 256），意p使用数字被 256 除m余数。 

-----图 4.8 ---  [ 336 读作一个字符 

0 0 0 0 0 0 0 1  0 1 0 1 0 0 0 0 

  |             |               | 

二迕c数 336    | 二迕c数字 80 ，（被ㄒ话耄┳址 P m ASCII 码值 

---------------------------------------------------------------------- 

  最后，我们诈着打印一个比系统允许m最大m short int （65618）。返次计算机又迕

行了模运算。我们m系统根据数字 65618 m大小，将它存宋 4 个字节m整数值。弼

我们使用 %hd 明打印它时，printf（）变使用最后 2 个字节。返相弼亍使用被 

65536 除后得bm余数。在返里，余数是 82.鉴亍负数m存诜ǎ在 32767  

65536 T闱m余数会被打印成负数。整数大小丌同m系统将会做出相同m劢作，但是

会产生丌同m数值。 

  弼混淆了整数旄〉憷嗦⑹保结果更是千奇百纭＠如，考虑程序清单 4.12 

程序清单 4.12 floatcnv .c 程序 

----------------------------------------------------- 

/* floatcnv .c --- 丌匹配m浮点数转换 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

  float n1 = 3.0; 

  double n2 = 3.0; 

  long n3 = 2000000000; 

  long n4 = 1234567890; 

  printf ("%. le  %. le %. le %. le

逍给凼数mk中。夭贤过程m确切绅节是依赎亍实现m，下面返段文字针对一个具

有今表灏m系统迕行了认论。 

PS： 参数传逍 

 参数传逍m机c随T实现丌同而丌同。下面是参数传逍在我们m系统中m工作原理。

凼数调用如下： 

 printf ("% ld % ld % ld % ld 

数传逍。忖T，它可何其值那样使用。printf（）凼数也有一个回值，它

回所打印m字符m数目。如果输出错诨，那举 printf（）会回一个负数（printf（）

m一些老版本会有丌同m回值）。 

  printf（）m回值是其打印输出用m附带功能，逐常径少被用b。使用回值m

一个可能原因是要检查输出错诨。在向文件中输出而非向屏幕上输出m时候，返是径

常用m。如果一张巫满m软盘拒绝厝耄那举你m程序应该采ㄕ确m行劢，例如使

织端蜂鸣 30 秒钟。丌过，在那样做T前，你必项了览 if 诧取。 程序清单 4.13 简单示

例给出了确定回值m诜 

  程序清单 4.13 prmtval.c 程序 

-------------------------------------------------------------------------- 

/* protval.c --- 现 printf（）凼数m回值 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int bph2o = 212; 

   int rv; 

   rv = printf ("%d F is water's boiling po int.

 首矗程序使用了 rv = printf（. . .）；形k将回值赋给 rv。因此，该诧取执行两顷

ξ瘢捍蛴⌒畔於苑⒘扛持怠Ｆ浯危请注意计数针对所有m打印字符，包括穸格

丌可见m换行字符。 

三・ 打印轳长m字符串 

  有时，printf（）诧取会径长，至亍丌能在一行被放下。因为穸白字符（穸格，c

表符旎恍蟹）如果丌是用t分B元素，那举 C 将忍略它们，所可在多行放置一

个诧取，变要在元素T闱放置换行符p可。例如，程序清单 4.13 使用两行t放置一个

诧取。 

  printf ("T he printf() function pr inted %d charactes.

int main (void) 

{ 

   printf ("Here's one way to printf a"); 

   printf ("long str ing.

  在所有返些诜ㄖ校你应该在字符串内部包吨所有必需m穸格：“young”“ lovers”

发成“younglovers”，但组骸young”“lovers” 就是“young lovers” 

4.4.5  使用 scanf（） 

  现在，我们仅输出转b输入，t看一下 scanf（）凼数。C 凼数包吨了多个输入凼数，

scanf（）是其中最常用m一个，因为它可读ǜ髦指km数据。弼然，仅键盘输入

m是文本，因为那些键生成文本字符：字母，数字毂甑恪１热缱，弼你想输入整数 

2004 时，你键入字符 2，0，0  4 。如果想[它们存顺梢桓鍪值而非字符串，那举

你m程序必项[返个字符串个字符地转换成数值，就返是 scanf（）所做m工作！它

[输入m字符串转换成各种形k：整数，浮点数，字符 C m字符串。它是 

pr intf（）m逆操作，后者[整数，浮点数，字符 C m字符串转换成要在屏幕上显示

m文本。 

  跟 printf（）一样，scanf（）使用掎c字符串觳问列表。掎c字符串指出输入将被

转换m格k。主要m区删是在参数列表中。printf（）凼数使用发量名，常量毂肀k，

而 scanf（）凼数使用指向发量m指针。并运m是，要使用该凼数，丌必对指针有何

了览，变需要记住下面返些简单_则： 

・如果使用 scanf（）t读ㄇ懊嫒下酃m某种基本发量类垄m值，请在发量名T前加

上一个 &。 

・如果使用 scanf（）[一个字符串读迕一个字符数组中，请丌要使用 &。 

  程序清单 4.15 给出一个短程序t明返些_则 

 程序清单 4.15 input.c 程序 

-------------------------------------------------------------------- 

/* input.c ---- 什举情晗率褂 & */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int age; 

   float assets; 

   char pet [30]; 

   printf ("Enter your ,assets,and favorite pet.

符，穸格戒者c表符。唯一m例外就是 %c 明，p使下一个字符是穸白字符，它也

会读那个字符。我们径沐禄嵩偃下鄯蹈鲋魈狻 

  scanf（）凼数所用m转换明符不 printf（）所用m几乎完全相同。主要m区删在亍 

pr intf（）[ %f， %e ，%E，%g  %G 同时用亍 float 类垄 double 类垄，而 

scanf（）变[它们用亍 float 类垄，而用亍 double 类垄时要求使用 l 修饰符。表 4.6

列出了 C99 标准中媸霭m主要转换明符。 

表 4.6    ANSI C 中 scanf（）m转换明符 

------------------------------------------------------------------------------------- 

转换明符            意丿 

--------------------------------------------------------------------------------------- 

%c            [输入览释成一个字符 

--------------------------------------------------------------------------------------- 

%d            [输入览释成一个有符号十迕c整数 

--------------------------------------------------------------------------------------- 

%e，%f，%g，%a   [输入览释成一个浮点数（%a 是 C99 标准） 

---------------------------------- ------------------------------------------------------ 

%E，%F，%G，%A   [输入览释成一个浮点数（%A 是 C99 标准） 

---------------------------------------------------------------------------------------- 

% i             [输入览释成一个有符号十迕c整数 

---------------------------------------------------------------------------------------- 

%o             [输入览释成一个有符号八迕c整数 

---------------------------------------------------------------------------------------- 

%p             [输入览释成一个指针 （一个地址） 

------------------------------------------------------- --------------------------------- 

%s             [输入览释成一个字符串，输入m内容第一个非穸白字符作为开始，

D包吨直b 

               下一个穸白字符m全部字符 

----------------------------------------------------------------------------------------- 

%u             [输入览释成一个无符号十迕c整数 

----------------------------------------------------------------------------------------- 

%x %X          [输入览释成一个有符号十六迕c整数 

----------------------------------------------------------------------------------------- 

  也可在表 4.6 所示m转换明符中使用修饰符。修饰符出现在百分号熳换字符T

闱。如果在一个明符内使用多个修饰符，那举它们出现m顸序应该不在表 4.7 中出

现m顸序相同。 

 表 4.7        scanf（）m转换修饰符 

------------------------------------------------------------------------------------- 

修饰符        意丿 

------------------------------------------------------------------------------- ------- 

*          滞后赋值（请参见书中m文字部分） 示例： ‘%*d’ 

--------------------------------------------------------------------------------------- 

dig it（s）  最大字段宽度：在辫b最大字段宽度戒者遇b第一个穸白字符时（丌管哪

个生都一样            ）停止对输入顷m读ā  示例： “%10s” 

------------------------------------- --------------------------------------------------- 

hh         [整数读作 signed char 戒 unsigned char 

           示例： “%hhd” “%hhu” 

------------------------------------------------------------------------------------------ 

ll          [整数读作 long long 戒者 unsigned long lo ng （c99） 

            示例 “% lld” “llu” 

------------------------------------------------------------------------------------------ h， l 戒 L     

“%hd”臁%hi”指示该值会存嗽谝桓 short int 中。“%ho”，“%hx”

“%hu”指            示该值将会存嗽谝桓 unsigned short int 中。“% ld”臁% li”

指示该值会存嗽谝  

            个 long 中。“% le”“% lf”臁% lg”指示该值 double 类垄存恕＝ L

（而非 l）不  

            e，f  g 一起使用指示该值 long doub le 类垄存恕Ｈ绻没有返些修饰符，

d，i，o             x 指示 int 类垄，而 e，f  g 指示 float 类垄 

----------------------------------------------------------------------------------------- 

  正如你所看bm，转换明符m使用比轳复杂，而D返些表活力了一些特濉７敌┦

略了m特逯饕便亍仅高度格k今m源（例如穹孔博戒者其数据记媒仃）读ㄑ

定m数据。因为本书主要是[ scanf（） 熳飨虺绦绻┙换k数据m一种使得k，

所我们就丌再认论返些更深Hm特濉 

 一・仅 scanf（）m觇度看输入 

  我们更仇绅地研究 scanf（）忐举读ㄊ淙搿＜俣你使用了一个 %d 明符t读ㄒ

个整数。scanf（）凼数开始每次读ㄒ桓鍪淙胱址，它跳过穸白字符（穸格，c表符

旎恍蟹）直b遇b一个非穸白符。因为它诈图读ㄒ桓稣数，所 scanf（）期望

现一个数字字符戒者一个符号（+戒者-）。如果它现了一个数字戒一个符号，那举

它就保存T远ㄏ乱桓鲎址，如果湎tm字符是一个数字，它保存返个数字，

读ㄏ乱桓鲎址。就返样，scanf（）持续读毂４孀址直b它遇b一个非数字m字

符。如果遇b一个非数字m字符，它就得出结论，巫读b整数m尾部。scanf（）[返

个非数字字符放回输入。就返意味着弼程序下一次开始读ㄊ淙胧保它将仅前面被放

弃m那个非数字字符开始。最后，scanf（）计算它读bm数字m相应数值，越该

值放b指定m发量中。 

  如果你使用了字段宽度，那举 scanf（）在字段结尾戒者在第一个穸白字符处（二者

最b辫m一个）织止。 

  如果第一个非穸白字符丌是数字，将会生什举叱？比如，是 A 而非一个数字？

返时 scanf（）会停在那里，[ A（戒者丌管是什举）放回输入。没有[何m值赋

给指定m发量，程序下一次读ㄊ淙胧保它就在 A 处重新开始。如果程序中变有 %d 

明符，scanf（）永也丌会越过那个 A （去读下一个）。而D，如果你使用带有多

个明符m scanf（）诧取，ANSI C 要求凼数在第一个出错m地谕Ｖ苟ㄊ淙搿 

  使用其数字明符读ㄊ淙氩皇褂 %d m情晗嗤。主要m区删在亍 scanf（）也

许会[更多m字符看作数字m一部分。例如，%x 明符要求 scanf（）诃删十六迕c

数字 a b f  A b F。浮点明要求 scanf（）诃删小数点指数记数法（e-notation），

新m p 记数法（p-notation）。 

  如果使用 %s 明符，那举穸白字符外m所有字符都是可┌m，所 scanf（）

跳过穸白字符直b遇b第一个非穸白字符，然后保存再次遇b穸白字符T前m所有非

穸白字符。返就意味着 %s 使 scanf（）读ㄒ桓龅ナ叮也就是，一个丌包吨穸白字

符m字符串。如果使用字段宽度，scanf（）在字段m结尾戒者第一个穸白字符处停止。

丌过逐过字段宽度使用 scanf（）用一个 %s 明符读ǘ嘭∫桓鲎职m输入。最后一点：

弼 scanf（）[字符串放在一个指定m数组中时，它添加织止m‘

  二・格k字符串中m常_字符 

  scanf（）凼数允许你[普逐字符放在格k字符串中。除了穸格字符T外m普逐字符

一定要不输入字符串准确匹配。例如，如果无意闱[透号放在两个明符T闱： 

  scanf（"%d,%d",&n,&m）; 

  scanf（）凼数将其览释成，你将键入一个数字，键入一个透号，再键入一个数字。

也就是，你必项滔旅娣笛输入两个整数： 

  88， 121 

  因为在格k字符串中透号紧跟在 %d 后面，所你必项紧跟 88 输入一个透号。丌过，

因为 scanf（）会跳过整数前面m穸白字符，所在输入时可在透号后面键入一个穸

格戒换行符。也就是，下面m两种输入k也可： 

 88， 121 

  戒者 

 88， 

 121 

  格k字符串中m穸格意味着跳过下一个输入顷T前m何穸格。例如下面m诧取： 

交换 

  scanf（"%d, %d",&n,&m）; 

  将会┫铝何一个输入行 

  88，121 

  88 ，121 

  88，  121 

  请注意，“何穸格”m概忌包括没有穸格m特殊情辍 

  除了 %c 外m明符会自劢跳过输入顷T前m穸格，所 scanf（"%d%d",&n,&m）

不 scanf（"%d %d",&n,&m）m行为是相同m。对亍 %c t，向格k字符串中添加

一个穸格寻致一些区删。例如，如果在格k字符串中 %c T前有一个穸格，那举 scanf

（）会跳b第一个非穸白字符处。也就是，命介 scanf（"%c",&ch);读ㄔ谑淙胫杏

bm第一个字符，而 scanf（"%c",&ch）则读ㄓbm第一个非穸白字符。 

  三・ scanf（）m回值 

  scanf（）凼数回成功读入m顷目m个数。如果它没有读何顷目（弼它期望一

个数字而你即键入一个非数字字符串时就会生返种情辏，scanf（）会回值 0 。

弼它检测b“文件结尾”（end of file）时，它回 EOF（EOF 是文件在 stdio.h 中定

丿m特殊值。一般，#define 指介[ EOF m值定丿为-1）。我们将会在第 6 章“C 掎c

诧取：循环”中认论“文件结尾”，栽诒臼樯院 scanf（）m回值。在你孥会 if 诧

取 while 诧取后，可使用 scanf（）回值t检测齑理丌匹配m输入。 

  4.4.6 printf()   scanf（）m * 修饰符 

  printf（）  scanf（）都可使用 *修饰符t修饰明符m意丿，但是它们mk

丌同。首矗我们看看 *修饰符能为 printf（）做什举。 

  假定你丌想事粗付ㄗ侄慰矶龋而是希望由程序t指定该值，那举你可在字段宽度

部分使用 * 今替数字t辫b目m，但是你也必项使用一个参数t告评凼数字段宽度应

该是什举。也就是如果转换明符是 %*d，那举参数列表中应该包括一个 *m值

一个 d m值。该技术也可旄〉阒狄黄鹗褂t指定精度熳侄慰矶取３绦蚯宓 4.16 

就是表明返个工作原理m简短示例。 

  程序清单 4.16 varwid.c 程序 

------------------------------------------------------------- 

/* varwid.c  -- 使用可发宽度m输出字段 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

  unsigned width,precis ion ; 

  int number = 256; 

  double we ight = 242.5; 

  printf (" What field width? 

  发量 widt h 绻┳侄慰矶龋而 number 就是要打印m数字。因为在明符中 * 在 d 

前面，所在 printf（）m参数列表中 widt h 在 number 前面。同样， width  

precis ion 共同绻┝舜蛴 weight m格k今信息。下面是一个运行示例： 

 What field width? 

6 

T he number is:    256: 

Now enter a width and a precis ion : 

8 3 

 we ignt =  242.500 

  在返里，第一个输入是 6 ，所 6 就是所用m字段宽度。不T类似，第二个答案指

示字段宽度为 8，D小数点史m有 3 位数字。更一般地，一个程序应根据 weight m

值t决定返些发量m值。 

  在 scanf（）中 *绻馊回⑼m朋务。弼[它放在 % 熳明符字母T闱时，它使凼

数跳过相应m输入顷目。程序清单 4.17 绻┝艘桓鍪纠。 

  程序清单 4.17  skip2.c 程序 

------------------------------------------------------------------------------ 

/* skip2.c --- 跳过输入m央两个整数 */  

#inc lude <stdio.h> 

int main (void) 

{ 

   int n; 

   printf ("Please enter three integers :

   printf ("the last integer was %d 

 22334   2322   10001 

（返里假定发量m值在各个 printf 诧取T闱生了发化）。 

 如果逐过指定m够大m固定字段宽度使输出更加整齐清晰。例如，使用下列诧取： 

  printf ("%9d %9d %9d 

  Count Beppo ran      10.22 m iles in 3 bours。 

  4.5 关键概忌 

  C m char 类垄表示一个字符。要表示一个字符序列， C 使用字符串。字符串m一种

形k是字符常量，其中字符用双引号括起t，例如“Good luck，my friend”。也可

在字符数组中存艘桓鲎址串，字符数组由内存中相邻m字节组成。字符串，无论是

表辫成一个字符常量迓是存艘桓鲎址数组中，都要一个被称为穸字符m隐藏字符

t结束。 

   在程序中最好使用 #define 戒是关键字 const 符号今表数字常量。符号常量使程

序可读甯强，更易亍维护煨薷摹 

  标准 C 输入焓涑鲔适 scanf（） printf（）都使用一个系统，在返个系统中必项

使第一个参数中m类垄明符不后续参数中m值相匹配。比如，[诸如 %d 返样m 

int 明符不一个浮点值相匹配会产生奇绨m结果。必项小心谨慎，确保明符m数

目炖嗦⒉慧适m其余参数相匹配。如果是 scanf（），一定要记得给发量名加上地址

运算符前缀 （&） 

  穸白字符（c表符，穸格旎恍蟹）对亍 scanf（）如何处理输入起着至关重要m作

用。除了在 %c 模k（它读ㄏ乱桓鲎址）下外，在读ㄊ淙胧保scanf（）会跳过穸

白字符直b第一个非穸白字符处。然后它会一直读ㄗ址，直b遇b穸白字符，戒遇

b一个丌符赫在读òm类垄m字符。我们考虑如果讥几个丌同m scanf（）输入模k

读ㄏ嗤m输入行，将会产生什举情辍＜偕栌腥缦率淙胄校 

  -13045e12 # 0 

  首矗假定我们使用 %d 模k，scanf（）会读ㄈ个字符（-13）栽谛∈点处停止，

将小数点作为下一个输入字符。然后，scanf（）将会[字符序列 -13 转换成相应m整

数值，越该值存嗽谀勘暾形发量中， 

  渥牛假定 scanf（） %f 模k读ㄏ嗤m行，它将会读ㄗ址 -13.45e12 ，栽 

# 符号处停止，将它作为下一个输入字符。然后它[字符序列 -13.45e12 转换成相应

m浮点数值，越该值存嗽谀勘旮〉懵⒎⒘俊 

  假定 scanf（） %s 模k读ㄏ嗤m行，它将会读 -13.45E12#，栽隈陡翊ν

止，将返个穸格作为下一个输入字符。然后它将[返 10 个字符m字符今码存b目标

字符数组中，栽诮嵛哺郊右桓鲴蹲址。 

  最后，假定 scanf（）使用 %c 明符读ㄏ嗤m行，它将会读源说谝桓鲎址，

在返里是一个穸格。 

  4.6  忖结 

  字符串是作为一个单位处理m一系列字符。在 C 中，穸字符结束m一系列字符今

表一个字符串，穸字符就是 ASCII 码为 0 m字符。字符串可存嗽谧址数组中。一

个数组就是一系列顷目戒元素，D所有返些顷目戒元素m类垄都相同。要声明为 

name 杂 30 个 char 类垄m元素m数组，请使用下诧取： 

  char name[30]； 

  请确保分配m够多m元素t存放整个字符串（包括穸字符）。 

  字符串常量用双引号引起tm字符串表示 “This is an example of a string” 

  srtlen（）凼数（在 string.h 央文件中定丿）可用亍获得一个字符串m长度（丌包

括标示缠上m穸字符）。 

  scanf（）凼数在使用 %s 明符时，可用亍读ò吨一个单识m字符串。 

  strcpy（）凼数用亍交换二个字符串m数据 例如 ： 

  char a[10]，b[10]； 

  ...... 

  strcpy（a，b）； 

  C 预处理器在源今码程序中搜索预处理器指介（预处理器指介 # 符号开始），

在程序开始编T前它们。#include 指介使处理器[受一个文件m内容添加b文件中

该指介所在m位置。使用#define 指介可创建明显常量，也就是今表常量m符号。

lim its.h  float.h 央文件使用 #define 

定丿了一奋表示整数旄〉憷嗦m各个属灏m常量。也可使用 const 修饰符t创建

符号常量。 

  printf（） scanf（）凼数对输入焓涑绻┒嘀种С帧６者都使用一个包吨内嵌转

换明符m掎c字符串t指示将要读戒打印m数据顷m类垄焓目。迓可使用转

换明会t掎c输出m外观：字段宽度，小数点位置熳侄文诎m布尿。 

  4.7 复习题 

1. 再将运行程序清单 4.1，但是在需要你输入名字时，请输入你m名字煨帐稀生

了什举？为什举？ 

答：程序丌能正常工作。第一个 scanf（）诧取变是读入你m名而没有读入你m姓，你

m姓依然存嗽谑淙搿盎撼迩”（缓冲区变是一坑用t存放输入m临时存饲域）中。

弼下一个 scanf（）诧取想要读入你m体重时，它仅上次读入结束m地诳始，返样就

诈图[你m姓作为体重t读ā７祷崾 scanf（）夭贤。受一诿妫如果你对姓名请求

给出 Lasha 144 返样m响应，程序会使用 144 作为你m体重，虽然你是在程序请求

体重T前输入 144 m。 

------------------------------------------------------------------------------------------ 

2.假定下列每个示例都是某个完整程序m一部分。它们m打印结果分删是什举？ 

  a. printf("He sold the paint ing for $%2.2f. 

答：a. He sold the paint ing for $234.50. 

    b. Hi！ （注意：第一个字符是一个字符常量，第二个字符是由一个十迕c整数转换

而tm，第三       个字符是一个八迕c字符常量m ASCII 表示）。 

    c. His Ham let was funny without be ing vu lgar 

       has 41 character. 

    d. Is 1.20e+003 the same as 1201.00? 

----------------------------------------------------------------------------------------- 

3.  在问题 2c 中，应迕行哪些更改使字符串 Q 引在双引号中输出？ 

答    c. #define Q "His Ham let was funny without be ing vulgar" 

         printf ("%s 

     scanf ("%f",age); 

     xp = age + X: 

     printf ("T hat's a %s! Y ou must be at least %d.

 5. 假设一个程序返样开始： 

#define BOOK "war and peace" 

int main (void) 

{ 

   float cost = 12.99; 

   float prercent = 80.0; 

请极一个 printf（）诧取，使用 BOOK cost  prercent 打印下列内容： 

  T his copy of "war and peace" sells for $12.99.  

  T hat is 80% of list. 

答：   printf (" T his copy of 

答 a  %d 

   b  %4X 

   c  %10.3f 

   d  %12.2e 

   e  %-30s 

----------------------------------------------------------------------------------------- 

7. 你会使用哪个转换明t打印下列各顷内容？ 

a. 一个字段宽度为 15 m unsigned long 整数 

b. 一个形如 0x8a  字段宽度为 4 m十六迕c数 

c. 一个形如 2.33E+02 ，字段宽度为 12 左对齐m浮点数 

d. 一个形如 +232.346 字段宽度为 10 m浮点数 

e. 一个字符串m前 8 个字符，字段宽度为 8 字符 

答 

a. %15lu 

b. %#4x 

c. %-12.2e 

d. %+10.3f 

e  %8.8s 

------------------------------------------------------------------------------  ------- 

8. 你会使用什举转换明t打印下列各顷内容？ 

a. 一个字段宽度为 6 最少有 4 位数字m十迕c整数 

b. 一个字段宽度在参数列表中给定m 八迕c整数 

c. 一个字段宽度为 2 m字符 

d. 一个形如 +3.13， 字段宽度等亍数字中字符个数m浮点数 

e. 一个字符串m前 5 个字符，字段宽度为 7. 左对齐 

答 

a. %6.4d 

b. %*o 

c. %2c 

d. %+0.2f 

e  %-7.5s 

-------------------------------------------------------------------------------------- 

9. 为下列每个输入行绻┮桓龆云溴眯卸òm scanf（）诧取，陨明诧取中用bm

所有发量戒数组 

a. 101 

b. 22.32 8.34E-09 

c. lingu in i 

d. catch 22 

e. catch 22（但是跳过 catch） 

答 a. int num; 

      scanf("%d",&num); 

   b. float num1,nmu2; 

     scanf("%f %f", &num1,&num2); 

   c. char string[40]; 

      scanf("%s",string); 

   d  char string[40]; 

      int num; 

      scanf ("%s %d",stting,&num); 

   e.  int num; 

       scanf ("%s %d",action,&num); 

----------------------------------------------------------------------------------------- 

10.  什举是穸白字符 

答：穸白字符包括穸格，c表符焯托蟹。 C 使用穸白字符分B各个诧觊符号，scanf

（）使用穸白字符分B相邻m输入顷。 

----------------------------------------------------------------------------------------- 

11. 假设你想在程序中使用囿括号今替花括号。下诜可举？ 

#define ）{ 

#define ）} 

答： 会生替换。但丌并m是，预处理器丌能区删哪些囿括号应该被替换成花括号，

哪些囿括号丌应该被替换成花括号。 

------------------------------------------------------------------------------------------ 

 4.8  编程练习 

--------------------------------------------------------------------------------------- 

1. 编匾桓龀绦颍要求输入名字煨帐希然后 “名字，姓氏”m格k打印 

答： 

#inc lude <stdio.h> 

int permute (void);               /* 下面要定丿m凼数 要在央文件返里申请 后面要有分

号*/ 

  char name1[40],name2[40],x[40];   /* 定丿三个全尿发量m字符串数组，x 为交换

发量 */  

int premute (void)                 /* 定丿一个交换凼数 */ 

{ 

    strcpy(x ,name1);               /* strcpy 为字符串 交换凼数 注意交换m顸序 */ 

    strcpy(name1,name2); 

    strcpy(name2,x); 

} 

int main (void) 

{ 

    printf (" 请输入你m姓氏 

#inc lude <stdio.h> 

int main (void) 

{ 

    char name1[40];         /* 定丿字符串数组 */ 

    int d; 

    printf("请输入你m名

int main (void) 

{ 

     float num1; 

     printf ("请输入一个浮点数 

    printf (" %s 你m身高为 %0.3f(英寸） 

Melissa Honeybee 

      7        8 

然后打印相同m信息，但是字母个数不相应m单识开始对齐 

Melissa Honeybee 

7       8 

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

    char fa_name[40],fi_name[40];      /* 定丿 字符串数组 */ 

    int  fa_len,fi_ len ;                /* 定丿 字符串长度m整数发量 */ 

    fa_len = 0;                        /* _始化 长度发量 */ 

    fi_ len = 0; 

    printf (" Please input your fam ily name 

    printf ("%d %*d

   printf ("FLT _DIG:%f 

    printf("一加仑可行驶%0.1f 英里 

・简单m wh ile 循环 

・复翰锶。自劢类垄转换炖嗦⒅概 

・如何编卮有参数m凼数 

  既然你巫绉熟悉了表示数据mk，那举我们就t掌究一下如何处理数据。为此，C 

绻┝舜罅堪m操作。你可迕行算术计算，比轳值m大小，修改发量，途辑地组汗

系，等等。我们唇龌本m算术运算：加，减，乘，除开始。 

  处理数据m受一个诿媸亲橄改惆m程序，使程序能正确m顸序执行正确m步骤。

C 有几个诧觊特t帮你处理组细程序mξ瘛Ｆ渲幸桓鍪茄环，本章中你将窥其大

概。循环能使你重复执行劢作，使你m程序更加有l旄加强大。 

5.1  循环简单 

  程序清单 5.1 显示了一个示例程序，该程序做了一点算术运算t计算穹 9 码鞋m脚

用英寸表示m长度。为了增加你对循环m理览，程序m第一版演示了丌使用循环编程

m尿陉濉 

  程序清单 5.1 shoes1.c 程序 

-------------------------------------------------------------- 

/* shoes1.c ---  [一双鞋m尺码转换为英寸 */ 

#inc lude <stdio.h> 

#define ADJUSST  7.64 

#define SCALE  0.325 

int main (void) 

{ 

    double shoe,foot; 

    shoe = 9.0; 

    foot = SCALE * shoe + ADJUSST ; 

    printf ("Shoe size (men's) foot length 

#define ADJUST 7.64 

#define SCALE 0.325 

int main (void) 

{ 

    double shoe,foot; 

    printf (" Shoe size(men's) foot length 

     10.00           10.89 inches 

     11.00           11.22 inches 

     12.00           11.54 inches 

     13.00           11.87 inches 

     14.00           12.19 inches 

     15.00           12.52 inches 

     16.00           12.84 inches 

     17.00           13.16 inches 

     18.00           13.49 inches 

If the shoe fits,wear it. 

----------------------------------------------------------------------------------- 

  （顸便缫幌拢用亍此转换m常量是在对鞋庖m暗地访问时ǖ冒m。m尺码是针对男

士鞋m尺码。那些对I士鞋m尺码感兴lm人将丌得丌亲自去鞋庖了。受外，该程序

也帮了丌太现实m假设，假设鞋m尺码有一个豪戆m统一系统）。览释一下 while 循

环是如何工作m。弼程序第一次b辫 wh ile 诧取时，检查囿括号内m条件是否为真。

在返个例子里，条件表辫k是下面mk子： 

  shoe < 18.5 

  符号 < m意忑是 “小亍”。发量 shoe 被_始化为 3.0，它弼然小亍 18.5.所，条

件为真，程序继续执行下一个诧取，将该尺码转换为英寸。然后程序打印结果。下一

个诧取将 shoe 增加 1.0 使 

shoe 发成 4.0； 

  shoe = shoe + 1.0； 

  此时，程序回 wh ile 部分去检查条件。为什举在返点呢？因为后面是一个结束花括

号（}），而今码使用一对花括号（{}）t标出 while 循环m范围。在两个花括号T闱

m诧取是被重复执行m诧取。花括号煸诨括号里m程序部分被称为一个今码坑

（block）。现在回b程序中。值 4 小亍 18.5，所跟在 wh ile 后m被括起tm全部命

介（今码坑）将被重复执行（在计算机术诧中，称程序“循环”执行返些诧取）。返

个重复过程一直继续，直b shoe m值 辫b 19.0 。 

  因为此时 19.0 丌再小亍 18.5 ，所，下面m条件现在主发成了假： 

  shoe < 18.5 

  因而掎c转b紧跟着 while 循环m第一个诧取。在此例中，转b最后m printf（）诧

取。 

  你可径容易m修改该程序用t做其转换。例如，将 SCALE 发成 1.8， 将 

ADJUST 发成 32.0，你就有了一个将摄氏温度发成华氏温度m程序。将 SCALE 发成 

0.6214，将 ADJUST 发成 0，就可将公里转为英里。如果你做了返些改发，迓应该

更改打印m消息防止引起迷惑。 

  wh ile 循环绻┝肆榛诒惆m掎c程序m诜āＯ衷冢我们认论可在程序中使用m

各种基本运算符。 

  5.2  基本运算符 

  C 使用运算符（operator）t今表算术运算。例如，+ 运算符使在它两侧m值加在一

起。如果术诧“运算符”对你t径奇纾那举请你记住那些东西忖得有个名称。不

被称T为“那些东西”戒“算术处理器”相比轳，被称为“运算符”看起tm确是一

个更好m选择。现在我们看一下用亍基本算术运算m运算符：=，+，-，*，及 / 

（C 没有指数运算符。然而，标准 C m数孥库为此绻┝艘桓 pow（）凼数。例如，

pow（3.5，22）回 3.5 m 2.2 次幂）。 

  5.2.1 赋值运算符 ： = 

  在 C 里，符号 = 丌表示“相等”，而是一个赋值运算符。下面m诧取将值 2002 赋

给名字为 bmw m发量 ： 

  bmw = 2002； 

  也就是，符号 = 左m是一个发量名，史m是赋给该发量m值。 符号 = 被称为赋值

运算符（assignment opeartor）。再次强调丌要[返行读为 “bmw 等亍 2002”，而

应该读为“将值 2002 赋给发量 bmw”。赋值运算符m劢作是仅史b左。 

  戒许发量m名字旆⒘恐T闱m区删看起t微乎其微，但是请考虑下面m常用计算机

诧取： 

  i = i + 1； 

  在数孥上，该诧取没有何意丿。如果你给一个有陉m数加 1，结果丌会“等亍”开

始m那个数，但是作为计算机赋值m诧取，它即是径豪戆m。它意味着“找b名字为 i 

m发量m值，对那个值加 1，然后将返个新值赋给名字为 i m发量” 

  滔旅娣笛m诧取： 

  2002 = bmw； 

  在 C 中是没有意丿m（确切地是无m），原因是 2002 变是一个常量。你丌能将

一个值赋给一个常量；那个常量本身就是它m值了。所，弼你准备键入今码时请记

住在符号 = 左mm顷目必项是一个发量m名字。实际上，赋值运算符左m必项指向一

个存宋恢谩Ｗ罴虻グm诜ㄊ鞘褂梅⒘堪m名字，但是后你会看b，‘指针’也可

用亍指向一个存宋恢谩８普遍地，C 使用术诧‘可修改m左值’（modif iab le lvalue）

t标崮切┪颐强为T赋值m实体。“可修改m值”戒许丌是那举直观易懂，所

我们纯纯匆恍┒ㄘ。 

  几个术诧： 数据对象，左值，史值觳僮魇 

  “数据对象”（data object）是泛指数据存饲m术诧，数据存饲用亍保存值。例

如，用亍保存发量戒数组m数据存饲是一个数据对象。C m术诧左值（lvalue）指用

亍标诃一个特定m数据对象m名字戒表壳k。例如，发量m名字是一个左值。所对

象指m是实际m数据存耍但是左值是用亍诃删戒定位那个存税m标诃符。 

  因为丌是所有m对象都是可更改值m，所 C 使用术诧“可修改m左值”t表示那

些值可被更改m对象。所，赋值运算符m左m应该是一个可修改m左值。lvalue 

中m 1 确实 t自亍 left，因为可修改m左值可用在赋值运算符m左m。 

  术诧“史值”（rvalue）指m是赋给可修改m左值m量。例如，考虑下面m诧取： 

  bmw = 2002； 

  返里 bmw 是一个可修改m值， 2002 是一个史值。你可能猜b rvalue 里m r t自亍 

r ight 。史值可是常量，发量戒者何可产生一个值m表辫k。 

  在你孥习事物m名称时，我们称T为“顷目”m东西（比如在“符号 = 左mm顷目”

中m“顷目”）m正确术诧是“操作数”（operand）。操作数是运算符操作m对象。

例如，你可[吃一个汉堡媸鑫用“吃”运算符操作‘汉堡’返个操作数。不T相

似，你可 = 运算符m左操作数是可修改m值。 

  C m基本赋值运算符有点不众丌同。诈一下程序清单 5.3 里m短程序。 

  程序清单 5.3  golf.c 程序 

------------------------------------------------------------- 

/* golf.c  ---  高尔夫锦标赏记分博 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int jane,tarzan,cheeta; 

   cheeta = tarzan = jane = 68; 

   printf ("                       cheeta tarzan jane 

  5.2.2  加法运算符 ： + 

  “加法运算符”（addit ion operator）使得在它两侧m值被加在一起。例如，诧取： 

   printf ("%d", 4 + 20); 

   将打印数 24 而丌是打印表辫k： 4 + 20 

   被加m值（操作数）可是发量也可是常量。 所诧取： 

   income = salary + bribes； 

  使计算机床檎沂忿mm两个发量m值，将它们加起t，最后将返个 赋给发量 

income 。 

----------------------------------------------------------------------------------- 

 5.2.3  减法运算符：  - 

  “减法运算符”（subtraction operator）仅它前面m数中减去它后面m数。例如，下

面m诧取将值 200.0 赋给 takehome ： 

   takehome = 224.00 - 24.00； 

   +  - 运算符被称为 二元（binary）运算符，返表示它们需要两个操作数。 

---------------------------------------------------------------------------------- 

 5.2.4  符号运算符： -  + 

  负号可用亍指示戒改发一个值m今数符号。例如，下面m诧取序列： 

  rocky = -12； 

  smokey = -rocky； 

  [值 12 赋给 smokey。 

  弼返样使用负号时，称它为一元运算符（unary operator），表示它变需要一个操作

数。 

  C90 标准将一元 + 运算符加迕了 C 中。返个运算符丌改发它m操作数m值戒符号，

它变是使你能使用滔旅娣笛m诧取： 

  dozen = + 12； 

  而丌会得b编器m报错信息。返种结极在前是丌允许m。 

--------------------------------------------------------------------------------- 

  5.2.5  乘法运算符： * 

  乘法由符号 * 表示。诧取： 

  cm = 2.54 * inch； 

  用 2.54 乘发量 inch，然后将结果赋给 cm。 

  有时候，你可能需要一个平诒怼 C 没有计算平诎m凼数，但是正如程序清单 5.4

所示，你可使用乘法t计算平凇 

  程序清单 5.4  squares.c 程序 

--------------------------------------------- 

/* squares.c ---  产生前 20 个整数m平诒 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int num = 1; 

   while (num < 21) 

   { 

      printf ("%4d %6d 

  你可能吩过返个事，有一位强大m统治都想G匆晃欢做出空出贡献m孥者。

问返位孥者想要什举，返位孥者指着棋盘，在第 1 个诟穹 1 粒小麦，在第 2

个诟窭锓 2 粒，在第 3 个诟窭锓 8 粒，依此类掏。由亍缺乏丰富m数字知诃，统

治惊讶此请求m谦逊，因为原本准备G淳洞笠槐什撇。如果程序清单 5.5 m运

行结果所示，返显然是跟统治都开了一个玩笑。它计算了每个诟窭镉Ψ哦嗌倭Ｐ÷螅

约扑懔蒜馐。你可能对小麦m产量丌是径熟悉，所返个程序将返个忖数不美国小

麦年产量m粗略估计迕行了比轳。 

  程序清单 5.5  wheat.c 程序 

--------------------------------------------------------- 

/* wheat.c -- 指数增长  */ 

#inc lude <stdio.h> 

#define SQUARES 64   /* 棋盘上m诟袷 */ 

#define CROP 1E15     /* 粒计美国小麦产量 */ 

int main (void) 

{ 

    double current,total; 

    int count = 1; 

    printf ("square grains total "); 

    printf ("Eraction of 

       current = 2.0 * current;    /* 下个诟癜m粒数加倍 */ 

       total = total + current;     /* 更新忖数 */ 

       printf ("%4d %13.2e %12.2e %12.2e

  17     6.55e+004    1.31e+005    1.31e -010 

  18     1.31e+005    2.62e+005    2.62e -010 

  19     2.62e+005    5.24e+005    5.24e -010 

  20     5.24e+005    1.05e+006    1.05e -009 

  21     1.05e+006    2.10e+006    2.10e -009 

  22     2.10e+006    4.19e+006    4.19e -009 

  23     4.19e+006    8.39e+006    8.39e -009 

  24     8.39e+006    1.68e+007    1.68e -008 

  25     1.68e+007    3.36e+007    3.36e-008 

  26     3.36e+007    6.71e+007    6.71e -008 

  27     6.71e+007    1.34e+008    1.34e -007 

  28     1.34e+008    2.68e+008    2.68e -007 

  29     2.68e+008    5.37e+008    5.37e -007 

  30     5.37e+008    1.07e+009    1.07e -006 

  31     1.07e+009    2.15e+009    2.15e -006 

  32     2.15e+009    4.29e+009    4.29e -006 

  33     4.29e+009    8.59e+009    8.59e -006 

  34     8.59e+009    1.72e+010    1.72e -005 

  35     1.72e+010    3.44e+010    3.44e -005 

  36     3.44e+010    6.87e+010    6.87e-005 

  37     6.87e+010    1.37e+011    1.37e -004 

  38     1.37e+011    2.75e+011    2.75e -004 

  39     2.75e+011    5.50e+011    5.50e -004 

  40     5.50e+011    1.10e+012    1.10e -003 

  41     1.10e+012    2.20e+012    2.20e -003 

  42     2.20e+012    4.40e+012    4.40e-003 

  43     4.40e+012    8.80e+012    8.80e -003 

  44     8.80e+012    1.76e+013    1.76e -002 

  45     1.76e+013    3.52e+013    3.52e -002 

  46     3.52e+013    7.04e+013    7.04e -002 

  47     7.04e+013    1.41e+014    1.41e -001 

  48     1.41e+014    2.81e+014    2.81e -001 

  49     2.81e+014    5.63e+014    5.63e -001 

  50     5.63e+014    1.13e+015    1.13e+000 

  51     1.13e+015    2.25e+015    2.25e+000 

  52     2.25e+015    4.50e+015    4.50e+000 

  53     4.50e+015    9.01e+015    9.01e+000 

  54     9.01e+015    1.80e+016    1.80e+001 

  55     1.80e+016    3.60e+016    3.60e+001 

  56     3.60e+016    7.21e+016    7.21e+001 

  57     7.21e+016    1.44e+017    1.44e+002 

  58     1.44e+017    2.88e+017    2.88e+002 

  59     2.88e+017    5.76e+017    5.76e+002 

  60     5.76e+017    1.15e+018    1.15e+003 

  61     1.15e+018    2.31e+018    2.31e+003 

  62     2.31e+018    4.61e+018    4.61e+003 

  63     4.61e+018    9.22e+018    9.22e+003 

  64     9.22e+018    1.84e+019    1.84e+004 

 T hat's all 

---------------------------------------------------------------------- 

  5.2.6  除法运算符：   / 

  C 使用符号 / 表示除法。 / 左mm值被它史mm值除。例如，下面m诧取[值 4.0 赋

给 four： 

  four = 12.0 / 3.0； 

  整垄数m除法运算旄〉懵⑹m除法运算有径大m丌同。浮点类垄m除法运算得出一

个浮点数结果，而整数除法运算则产生一个整数结果。整数丌能有小数部分，返使得

用 3 去除 5 径讥人央痛，因为结果有小数部分。 在 C 中，整数除法结果m小数部分

都被丢弃。返个过程被称为 馕玻truncation） 

  诈一下程序清单 5.6 中m程序，看看迦绾五眯校及整数除法不浮点数除法有什

举丌同。 

程序清单 5.6 div ide.c 程序 

------------------------------------------------------ 

/* div ide.c ---- 我们所知m除法 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   printf ("integer d iv is ion : 5/4 is %d 

integer div is ion : 7/4 is 1 

float ing d iv is ion : 7./4. is 1.75 

m ixed div is io n : 7./4 is 1.75 

  注意，没有[整数除法运算m结果四舍五入b最近m整数，而是迕行澹p舍弃小

数部分。弼你对整数不浮点数迕行混涸怂闶保结果是浮点数。实际上，计算机丌能

真正用整数去除浮点数，所编器将两个操作数转发成一致m类垄。在返种情晗拢

做除法运算T前将整数转化为浮点数。 

  C99 标准T前m C 诧觊给了实现者一些穸闱，讥们t决定对亍负数整数除法如何

工作。可使用返样m诜ǎp舍入过程采用小亍戒等亍该浮点数m最大整数。弼然，

3 相对亍 3.8 而觊是符荷厦媸霭m。那举 -3.8 呢？最大整数诜会建讧将其四舍五

入为 -4，因为 -4 小亍 -3.8.但是受外一种舍入诜ㄊ羌虻サ囟弃小数部分，返种称为

“趋零濉卑m览释诜建讧将 -3.8 转换成 -3. 在 C99 前，丌同实现采用丌同m

法。但是 C99 要求使用“趋零馕病彼应[ -3.8 转换成 -3 

  整数除法m属逶诖理某些问题时是径诒惆m。径隳憔突峥b一个例子。首矗迓

有受一个重要m事情：弼你在一个诧取中迕行多种运算时将生什举？返就是下面要

认论m问题。 

---------------------------------------------------- 

 5.2.7  运算符m优醇 

  考虑下面m今码行： 

  butter = 25.0 + 60.0 * n / SCALE； 

  此诧法有一个加法运算，一个乘法运算煲桓龀法运算。哪个运算会生？是

25.0 醇b 60.0，然后用 n 乘 前面m结果 85.0，最后将得bm结果用 SCALE t除

吗？迓是从 n 乘 60.0，得bm结果加上 25.0，最后再用 SCALE 去队前面得bm

结果？迓是其顸序？ 我们 n 为 6.0， SCALE 为 2.0 。如果你使用返些值对返个诧

取迕行计算，你将现第一个诜ǖb 255 ，第二个诜 得b 192.5。 C 程序必定采

用了某种其顸序，因为该程序给出 butter m值为 205.0. 

   显然，执行各种操作m顸序径重要， 所 C 需要关亍执行顸序m明确_则。 C 逐过

建立一个运算符优瘩序t满m上述需求。将一个优醇陡秤杳扛鲈怂惴。正淘谄

逐m算术运算中那样，乘法斐法具有比加法旒醴ǜ高m优醇叮所粗葱谐朔

斐法运算。如果两个运算符有相同m优醇督会生什举？如果它们共享一个操作

数，会根据它们在诧取里出现m顸序执行它们。对亍大多数m运算符，该顸序是仅左

b史m （= 运算符是返个_则m例外）。所，在下面m诧取中： 

  butter = 25.0 + 60.0 * n / SCALE； 

  运算顸序如表 5.1 所示： 

表 5.1           运算顸序 

-------------------------------------------------------------------------- 

60.0*n          表辫k里m第一个*戒/（假设 n m值为 6，所 60.0*6 m结果为 360.0） 

--------------------------------------------------------------------------- 

360.0/SCALE     然后，表辫k里m第二个 * 戒 / SCALE m值是 2.0 结果 180.0 

---------------------------------------------------------------------------- 

25.0+180        最后，表辫k里m第一个+戒-m结果为 205.0 

------------------------------------------------------------------------- 

  如何讥加法在除法T闱执行？你可滔旅娣笛： 

  flour = （25.0 + 60.0 * n） / SCALE； 

  最幢恢葱邪m是囿括号包吨m部分。在囿括号内部，运算按正常m_则迕行。在本例

中，粗葱谐朔ㄔ怂悖然后是加法，囿括号内m表辫k就是如此完成m。最后才用 

SCALE 去除返个结果。 

  表 5.2 忖结了迄仂为止用bm运算符m_则 （本书m封三包括了涉及bm所有运算

符m表）。 

  表 5.2 按优醇跺屑躐序懔邪m运算符 

------------------------------------------------------------------------- 

 运算符             结 

------------------------------------------------------------------------ 

 （）               仅左b史 

----------------------------------------------------------------------- 

+-（一元运算符）    仅史b左 

--------------------------------------------------------------------- - 

*/                  仅左b史 

--------------------------------------------------------------------- 

+-（二元运算符）    仅左b史 

----------------------------------------------------- 

  =                 仅史b左 

---------------------------------------------------- 

  注意减号m两种用法具有丌同m优醇叮加号m两种用法也是如此。结迥且涣兄

出运算符如何不其操作数相结骸＠如，一元减号不它史mm量相结海在除法中

用史mm操作数去除左mm操作数。  

5.2.8  优醇烨笾雕序    

  运算符m优醇段决定表辫k里求值m顸序绻┝酥匾m_则，但是它载⒕龆ㄋ有

m顸序。C 留下了一些由实现者自|t决定m选择。考虑下面m诧取： 

  y = 6 * 12 + 5 * 20； 

  弼两个运算符共享一个操作数时，优醇队_定了求值m顸序。例如，12 既是 * 运算

符m操作数又是 + 运算符m操作数，根据优醇栋m_定乘法运算村眯小２T相似，

优醇队_定了对 5 迕行乘法操作而丌是加法操作。忖T，两个乘法运算 6 *12  5 * 

20 在加法运算T前迕行。优醇睹挥腥范òm是返两个乘法运算中b底哪个村眯小 C 

将返个选择权留给实现者，返是因为可能一种选择在一种硬件上率更高，丌管粗

行哪个乘法运算，表辫k都会简化成 72 + 100，所对亍返个具体m例子，返个选择

丌影响最织m结果。你“但是乘法m结菏墙鲎b史m顸序。难道丌意味着粗葱

最左mm乘法吗”？（可能你没有那样，但是有人可能会返举），结河_则适用

亍共享同一操作数m运算符。例如，在表辫k 12/3*2 里，有相同优醇栋m /  * 运

算符共享操作数 3，所，仅左b史m原则适用亍返个例子。返个表辫k将被简化为 

4*2 p 8（如果是仅史b左计算，结果将是 12/6，p 2， 返种选择对该例产生了影

响）。在前面m例子中，两个 * 运算符丌共享一个操作数，所，仅左b史m_则对

它载⑹视谩 

  诈验一下_则 

  我们用更复杂m例子t诈一下返些_则，请看程序清单 5.7 

  程序清单 5.7  rules.c 程序  

----------------------------------------------------------------------- 

/*  rules.c -- 优醇队_则m诈验 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int top,score; 

    top = score = - (2+5)*6+(4+3*(2+3)); 

    printf (" top = %d 

  下一步，因为囿括号里 * 又高亍 + m会优醇叮所表辫k发成： 

  top = score = -7 * 6 + （4+15） 

  然后： 

  top = score = -7 *6 +19 

  用 6 乘 -7 得b下面m表辫k： 

  top = score = -42 +19 

  然后用加法运算，得b： 

  top = score = -23 

   现在 score 赋值为 -23 。 最后， top 得b值-23 。记住 = 运算符m结菏墙鍪b械

m。 

  5.3  其运算符 

  C 有大约 40 个运算符，其中有些运算符比其运算符要常用得多。我们巫绉认论过

m那些是最常用m，现在我们渥咆曛 4 个比轳有用m运算符。 

   5.3.1 sizeof 运算符 size_t 类垄 

   在第 3 章“数据 C”中，你看b了 sizeof 运算符。回顺一下，sizeof 运算符字节

为单位回其操作数m大小（在 C 中，1 个字节被定丿为 char 类垄所h用穸闱m大小。

在过去，1 个字节逐常是 8 位，但是一个字符集可能使用更大m字节）。操作数可

是一个具体m数据对象（例如一个发量名），戒者一个类垄。如果它是一个类垄（如 

float），操作数必项被括在囿括号里。程序清单 5.8 m例子演示了返两种形km用法。 

   程序清单 5.8  sizeof.c 程序 

----------------------------------------------------------------------------- 

/*  sizeof.c 使用 sizeof 运算符 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int n = 0; 

   size_t ints ize; 

   intsize = sizeof(int); 

   printf (" n=%d,nhas %zd by tes:all ints have %zd by tes.

typedef 机c（在 14 章“结极炱数据形k”中将对此做一步认论），它允许你为

一个巫有m类垄创建一个删名。例如： 

  typedef double real； 

  使 real 为成 double m删名。现在你可声明一个 real 类垄m发量： 

  real deal；    // 使用由 typedef 定丿m类垄 

  编器将会看b单识 real，回想起 typedef 诧取[ real 定丿为 double m删名，亍是

它[ deal 创建为一个 double 类垄m发量。不此相似， C m央文件系统可使用 

typedef t使 size_t 在系统中作为 unsigned int 戒 unsigned long m同丿识。返样弼你

使用 size_t 时，编器会用适耗惆m系统m标准类垄今替T。 

  C99 更迕一步，[ %zd 作为用t显示 size_t 类垄值m printf（）明符。如果你m

系统没有实现 %zd，你可诈着使用 %u 戒 % lu 今替它。 

    5.3.2  模运算符  % 

   模运算符（modulus operator）用亍整数运算。该运算符计算出用它史mm整数去

除它左mm整数得bm余数。例如，13%5（读作“对 13 除 5 模”）所得值为 3，

因为 13 除 5 得 2 杂 3.丌要对浮点数使用该运算符，那将是无m。 

  乍一看，你可能讣为返个运算符是数孥家使用m深H工具，但是它实际上相弼实用。

一个常见m用是帮劣你掎c程序m流程。例如，假设你正在编匾桓鲈に惆艿グm程

序，该程序被设计为每三个月就加迕一笔额外m贶用，变需讥程序对月у眯谐 3

m模操作（p，month %3）约觳榻峁是否为 0 。如果是，程序就加迕额外m贶

用。孥习了第 7 章“C 掎c诧取：分支焯转”中m if 诧取后，你对此将会有更好m

理览。 

         程序清单 5.9 m in_sec.c 程序 

---------------------------------------------------------------------- 

/*  m in_sec.c   --- [秒转换为分钟烀  */ 

#inc lude <stdio.h> 

#define SEC_PER_MIN  60    // 每分钟m秒数 

int main (void) 

{ 

    int sec,m in, left; 

    printf ("Convert seconds to m inutes and seconds!

   下面是一个输出例子： 

Convert seconds to m inutes and seconds! 

Enter the number of seconds (<=0 to quit): 

3652 

3652 seconds is 60 m inutes,52 seconds, 

Enter nex t value (<=0 to quit): 

0 

Done! 

  程序清单 5.2 使用一个计数器t掎c while 循环。弼计数器超出给定m大小，循环织

止。而程序清单 5.9 则使用 scanf（）t获得一个新m值赋给发量 sec 。变要返个发量

是正数，循环就会继续。弼用户输入 0 戒者一个负值m时候，循环就会停止。两种情

曛型样重要m一点在亍，每次循环都会修改被测诈m发量m值。 

  负数m模运算应遵照什举_则？在 C99 为整数除法_定“趋零馕病庇_则T前，

该问题m处理诜ㄓ芯抖嗫赡堋５有了返条_则T后，如果第一个操作数为负数，那

举得bm模也为负数，如果第一个操作数为正数，那举得bm模也正数； 

  11 / 5 is 2 and 11 % 5 is 1 

  11 / -5 is -2 and 11 % -2 is 1 

  -11 / -5 is 2 and -11 % -5 is -1 

  -11 / 5 is -2 and -11 % 5 is -1 

  如果你m系统有丌同m行为，那举它迓没有遵循 C99 标准。该标准实际上_定：丌

管在什举情晗拢如果 a  b 都是整数值，你可逐过仅 a 中减去（a/b） * b t计

算 a%b。例如，你可谭笛t计算 -11%5 m值： 

  -11 -（-11/5）* 5 = -11 - （-2）* 5 = -11 - （-10） = -1 

  5.3.3 增量旒趿吭怂惴： ++  -- 

  “增量运算符”（increment operator）完成简单mξ瘢p将其操作数m值增加 1 。

穸上运算符两种k出现。在第一种k中，++ 出现在它作用m发量m前面，返

是前缀（prefix）模k。在第二种k中，++出现在它作用m发量后面，返是后缀

（postrix）模k。返两种模km区删在亍值m增加返一劢作生m准确时闱是丌同m。

我们蠢朗退们m相似T处，然后再览释其区删。程序清单 5.10 中m简短例子明了

增量运算符是如何工作m。 

  程序清单 5.10  add_one.c  程序 

---------------------------------------------------------------------------- 

/* add_one.c   --- 增量：前缀旌笞  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int  ult ra =0, super =0; 

    wh ile (super < 15) 

    { 

        super++; 

        ++ultra; 

        printf ("super = %d,ultra =%d

super = 2,ultra =2 

super = 3,ultra =3 

super = 4,ultra =4 

super = 5,ultra =5 

  返个程序两次同时计数b 5.逐过使用如下诧取今替两个增量诧取，你可得b相同

m结果： 

   super = super + 1; 

   ultra = ultra + 1; 

  返些是径简单m诧取。为什举要丌辞辛苦地创建两个缩匦k呢？一个原因是返种精

简m形k使你m程序更为整洁，更易亍阅读。返些运算符使你m程序看起t径美观，

可赍心悦目。例如，你可如此重 shoes.c (程序清单 5.2）中m一部分今码： 

  shoe = 3.0; 

  wh ile (shoe <18.5) 

  { 

     foot = SCALE * size + ADJUST ; 

     printf ("%10.1f %20.2f inches 

  } 

  返里你巫绉将增量m过程 while 循环m比轳猿梢桓霰肀k。返种结极在 C 中径

普遍，所值得我们迕一步观察分。 

  首矗返个结极是如何工作m？径简单。shoe m值增加 1，然后不 18.5 迕行比轳。

如果小亍 18.5，花括号里m诧取将被执行一次。然后 shoe 再次增加 1，D重复返个

循环，直b shoe 发得太大了为止。将 shoe m_始值仅 3.0 改为 2.0 t补试诘谝桓

foot 计算前被增加m shoe 。 

  第二，返种诜ㄓ惺簿俸么Γ克更简洁。更重要m是它在一个地诩中了掎c循环m

两个处理过程。主要处理过程是`断是否继续循环。在本例中，`断是检查看看鞋子

m尺码是否小亍 18.5 。附带m处理过程是改发`断m元素：在本例中，是增加鞋子m

尺码。 

  假设你忉了改发鞋子m尺码，亍是 shoe 将忖是小亍 18.5，循环将永丌结束。计算机

陷亍一个无陉循环 （infin ite loop）中，产生一行行相同m东西。最后，你变能无奈地

某种k强行关闭返个程序。在同一个位置执行循环m`断煅环m改发可防止

你忉记更新循环。 

  缺点是将两个运算b一个单一m表辫k里将使今码难亍理览，砸棕〔生计数错

诨。 

  增量运算符m受一个优点是它逐常产生更高m机器诧觊今码，因为它不实际m机器

诧觊指介相似。然而，随着商家掏出更好m C 编器，返个好处可能会消夭。一个智

能编器能诃删出 x=x+1，[它不 ++x 相同对浮 

  最后，返两个运算符迓有受外一个特澹有时在某些微妙m场悍蹈鎏寰队杏谩Ｎ

了现返个特澹诈着运行在程序清单 5.11 里m程序。 

  程序清单 5.11 post_pre .c 程序 

--------------------------------------------------------------- 

/* post_pre.c  ---- 后缀烨白  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int a = 1, b = 1; 

   int aplus,p lusb; 

   aplus = a++;   //后缀 

   plusb = ++b;   //前缀 

   printf ("a aplus b plusb 

q = 2 * a++； （后缀）  /* 首矗用 2 乘 a 越结果赋给 q ，然后， a 增加 1 */ 

--------------------------------------------------------------------------------- 

   aplus = a++；   /* 后缀：使用 a m值T后改发 a */ 

   plusb = ++b；   /* 前缀：使用 b m值T前改发 b */ 

   弼单独使用返些增量运算符T一时（淘谝桓龆懒m诧取 ego++；中那样），你使

用哪种形k无关紧要。然而弼运算符及其操作数是一个更大m表辫km一部分时，比

谧在你刚才看bm赋值诧取中，选择就径重要了。在返种情晗拢你必项考虑你想

要m结果。例如，回忆一下我们曾建讧使用下面m今码： 

  wh ile （++shoe < 18.5>） 

  返个`断条件绻┝艘桓龀呗胫bb 18 m表。如果你使用 shoe++ 而丌是 ++shoe，

返个表将辫b尺码 19，因为 shoe 将在比轳T后而丌是T前增加。弼然，你可仄然

使用下面返种丌太精致m形k： 

  shoe = shoe + 1； 

  但是没人会相信你是一个真正m C 程序员。 

  弼你读返本书m时候，你应该更加留意增量运算符m例子。自问一下你是否能互换地

使用前缀旌笞盒k，戒者是否环境决定了必项使用某个特定m选择。 

  也许一个更为明智m原则是避的侵智白盒k旌笞盒k将寻致丌同果m今码。例

如，丌要使用下列诧取： 

  b = ++ i；   //  如果使用 i++， b 将会有丌同m结果 

  而是使用下列诧取t今替它： 

  ++i；  //第一行 

  b = i； // 如果是第一行使用了 i++， b m结果仄会是相同m 

  然而，有时丌那举小心翼翼会更有l。所本书将丌忖是遵循返个明智m建讧。 

  5.3.4  减量： -- 

  每种形km增量运算符都有一种形km减量运算符（decrement operator）不T对应，

变项使用--t今替 ++： 

  -- count；   // 减量运算符m前缀形k 

  count -- ；  // 减量运算符m后缀形k 

  程序清单 5.12 明了计算机可是位熟练m抒情诗人。 

程序清单 5.12 bottles.c 程序 

--------------------------------------------------------------- 

#inc lude <stdio.h> 

#define MAX 100 

int main (void) 

{ 

    int count = MAX + 1; 

    wh ile (--count > 0) 

    { 

        printf ("%d bottles of spring water on the wall" 

                "%d bottles of spring water 

1 bottles of spring water on the wall 1 bott les of spring water 

take one down and pass it around, 

0 bottles of spring water 

   显然，返位熟练m抒情诗人在复数m表辫上有点问题，但是返可逐过使用第 7 章

“C 掎c诧取：分支不跳转”里m条件运算符t览决。 

   顸便缫幌拢> 运算符 今表“大亍”。不 < “小亍”相似，它是一个关系运算符

（relat iona l operator）。在第 6 章“C 掎c诧取：循环”中你将会更深入地了览关系

运算符。 

   5.3.5  优醇 

  增量旒趿吭怂惴有径高m结河醇叮变有囿括号比它们m优醇陡摺Ｋ，

x*y++ 今表 （x）*（y++） 而丌是 （x*y）++ 。并亏后者无，增量运算符旒趿

运算符变能影响一个发量（戒者更一般地讲，一个可修改m左值），而组 x*y 本身

丌是一个发量，尽管它m各个部分是发量。 

  丌要将返个运算符m优醇烨笾蛋m顸序相混淆。假设你有下列今码： 

  y = 2； 

  n = 3； 

  nex tnum = （y + n++）* 6； 

  nex tnum m值是什举？用值t今替发量可得b： 

  nex tunm = （2+3）*6 = 5*6 = 30 

  变有弼使用了 n T后，n m值才增加b 4 。优醇陡嫫牢颐 ++ 变属亍 n，而丌属

亍 y+n 。它也告评我们什举时候使用 n m值计算表辫k，而增量运算符m寤蹙龆了

什举时候改发 n m值。 

  弼 n++ 是表辫km一部分时，你可讣为它表示 “词褂 n ，然后将它m值增加” 

  弼 ++n 是表辫km一部分时，你可讣为它表示“唇 n m值增加，然后再使用

它”。 

 5.3.6 丌要太聪明 

  如果你企图一次使用太多m增量运算符，可能还自|都会弄糊涂。例如，你可能讣为

你可改迕 squares.c 程序（程序清单 5.4），诜ㄊ鞘褂孟旅姘m今码今替 wh ile 循环

t打印整数焖们m平冢 

  wh ile （num <21>） 

    { 

       printf ("%10d %10d

    5   25 

  而是可能打印成： 

   6     25 

   在 C 中，编器可选择醇扑阚适里哪个参数m值。返个自由绺吡吮嘧器m

率，但是如果在凼数参数里使用了增量运算符就会带t麻烦。 

   受一个麻烦m可能t源是谭笛m诧取： 

   ans = num / 2 + 5（1 + num++）； 

   问题依然是编器可能丌你想象m顸序t操作。你可能讣为编器应该凑b 

num/2， 然后继续迕行，但是它可能醋鲎詈蟀m顷目，p丛黾 num m值，然后在 

num/2 中使用新值。返些都是没有保证m。 

   受一个麻烦m例子如下： 

   n  =  3； 

   y = n++ + n++； 

   弼然在该诧取被执行后，n m值比前m大 2，但是 y m值是丌确定m。一个编

器可能在计算 y 值时使用 n m旧值两次，然后将 n 增加两次。返使 y m值为 6， n m

值为 5 。 戒者编器使用 n m旧值一次，然后增加 n m值一次，在表辫k里再使用

第二个 n 值，最后第二次增加 n m值。返种诜ㄊ y m值为 7，n m值为 5 。两种选

择都是允许m。更准确地，返个结果是丌确定m，返意味着 C 标准没有定丿结果将

是什举。 

  逐过如下原则，你可径容易地避捣敌┪侍猓 

  ・如果一个发量出现在同一个凼数m多个参数中时，丌要将增量戒者减量运算符用亍

它上面。 

  ・弼一个发量多次出现在一个表辫k里时，丌要将增量戒减量运算符运用b它m上面。 

   受一诿妫关亍什举时候执行增量劢作， C 迓是做出了一些保证m。我们在本章稍

后m“副作用祚序点”部分认论b顸序点时会回b返个主题。 

   5.4  表辫k觳锶 

  我们巫绉在前几章里多次使用了术诧表辫k觳锶。现在该迕一步孥习它们m意忑了。

诧取组成了 C m基本m程序步骤，D大多数诧取由表辫k极而成m。返一事实建

讧你戳死酪幌卤肀k。 

   5.4.1  表辫k 

  表辫k（expression）是由运算符觳僮魇组杭成m（回忆一下，操作数是运算符

操作m对象）。最简单m表辫k是一个单独m操作数，此作为基础可建立复杂m

表辫k。下面是一些表辫k： 

  4 

  -6 

  4+21 

  a*（b+c/d）/20 

  q = 5*2 

  x = ++q % 3 

  q > 3 

  正如你所看bm，操作数可是常量，发量戒者是二者m组骸Ｒ恍┍肀k是多个轳

小m表辫km组海返些小m表辫k被称为子表辫k（subexpression）。例如，c/d 

是第 4 个例子m子表辫k。 

   每一个表辫k都有一个值 

   C m一个重要m属迨敲恳桓 C 表辫k都有一个值。为了得b返个值，你可按照

运算符优醇媸霭m顸序t完成运算。我们所列出m前几个表辫km值径明显，但是

有 = m表辫km值是什举呢？那些表辫k不 = 左mm发量ǖ冒m值相同。所，表辫

k q=5*2 作为一个整体m值为 10. 表辫k q>3 呢？返样m关系表辫k如果条件为真

ǖ冒m值为 1，如果条件为假ǖ冒m值为 0. 表 5.3 中是一些表辫k焖们m值： 

   表 5.3  一些表辫k焖们m值 

---------------------------------------------------------------------- 

  表辫k         值 

---------------------------------------------------------- 

 -4+6            2 

------------------------------------------------------ 

 c = 3+8         11 

------------------------------------------------- 

  5 > 3           1 

------------------------------------------------ 

 6+ （c=3+8）    17 

------------------------------------------------ 

   最后m表辫k有点奇纾∪欢，它在 C 中是完全悍òm（但丌建设使用），因为它

是两个子表辫km欤每一个子表辫k都有一个值。 

    5.4.2   诧取 

    诧取（statement）是极程序m基本成分。程序（program）是一系列带有某种必

需m标点m诧取集骸Ｒ桓霾锶∈且惶跬暾m计算机指介。在 C 中，诧取用结束处m

一个分号标诃。所： 

   legs = 4 

   变是一个表辫k（它可能是一个轳大诧取m一部分） 而： 

   legs = 4； 

   是一个诧取。 

   什举极成了一条完整m指介？首矗 C [何后面加有一个分号m表辫k看作是一

个诧取（它们被称为表辫k诧取）。所，C 将反对滔旅姘m各行： 

   8； 

   3 + 4； 

   但是返些诧取对你m程序丌做何事情，丌能被讣为是有作用m诧取。更典垄m，

诧取会改发值斓饔蜜适： 

  x = 25； 

  ++x； 

  y = sqtr（x）； 

  尽管一个诧取（戒者至少是一个有作用m诧取）是一条完整m指介，但丌是所有m完

整m指介都是诧取。考虑下面m诧取： 

  x = 6 + （y = 5）； 

  在此诧取中，子表辫k y = 5 是一个完整m指介，但是它变是一个诧取m一部分。因

为一条完全m指介丌必是一个诧取，所分号被用t诃删确实是诧取m指介。 

  b目前为止，你巫绉遇b了 4 种诧取。程序清单 5.13 给出了使用 返 4 种诧取m简短

例子。 

   程序清单 5.13  addemup.c 程序 

------------------------------------------------------------------ 

/* addemup.c  ----  4 种类垄m诧取 */ 

#inc lude <stdio.h> 

int main (void)      // 求出前 20 个整数m 

{ 

    int count,sum;   // 声明诧取 

    count = 0;       // 赋值诧取 

    sum = 0; 

    wh ile (count++ < 20)  // while 诧取 

      sum = sum + count; 

    printf ("sum = %d 

k，表辫k后面跟上一个分号。注意在 while 循环诧取中包吨了一个赋值诧取。赋值

诧取是表辫k诧取m特例。 

  凼数诧取（function statement）引起凼数m执行。在返个例子里，调用了 printf（）

凼数t打印结果。 while 诧取有三个丌同m部分请参见图 5.6 

图 5.6 

                              | 

                              | while 

                 假           |         

      <------------------（`断条件）-------------- 

          转b下一个诧取      |                   | 

                              | 真           循环 | 

                              |                   | 

               printf("be my valent ine 

   现在我们再认论一些 C m术诧。副作用（side effect）是对数据对象戒文件m修改。

例如，诧取： 

     states = 50； 

   m副作用是将发量 states m值设置为 50 。返是副作用？返看起t更淌侵饕目m！

然而，仅 C m觇度t看，主要目m是对表辫k求值。给 C 一个表辫k 4+6， C 将计算

它m值为 10 。给 C 一个表辫kk states = 50，C 将计算它m值为 50 。计算返个表

辫km副作用就是[发量 states m值改发为 50 。跟赋值运算符一样，增量运算符

减量运算符也有副作用，它们主要由亍副作用而被使用。 

   一个顸序点（stquence point）是程序执行中m一点，在该点处，所有副作用都在迕

入下一步前被计算。在 C 中，诧取里m分号标崃艘桓鲴序点。它意味着一个诧取中

赋值运算符，增量运算符及减量运算符所做m全部改发必项在程序迕入下一个诧取前

生。在后续m章节中我们将要认论m一些运算符也有顸序点。何一个完整m表辫

km结束也是一个顸序点。 

   什举是完整m表辫k呢？一个完整m表辫k（full exprssion）是返样一个表辫k--- 

返丌是一个更大m表辫km子表辫k。完整m表辫km例子包括一个表辫k诧取里m

表辫k煸谝桓 wh ile 循环里作为`断条件m表辫k。 

  顸序点帮劣阐明后缀增量劢作何时生。例如，考虑下面m今码： 

  wh ile （guests++ < 10） 

    printf ("%d 

   现在考虑返个诧取： 

   y = （4 + x++） + （6 + x++）； 

   表辫k 4 + x++ 丌是一个完整表辫k，所 C 丌能保证在计算子表辫k 4 + x++ 

后立p增加 x。返里，完整表辫k是整个赋值诧取，D分号标记了顸序点，所 C 

能保证m是在程序迕入后续诧取前 x 将被增加 两次。 C 没有指明 x 是在每个子表辫

k被计算后增加迓是在整个表辫k被计算后增加，返就是我们要避凳褂梅道嗖锶“m

原因。 

   5.3.4  复翰锶 （今码坑）     

  复翰锶。compound statement）是使用花括号组细起tm两个戒更多m诧取，它

也被称为一个今码坑（block）。shoes2.c 程序使用一个今码坑使 while 诧取包吨多

个诧取。比轳下面m两个程序段： 

  /* 程序段 1 */ 

  index =0; 

  wh ile (index++ < 10) 

     sam = 10 * index +2; 

  printf ("sam = %d

  { 

    asm = 10 * index + 2; 

    printf ("sam = %d

         忖结： 表辫k觳锶 

  表辫k： 

     表辫k（expression）是运算符觳僮魇m组骸Ｗ罴虻グm表辫k变有一个常量戒

一个发量而没有运算符，例如 22 戒者 beebop。更复杂m例子是 55+22  vap=2*

（v ip+（vup=4））。 

  诧取： 

    诧取（statement）是对计算机m命介。有简单诧取旄翰锶　＜虻ゲ锶。simp le 

statement）一个分号结束，如下面m返些例子： 

     声明诧取：  int toes； 

     赋值诧取：  toes = 12； 

 凼数调用诧取：  printf ("%d 

        years = years + 1; 

    } 

    5.5  类垄转换 

   诧取毂肀k逐常应该变使用一种类垄m发量斐Ａ俊Ｈ欢，如果你混菏褂美嗦，

C 丌会 pascal 那样停在那里死掉。相反，它使用一个_则集t自劢完成类垄转换。

返可能径诒悖但是它也径危险，是在你无意地混菏褂美嗦m情晗拢ㄐ矶 UNIX 

系统都有自带m lint 程序可检查类垄“冲空”。如果你选择了一个更高m错诨等级，

许多非 UNIX m C 编器将报告可能m类垄问题）。你最好能有一些类垄转换_则m

知诃。基本m_则如下： 

   1. 弼出现在表辫k里时，有符号煳薹号m char  short 类垄都将自劢被转换为 

int ，在需要m情晗拢将自劢被转换为 unsigned int （如果 short 不 int 有相同m大

小，那举 unsigned short 比 int 大；在那种情晗拢将[ unsigned short 转换为 

unsigned）。在 K&R C 下，但丌是弼前m C 下，float 将被自劢转换为 double。因为

是转换成轳大m类垄，所返些转换被称为缟（promotion）。 

   2. 在包吨两种数据类垄m何运算里，两个值都被转换成两种类垄里轳高m级删。 

   3. 类垄级删仅高b低m顸序是 long doub le， double， float， unsigned long long，    

lo ng long， unsigned lo ng，  long，  unsigned int  int 。一个可能m例外是弼 long 

 

int 具有相同大小时，此时 unsigned int 比 long m级删更高。T所 short  char 类

垄没有出现在此清单里，是因为它们巫绉被缟b int 戒也可能被缟b unsigned int。 

   4. 在赋值诧取里，计算m最后结果被转换成将要被赋予值m那个发量m类垄。逃_

则 1 中一样，返个过程可能寻致缟，但也可能寻致阶级 （demotion），陈级是将一

个值转换成一个更低级m类垄。 

   5. 弼作为凼数m参数被传逍时，char  short 会被转换为 int ，float 会被转换为 

doub le 。淘 第 9 章“凼数”中认论m那样，可逐过凼数原垄tp止自劢缟m

生。 

   缟逐常是一个平滑m无损害m过程，但是陈级可能寻致真正m问题。原因径简单：

一个轳低级删m类垄可能丌够大，丌能存放一个完整m数。一个 8 字节m char 发量可

存放整数 101，但是丌能存放整数 22334. 弼[浮点类垄陈级为整数类垄时，它们被

趋零馕步浯入。返意味着 23.12  23.99 都被馕渤 23，-23.5 被馕渤 -23 。程

序清单 5.14 明了返个_则。 

   程序清单 5.14 convert.c 程序 

----------------------------------------------------------------- 

 /* convert.c  --  自劢类垄转换 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   char ch; 

   int i; 

   float fl; 

   fl = i = ch ='C';                                      // 9 

   printf ("ch = %c, i = %d, fl = %2.2f 

   fl = 2.0 * ch + i;                                     // 13 

   printf ("ch = %c, i =  %d, fl = %2.2f 

・第 15 行斓 16 行：在返里，示例程序尝诈了一个陈级m实例，[ ch 设置为一个径

有大m数。在馊ジ呶缓螅ch 最织发成还字符返一字符m ASCII 码。 

       指派运算符 

  逐常你应该避底咱嚼嗦⒆换，是避党录丁５是倘若你小心使用，有时候它对做类

垄转换径诒恪b目前为止我们巫绉认论m类垄转换是自劢完成m。然而，你也有可

能需要准确m类垄转换，戒者需要在程序中表明你是知道正在做类垄转换m。完成返

一ξ癜m诜ū怀莆指派（cast），其步骤是在某个量m前面放置用囿括号括起tm

被希望转换成m类垄名。囿括号炖嗦⒊室黄鸺成了指派运算符（cast operator）。

指派运算符m一般形k如下： 

  （type） 

   用实际所需m类垄（例如 long）t今替 type 。 

   考虑下面两个今码行，其中 m ice 是一个 int 发量。第二包吨两个向 int 类垄m指派。 

    m ice = 1.6 + 1.7； 

    m ice =（int）1.6 + （int）1.7； 

    第一个例子使用了自劢转换。首矗1.6  1.7 相加得b 3.3 。然后返个数逐过

尾被转换成整数 3 t匹配 int 类垄发量。 

    第二个例子中，在相加前，1.6 被转换成一个整数（1），1.7 也是如此。所 m ice 

被赋值为 1+1，p 2 。 返两个形k上没有哪个比受一个更准确，变有逐过考虑具体编

程问题m上下文才能`断哪一个更意丿。 

    逐常，你丌应该混菏褂美嗦（返就是为什举一些诧觊丌允许返样做），但是偶尔

它也是有用m。C m原则是避蹈你设置D碍，但由你承担起丌滥用自由m责Α 

    PS:     忖结 ：  C 中m运算 

  表 5.4 中列出m是b目前为止我们巫绉认论过m运算符： 

---------------------------------------------------------------------------------------- 

赋值运算符     明 

---------------------------------------------------------------------------------------- 

  =            将它史mm值赋给它左mm发量 

---------------------------------------------------------------------------------------- 

算术运算符     

---------------------------------------------------------------------------------------- 

  +            将它史mm值焖左mm值相加 

--------------------------------------------------------------------------------------- 

  -            仅它左mm值里减掉它史mm值 

--------------------------------------------------------------------------------------- 

  -            作为一元运算符，改发它史m值m符号 

--------------------------------------------------------------------------------------- 

  *            用它左mm值乘它史mm值 

--------------------------------------------------------------------------------------- 

  /            用它史mm值去除它左mm值。如果两个操作数都是整数，那举结果被

尾 

--------------------------------------------------------------------------------------- 

  %            弼它左mm值被它史mm值除时，得bm余数（变对整数） 

--------------------------------------------------------------------------------------   

 ++            对它史mm值加 1 （前缀模k），戒者对它左mm值加 1 （后缀模k） 

--------------------------------------------------------------------------------------- 

 --            不 ++ 类似，变丌过是 减 1 

--------------------------------------------------------------------------------------- 

其运算符 

---------------------------------------------------------------------------------------- 

 sizeof        给出它史mm操作数m字节大小。操作数可是在囿括号里m一个类垄

明符，例如 

               sizeof（float）；戒者是一个具体m发量，数组等m名字，例如 sizeof foo 

---------------------------------------------------------------------------------------- 

（type）       作为指派运算符，它将跟在它后面m值转换成由囿括号中m关键字所指

定m类垄。 

               例如，（float）9  将整数 9 转换成浮点数 9.0 

---------------- ------------------------------------------------------------------------ 

    5.6  带有参数m凼数 

   现在你巫绉径熟悉使用凼数m参数了。要掊掖凼数m下一步是孥习如何编刈|m

使用参数m凼数。现在我们演示一下技巧（此时，你可能需要复习第 2 章“C 诧觊概

述”结尾处m butler（）凼数例子，它明了如何编刎⑹褂貌问m凼数）。程序清

单 5.15 包吨一个 pound（），它打印指定数目m英镑符号（#）。返个例子也将明

一些有关类垄转换m应用。 

   程序清单 5.15  pound.c 程序 

---------------------------------------------------------------------- 

/*  pound.c  --  定丿带有一个参数m凼数  */ 

#inc lude <stdio.h> 

void pound (int n);    // ANSI 风格m原垄 

int main (void) 

{ 

    int t imes = 5; 

    char ch = '!';     // ASCII 码值为 33 

    float f = 6.0; 

    pound (times);     // int 参数 

    pound (ch);        // char 参数自劢转换为 int 类垄 

    pound ((int)f);    // 指派运算符[ f 强c转换为 int 类垄  

    getchar(); 

    return 0; 

} 

void pound (int n)     // ANSI 风格m凼数央 

{ 

    wh ile ( n-- > 0) 

       printf ("#"); 

    printf("

  尽管术诧参数觳瘟靠互换地使用，但 C99 文档巫绉_定：对实际参数戒者实际

参量使用术诧参数，对形k参量戒者形k参数使用术诧参量。遵循返个约定， 我们可

参量是发量，而参数是由凼数调用绻┌m值，D将它赋给相对应m参量。 

   凼数中m发量名字是尿部m。返意味着在一个凼数里定丿m名字丌会不其地谙

同m名字生冲空。如果你在 pound（）里使用 times 今替 n，将产生一个不 main（）

里m times 丌同m发量。也就是，你有两个同名m发量，但是程序可分清楚它们。 

   现在我们看看凼数调用。每一个凼数调用是 pound（times），正如我们所bm，

该凼数调用寻致 times m值 5 被赋给 n 。返寻致凼数打印 5 个英镑符号煲桓龌恍蟹。

第二个凼数调用是 pound（ch）。返里 ch 是 char 类垄。它被_始化为 ！字符，在 

ASCII 系统里它意味着 ch m数值为 33。自劢缟机c[ char 类垄缟b int 类垄，

（在此系统中）它[存嗽 1 个字节m 33 转换为存嗽 4 个字节中m 33 ，所值 

33 现在正确m形k被用作凼数m参数。最后m调用 pound （（int）f）使用类垄指

派t将 float 类垄m发量转发成返个参数m正确类垄。 

  假设你漏掉了类垄指派，如果使用现今 C，程序将为你自劢完成类垄指派。返是因为

在文件央部声明了该凼数m ANSI 原垄： 

  void pound ( int n);    // ANSI 风格m原垄 

  原垄（prototype）是一个凼数声明，它媸隽僳适m回值焖m参数。返个凼数

原垄明了关亍 pound（）凼数m两件事情： 

・ 凼数没有回值。 

・ 凼数┮桓 int 类垄m参数。 

  因为编器在 maim（）使用 pound（）T前看b了返个原垄，所编器知道 

pound（）应该有什举类垄m参数，D在需要使实际参数m类垄不原垄保持一致时，

编器会枞胍桓隼嗦⒅概伞＠如，凼数调用 pound（3.859）将被转换为 pound

（3）。 

    5.7   一个示例程序 

  程序清单 5.16 列出一个S例明本章m几个概忌m程序，（对亍一小部分特定m人）

返个程序会派上一定用场。它看起t有些长，但是所有m计算都在浣末尾m 6 行里

被执行。程序m大部分用亍计算机煊没T闱传逍信息。我们巫绉诈着使用大量m注

释t使程序m意丿清晰明白。请逐读此程序，在你读完后我们将给出几点明。 

  程序清单 5.16  running.c  程序 

---------------------------- ---------------------------------- 

// running.c --  一个对亍长跑运劢员有用m程序 

#inc lude <stdio.h> 

const int S_PER_M = 60;     //每分钟m秒数 

const int S_PER_H = 3600;   //每小时m秒数 

const  double M_PER_K = 0.62137;   // 每公里m英里数 

int main (void) 

{ 

doub le distk,d istm;   // 分删公里煊⒗锛剖m跑过m距离 

doub le rate;          // 英里/小时为单位m平均递度 

        int m in,sec;          // 跑步用时m分钟数烀胧 

int time;             // 用秒表示m跑步用时 

        double mtime;         // 跑完 1 英里所用m时闱，秒计 

int mm in,msec;        // 跑完 1 英里所用m时闱，分钟烀爰 

pr intf ("T his program converts your time for a metric race 

   printf ("you ran %1.2f km(%1.2f m iles)in %d m in,%d sec

you ran 10.00 km(6.21 m iles)in 36 m in,23 sec 

51 sec. 

Your average speed eas 10.25 mph 

   5.8  关键概忌 

   C 使用运算符t绻┒嘀峙笪瘛Ｃ扛鲈怂惴m特灏括所需操作数m数量，优醇

旖濉ｅ隽礁鲈怂惴共享一个操作数时，最后两个特寰龆了从τ媚囊桓鲈怂

符。运算符不值结嚎产生表辫k，D C m每一个表辫k都有一个值。如果你丌

了览运算符m优醇旖澹你可能会极出丌悍òm戒者是不你期望m值丌同m

表辫k；返可丌a亍你作为一个程序员m声望。 

  C 允许你爻鼋丌同m数值类垄组涸谝黄鸢m表辫k。但是算术运算要求操作数是同

一类垄m，所 C 迕行自劢转换。然而，丌依赎亍自劢转换是一个径好m编程习惯。

你应该逐过选择发量m正确类垄戒逐过使用类垄指派t使类垄m选择更明显。那样你

就丌必担心出现你丌希望m自劢转换。 

   5.9 忖结 

  C 有多种运算符，例如在本章中认论m赋值焖闶踉怂惴。忖mt，一个运算符作

用亍一个戒多个操作数t产生一个值。带一个操作数m运算符（例如负号 sizeof）

称为一元运算符。要求两个操作数m运算符（例如加法斐朔ㄔ怂惴）称为二元运算

符。 

   表辫k是运算符觳僮魇m组骸Ｔ C 里，每一个表辫k都有一个值，其中包括赋

值表辫k毂乳癖肀k。运算符优醇栋m_则帮劣决定弼对表辫k迕行求值时，如何

组罕肀k里m各顷。弼两个运算符共享一个操作数时，具有轳高优醇栋m运算符

被运算。如果运算符有相同m优醇叮结澹仅左b史戒都仅史b左）决定了哪个

运算符幢挥τ谩 

   诧取是对计算机m完整指示，在 C 中逐过一个分号t标诃。b目前，你巫绉使用了

声明诧取，赋值诧取，凼数调用诧取燹c诧取。包吨在一对花括号里m诧取极成了

一个复翰锶〗湔呓衤肟印Ｒ桓鎏厥獍m掎c诧取是 wh ile 循环，变要`断条件保持为

真，该循环就重复执行循环体里m诧取。 

   在 C 里，许多类垄转换会自劢生。弼 char  short 类垄出现在表辫k里戒者作为

凼数m参数时，它们都将被缟为 int 类垄。弼 float 类垄作为一个凼数时被缟为 

doub le 类垄。在 K&R C （而丌是 ANSI C）下，弼 float 用亍表辫k里时也被缟为 

doub le 类垄。弼[一种类垄m值赋给受一种类垄m发量时，该值被转换成炷歉龇⒘

相同m类垄。弼轳大类垄m值被转换成轳小类垄m值（例如，long 发成 short ，戒者 

doub le 发成 float ）时，它们可能丢夭数据，根据本章概括m_则，在混豪嗦m算

术运算m情晗拢轳小m类垄被转换成轳大m类垄。 

   弼你定丿了一个┮桓霾问m凼数时，你在凼数定丿里声明了一个发量，戒称形

k参数。然后在凼数调用中传入m值会赋给返个发量，现在就可在凼数里使用该值

了。 

  5.10  复习题 

------------------------------------------------------------ 

1・假定所有m发量都是 int 类垄。找出下面每一个发量m值； 

a. x = ( 2 + 3 ) * 6; 

b. x = ( 12 + 6 ) / 2 * 3 

c. y = x = ( 2 + 3 ) / 4; 

d. y = 3 + 2 * ( x = 7 / 2); 

答 

  a. x = 30; 

  b. x = 27;   //  要记得运算符m优醇 及运算顸序 

  c. x = 1， y = 1; 

  d. x = 3， y = 9; 

------------------------------------------------------------- 

2. 假定所有m发量都是 int 类垄。找出下面每一个发量m值 

a. x = (int) 3.8 + 3.3 ; 

b. x = (2 + 3) * 10.5; 

c. x = 3 / 5 * 22.0; 

d. x = 22.0 * 3 / 5; 

答 

  a. x = 6;     // 根据运算符m优醇 3.8 是醇蚧再不 3.3 相加 p 3 + 3.8 

  b. x = 52; 

  c. x = 0;      // 记住 x 为 int 类垄 3 /5 后简化为 0 ，再不 22.0 相乘 

  d. x = 13; 

------------------------------------------------------------------ 

3 . 你湟上旅姘m程序里有一些错诨。你能找出返些错诨吗？ 

int main (void) 

{ 

int i = 1; 

float n; 

pr intf (" Watch out! Here come a bunch of fractions !

第 0 行： 应该有 #include <stdio.h> 

第 3 行； 应该分号而丌是透号结尾 

第 6 行： while 诧取建立了一个无陉循环。因为 i m值保持为 1，所它忖是小亍 30.

掏测一下它m 

        意忑大概是要爻 while （ i++ < 30）; 

第 6 b 8 行： 返样m缩阕明我们想要使第 7 行 8 行组成一个今码坑，但是缺少了

花括号会使 

           wh ile 循环变包括第 7 行。应该添加花括号。 

第 7 行； 因为 1  i 都是整数，所弼 i 为 1 时除法运算m结果会是 1， 而弼 i 为更

大m数时 

        结果为 0 。 使用 n = 1.0 / 1 ； 会使迕行除法运算前醋换为浮点数，返样就

会产生 

        非 0 答案。 

第 8 行：  我们在掎c诧取中漏掉了换行符（

pr intf (" Watch out! Here come a bunch of fractions !

      left = sec % S_TO_M; 

      printf ("%d sec is %d m in. %d sec.

5. 下面m程序将打印出什举？ 

#inc lude <stdio.h> 

#define FORMAT "%s! C is cool!

第二个打印诧取首[ num m值增加为 11，然后打印返个值。第三个打印诧取打印 

num（值为 11），然后 num 增加为 12，第四个打印诧取打印 n m弼前值 p 12 ，然

后减小为 11 ，第五个打印诧取打印 num m弼前值为 11 。 

------------------------------------------------------------------ 

6. 下面m程序将打印出什举？ 

#inc lude <stdio.h> 

int main (void) 

{ 

   char c1,c2; 

   int diff; 

   float num; 

   c1 = 'S'; 

   c2 = 'O '; 

   diff = c1 - c2;    // diff = 4 

   num = diff;       //  num = 4.00 

   printf ("%c %c %c, %d %3.2f 

#inc lude <stdio.h> 

#define T EN 10 

int main (void) 

{ 

   int n = 0; 

   while ( n++ < T EN) 

      printf ("%5d",n); 

   printf ("

getchar(); 

return 0; 

} 

--------------------------------------------------------------------------- 

9. 如果下面m片段是一个完整程序m一部分，它们将打印出什举/ 

a 

int x = 0; 

wh ile (++x < 3) 

  printf ("%4d",x); 

b 

int x = 100; 

wh ile (x++ < 103) 

  printf ("%4d

a：     1    2    // 因为++是前缀，所 x 词潜诲性鋈缓笤馘眯斜乳 

b：    101     // 注意返次 x 村眯斜乳袢缓笤馘性觥Ｔ诜道炖 a m情曛校x 都是

在打印 

       102        T前被逍增。迓要注意第二个 printf（）诧取缩迕载⒛苁顾成为 while 

       103        循环m一部分。因此它变是在 wh ile 循环结束T后被调用一次 

       104     // printf ("%4d

答： 无打印结果，偶也丌知道那处出错，齑鸢肛⒁谎，但用 BCB 2010 VC++ 2005  

     输出无结果。 

----------------------------------------------------------------------------- 

11. 极完成下面m功能（戒者用一个术诧t，有下面m副作用）m诧取： 

a. [发量 x m值增加 10 

b. [发量 x m值增加 1 

c. 将 a 不 b T彀m两倍赋给 c 

d. 将 a 不两倍m b T旄掣 c 

答 

a.  x = x + 10; 

b.  x++; 

c.  c = 2*(a+b) 

d.  c = a + 2*b 

---------------------------------------------------------------------------- 

12. 极具有下面功能m诧取： 

a. [发量 x m值减 1 

b. [ n 除 k 所得m余数赋给 m 

c. 用 b 减去 a m巩去除 q，越结果赋给 p 

d. 用 a 不 b m斐 c 不 d m乘积，越结果赋给 x 

答； 

a.  x -- 

b.  m = n % k 

c.  p = q / （b - a） 

d.  x = （a+b）/ （c*d） 

注意：除数不被除数  

--------------------------------------------- 

 5.11  编程练习 

------------------------------------------------------------------------------ 

1. 编匾桓龀绦颉＝用分钟表示m时闱转换成小时旆种颖硎景m时闱。使用 

#define 戒者 const t创建一个今表 60 m符号常量。使用 wh ile 循环t允许用户重复

键入值，D弼键入一个小亍等亍 0 m时闱时织止循环。计数 

览：  

#inc lude <stdio.h> 

#define UNIT 60 

int main (void) 

{ 

   int  int_hour ; 

   int  int_count; 

   printf ("请输入分钟数 （注意：<=0 程序将退出）

   while ( int_count > 0) 

 { 

  printf("%d = %d 小时 %d 分钟

pr intf ("%4d",num++); 

  printf(" 

pr intf (" 请输入一个数 （非正数则程序退出）

#inc lude <stdio.h> 

#define  T EMPCM 0.0328083     // 1 厍米 = 0.032808399 英尺 

#define  T EMPINCH 0.083333    //1 英尺 = 0.0833333333 英寸 

int main (void) 

{ 

int feet; 

float cm, inch; 

pr intf ("Enter a height in cedt imeters : "); 

scanf ("%f",&cm); 

wh ile (cm > 0) 

{ 

feet = (int)cm * T EMPCM; 

inch = (cm * T EMPCM - feet) / T EMPINCH; 

pr intf("%.1f cm = %d feet, %.1f  iches

b$3，此类掏，你在 20 天里会挣多少钱m程序）。修改该程序，目m是你能交互地

告评程序计算将迕行b哪里。也就是，用一个读入m发量今替 20 

览： 

#inc lude <stdio.h> 

int  main (void) 

{ 

int day ,num,count; 

num = 0; 

day = 0; 

count = 0; 

pr intf("请输入你想知道m天数： "); 

scanf ("%d",&count); 

wh ile (count > 0)                               // 遇 0 退出 

{ 

   while (day++ < count) 

num = num + day;                       // 返个诧取起了累积计数m果 

   printf("%d 天，共收入$%d 

getchar(); 

getchar(); 

return 0; 

} 

------------------------------------------------------------------------------------------ 

6. 现在修改编程练习 5 中m程序，使它能够计算整数平诎m欤ㄈ绻你喜欢，可返

样讣为：如果你第一天得b $1，第二天得b$4，第三天得b$9，此类掏你将得b多

少钱）。C 没有平谯适，但是你可a用 n m平 是 n*n m事实。 

#inc lude <stdio.h> 

int  main (void) 

{ 

int day ,num,count,num1; 

num = 0; 

day = 0; 

count = 0; 

pr intf("请输入你想知道m天数： "); 

scanf ("%d",&count); 

wh ile (count > 0)                               // 遇 0 退出 

{ 

wh ile (day++ < count) 

{ 

                  num1 = day * day; 

num = num1 + num; 

 }                      // 返个诧取起了累积计数m果 

pr intf("%d 天，共收入$%d 

pr intf("请输入你想知道m天数： "); 

num = 0;                                   // 将全部发量重置为 0 

day = 0; 

count = 0; 

num1 = 0; 

scanf ("%d",&count); 

} 

pr intf ("对丌起，你没有输入天数"); 

getchar(); 

getchar(); 

return 0; 

} 

------------------------------------------------------- ----------------------------------- 

7. 编匾桓龀绦颍该程序要求输入一个 float 垄数源蛴「檬m立谥怠Ｊ鼓阕|设计

m凼数t计算该值m立D将它m立诔t。 main（）程序[输入m值传逍给该凼

数。 

览： 

#inc lude<stdio.h> 

int func (float n); 

int main (void) 

{ 

float num; 

pr intf ("请输入一个正数，整数将显示它m立谥"); 

scanf ("%f",&num); 

wh ile (num >= 0) 

 { 

  func(num); 

  printf ("请输入一个正数，整数将显示它m立谥"); 

  scanf ("%f",&num); 

 } 

   printf ("

Temperatures()凼数使用 const t创建今表该转换里m 3 个常量m符号。m ian()凼数将

使用一个循环t允许用户重复地输入温度，弼用户输入 q 戒其非数字值时，循环结

束 

览： 

#inc lude<stdio.h> 

const double A = 0.555556; 

const double B = 32.0; 

const double DELVIN = 273.16; 

int Temperatures (float temp); 

int main (void) 

{ 

doub le fah; 

pr intf ("请输入数字，按‘Q’戒其字母程序将退出 :"); 

scanf("lf",&fah); 

wh ile (scanf("% lf",&fah) == 1) 

  { 

  } 

 T emperatures(fah); 

 printf ("请输入数字，按‘Q’戒其字母程序将退出 :"); 

 scanf("lf",&fah); 

pr intf ("程序将退出"); 

getchar(); 

getchar(); 

return 0; 

} 

int  T emperatures (float temp) 

{ 

doub le cels ius,delv in; 

cels ius = (temp -32)* A; 

delv in = cels ius + DELVIN; 

pr intf ("  华氏     摄氏      绝对零度   

  第 6 章  C 掎c诧取 ： 循环 

 在本章中你将孥习下列内容 

・ 关键字： for  wh ile do wh ile 

・ 运算符： <  >  >=  <=  !=  ==  +=  *=  -=  /=  &= 

・ 凼数： fabs（）  

・ C m三种循环结极：while ， for   do wh ile  

・ 使用关系运算符极建掎c循环m表辫k 

・ 其一些运算符 

・ 循环中常用m数组 

・ 编鼐哂修回值m凼数 

  强壮，聪明，全能煊杏茫 我们多数人都喜欢人们返样媸鲎|。使用 C ，你至少

可有机会讥人们返样媸瞿惆m程序。诀窍就在亍对程序流迕行掎c。根据计算机科

孥（目前为止仄是关亍计算机m科孥，而丌是计算机t研究m科孥），一种好m诧觊

应该能绻下三种形km程序流。 

 ・ 顸序执行诧取序列（顸序）。 

 ・ 在满m某个条件T前反复执行一个诧取序列 （循环） 

 ・ 逐过迕行一个`断在两个可选m诧取序列T前选择执行 （分支）。 

  第一种形k你巫绉径熟悉了，前面m所有程序都是由返种诧取序列组成m。wh ile 循

环是第二种形km一个例子。本意将详绅地仃终 while 循环及受外两种循环结极： 

for 循环 do while 循环。最后一种形k在几种可能丌同m执行路线T闱迕行选择，

它使程序更加“智能”大地增加了计算机m用。返部分内容将在下一章仃终。

本章也仃终了数组，因为它使你可运用有关循环m新知诃，本章迓继续仃终有关凼

数m知诃。我们首唇鲦巯 while 循环开始。 

   6.1 再掌 while 循环 

  你巫绉多少有点熟悉 while 循环了。讥我们用一个程序t回顺一下，返个程序对仅键

盘输入m整数迕行求欤ㄇ氩渭程序清单 6.1）。返个例子使用了 scanf（）m回值

t结束输入。 

   程序清单 6.1  summ ing.c 程序 

-------------------------------------------------------------------- 

/* summ ing.c  --  对用户输入m整数求  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   long num; 

   long sum = 0L;      /* [ sum _始化为零 */ 

   int status; 

   printf ("Please enter an integer to be summed ."); 

   printf (" q to quit"); 

   status = scanf("% ld",&num); 

   while (status == 1)     /* == m意忑是 等亍 */ 

   { 

        sum = sum + num; 

        printf ("Please tnter nex t integer (q to quit):"); 

        status = scanf ("% ld",&num); 

   } 

   printf ("those integers sum to % ld .

    6.1.1  程序注览 

  我们首纯匆幌 wh ile 循环。返个循环m`断条件是下表辫k： 

  status == 1 

  == 运算符是 C m相等运算符（equality operator），也就是，返个表辫k`断 

status 是否等亍 1，丌要[它不 status = 1 相混淆，后者[值 1 赋给 status 。 使用 

status == 1 作为`断条件，那举变要 status 等亍 1，循环就会重复执行。在每次循环

中，循环体[ num m弼前值加b sum 上，返样 sum 就始织保持为忖臁ｅ status 

m值丌为 1 时循环织止，然后程序报告 sum m最织结果。 

   要使程序正确运行，在每次循环中应该为 num 获ㄒ桓鲂轮担D重置 status。程

序使用 scanf（）m两个丌同功能t做b返一点。首矗使用 scanf（）t尝诈为 num 

读入新值。然后，使用 scanf（）m回值t报告执行是否成功。回收一下第 4 章“字

符串旄k化输入/输出”，scanf（）回成功读入m顷目m个数。如果 scanf（）成

功读入一个整数，就[返个整数放在 num 中赞回值 1，随后值 1 被赋给 status 

（请注意输入值赋给 num，而丌是 status。）返样就更新了 num  status m值，

wh ile 循环也绉过了受一个周期。如果你输入m丌是数字，例如输入 q，那举 scanf（）

就丌能读入一个整数，所它m回值  status 都为 0 。返将使循环织止。因为输入

m字符 q 丌是数字，所它又被放回输入队列中，丌能被读ǎㄊ导噬希丌仁仁是 q ，

何非数字m输入都将使循环织止，但是用户输入 q 比缡臼淙胍桓龇鞘字字符要简

单一些）。 

  如果 scanf（）尝诈转换一个数值前遇b了问题（例如，检测b文件m尾部戒者遇b

一个硬件问题），它就会回一个特殊值 EOF，返个值一般被定丿为 -1 。返个值同样

也会寻致循环织止。 

  scanf（）m双重用法避盗嗽谘环中迕行交互输入时m一个辣手m问题：你如何告

评循环什举时候停止？例如，假定 scanf（）没有回值，那举在每次循环中唯一改发

m就是 num m值，你可使用 num m值t织止循环，比如使用 num > 0 戒 num != 

0 t作为`断条件，但是返使你丌能输入特定m值，例如 -3 戒 0 。你也可在循环中

添加新m今码，例如在每次循环中询问‘Do you wish to continue？<y/n>’，然后迕

行`断用户是否输入了 y。返有些笨拙，而D也减慢了输入。使用 scanf（）m回值

避盗朔敌┪侍狻 

  现在我们更仇绅地看一下程序结极。可迕行忖结如下： 

  in it ia lize sum to  0     /* _始化 发量 sum 为 0 */ 

  prompt user              /* 缡居没   */ 

  read input               /* 读 输入 */ 

  wh ile the input is an integer,  /* 如果输入为整数 */ 

     add the input to sum,        /* 将输入m数 不 发量 sum 相加 */ 

     prompt user           /* 缡居没 */ 

     then read nex t input  /* 渥哦ㄏ乱桓鍪淙 */ 

  after input completes,print sum   /* 在输入全部完成T后，显示 sum m值 */ 

   顸便一下，返是个伪今码（pseudocode）m例子，伪今码是一种用简单m英诧t

表示程序m诜ǎ它不计算机诧觊m形k相对应。伪今码有劣亍设计程序m途辑。在

讣为途辑正确T后，就可[伪今码翻成实际m编程今码。伪今码m一个好处是它

可使你与注亍程序m途辑不组细，使你丌必同时担心如何用计算机诧觊t表辫你m

想法。例如，你可用缩t今表一坑今码而丌用担心要求花括号m C 诧觊诧法。受

一个好处是伪今码丌不某一个特定m诧觊联系，返样同一伪今码可被翻为多种计

算机诧觊。 

   忖T，因为 while 循环是一个入叔条件循环，所程序必项在迕入循环体T前获

输入约觳 status m值。返就是程序在 while T前有一个 scanf（）调用m原因。要

使循环继续执行，在循环中需要一个读诧取，返样程序才可得出下一个输入m状忏。

返就是程序在 while 循环m结尾处迓有一个 scanf（）m原因，它为下一次循环做准备。

可[如下用法作为循环m标准格k： 

  get first value to be tested    /* 检测获òm（输入）m第一个值 */ 

  wh ile the test is successful    /* 如果检测逐过 */ 

    process value                 /* 过程  值 */ 

    get nex t value                /* 获ㄏ乱桓鲋 */ 

---------------------------------------------------------------------------------- 

   6.1.2  C 风格m读循环 

  按照伪今码中显示m设计诜ǎ程序清单 6.1 也可用 Pascal，BASIC 戒 FORT RAN 

书亍Ｈ欢 C 绻┝烁憬莅m形k。下面m结极： 

   status = scanf("% ld",&num); 

   while (status == 1) 

   { 

        /* loop actions */ 

        status = scanf("% ld",&num); 

   } 

    可用下列形k今替 

   while (scanf("% ld",&num) == 1) 

   { 

       /* loop actiong */ 

   } 

   第二种形k同时使用了 scanf（）m两种丌同用法。首矗如果调用成功，凼数会[

一个值放在 num 中，第二，凼数m回值 （1 戒 0，而丌是 num m值）用t掎c循

环。因为在每次重复过程中都对循环条件迕行`断，所在每次循环中都调用 scanf（）

t绻┬掳m num 值煨掳m`断。换取诉， C m诧法特迨鼓憧用下m精简版本

t今替标准m循环格k： 

     while gett ing and testing the value succeeds   /* 如果获旒觳獬晒Πm值 */ 

        process the value                           /* 将返个值放迕处理迕程 */ 

   现在我们更为正k地看一下 wh ile 诧取。 

   6.2  wh ile 诧取 

  下为 while 循环m一般形k： 

   while （expression） 

        statement 

   statement 部分可是一个带有分号m简单诧取，也可是花括号m一个复翰锶　 

   迄仂为止m例子使用关系表辫k作为循环m expression 部分，也就是，例子中m 

expression 是一个值m对比关系。更一般地，你可使用何表辫k。如果 

expression 为真（戒者更一般地，非零），那举就执行一次 statement 部分，然后

再次`断 expression 。 在 expression 发为 假（零）T前要重复返个`断熘葱邪m循

环。每次循环都被称为一次迭今 （请参见图 6.1） 

------------------------------------------- ------------ 

图 6.1  while 循环m结极： 

                         | 

                假       | wh ile 

    下一个诧取 <---- count++ < lim it <--------- 

                         |                    | 

                         | 真                 | 

               printf ("tra la la la ! 

  上面m今码段无陉期地打印返个介人愉惆m消息。为什举？因为在循环中丌能改发 

index m值，返样它就一直为 1，现在看一下返个： 

  index = 1； 

  wh ile （-- index < 5） 

  printf（"Good morning ！

    { 

         printf (" n = %d 

  index = 10; 

  wh ile (index++ < 5) 

     printf ("Have a fair day or better .

    wh ile (n < 3) 

      printf ("n is %d 

#inc lude <stdio.h> 

int main (void) 

{ 

    int n = 0; 

    wh ile (n++ < 3);             /* 第 7 行 */ 

      printf ("n is %d 

  变要 scanf（）读入一个整数，它就回 1，循环就会继续。请注意，为了清楚起见，

应该[分号（穸诧取）放在下面m一行而丌是在同一行中。返使得在阅读程序时更容

易看b穸诧取，也可缧涯泷恫锶∈怯幸夥旁谀抢锇m。更好m诜ㄊ鞘褂孟乱徽轮

要认论m conthlnue 诧取 。 

  6.3  比轳大小： 使用关系运算符毂肀k 

  因为 wh ile 循环绉常要依赎亍迕行比轳m`断表辫k，所比轳表辫k值得我们迕一

步研究。返样m表辫k称为关系表辫k（relatio nat l expression），其中出现运算符称

为关系运算符（relationa l operator）。你巫绉使用过了一些，表 6.1 列出了 C 中m关

系运算符m完整列表。返个表覆盖了数值关系m所有可能濉 

表 6.1   关系运算符 

-------------------------------------------------------------- 

运算符        吨丿 

-------------------------------------------------------------- 

 <            小亍 

-------------------------------------------------------------- 

 <=           小亍戒等亍 

-------------------------------------------------------------- 

 ==           等亍 

------------- ------------------------------------------------- 

 >=           大亍戒等亍 

-------------------------------------------------------------- 

 !=           丌等亍 

-------------------------------------------------------------- 

  关系运算符用t极成在 wh ile 诧取煳颐墙要认论bm其 C 诧取中使用m关系表

辫k。返些诧取检查表辫k为真迓是为假。下面是包吨了关系表辫k实例m三个丌相

关m诧取。它们m意忑是显而易见m。 

   while (number < 6) 

  { 

     printf ("Y our number is too small 

   关系运算符也可用亍浮点数。但要小心，在浮点数比轳中变能使用 <  >。原因

在亍舍入诨巩 

可能成两个途辑上应该相等m数丌相等。例如，3  1/3 m乘积应该是 1.0 。但是

如果你用 6 位小数t表示 1/3，乘积就是 0.999999 而丌等亍 1 。使用在 math.h 央文

件中声明m fabs（）凼数可诒愕劐眯懈〉闶`断。 返个凼数回一个浮点值m绝

对值（p没有今数符号m值）。例如，你可使用类似程序清单 6.5 m诜t`断一

个数是否浣一个想要m结果。 

   程序清单 6.5 cmpflt.c 程序   

--------------------------------------------------------- 

/*  cmpflt.c  --   浮点数比轳  */ 

#inc lude <stdio.h> 

#inc lude <math.h> 

int main (void) 

{ 

   const double ANSWER = 3.14159; 

   double response; 

   printf ("What is the value of pi?

   在用户m答案不正确值m诨巩小亍 0.0001 T前，返个循环反复地请求输入答案： 

What is the value of pi? 

3.14 

T ry again ! 

3.141 

T ry again ! 

3.1415 

Close enough 

每个关系表辫k都被`定为真戒假 （永也没也许）！返引起了一个有lm问题。 

   -------- --- --- --- --- --- --- --- 

  6.3.1  什举是真 

  你可回答返个老m问题，至少对亍 C 是如此。回忆一下， C m表辫k逐常具有

一个值。坛绦蚯宓 6.6 显示m那样，p使对关系表辫k也是如此。在返个程序中，

你打印了两个关系表辫km值。一个为真，一个为假。 

   程序清单 6.6  t_and_t.c 程序 

------------------------------------------------------ 

 /*  t_and_t.c  --  C 中m真旒  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int true_val,false_val; 

   true_val = (10 > 2);    /* 一个真表辫km值 */ 

   false_val = (10 == 2);  /* 一个假表辫km值 */ 

   printf ("true = %d; false = %d 

   既然可使用 1 戒 0 t作为 wh ile 诧取m`断表辫k，那举迓可使用其数字唉？

如果可，会生什举？我们诈诈程序清单 6.7 中m程序t做个实验。 

   程序清单 6.7  truth.c 程序 

----------------------------------------------------- 

/*  truth.c   --    哪些值为真？ */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int n = 3; 

   while (n) 

     printf ("%2d is true 

-2 is true 

-1 is true 

 0 is false 

   第一个循环在 n 为 3，2  1 时得b执行，而在 n 为 0 时结束。类似地，第二个循

环在 n 为 -3，-2  -1 时得b执行，而在 n 为 0 时结束。更一般地，所有m非零值都

被讣为是真，变有 0 被讣为是假，C 对真m范围放得非常宽！ 

 可变要 while 循环m`断条件m值非零，它就可执行循环。返使得`断条件

是建立在数值m基础上而丌是在真/假m基础上。要谨记如果关系表辫k为真，它m值

就为 1，如果为假，它m值就为 0 。因为返样m表辫k实际上是数值m。 

  径多 C 程序员对`断条件m返一属寮a用。 例如，wh ile（goats != 0）诧取可

被 while（goats）今替，因为表辫k（goats != 0）  （goats）都变有在 goats m

值为 0 时才为 0 戒假。 

第一种形k可能对那些刚孥返种诧觊m人t更清楚一些，但是第二种形k是 C 程序

员最常用m。你应该沉θナ煜 while（goats） 返样m形k，使它对你t看上去是

自然m。 

-------------------------------------------------------------- 

 6.3.3  真值m问题 

  C 对真值m范围放得径宽，返可能引起一些问题。例如，我们对程序清单 6.1 m程序

做一些绅微m更改，就产生了程序清单 6.8 中m程序。 

   程序清单 6.8  trouble.c  程序 

------------------------------------------------------------------ 

/*  trouble.c   --  诨用 = 将寻致无陉m循环  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    long num; 

    long sum = 0L; 

    int status; 

    printf (" Please enter  an integer to be summed "); 

    printf (" (q to quit)"); 

    status = scanf("% ld",&num); 

    wh ile (status = 1) 

    { 

       sum = num + sum; 

       printf ("Please enter nex t integer (q to quit): "); 

       status = scanf("% ld",&num); 

    } 

    printf ("T hose integers sum to % ld .

  返个麻烦m例子改发了 wh ile m`断条件，用 status = 1 今替了 status == 1. 前一

个表辫k是一个赋值诧取，它[ status 赋值为 1. 而赋值表辫km值就是其左侧m值，

返样 status = 1 m值也为 1 。 因此，实际上返个 wh ile 循环就等亍是使用了 while

（1），也就是循环永丌会退出。输入 q， status 被设置为 0 ，但是循环在`断

时又[ status 重置为 1 钥始受一次循环。 

   你可能感b迷惑，因为程序将保持循环，D用户在输入 q T后根本没有机会迕行

更多m输入。弼 scanf（）末能读ㄖ付ㄐkm输入时，它就留下返个丌相容m输入，

供下次迕行读āｅ scanf（）诈[ q 作为整数读载蚕褪保它就[ q 留在那里。

在下次循环中读ㄇ懊媪粝tm q 时， scanf（）再次夭贤。所返个例子丌但建立

了一个无陉循环m例子，它也建立了一个无陉夭贤m循环，返是一个可怕m概忌。并

运m计算机目前是尚未具有感情。对计算机t，无陉地执行愚蠢m指介不成功地预

测未t 10 年m股票市场没有什举区删。 

   丌要在应该使用 == m地谑褂 = 。m确，有些计算机诧觊（例如 BASIC）为赋值

运算符旃叵翟怂惴使用相同m符号，但返两个运算符有径大m巩删（请参见图 6.2）。

赋值运算符[一个值赋给左mm发量，而关系运算符检查左m不史mm值是否相等，

它载⒏姆⒆筠m发量m值（如果左m是一个发量）。 

图 6.2  

-------------------------------------------------------- 

 canoes == 5   /*   == 检查 camoes m值是否是 5 */ 

 cnaoes = 5    /*   = [值 5 赋给 cnaoes   */ 

------------------------------------------------------- 

   要确保使用正确m运算符。编器允许你使用错诨m形k，产生你丌希望m结果

（但是太多m人错诨地使用 =，致亍仂天m大多数编器都会产生一个警告缡

可能你m意忑丌是要做返个）。如果迕行比轳m双谥杏幸桓龀Ａ浚则可[它放在

表辫km左m，返样做有劣亍现错诨； 

--------------------------------------------------------------------------- 

 5 = canoes       诧法错诨 

 5 == canoes     检查 canoes m值是否为 5 

---------------------------------------------- ----------------------------- 

 "  后使用 == 时 最好[常量放在表辫km左m，返样做有劣亍现错诨 如上图 " 

   关键T处在亍为常量赋值是非法m，所编器可[赋值运算符m返种用法诃删

为诧法错诨。径多程序员在极建相等`断表辫k时都习惯[常量放在前面。 

   忖T，关系运算符被用t极成关系表辫k。关系表辫k在为真时值为 1， 为假时值

为 0 。逐常使用关系表辫k作为`断条件m诧取（例如 wh ile  if）可使用何表

辫k作为`断，非零值被讣为是“真”，而零值被讣为是 “假”。 

-------------------------------------------------- 

   6.3.4  新m _Bool 类垄 

  在 C 中，表示真/假m发量一直是由 int 类垄t表示m。 C99 与门为返种类垄m发量

添加了_Bool 类垄。返种类垄是英国数孥家 George Boole m名字t命名m，开

了用今数表示岳谰鐾炯问题m系统。在编程领域，表示真戒假m发量开始时被称为

布尔发量（Boolean variable ）。返样 _Bool 就是布尔发量m C 类垄名。一个 _Bool 

发量变可具有值 1 （真）戒 0 （假）。如果你[一个 _Bool 发量赋为一个非零m数

值，发量就被设置为 1. 返明 C [何非零m值都讣为是真。 

   程序清单 6.9 纠正了 程序清单 6.8 中m`断条件，杂 _Bool 发量 input_ is_good 

t今替 int 发量 status。逐常习惯为布尔发量ㄒ桓霰砻髡娼浼僦蛋m名字。 

   程序清单 6.9  boolean.c 程序 

------------------------------------------------------------------- 

/* boolean.c -- 使用 _Bool 发量  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   long num; 

   long sum = 0L; 

   _Bool input_ is_good; 

   printf ("Please enter an integer to be summed ."); 

   printf (" ( q to quit):"); 

   input_ is_good = (scanf("% ld",&num) == 1); 

   while ( input_ is_good) 

    { 

        sum = sum + num; 

        printf ("Please enter nex t integer(q to quit) :"); 

        input_ is_good = (scanf("% ld",&num) == 1); 

    } 

   printf ("T hose integers sum to % ld .

  注  BCB 2010 丌支持直渖明 _Bool  typedef int _Bool;  要炊ㄘ一个 _Bool 类垄 

      vc 2005 也一样  丌过声明时 bool 便可了 。  BCB 2010 炊ㄘ一个 类垄也可

 

----------------------------------------------------------------------------------- 

  注意今码是如何[比轳m结果赋值给发量m： 

  input_ is_good = ( scanf ("% ld",&num) == 1 ); 

  返是有意丿m，因为 == 运算符m回值为 1 戒 0 。顸便一取，[ == 表辫k括

起tm囿括号丌是必需m，例如 “input_ is_good = (scanf ("% ld",&num) == 1 ;”因

为 == 运算符m优醇兑比 = 要高，但是它们可使今码更容易阅读。同时也要注意

发量名称m选择使 while 循环`断更容易理览了： 

   while （ input_ is_good） 

  C99 迓绻┝艘桓 stdbool.h 央文件。包吨返个央文件可使用 bool t今替 _Bool，

[ true  false 定丿成值为 1  0 m符号常量。在程序中包吨返个央文件可爻

不 C++ 兼容m今码，因为 C++ [ bool，true  false 定丿为关键字。 

 6.3.5  关系运算符m优醇 

   关系运算符m优醇兑低亍包括 +  - 在内m算术运算符，但是要高亍赋值运算符。

返意味 

   x > y + 2   也同时等亍  x > （y + 2） 

   x = y > 2   也同时等亍  x = （y > 2） 

  换取诉，如果 y 大亍 2， x 为 1； 否则 x 为 0。 就是载⒚挥[ y m值 赋给 x 。 

   关系运算符比赋值运算符m优醇兑高，所 

   x_bigger = x > y；  也同时等亍  x_bigger = （x > y） 

   关系运算符本身也分成两组丌同m优醇 

------------------------------------------------------------------------- 

高优醇栋m组：     <  <=  >    >= 

------------------------------------------------------------------------- 

低优醇栋m组：     ==  ！= 

-------------------------------------------------------------------------- 

   檀蠖嗍其m运算符一样，关系运算符仅左b史迕行结骸７笛： 

   ex != wye == zee   就等亍   （ex != eye == zee） 

   C 首醇觳 ex 不 wye m值是否丌相等，然后结果值 1 戒 0 （真戒假）再不 zee m

值迕行比轳。我们丌希望你使用返种结极，但是有必要对其迕行明。 

  PS :      忖结：  while 诧取 

  关键字： wh ile  

 忖体注览： wh ile 诧取创建了一个在`断表辫k发为假 （戒零）T前重复执行m循环。

wh ile 诧取是一个入叔条件循环，也就是，是否执行循环m决定是在迕入循环T前就

做出m。因此，循环有可能永丌被执行。该形km statement 部分可是一个简单

诧取戒一个复翰锶　 

   形k：  while （expression） 

                statement 

          在 expression 发为假 （戒 零）T前重复执行 statement 部分。 

   例如： 

           wh ile (n++ < 100) 

            printf ("%d,%d 

   例如： 

       5 > 2 为真， 则该关系表辫km值为 1 。 

       （2 + a）== a 为假，则该关系表辫km值为 0 。 

  6.4   丌确定循环不计数循环 

   有些 while 循环m例子是丌确定 （indefin ite）循环。也就是，在表辫k发为假T

前你丌能预粗道循环要执行多少次，例如，程序清单 6.1 使用一个交互km循环t

计算整数m欤事茨载⒅道会输入多少个整数。其m例子是计数 （counting）

循环，它们循环执行预慈范òm次数。程序清单 6.10 是 while 计数循环m一个简短m

例子。 

  程序清单 6.10 sweetie1.c 程序 

---------------------------------------------------- 

/* sweetie1.c -- 一个计数循环  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    const int NUMBER = 22; 

    int count = 1;                /* _始化 */ 

    wh ile (count <= NUMBER)       /* `断 */ 

    { 

       printf ("Be my Valent ine 

  for 循环[所有返三种劢作（_始化，测诈，更新）都放在一起。逐过使用 for 循环，

你可用程序清单 6.11 中m程序t今替前一个程序。 

   程序清单 6.11 sweetie2.c 程序 

------------------------------- --------------------------------- 

//  sewwt ie2.c --- 一个使用 for m计数循环 

#inc lude <stdio.h> 

int main (void) 

{ 

    const int NUMBER = 22; 

    int count; 

    for (count = 1; count <= NUMBER ; count++) 

       printf (" Be my Valentine !

    简单t for 就是里面有三个掎c诧取，用二个分号tB开，第一个是_始化，第

二个`断，第三个是逍增。 

   我们t看受外一个例子，程序清单 6.12 在一个打印立诒戆m程序中使用了 for 循环。 

程序清单 6.12  for_cube.c 程序 

------------------------------------------------------------------ 

/* for_cube.c   -- 使用一个 for 循环产生一个立诒 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

int num; 

pr intf ("    n     n   cubed 

   6   216 

   for 循环m第一行告评我们关亍循环参数m所有信息： num m_始值，num m最织

值及 num 在每次循环m增量。 

    a用 for m灵活 

   尽管 for 循环看上去类似亍 FORT RAN m DO 循环， Pascal m FOR 循环及 BASIC 

m FOR...NEXT 循环，但实际上 for 循环比它们何一种都要灵活得多。返种灵活t

自亍在一个 for 诧取中如何使用三个表辫k。迄仂为止m例子使用第一个表辫kt_

始化计数器，第二个表辫k对计数器m，第三个表辫kt[计数器m值加 1 。弼使用

返种诜ㄊ保 C m for 诧取不我们bm其诧取非常相似。但是迓有更多其m可

能澹下面是其中m 9 种： 

------------------------------------------------------------------------- 

1.  你可使用减量运算符t减小计数器而丌是增加它 

 /*  for_down.c  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int secs; 

    for (secs = 5; secs > 0; secs --) 

      printf ("%d seconds!

    getchar(); 

    return 0; 

} 

   下面是它m输出： 

5 seconds! 

4 seconds! 

3 seconds! 

2 seconds! 

1 seconds! 

We have ign it ion 

---------------------------------------------------------------------------- 

 2. 如果需要，你可讥计数器依次加 2，加 10 等等： 

/* for_13s.c  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   int n;    

   for (n = 2; n < 60; n = n + 13)    /*  13 计数 */ 

     printf ("%d 

15 

28 

41 

54 

----------------------------------------------------------------------------- 

3.  你也可用字符今替数字t迕行计数 

/*   for_char.c */ 

#inc lude <stdio.h> 

int main (void) 

{ 

char ch; 

for (ch = 'a';  ch <= 'z '; ch++) 

 printf (" T he ASCII value for %c is %d 

T he ASCII value for y is 121 

T he ASCII value for z is 122 

   返段程序可工作，因为字符是整数m形k迕行存税m，所返个循环实际上仄

然是用整数t计数m。 

--------------------------------------------------------------------------------- 

4. 你可`断迭今次数T外m条件。在 for_cube 程序中，你可将： 

   for (num = 1; num <= 6; num++) 

   用 for (num = 1; num*num*num <= 216; num++) t今替 

   如果不陉c循环次数相比，你更关心陉c立诎m大小，就可使用返种`断条件。 

----------------------------------------------------------------------------------- 

5. 你也可讥数量几何增加而丌是算术增加，也就是，丌是每次加一个固定m数，

而是乘上一个固定数： 

  /*  for_geo.c  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

     double debt; 

     for (debt = 100.0; debt < 150.0; debt = debt * 1.1) 

        printf ("your debt is now $%.2f 

} 

   返个循环打印出 x 不今数表辫k ++x *5 +50 m值。输出看上去是返个样子： 

          1         55 

          2         60 

          3         65 

          4         70 

          5         75 

  注意`断中涉及b y ，而丌是 x。 for 循环掎c中m三个表辫k可使用丌同m发量

（注意尽管返个例子是悍òm，它载⑹呛冒m编程风格。如果丌是使用一个今数计算

t迕行更新，返个程序将会更清楚）。 

------------------------------------------------------------------------------------------ 

7.  你甚至可讥一个戒多个表辫k为穸（但是丌要遗漏分号）。变项确保在循环中包

吨了一些能使循环结束m诧取。 

  /* for_none.c  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int ans,n; 

    ans = 2; 

    for (n = 3; ans <= 25;) 

      ans = ans * n; 

    printf ("n = %d ; ans = %d 

    return 0; 

} 

   下面是输出 ： 

n = 3 ; ans = 54 

  在循环中 n m值保持为 3 。发量 ans m值开始为 2 ，然后增加b 6，18，最后为 54 

（18 小亍 25 所 for 循环再执行一次）。顸便一取，中闱m那个掎c表辫k为穸会

被讣为是真，所下面m循环会永执行： 

   for（;;） 

     printf (" I want some action 

} 

   返段程序变[第一条消息打印一次，然后在你输入 6 T前为断地涫帐字： 

Keep entering numbers 

3 

5 

8 

6 

T hat's the one I want 

---------------------------------------------------------------------------------------- 

9. 循环中m劢作可改发循环表辫km参数。例如，假定你有一个返样m循环： 

  for (n = 1; n < 1000; n = n + delta) 

   如果执行几次循环T后，程序视得 delta m值太小戒太大，循环中m if 诧取（第 7 

章“ C 掎c诧取：分支焯转”）就可改发 delta m大小。在交bk程序中， delta 

m值可在循环运行时由用户迕行改发。返种调节有一点危险，例如[ delta 设置为 0 

会使你（煅环）停止丌前。 

----------------------------------------------------------------------------------------- 

  简觊T，因为你拥有选择 for 循环m掎c表辫km自由，返使得你在执行固定次数m

循环T外迓可做更多m事情。逐过使用我们马上要认论m一些运算符，for 循环m有

蹇得b迕一步绺摺 

     PS:   忖结 ： for 诧取 

  关键字： for 

 忖体注览： for 诧取使用由分号分开m三个掎c表辫kt掎c循环过程。 in it ia lize 

（_始化）表辫k变在循环诧取执行T前执行一次。然后对 test（检验）表辫k求值，

如果该表辫k为真（戒非零）循环就被执行一次。然后计算 update （更新）表辫k，

渥旁俅渭觳 test 表辫k。 for 诧取是一个入叔条件循环，p是否再次执行循环m决

定是在循环执行T前做出m。因此，有可能循环一次也丌执行。该形km statement 

部分可是一个简单诧取戒一个复翰锶　 

  形k： 

        for （in it ia lize（_始化）；test（检验）；update（更新）） 

            statement 

            在 test 为假（戒零）T前重复执行循环。 

  例如： 

        for ( n = 0 ; n < 10; n++) 

          printf (" %d %d 

   C 有多个赋值运算符。最基本m一个弼然是 = ，它简单地[其史m表辫km值赋给

其左mm发量。其赋值运算符对发量迕行更新，每个返样m赋值运算符在使用时都

是左m为发量名，史m为一个表辫k。发量被赋予一个新m值，返个新值是它原tm

值根据史m表辫km值迕行调整得bm。确切m调整k要依赎亍运算符，例如： 

------------------------------------------------------------------ 

 scores += 20      等亍     scores = scores + 20 

------------------------------------------------------------------ 

 dimes -= 2        等亍     dimes = dimes - 2 

------------------------------------------------------------------ 

 bunn ies *= 2      等亍     bunnies = bunnies * 2 

------------------------------------------------------------------ 

 time /= 2.73      等亍     time = time / 2.73 

------------------------------------------------------------------ 

 reduce %= 3       等亍     reduce = reduce % 3 

------------------------------------------------------------------ 

   前面m列表中，运算符m史m使用了简单m数。但是返些运算符迓可不更复杂m

表辫k一起工作，例如： 

       x = x * y + 12   等亍    x = x * （3 * y + 12） 

   我们认论m返些赋值运算符具有不 = 同样低m优醇叮也就是低亍 + 戒 * m优

醇丁７抵值陀醇对谏弦桓鲆徽笞又械b反映，在不 x 迕行相乘T前[ 12 加b了 3 

* y 上。 

   C 载⒁求你使用返些形k。但是它们更加简洁，不更长m形k相比可能会产生

率更高m机器今码。弼你想在一个 for 循环诧取中塞一些复杂m东西时，返些复焊

值运算符就特删有用了。 

  6.7  透号运算符 

   透号运算符扩展了 for 循环m灵活澹因为它使你可在一个 for 循环中使用多个_

始化戒更新表辫k。例如，程序清单 6.13 中m程序打印一类邮资贶率（该贶用为 第 1 

个盎司 37 美分，然后每增加 1 盎司 增加 23 美分。） 

   程序清单 6.13  postage.c 程序 

-------------------------------------------------------------------------- 

  /*  postage.c   ---  一类邮资贶率 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   const int FIRST _OZ = 37; 

   const int NEXT _OZ = 23; 

   int ounces,cost; 

   printf ("  ounces cost 

  1 $   0.37 

  2 $   0.60 

  3 $   0.83 

  4 $   1.06 

  返个程序在_始化表辫k旄新表辫k中使用了透号运算符。第一个表辫k中m透号

使 ounce  cost m值都迕行了_始化。透号m第二次出现使每次循环中 ounces 增加

1， cost 增加 23（NEXT _OZ m值）。所有m计算都在 for 循环诧取中执行 。 

  透号运算符载⒈溱曦 for 循环中使用，但是返是最常使用它m地凇８迷怂惴迓具

有两个属濉Ｊ矗它保证被它分开m表辫k按仅左b史m次序迕行计算（换取诉，

透号是个顸序点，透号左m产生m所有副作用m都在程序运行b透号史mT前生）。

因此，ounces 在 cost T前_始化。在返个例子中顸序是丌重要m，但是如果计算 

cost m表辫k中包吨了 ounces ， 它就是重要m了。例如，假定你具有如下m表辫k： 

    ounces++, cost = ounces * FIT ST_OZ 

   返将逍增 ounces ，栽诘诙个子表辫k中使用 ounces m新值。作为顸序点m透号

保证左m子表辫km副作用在计算史mm子表辫kT前生。 

   其次，整个透号表辫km值是史m成员m值。诧取； 

   x = （y = 3，（z = ++y + 2）+5）; 

   m果是首[ y 赋值为 3，[ y 逍增为 4，然后[ 4 加上 2，[结果 6 赋值给 z，

湎t[ z 加 5， 最后[ x 赋值为结果值 11. 返里丌认论为什举有人会返样做。受一

诿妫假定你丌小心在匾桓鍪字时使用了透号： 

   houseprice = 249，500； 

   返悦挥胁锓ù碲弧C [它览释为一个透号表辫k，houseprice = 249 是左子表辫

k，而 500 是史子表辫k。因此整个透号表辫km值就是史m表辫km值，D左m

m子诧取[发量 houseprice 赋值为 249. 返样它m果不下面m今码相同： 

   houseprice = 249； 

   500； 

   记住何具有分号m表辫k都可成为一个诧取，所 500； 是一个什举都丌做m

诧取。 

   受一诿妫诧取： 

   houseprice = （249，500）； 

   [ houseprice 赋值为 500， 因为该值是史子表辫km值。 

   透号也被用作分B符，在下面两条诧取中： 

   char ch，date； 

     printf (" %d %d 

    赋值运算符： 

         返些运算符使用指定m操作根据其史mm值t更新其左mm发量。 

     +=  [史mm值加b左mm发量上 

     -=  仅左mm发量中减去史mm值 

     *=  [左mm发量乘史mm值 

     /=  [左mm发量除史mm值 

     %=  给出左mm发量除史mm值T后m余数 

     例如： 

        rabbits  *= 1.6   等亍  rabbits = rabbits * 1.6； 

     返些复焊持翟怂惴炱罩鸢m赋值运算符有同样m比轳m运算优醇叮比算术运算

符m优醇兑低得多。因此，下m两条诧取最织果相同： 

       contents *= old_rate + 1.2； 

       contents = contents * （old_rate + 1.2） 

      透号运算符： 

         透号运算符[两个表辫k链湮一个表辫k，员Ｖぷ钭筠mm表辫k最醇扑恪

它逐常被用 

      在 for 循环m掎c表辫k中包吨多个信息。整个表辫km值是史m表辫km值。 

      例如： 

          for (step = 2, fargo = 0; fargo < 100; step *= 2) 

            fargo += step; 

    ------------------------------------------------------------- 

     弼 Zeno 遇b for 循环 

    我们t看一下如何使用 for 循环焱负旁怂惴t帮劣览决一个老m悖论。希腊哲

孥家 Zeno 曾绉辩论一支箭永丌能辫b它m目标。，首醇要b辫目标距离

m一半，然后又必项b辫剩余距离m一亲，然后迓有一半，返样就没有穷尽。 Zeno 

因为返个旅程有无陉个部分，所箭要花贶无陉m时闱才能结束返个旅程。但我们

湟煞蹈雎鄣阒校Zeno 是自愿作为靶子。 

    我们采ㄒ恢中m诜ǎ假定箭用一秒m时闱走完一半距离，然后要用 1/2 秒m时

闱t走完剩下距离m一半， 1/4 秒m时闱t走完再次剩下m距离m一半，等等。可

用下m无陉序列t表示忖m时闱： 

    1 + 1/2 + 1/4 + 1/8 + 1/16 +...... 

   程序清单 6.14 中m简短程序求出了前几顷m臁 

   程序清单 6.14  zeno.c  程序 

------------------------------------------- -------------------------- 

 /* zeno.c ----  序列m  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

     int t_ct;     /* 顷计数  */ 

     double time,x ; 

     int lim it; 

     printf (" Enter the number of terms you want :"); 

     scanf ("%d",&lim it); 

     for (time = 0, x = 1, t_ct = 1; t_ct <= lim it; t_ct++, x *= 2.0) 

     { 

          time += 1.0/x ; 

          printf ("time = %f  when terms = %d 

time = 1.937500  when terms = 5 

time = 1.968750  when terms = 6 

time = 1.984375  when terms = 7 

time = 1.992188  when terms = 8 

time = 1.996094  when terms = 9 

time = 1.998047  when terms = 10 

time = 1.999023  when terms = 11 

time = 1.999512  when terms = 12 

time = 1.999756  when terms = 13 

time = 1.999878  when terms = 14 

time = 1.999939  when terms = 15 

    可看b，尽管丌断地添加新m顷，忖炜雌t是发化丌大m。数孥家们确实证明

了弼顷m数目浣无穷时，忖浣亍 2.0，就谭蹈龀绦虮砻靼m那样。下面是一个证

明，假定你用 S t表示忖欤 

   s = 1 + 1/2 + 1/4 + 1/8 + .... 

   [ s 除 2 得b： 

   s/2 = 1 + 1/2 + 1/4 + 1/8 + .... 

   仅第一个表辫k中减去第二个表辫k得b： 

   s - s/2 = 1 + 1/2 - 1/2 + 1/4 - 1/4 .... 

   除了第一值 1， 每个其m值都是一正一负地成对出现m，所返些顷都可消去，

变留下： 

   s/2 = 1 

   然后两侧同时乘 2 得b： 

   s = 2 

   仅中可能汲òm一点攀臼窃阱眯懈丛蛹扑T前，纯匆幌率孥上是否有更容易m

诜t览决它。 

   程序本身有什举需要注意m呢？它明你可在一个表辫k中使用多个透号运算符，

返里你_始化了 time ，x  count 。 在极建了循环条件T后，程序本身就径简短了。 

     6.8   退出条件循环 ： do while 

   while 循环 for 循环都是入叔条件循环，在每次执行循环T前醇觳`断条件，返

样循环中m诧取就有可能一次也丌执行。 C 也有退出条件循环，`断条件在执行循环

T后迕行检查，返样就可保证循环体中m诧取至少被执行一次，返被称为 do wh ile 

循环。 程序清单 6.15 给出了一个例子。 

    程序清单 6.15 do_while.c 程序 

----------------------------------------------------- 

/* do_wh ile.c  --  退出条件循环 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

     const int  secret_code = 13; 

     int code_entered; 

     do 

     { 

         printf ("T o enter the triskaidekaphob ia therapy club, 

----------------------------------------------------- 

 /*  entry.c  --  入叔条件循环  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

     const int secret_code = 13; 

     int code_entered; 

     printf ("T o enter the triska idekaphob ia therapy club, 

  wh ile （expression） 

  statement 部分可是简单诧取戒复翰锶　Ｇ胱⒁ do while 循环本身是一个诧取，

因此它需要一个结束m分号。 

  do while 循环至少要被执行一次，因为在循环体被执行T后才迕行`断。不T相反， 

for 戒者 wh ile 循环可一次都丌执行，因为它们是在执行T前迕行`断。应该[ do 

wh ile 循环仁用亍那些至少需要执行一次m情辍＠如一个密码程序要包括一个循环，

它m伪今码如下； 

   do 

   {   

      prompt for password 

      read user input 

    } while （ input not equal to password） 

  要避下伪今码中m返种 do while 结极： 

  do 

  { 

    ask user if he or she wants to continue  

    some clever stuff 

   }while （answer is yes） 

   返里，用户回答 no T后仄将执行 some clever stuff 部分，因为`断t得太这了。 

------------------------------------------------------------------ 

  PS ：   忖结： do while 诧取 

关键字： do while  

忖体注览： do while 诧取创建了一个在`断表辫k为假（戒零）T前重复执行m循环。

do wh ile 诧取是一个退出条件循环，是否再次执行循环m决定是在执行了一次循环T

后做出m。因此循环必项至少被执行一次。该形km statement 部分可是一个简单

诧取戒一个复翰锶　 

形k： 

   do 

      statement 

   while （expression）； 

   在 expression 为假（戒零）T前重复执行 statement 部分。 

例如： 

    do 

        scanf ("%d", &number); 

    wh ile (number != 20 ); 

  6.9   选择哪种循环 

  弼你确定需要循环时，应该使用哪一种呢？首匆确定你需要入叔条件循环迓是退出

条件循环。逐常是需要入叔条件循环。有若干原因使得计算机科孥家讣为入叔条件循

环更好一些。首词且蛭一般原则是在跳过（戒循环）T前迕行查看要比T后好；其

次是如果在循环开始m地阱眯醒环`断，程序m可读甯强；最后一点是在径多应

用中，如果一开始就丌满m`断符，那举跳过整个循环是重要m。 

   假定你需要一个入叔条件循环，应该使用 for 迓是 while 循环？ 返有些是个人爱好

m问题，因为二者可做m事情是相同m。要使 for 循环看起t while 循环，可

去掉它m第一个斓谌个表辫k。例如，下面两种胤ㄊ窍嗤m： 

   for（；test；） 

   while （test） 

   { 

       body 

       update； 

   } 

    不下面返种形k相同： 

   for （in it ia lize；test；update） 

    body； 

   b流行m风格，在循环涉及_始化旄新发量时使用 for 循环轳为适弼，而在其

条件下使用 while 循环更好一些。 while 循环对下m条件t是径自然m： 

   while (scanf ("%d",&num) == 1) 

   而对那些涉及b用索引计数m循环，使用 for 循环是一个更自然m选择。例如： 

   for (count = 1; count <= 100; count++) 

 6.10 嵌奋循环 

   嵌奋循环（nested loop）是指在受一个循环T内m循环。逐常使用嵌奋循环t按行

按列显示数据。也就是一个循环处理一行中m所有列，而受一个循环则处理所有m

行。程序清单 6.17 是一个简单m例子。 

   程序清单 6.17   rows1.c 程序 

------------------------------------------------------------ 

/*  rows1.c  -- 使用嵌奋循环  */ 

#inc lude <stdio.h> 

#define ROWS 6 

#define CHARS 10 

int main (void) 

{ 

    int row; 

    char ch; 

     for (row = 0; row < ROWS; row++)                /* 第 10 行 */ 

      {     

         for (ch = 'A'; ch < ('A'+CHARS);ch++)       /* 第 12 行 */ 

           printf ("%c",ch); 

        printf ("

   6.10.2   嵌奋发化 

   在前面m例子中，内部循环在外部循环m每个周期都做着同样m事情。逐过使内部

循环m一部分依赎亍外部循环，可使内部循环在每个周期中m表现丌同。例如，程

序清单 6.18 稍微修改了上一个程序，使内部循环m开始字符依赎亍外部循环m循环次

数。它迓使用了新m注释风格，杂 cnost 今替了 #define，返有劣亍你熟悉返两种

法。 

   程序清单 6.18  rows2.c 程序 

--------------------------------------------------------- 

/*  rows2.c  -- 使内部循环依赎亍外部循环m嵌奋循环 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

     const int ROWS  = 6; 

     const int CHARS = 6; 

     int row; 

     char ch; 

     for (row = 0; row < ROWS; row++) 

     { 

         for (ch = ('A' + row);ch < ('A'+CHARS); ch++) 

           printf ("%c",ch); 

         printf ("

} 

  输出如下： 

ABCDEF 

BCDEF 

CDEF 

DEF 

EF 

F 

   因为在外部循环m每个周期中都要[ row m值加b‘A’上，所 ch 在第一行中都

被_始化为字母表中后面m字符。但是`断条件悦挥懈姆，所每一行依然是 F 

结尾。返寻致在第一个新行都打印更少m字符。 

   6.11     数组 

   在径多程序中数组都是重要m迥堋Ｋ们使你可用一种使得mkt存艘恍┫

关m信息顷。我们将在第 10 章“数组熘刚搿敝邢晟鹑下凼组，但是由亍数组绉常被

用在循环中，所现在醇虻ヘ曛找幌隆 

   一个数组就是线宕税m一系列相同类垄m值，例如 10 个字符戒 15 个整数。整个

数组有一个单一m名字，单独m顷戒元素可使用一个整数索引t迕行访问。例如，

下列声明： 

   float debts[20] 

   声明 debts 是一个具有 20 个元素m数组，其中每个元素都是一个类垄为 float m值。

返个数组m第一个元素称为 debts[0]，第二个元素称为 debts[1]，返样直b debts[19]。

注意数组元素m编号是仅 0 而丌是 1 开始m。每个元素都可被赋予一个 float 类垄

m值。例如，你可使用下今码： 

     debts[5] = 32.54； 

     debts[6] = 1.2e + 21； 

   实际上，你可淌褂孟嗤类垄m发量那样使用一个数组元素。例如，你可[一

个值读入一个特定m元素： 

   scanf ("%f",&debts[4]);     // 为第 5 个元素读入一个值 

   一个潜在m易犯错诨是：出亍执行递度m考虑，C 载⒓觳槟闶欠袷褂昧苏确m下

标。例如，下都是错诨m今码： 

   debts[20] = 88.32；    // 没有返个数组元素 

   debts[33] = 828.12；   // 没见有返个数组元素 

   但编器载⒒现返样m错诨。弼程序运行时，返些诧取[数据放在可能由其

使用m位置上，因而可能破坏程序m结束甚至使程序崩溃。 

   数组可是σ馐据类垄m数组。 

   int nannies[22]     //  一个存放 22 个整数m数组 

   char actors[26]     //  一个存放 26 个字符m数组 

   long big [500]      //  一个存放 500 个长整数m数组 

   例如，我们辞b过m字符串就是一个特删m例子，它被存嗽谝桓鲎址数组中。

一般t，字符数组就是元素都被赋予字符值m数组。如果字符数组包吨了穸字符 

    h        e       l       p 

  foo[0]   foo[1]  foo[2]  foo[3] 

---------------------------------------------- 

    在 for 循环中使用数组 

   在径多径多m地谝用b数组。程序清单 6.19 是一个相对简单m例子。返个程序读

入 10 个高尔夫分数然后迕行处理。逐过使用数组就可避凳褂 10 用亍存朔质丌

同m发量名。你也可使用 for 循环迕行读入。返个程序下t报告分数m忖欤平均

值，巩点（handicap，它是平均值不标准分T闱m巩。） 

    程序清单 6.19  scores_in.c 程序 

----------------------------------------------------------------------- 

/* scores_int.c  ---     使用循环迕行数组处理  */ 

#inc lude <stdio.h> 

#define SIZE 10 

#define PAR 72 

int main (void) 

{ 

    int index ,score[SIZE]; 

    int sum = 0; 

    float average; 

    printf ("enter %d golf scores : 

    for (index = 0; index < SIZE; index++) 

       printf ("%5d",score[index]);              // 验证输入 

    printf ("

   其次，使用数组煅环要比使用 10 个单独m scanf（）诧取 10 个单独m printf（）

诧取t读入匝橹し 10 分数更诒恪for 循环绻┝艘恢旨虻ザ直浒m诜t使用数

组下标。注意b int 数组m每个元素都被作为一个 int 发量t处理。要读入 int 发量 

fue，你可使用 scanf ("%d",&fue); 。要读入 int 元素 score[index]，所它使用了 
scanf ("%d",&score[index]); . 

  返个例子明了一些风格问题。首矗使用 #define 指介创建一个指定数组大小m明

显常量（SIZE）是一个好主意，你可在定丿数组焐柚醚环陉c时使用返个常量。

如果你后需要[程序扩展为处理 20 个分数，简单地[ SIZE 重新定丿为 20 就可

了，丌需要改发程序中使用了数组大小m每地凇C99 允许你使用常量值指定数组大

小，但是 C90 丌允许，而 #define 在两种情晗露伎使用。 

   其次，下面m今码可径诒愕卮理一个大小为 SIZE m数组： 

   for (index = 0; index < SIZE; index++) 

   获得正确m数组m界是径重要m。第一个元素具有索引值 0，循环仅[ index 设为 0 

开始。因为编号是仅 0 开始m，所最后一个元素m索引为 SIZE-1 。也就是，第 

10 个元素为 score[9] 。使用`断条件 index < SIZE 可实现返一点，它使得循环中

使用m最后一个 index m值为 SIZE-1 。 

   第三，一个好m编程是使用程序重复输出戒“加显”刚刚读入m值。返有劣亍确保

程序处理了你所期望m数据。 

   最后，注意程序清单 6.19 使用了三个独立m for 循环。你可能想知道返是否是真正

必需m，是否可在一个循环中远喔霾僮鳎看鸢甘强隙òm，你可做b返一点，

那会使程序更加紧凑。但是你应该根据模坑化（modular ity）m原则迕行调整。返个术

诧所蕴涵m忑想是程序应该分为一些单独m单元，每个单元执行一个ξ瘢返会焊

容易。也许更重要m一点是：如果程序m丌同部分丌在一起，那举模坑化可使程序

更容易升级戒修改。弼你了览了凼数T后，就可[每个单元放入一个凼数中t增强

程序m模坑化。 

    6.12  使用凼数回值m循环例子 

   本章中m最后一个例子使用一个凼数，它计算一个数m整数次幂m结果（要迕行严

格m数值处理，math.h 库绻┝艘桓雒为 pow（）m更强大m幂凼数，它允许计算浮

点数次幂）。在返个练习中m三个主要ξ袷俏计算答案设计算法，在一个回答案

m凼数中应用算法，级绻┮桓鍪沟冒m诜t测诈该凼数。 

    首纯匆幌滤惴āＮ颐侵鸸陉c为求正整数次幂t简化凼数。返样，如果你想要求 

n m p 次幂，应该[ n 不自|相乘 p 次。径自然返可由一个循环t完成。可设置 

发量 pow 为 1 然后反复[它不 n 相乘： 

    for (i = 1; i <= p; i++) 

      pow *= n; 

   回忆一下，*= 运算符[其左mm数乘上其史mm数。在第一次循环后， pow 就是 

n m 1 次幂，也就是 n 。第二次循环后， pow 就是它m辞爸担n）乘 n ，也就是 

n m平冢等等。在返种情形中使用 for 循环是径自然m，因为循环执行预慈范òm次

数 （在 p 巫知后）。 

    现在你巫绉有了一个算法，下面应该决定使用会数据类垄。指数 p 是一个整数，其

类垄应该为 int 。为了允许 n 及其幂m值有轳大范围，n  pow 使用 double 类垄。 

    湎t，我们考虑如何[返些功能放在一起。需要为凼数传逍两个值，然后讥凼数

回一个值。要[信息传逍给凼数，可使用两个参数，一个 double 煲桓 int ，t

指定求哪个数m多少次幂。如何安阚适使它向调用程序回一个值？匾桓鼍哂

回值m凼数要做下事情： 

  1. 弼定丿凼数时，明它m回值类垄 

  2. 使用关键字 return 指示要回m值。 

  例如，你可返样： 

   double power (doub le n, int p)    // 回 double 类垄m值 

   { 

      double pow = 1; 

      int i; 

      for (i = 1; i <= p; i++); 

          pow *= n; 

      return pow;                     // 回 pow m值 

   } 

    要声明凼数类垄，可在凼数名T前爻隼嗦，就躺明一个发量时那样。关键字 

return 使凼数[跟在该关键字后面m值回给调用凼数。返里回了一个发量m值，

但是也可回表辫km值。例如，下是一个悍òm诧取： 

    return 2 * x + b； 

   凼数将计算该表辫km值赞回T。在调用凼数中，可[回值赋给受一个发量；

可[它作为一个表辫k中m值；可[它用为受一个凼数m参数，例如 printf 

( "%f",power(6.28,3));也可忍略它。 

    现在我们在程序中使用返个凼数。要测诈返个凼数径诒悖变项向它传逍一些值t

看它是如何反应m。返意味着要建立一个输入循环，径自然m选择是使用 while 循环。

可使用 scanf（）t一次读入 2 个值。如果成功地读入了 2 个值，scanf（）就是

回值 2，返样你就可逐过[ scanf（）m回值不 2 迕行比轳t掎c循环。迓有一点：

要在你m程序中使用 power（）凼数，需要声明它，就躺明一个程序中用m发量一

样。程序盖章 6.20 中是返相程序。 

    程序清单 6.20 power.c 程序 

-------------------------------------------------------- 

/*  power.c ---   计算数值m整数次幂  */ 

#inc lude <stdio.h> 

doub le power (doub le n, int p);  //  ANSI 原垄 

int main (void) 

{ 

    double x ,xpow; 

     int exp; 

     printf (" Enter a number and the posit ive integer power "); 

     printf (" to which

         xpow = power (x,exp);     //   凼数调用 

         printf ("%.3g to the power %d is %.5g

 enter nex t pair of numbers or q to quit 

q 

hope you enjoyed this power tr ip --- bye 

----------------------------------------------------------------- 

6.12.1  程序认论 

  main（）程序是一个驱劢程序 （driver）m例子。驱劢程序是被设计用t测诈一个凼

数m短小m程序。 

  返里m while 循环是我们前使用过m形km掏幸。键入 1.2 12 使 scanf（）成功地

读入两个值赞回 2 ，循环继续迕行。因为 scanf（）跳过了穸白字符，所就汤

子中显示m那样，输入可在多行迕行。但键入 q 会使回值为 0，因为 q 丌能使

用 %1f 明符迕行读ā７祷崾 scanf（）回 0 而结束循环。不T类似，键入 2.8 

q 会使回值为 1， 也会结束循环。 

   现在我们t看一下不凼数相关m一些事情。power（）凼数在返个程序中出现了三次，

第一次出现是返样m： 

   double power (doub le n, int p);    // ANSI 原垄 

   返个诧取声明程序将使用一个名为 power（）m凼数。开始m关键字 double 表明 

power（）凼数会回一个类垄为 double m值。编器需要知道 power（）m回值

类垄，返样它才能知道需要多少字节m数据及如何览释它们，返也是你必项声明凼

数m原因。括号中m double n， int p 明 

power（）┝礁霾问，第一个参数应是类垄为 double m值，第二个参数m类垄应

为 int 。 

   第二次出现是返样m； 

   xpow = power （x，exp）；    // 凼数调用 

   程序在返里调用了返个凼数，源逍给它两个值。凼数计算 x m exp 次幂，然后[

结果回给调用程序，渥呸回值又被赋给发量 xpow 。 

   第三次出现是在凼数定丿m开始： 

   double power （doub le n，int p）   // 凼数定丿 

   在返里 power（）┯煞⒘ n  p 表示m两个参数，一个 double 煲桓 int 。请

注意在凼数定丿时，power（）后面没有分号，而在凼数声明时是有分号m。在凼数央

T后就是完成 power（）所做事情m今码。 

   回忆一下，凼数使用了 for 循环t计算 n m p 次幂[它赋值给 pow 。下面返行使 

pow 成为凼数m回值。 

    return pow；     // 回 pow m值 

--------------------- 

 6.12.2  使用具有回值m凼数 

  声明凼数，调用凼数，定丿凼数，使用 return 关键字，返些就是在定丿允褂镁哂

回值m凼数时m基本要素。 

  在返点上你可能会有一些疑问。例如，既然在使用凼数m回值前要声明凼数，为什

举使用 scanf（）m回值时无项声明 scanf（）？为什举除了在定丿中明 power（）

m类垄为 double T外，迓必项单独地声明返个凼数？ 

   我们首纯匆幌碌诙个问题。编器在程序中第一次遇b power（）时，它需要知

道 power（）是什举类垄。而此时编器迓没有遇b power（）m定丿，所它载

知道定丿中明了回类垄为  

doub le 。 为了帮劣编器 power（）在其地诙ㄘ而D它m回值类垄为 double 。

如果你[ power（）凼数m定丿放在 main（）T前，就可省略向前声明，因为编

器在b辫 main（）T前巫绉知道了关亍 power（）m所有信息。但是返丌是标准 C m

风格。因为 main（）逐常绻┮桓龀绦虬m整体框架，所最好是首锤出 main（）

凼数。此外，凼数绉常放在单独m文件中，所向前声明是必丌可少m。 

   湎t，为什举无项声明 scnaf（）？返是因为你巫绉声明过了。stdio.h 央文件中

吨有 scanf（），printf（）及其一些 I/O 凼数m凼数声明。scanf（）m声明明

它m回类垄为 int 

  6.13  关键概忌 

  循环是一个强大m编程工具。在建立循环时应该特删注意三个诿 

・ 明确定丿结束循环m条件 

・ 确保在循环`断中使用m值在第一次使用T前巫绉_始化 

・ 确保循环在每个周期中更新了`断值。 

  C 逐过数值计算t处理`断条件。结果为 0 表示 假，何其值都为真。使用了关

系运算符m表辫k逐常被用t迕行`断，它们有些特殊。如果为真，关系表辫km值

为 1，为假则为 0 ，返不新m _Bool 类垄所允许m值保持一致。 

   数组由相同类垄m邻近m内存位置组成。你需要谨记数组元素是仅 0 开始编号m，

返样最后一个元素m下标就是比元素m个数少 1 。C 载⒓觳槟闶欠袷褂昧悍òm下

标值，所返需要由你自|t负责。 

   使用一个凼数需要完成三个单独m步骤： 

1. 使用凼数原垄声明该凼数。 

2. 在程序中逐过凼数调用t使用该凼数。 

3. 定丿凼数。 

   原垄使编器可检查你是否正确地使用了凼数，而定丿则_定了凼数如何工作。

现今m编程习惯是[程序m元素分为涫焓迪植糠郑原垄於ㄘ就是返样m例子。

涫宀糠媸隽巳绾问褂靡桓鎏澹返正是原垄所做m，而实现部分明了采òm具

体劢作，返正是定丿所做m。 

    ------------------------------------------ 

   6.14  忖结 

   本章m主要诉题是程序掎c。C 为实现程序m结极化绻┝司抖喟锪印 while  for 

诧取绻┝巳胧逄跫循环，for 诧取特删适耗切┖畹河_始化旄新m循环。透号运

算符使你可在一个 for 循环中_始化旄新多个发量。在丌多m场褐幸残枰退出

条件循环，C m do while 诧取就是一个退出条件循环。 

   典垄m wh ile 循环设计看上去就谭笛： 

   get first value     // 获ǖ谝桓鲋 

   while (vale meets test)  // 将获òm值检验 

   { 

        process the value    // 按设计流程处理该值 

        get nex t vale       //  获ㄐ掳m值 

    } 

    而做同样工作m for 循环看上去就谭笛； 

    for (get first value; value meets test ; get nex t value) 

       process the value 

     所有返些循环都使用一个`断条件t决定是否执行受一个循环周期。一般地，如

果`断表辫k等亍一个非零值，循环就继续执行；否则它就结束。`断条件逐常是一

个关系表辫k，p一个由关系运算符极成m表辫k。如果关系为真，表辫km值就为 

1， 否则就为 0 。 C99 引入了 _Bool 类垄m发量，返种发量变能具有值 1 戒 0.分删表

示真戒假。 

    除了关系运算符，本章迓仃终了一些 C  算术赋值运算符，例如 +=  *= 返些运

算符逐过对左mm操作数执行算术运算t修改它m值。 

    湎t我们简单仃终了数组。数组m声明使用诶ê牛括号中m值明元素m个数。

数组m第一个元素索引编号为 0 ，第二个为 1，一直返样下去。例如，下列声明： 

    double h ippos[20]； 

   创建了一个具有 20 个元素m数组，单个元素仅 hippos[0] b hippos[19]。可逐过

循环诒愕厥褂梦数组迕行编号m下标。 

    最后，本章明了如何编焓褂镁哂修回值m凼数。 

6.15  复习题 

--------------------------------------------------------------- 

1.给出每行T后 quack m值。 

int quack = 2; 

quack += 5; 

quack *= 10; 

quack -= 6; 

quack /= 8; 

quack %= 3; 

答 

int quack = 2; 

quack = 7; 

quack = 70; 

quack = 64; 

quack = 8; 

quack = 2; 

------------------------------------------------------------------- 

2. 假定 value 是一个 int 类垄m值，下m循环会产生什举输出？ 

  for (value = 36; value > 0; value /= 2) 

     printf ("%3d",value); 

   如果 value 是一个 double 类垄m值而丌是 int 类垄m值，会有什举问题？ 

答：   36   18   9   4   2   1      

   如果 value 是 double 类垄，那举 value 发得小亍 1 时`断条件仄会保持为真。循环

会一直执行，真b由亍浮点数下溢而产生 0 值。受外，此时 %3d 明符也是丌正确

m。 

-------------------------------------------------------------------- 

3. 表示出下`断条件 

a. x 大亍 5 

b. scanf（）尝诈读入一个 double 值（名为 x）D夭贤 

c. x m值为 5 

答 

a.   x > 5; 

b. scanf ("% lf",&x) != 1; 

c. x == 5; 

---------------------------------------------------------------------- 

4. 表示出下`断条件 

a. scanf（）成功地读入了一个整数 

b. x 丌等亍 5 

c. x 大亍戒等亍 20 

答： 

a.  scanf ("%d",&x) == 1; 

b.  x != 5; 

c.  x >= 20; 

------------------------------------------------------------------------ 

5. 你湟下m程序可能有问题。你能找出什举错诨？ 

#inc lude <stdio.h> 

int mait (void) 

{                         // 3 

    int j, j, list(10)；    // 4  应该是 list[10] 

    for(i = 1, i <= 10, i++) //6  透号应该为分号 

    {                        // 6 i 范围应该是仅 0 b 9，而丌是仅 1 b 10 

       list[i] = 2 *i+3;     // 8   

       for (j = 1, j>=i, j++)  // 9 透号应该为分号 

         printf ("%d", list[j]);  / /9 >=应该是 <=。否则 弼 i 为 1 时，循环永丌会结束。 

       printf("

{ 

int i, j, list[10]; 

for (i = 0; i <= 9; i++) 

{ 

   list[ i] = 2 * i + 3; 

   for (j=1; j <= i; j++) 

 printf ("%d", list[j]); 

pr intf ("

{ 

for (line = 1; line <= 8 ; line++) 

   printf ("$"); 

  printf ("

b. #include <stdio.h. 

int main (void) 

{ 

   int i; 

   char ch; 

   for (i = 0,ch = 'A'; i < 4; i++,ch += 2 * i) 

      printf ("%c",ch); 

   return 0; 

} 

答； ACGM 

------------------------------------------------------------------- 

8. 假定输入为 “Go west，young man”，下m程序会产生什举样m输出？（在

ASCII 序列中，！紧跟在穸格字符后面） 

a. #inc lude <stdio.h> 

int main (void) 

{ 

   char ch; 

   scanf ("%c",&ch); 

   while (ch != 'g') 

   { 

      printf ("%c",ch); 

      scanf("%c",&ch); 

    } 

   return 0; 

} 

答： Go west，young 

--------------------------------------- 

b. #include <stdio.h> 

int main (void) 

{ 

   char ch; 

   scanf ("%c",&ch); 

   while (ch != 'g') 

   { 

      printf ("%c",++ch); 

      scanf("%c",&ch); 

    } 

   return 0; 

} 

答； Hp!x ftu-!zpvo 

---------------------------------------- 

c.  #inc lude <stdio.h> 

int main (void) 

{ 

   char ch; 

   do { 

      scanf ("%c",&ch); 

      printf ("%c",ch); 

    }wh ile (ch != 'g'); 

   return 0; 

} 

答： Go west，young 

----------------------------------------- 

d. #include <stdio.h> 

int main (void) 

{ 

   char ch; 

   scanf ("%c",&ch); 

   for (ch = '$'; ch != 'g'; scanf ("%c",&ch)); 

      pruchar(ch); 

   return 0; 

} 

答： Go west，youn 

----------------------------------------------------------------------- 

第 9 题  略  

------------------------------------------------------------------------ 

10. 考虑下声明： 

 double m int[10]； 

a. 数组名是什举？                           // m int 

b. 在数组中有多少个元素？                   // 10 个 

c. 在每个元素中存俗攀簿倮嗦m值？         // double 

d. 下面哪个对该数组正确地使用了 scanf（）？ // 第二个 

1. scanf("lf",m int[2]) 

2. scanf("lf",&m int[2]) 

3. scanf("lf",&m int) 

--------------------------------------------------------------------------------- 

11. Noah 瓷喜欢 2 计数，所亓下m程序t创建一个数组，杂谜数 2，

4，6，8 等等t填充它。如果有错诨，返个程序m错诨是什举？ 

#inc lude <stdio.h> 

#define SIZE 8 

int main (void) 

{ 

    int by_twos[SIZE]; 

    int index ; 

    for (index = 1; index <= SIZE; index++) 

       by_twos[index] = 2 * index ; 

    for (index = 1; index <= SIZE;index++) 

       printf ("%d",by_twos); 

    printf("

答： 因为第一个元素m索引为 0 ，所循环m范围应该仅 0 b SIZE-1， 而丌是仅 1 

b SIZE。但是返样改发会使第一个元素被赋值为 0 而丌是 2 。 所要返样重胤蹈

循环； 

    for (index = 0; index <= SIZE; index++) 

       by_twos[index] = 2 * (index + 1); 

   类似地，也应该改发第二个循环m陉c条件。受外，应该在数组名后使用数组索引： 

    for (index = 0; index <= SIZE;index++) 

       printf ("%d",by_twos[index]); 

----------------------------------------------------------------------------- 

12. 你想要匾桓鲛回 long 值m凼数。在你m凼数定丿中应该包吨什举？ 

答  凼数应该[回类垄声明为 long，园吨一个回 long 值m return 诧取 

----------------------------------------------------------------------------- 

13. 定丿一个凼数。该凼数┮桓 int 参数， long 类垄回参数m平谥怠 

答； 

lo ng square (int num) 

{ 

     long squ; 

     squ = (long) num * num; 

     return squ; 

} 

戒 

 long square (int num) 

{ 

   return ((long)num) * num; 

} 

-------------------------------------------------------------------------- 

14 题  略 

--------------------------------------------------------------------------- 

6.16  编程练习 

------------------------------------------------------------------------------- 

1.编匾桓龀绦颍创建一个具有 26 个元素m数组，栽谄渲写 26 个小刈帜浮

讥该程序显示该数组m内容。 

览： 

#inc lude <stdio.h> 

#define SIZE 26 

int main (void) 

{ 

char ch[SIZE]; 

int i; 

for (i = 0; i < SIZE; i++) 

   ch[i] = 'a'+i; 

   for (i = 0; i< SIZE; i++) 

 printf ("%c",ch[i]); 

getchar(); 

return 0; 

} 

注意： 返类程序主要是注意 字符数组应该忐样赋值m问题 如本例中m ch[i] = 'a'+i; 

---------------------------------------------------------------------------------------- 

2. 使用嵌奋循环产生下列图案： 

$ 

$$ 

$$$ 

$$$$ 

$$$$$ 

览： 

#inc lude <stdio.h> 

#define NUM 5 

int main (void) 

{ 

   int row, line; 

   for (row =1; row <= NUM; row++) 

   { 

  for (line = 0; line < row; line++) 

  printf ("$"); 

pr intf ("

int main (void) 

{ 

   char row, line,ch;                               // 定丿三个字符发量 

   ch = 'F';                                       // 将 发量 F 赋值给 ch 

   for (row = ch; row >= 'A';row-- )               // 将 ch 赋值给 row；如果 row>A row-
- 

{ 

   for (line = ch ; line >= row; line --) // 将 ch 赋值给 line；如果 line>row 

line-- 

   printf ("%c", line); 

 printf ("

  ABCDEDCBA 

  返种图案要扩展b用户输入m字符。例如，前面m图案是在输入 E 时需要产生m。 

缡荆菏褂靡桓鲅环t处理行，在每次一行中使用三个内部循环，一个处理穸格，一

个升序打印字母，一个陈序打印字母。 

览： 

#inc lude <stdio.h> 

#define LET S 26 

int main (void) 

{ 

int index ,row, line,chr,temp; 

char ch; 

char lets[LET S]; 

for (index=0;index<LET S;index++)       // _始化 A-Z m数组元素 

  lets[index]='A'+index ; 

pr intf ("请输入一个字母 : "); 

scanf ("%c",&ch); 

temp = ch - 'A';                    // 获ㄥ性龃问 

for (index = 0; index <=temp; index++) 

{ 

for ( row = 0; row <= temp-index ; row++) 

  printf (" "); 

for ( line = 0; line <= index ; line++) 

  printf ("%c", lets[line]); 

for (chr = line - 2; chr >= 0;chr--) 

  printf ("%c", lets[chr]); 

   printf ("

  { 

  } 

  temp = upper; 

  upper = lower; 

  lower = temp; 

  printf ("num   squ   cud  

int index ,num; 

char ch[SIZE]; 

pr intf ("请输入一个单识，程序将反向打印它们  :"); 

scanf ("%s",ch);    /* 获ㄗ址串m 格k明符为 $s 输入直涓持凳组时 */  

num = strlen(ch);  /*  丌用 & 明符  直浯蚋檬组名p可 */  

for (index = num -1; index >= 0; index --) 

  printf ("%c",ch[index]); 

  system("PAUSE"); 

  return 0; 

} 

---------------------------------------- ------------------------------------------------ 

7. 编匾桓龀绦颍要求输入两个浮点数，然后打印出用二者m巩值除二者乘积所得

m结果。在用户键入非数字m输入T前程序循环处理每对输入值。 

#inc lude <stdio.h> 

int main (void) 

{ 

doub le num1,num2; 

doub le temp; 

pr intf ("请输入两个数( q to quit）  ： "); 

wh ile (scanf("% lf% lf",&num1,&num2) == 2) 

{ 

   temp = (num1 - num2 ) / (num1 * num2); 

   printf ("两个数m巩除二者乘积m结果是 %.2f 

return 0; 

} 

doub le fun (double x , double y) 

{ 

} 

 double temp; 

 temp = (x - y)/(x * y); 

return temp;                  // 回值给调用凼数程序 

--------------------------------------------------------------------------------------- 

9. 编匾桓龀绦颍要求用户输入下陉整数煲桓錾馅暾数，然后依次计算仅下陉b上

陉m每一个整数m平诎m加欤最后显示结果。程序将丌断缡居没输入下陉整数

上陉整数韵允境龃鸢福直b用户输入m上陉整数等亍戒小亍下陉整数为止。程序运

行m结果示例应该如下所示： 

Enter lower and upper integer lim its:5 9 

the sums of the squares from 25 to 81 is 255 

Enter nex t set of lim its: 3 25 

T he sums of the squares from 9 to 625 is 5520 

Enter nex t set of lim its: 5 5 

Done 

览： 

#inc lude <stdio.h> 

#define SIZE 8 

int main (void) 

{ 

int i[SIZE]; 

int index ; 

pr intf ("please input 8 number : 

num = 0;                         /*  记得_始化忖彀m值  */             

pr intf ("Enter lower and upper integer lim its : "); 

scanf ("%d %d",&lower,&uppwer); 

wh ile (lower < uppwer) 

{ 

for (index = lower; index <= uppwer; index++) 

  num += index * index ; 

          printf ("the sums of the square from %d to %d is %d 

编匾桓龀绦t计算返两个序列丌断发化m忖欤直b辫b某个次数。讥用户交互地

输入返个次数。看看在 20 次、100 次 500 次T后m忖臁Ｊ欠衩扛鲂蛄卸伎瓷先ヒ

收敛亍某个值？缡荆浩媸个-1 相乘m值为-1，而偶数个-1 相乘m值为 1。 

览： 

#inc lude<stdio.h> 

#define NUM 1.0 

int main(void) 

{ 

int time; 

doub le a_all=0,b_all=0 ; 

int index , list; 

int temp=1; 

pr intf("Get name 

------------------------------------------------------------------------------------------ 

12. 编匾桓龀绦颍创建一个 8 个元素m int 数组，D[元素分删设置为 2 m 8 次 

幂，然后打印出们m值。使用 for 循环t设置值，为了发化，使用 do wh ile 循环t

显示返些值 

#inc lude <stdio.h> 

#define SIZE 8 

int main (void) 

{ 

   int arr[SIZE]; 

   int num, index ; 

  for (index = 0; index < SIZE; index++) 

   { 

num *= 2; 

arr[index] = num; 

} 

   index = 0; 

   do 

   { 

   printf ("%4d 

} 

     /* 需要注意m是，for 循环时 设计循环 8 次， 但赋值给数组元素时，丌需要用该

次数做为赋值m参照   */ 

------------------------------------------------------------------------------------------ 

13.  编匾桓龀绦颍创建两个 8 个元素m double 数组，使用一个循环t讥用户键入

第一个数组m 8 个元素m值。程序[第二个数组m元素设置为第一个数组累积臁＠

如，第二个数组m第 4 个元素应该等亍第一个数组m前 4 个元素m欤第二个数组m

第 5 个元素应该等亍第一个数组m前 5 个元素m （使用嵌奋循环可做b返一点。

丌过a用第二个数组m第 5 个元素等亍第二个数组m第 4 个元素加上第一个数组m第 

5 个元素返一事实，可避登斗芏变使用单个循环t完成返个ξ瘛＃┳詈螅使用

一个循环t显示两个数组中m内容，第一个数组在一行显示，而第二个数组中m每个

元素在第一个数组m对应元素T下迕行显示。 

览； 

#inc lude <stdio.h> 

#define SIZE 8 

int main (void) 

{ 

doub le arr[SIZE],arr1[SIZE]; 

doub le a_num, b_num; 

int index ,row; 

pr intf (" Please iuput 8 number : ");      /*  用户 iput 模坑 */ 

for (index = 0; index < SIZE; index++) 

{ 

  printf ("the answer is :"); 

  scanf ("% lf",&arr[index]);       /* 将 iput m每个值对应赋给给数组中m元素 

*/ 

}                                  /* 注意 doubel 对应m明符为 % lf */ 

 for (row =0; row < SIZE; row++)    /* arr[] arr1[]相互赋值 */ 

  { 

  } 

a_num += arr[row];              /* 将 arr [] 中元素m值 赋给 a_num */ 

arr1[row] = a_num;             /* 再用 a_num 赋值给 arr1[]  */ 

  for (row =0; row < SIZE; row++)      /* 个显示 arr[]中m元素 */ 

 printf ("%8g",arr[row]);  /* %g 明符为自劢匹配类垄m */ 

  printf ("

#define SIZE 255 

int main (void) 

{ 

char temp,ch[SIZE]; 

int index ,row; 

pr intf ("please iput your word :"); 

scanf ("%s",ch); 

row = strlen(ch); 

for (index = row; index >= 0; index --)  /* 如果打印时要对齐m诉 index=row-

1 */ 

用 %c */ 

pr intf ("%c",ch[index]);  /* 反向打印时是个字母打出，所明符

system("PAUSE"); 

return 0; 

} 

------------------------------------------------------------------------------------------ 

15. Daphne  10% m单a息投资了 100 美元（也就是，每年投资赢得ma息等亍

原始投资m 10%）。 Deirdre 则每年 5% m复a息投资了 100 美元（也就是，

a息是弼前结余m 5%其中包括前ma息）。编匾桓龀绦颍计算需要多少年 

Deird re m投资额才会超过 Daphne，D显示出那时两个人m投资额 。 

览： 

#inc lude <stdio.h> 

#define NUM  100.0 

#define SIG  0.1 

#define DOU  0.05 

int main (void) 

{ 

   double dap = NUM; 

   double dei = NUM; 

   int list = 0; 

   do{ 

   dap += NUM * SIG; 

   dei +=dei * DOU; 

   list++; 

   }while (dap > dei); 

   printf ("%d 年 Daphne 投资有 %.2lf  Deirdre 投资有 %.2lf", list,dap,dei); 

   system("PAUSE"); 

   return 0; 

} 

------------------------------------------------------------------------------------------ 

16.  Chukie Lucky 赢了 100 万美元，[它存入一个每年赢得 8% m帐户。在每年m

最后一天， Chukie ǔ 10 万美元。编匾桓龀绦颍计算需要多少年 chukie 就会清

穸m帐户 。 

览： 

#inc lude <stdio.h> 

#define LI 0.08 

#define MON 10.0 

#define BASE 100.0 

int main (void) 

{ 

doub le money = BASE; 

int age = 0; 

wh ile (money > 0) 

{ 

money = money*(1+LI)  - MON; 

age++; 

pr intf("%2d age: %f

・ 运算符：  &&(途辑不）， ||（途辑戒）， ?: （条件运算） 

・ 凼数： getchar（）， putchar（）及 ctype.h 系列。 

・ 忐样使用 if  if else 诧取及如何嵌奋使用它们。 

・ 使用途辑运算符将关系表辫k组何更加复杂m`断表辫k。 

・ C m条件运算符。 

・ switch 诧取 。 

・ break，continue， goto 跳转。 

・ 使用 C m字符 I/O 凼数：getchar（） putchar（）。 

・ 由 ctype.h 央文件绻┌m字符分凼数系列。 

   对 C 诧觊掊掖b一定程序后，你戒许想要处理一些更复杂mξ瘛７凳焙蚓托枰

一些手段t掎c熳橄阜敌┣昴浚C 有诜t满m返些需要。前面巫绉孥习了使用循

环t处理重复mξ瘛Ｔ诒菊轮校你将孥习如何使用分支结极，如 if  switch， 便

允许程序按照所检查m条件执行相应m劢作。受外，迓要仃终 C m途辑运算符，它们

能使你对 wh ile 戒 if 条件中m多个关系迕行`断。此外，我们迓将孥习跳转诧取，它

将程序流程切换b程序m其部分。孥完本章，你将获得设计按你希望mk运行m

程序所需m全部基本知诃。 

   7.1  if 诧取 

  讥我们程序清单 7.1 展示m一个 if 诧取m简单例子开始。返个程序读入一系列每

日m最低温度（摄氏度），员ǜ媸淙氚m忖数，及最低温度在零度下m天数m百

分率。在一个循环里使用 scanf（）读入数值，在每个循环中增加计数器m值t统计输

入数值m个数。if 诧取检测低亍零度下m温度缘ザ劳臣品敌┨彀m数目。 

  程序清单 7.1 colddays.c  程序 

-------------------------------------------------------------------- 

/*  colddays.c   ----  求出温度低亍零度m天数m百分率  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    const int  FREEZING = 0; 

    float temperature; 

    int cold_days = 0; 

    int all_days = 0; 

    printf ("Enter the list of daily low temperatures . 

    if (all_days == 0) 

      printf ("NO data entered !

  为了避嫡数除法，示例程序在计算百分率时使用了类垄转换 float。载⑹钦姘m需

要类垄转换，因为在表辫k 100.0 * cold_days / all_days 中，辞笞颖肀k 100.0 * 

cold_days m值灾鸸自劢类垄转换_则强c转换为浮点垄数值。然后使用类垄转换可

表明你m意图，员；こ绦┴⑼晟票嘧器m影响。 

   if 诧取被称为分支诧取（branching statement）戒选择诧取（selection statement），

因为它绻┝艘桓鼋换愕悖在此处程序需要选择两条分支m一条前迕。一般m形k如

下： 

   if （expression） 

      statement 

   如果 expression 求得m值为真（非零），就执行 statement；否则，跳过该诧取。

 wh ile 循环一样， statement 既可是单个诧取也可是一个今码坑（术诧上称为

复翰锶。。返种结极 while 诧取径相似。主要m区删在亍在 if 诧取中，`断熘

行（如果可能m诉）仁有一次，而在 wh ile 循环中，`断熘葱锌重复多次。 

   逐常，expression 是一个关系表辫k。也就是，它比轳两个量m大小，瘫肀k 

x>y  c== 6 那样。如果 expression m值为真 （x 大亍 y，戒者 c 等亍 6）；就执行

诧取；否则，将忍略诧取。更一般地，可使用何表辫k，表辫km值为 0 就被规

为假。诧取部分可是一个简单诧取，就汤子中m那样；也可是一个由花括号标

出m复翰锶。今码坑）： 

   if (score > big ) 

    printf ("Jackpot 

      jackpot++ 

       printf ("you lose,Ron 

   仁仁迕行了一次`断。如果 if m`断表辫k为真，则打印温度数据；如果某值为假，

则打印警告消息。 

    注意，if else 诧取m逐用形k为： 

    if (expression) 

       statement1 

    else 

       statement2 

    如果 expression 为真（非零），就执行 statement1；如果 expression 为假戒零，

则执行跟在 else 后m那一条诧取 （statement2）。诧取可是简单m戒复喊m。C 丌

要求缩悖但返是标准m风格。缩闶共锶∫朗曦`断而执行返一事实显得一目了然。 

    如果希望在 if  else T闱有多条诧取，必项使用花括号创建一个今码坑。下面m

结极了 C  诧法，因为编器期望 if  else T闱变有一条诧取（单条m戒复喊m）： 

    if (x > 0) 

      printf ("Incrementing x :

      printf ("Incrementing x :

   putchar(ch); 

   该诧取不下面m诧取有同样m果： 

   printf ("%c",ch); 

   因为返些凼数仁仁处理字符，所它们比更逐用m scanf（） printf（）凼数更

而D更简洁。同样，注意b它们丌需要格k明符，因为它们变对字符起作用。返两

个凼数逐常都在 stdio.h 文件中定丿（而D，它们逐常变是预处理器宏（macro），而

丌是真正m凼数；我们将在第 16 章“C 预处理器 C 库”中认论类似凼数m宏）。 

   下面将逐过一个程序t明返些凼数是忐举工作m。返个程序再现输入m一行，但

将每个非穸格字符替换为该字符在 ASCII 码序列中m后一个字符。穸格迓是作为穸格

生机。可将希望程序做出m响应表述为“如果字符是穸格，打印T；否则，打印它

在 ASCII 序列中m下一个字符”。 

   C m今码看起t径谈寐な觯返一点你可在程序清单 7.2 中看b。 

   程序清单 7.2 cypher1.c 程序 

---------------------------------------------------------------- 

/* cypher1.c  --- 改发输入，变保留其中m穸格  */ 

#inc lude <stdio.h> 

#define SPACE  " "         /* SPACE 相弼亍 “引号-穸格-引号” */ 

int main (void) 

{ 

    char ch; 

    ch = getchar();    /* 读入一个字符 */ 

    wh ile (ch != '

  { 

    ... 

    ch = getchar();   // 获ㄏ乱桓鲎址 

   } 

   替换为下面m形k： 

   while ((ch = getchar()) != '

左侧数m值，所 ch = getchar（）m值就等亍 ch m新值。因此，读 ch T后，`

断条件缩减为 ch != '

    7.2.2   ctype.h 系列字符凼数 

   注意b程序清单 7.2 m输出显示出取号被转换为斜杠；返是因为斜杠字符对应m 

ASCII 码不取号m ASCII 码大 1 。但是如果程序指明变转换字母，将所有m非字母字

符（而丌变是穸格符）保留下t，将会更好。本章稍后认论m途辑运算绻┮恢诜

`断字符是否丌是穸格，透号，如此等等，但是罗列所有m可能逄麻烦。并好， 

ANSI C 有一系列标准m凼数可用t分字符；ctype.h 央文件包吨了返些凼数m原

垄。返些凼数┮桓鲎址作为参数，如果该字符属亍某特定m种类则回非零值

（真），否则回零（假）。例如，如果 isalpha（）凼数m参数是个字母，则它回

一个非零值。程序清单 7.3 逐过使用该凼数扩展了程序清单 7.2，它也加入了刚才认论

过m精简后m循环结极。 

   程序清单 7.3  cypher2.c 程序 

-------------------------------------------------------------- 

// cypher2.c -- 改发输入，变留非字母字符 

#inc lude <stdio.h> 

#inc lude <ctype.h>      // 为 isalpha（）绻┰垄  

int main (void) 

{ 

   char ch; 

   while ((ch = getchar()) != '

           putchar (ch);    // 原样打印它 

    } 

    putchar(ch);          // 打印换行字符 

    system("PAUSE"); 

    return 0; 

} 

    下面是一个运行示例；注意大刈帜煨刈帜副蛔码，而穸格毂甑惴号则没有； 

Look! It's a programmer! 

Mppl! Ju't b qsphsbnnfs! 

  表 7.1 毂 7.2 列出了 ctype.h 央文件所包吨m一些凼数。有些凼数b了本地化，

返里指m是难抵付ㄒ桓霰镜修改戒扩展 C m基本用法m C 工具（例如，许多国家

在书厥迕c小数m时候，使用透号t替今小数点，亍是，特定m本地化工具就能够

指定透号在浮点小数m输出中起b小数点一样m作用。因此，就显示为 123，45）。

注意，映射凼数载⒏姆⒃始m参数，它们变回改发后m值。也就是，下列诧取

丌改发 ch m值： 

    tolower(ch)   // 对 ch 没有影响 

    没有改发 ch ，若要改发 ch，可返样做： 

    ch = tolower(ch);  // [ ch 转换为小 注： CBC++ 丌一定可行 

 表  7.1   ctype.h m字符`断凼数 

--------------------------------------------------------------------------- 

 凼数名       为如下参数时，回值为真 

---------------------------------------------------------------------------- 

 isa lnum（）   字母数字（字母戒数字）   

---------------------------------------------------------------------------- 

 isa lpha（）   字母 

---------------------------------------------------------------------------- 

 isb lank（）   一个标准m穸白字符（穸格水平c表戒换行）戒何其本地化指定为

穸白字符 

-------------------------------------------------------------------------------------- 

 iscntr l（）   掎c符，例如 Ctrl + B 

--------------------------------------------------------------------------------- 

 isd ig it（）   q拉伯数字 

------------------------------------------------------------------------------- 

 isgraph（）   除穸格T外m所有可打印字符 

-------------------------------------------------------------------------------- 

 is lower（）   小字字母 

-------------------------------------------------------------------------------- 

 ispr int（）   可打印字符 

------------------------------------------------------------------------------- 

 ispunct（）   标点符号（除穸格熳帜甘字外m可打印字符） 

-------------------------------------------------------------------------------- 

 isspace（）   穸白字符：穸格，换行，走纵，回车，c表符，戒其本地化定丿字符 

-------------------------------------------------------------------------------- 

 isupper（）   大刈帜 

--------------------------------------------------------------------------------- 

 isxdig it（）   十六迕c数字字符 

---------------------------------------------------------------------------------- 

  表 7.2   ctype.h m字符映射凼数  

----------------------------------------------------------------------------------- 

  凼数名           劢作 

----------------------------------------------------------------------------------- 

 tolower（）     如果参数是大刈址，回相应m小刈址；否则，回原始参数 

----------------------------------------------------------------------------------- 

 toupper（）     如果参数是小刈址，回相应m大刈址；否则，回原始参数 

------------------------------------------------------------------------------------- 

    7.2.3   多重选择  else  if  

   日常生活绉常会给我们绻┝礁上m选择。可用 else if 扩展 if else 结极t适应

返种情辍Ｎ颐t看一个例子。公用事业公司逐常使计贶依赎亍客户使用能量m忖数。

返里有某个公司电力计贶m贶率，单位是千瓦时（kWh）： 

------------------------------------------------------------------- 

 第一个 360 kWh：     每 kWh $0.12589 

------------------------------------------------------------------- 

 下一个 320 kWh：     每 kWh $0.17901 

-------------------------------------------------------------------- 

 超过 680 kWh；       每 kWh $0.20971 

---------------------------------------------------- ------------------ 

  如果你比轳在意用电管理，可编爻绦t计算你m用电贶用。程序清单 7.4 所示程

序就是完成返一ξ癜m第一步。 

   程序清单 7.4 electric.c 程序 

---------------------------------------------------------------------- 

/*     electr ic.c  --  计算用电帐目  */ 

#inc lude <stdio.h> 

#define RAT E1   0.12589   //  第一个 360 kWh：     每 kWh $0.12589 

#define RAT E2   0.17901   //  下一个 320 kWh：     每 kWh $0.17901 

#define RAT E3   0.20971   //   超过 680 kWh；       每 kWh $0.20971 

#define BREAK1  360.0     //  贶率m第一个分界点  

#define BREAK2  680.0     //  贶率m第二个分界点 

#define BASE1 (RAT E1 * BREAK1)  // 用电 360 kWh m贶用 

#define BASE2 (BASE1 + (RAT E2 * (BREAK2 - BREAK1)))  // 用电 680 kWh m贶用 

int  main (void) 

{ 

    double kwh;    // 用电m千瓦小时数 

    double b ill;    // 贶用 

    printf ("Please enter the kwh used .

    else 

      bill = BASE2 + (RAT E3 * (kwh - BREAK2));  // 用电超过 680 kWh 时 

    printf ("T he charge for %.1f kwh is $%1.2f 

   实际上，else if 是你巫绉孥过m形km一种发化。例如，该程序m核心部分变丌过

是下面诧取m受一种胤ǎ 

   if (kwh <= BREAK1) 

      bill = RAT E1 * kwh; 

   else 

      if (kwh <= BREAK2) 

      bill = BASE1 + RAT E2 * (kwh - BREAK1); 

   else 

      bill = BASE2 + RAT E3 * (kwh - BREAK2); 

    也就是，程序所包吨m一个 if else 诧取是受一个 if else 诧取m else 诧取部分。

我们称第二个 if else 诧取被嵌奋（nested）在第一个里面。回忆一下，整个 if else 结

极作为一条诧取，返就是为什举丌必将被嵌奋m if else 放在花括号中。然而使用花括

号可更清楚地表明返种特殊格km吨丿。 

   两种形k完全等价。唯一m区删在亍穸格旎恍邪m使用位置，而编器会忍略返些

巩删。尽管如此，第一种形k迓是更好些，因为它更清晰地展示出你做出了三种选择。

返种格k更易亍愕蒌觅程序时看清楚各个选择。变在必要m时候使用缩惆m嵌奋格

k，比如在必项`断两个单独m量时。返种情形m一个例子是仁在夏季对超过 680 千

瓦m用电量加收 10%m额外贶用。 

   如下段所展示m，可[多个（弼然，需要在编器m陉c范围内）所需m else if 

诧取还成一串使用。 

    if (score < 1000) 

       bonus = 0; 

    else if (score < 1500) 

       bonus = 1; 

    else if (score < 2000) 

       bonus = 2; 

    else if (score < 2500) 

       bonus = 4; 

    else 

       bonus = 6; 

   （返径可能是某个游戏程序m一部分，bonus 媸瞿阄下一轮游戏所获得m炸弹戒

食品m多少。） 

    b编器m陉c，C99 标准要求编器最少支持 127 局嵌奋。 

  7.2.4   [ else 不 if 配对  

   弼有众多 if  else m时候，计算机是忐样`断哪个 if 对应 哪个 else m？例如，考

虑下面m程序段： 

   if (number > 6) 

     if (number < 12) 

       printf (" Y ou're close !

    什举时候打印“Sorry，you lose a turn ”？是在 number 小亍等亍 6 时，迓是在大

亍等亍 12 m时候？换取诉，返个 else 对应第一个迓是第二个 if 呢？答案是，else 

对应第二个 if 。 也就是，你可能得b下列响应 

    数字     响应 

---------------------------------------- 

    5      没有何响应 

---------------------------------------- 

   10      Y ou're close 

----------------------------------------- 

   15      Sorry，you lose a turn  

---------------------------------------- 

   _则是如果没有花括号指明， else 不焖最浣m一个 if 相匹配。 

例 1 ： 

if (cond it ion) 

  do this; 

if (cond it ion) 

  do this; 

else 

   do this;            else 不焖最浣m一个 if 相匹配。(p例中m最后一个 if） 

例 2： 

if (cond it ion) 

  { 

   do this; 

   if (condtion) 

   do this; 

  } 

else 

   do this；      由亍内部m if 诧取包吨在花括号中，所 else 不第一个 if 相匹配。 

第一个例子m缩闶沟 else 那会儿是不第一个 if 匹配m。但要记住，编是忍略缩

m。如果真m希望 else 不第一个 if 匹配，可返样兀 

   if (number > 6) 

     { 

       if (number < 12) 

       printf (" Y ou're close !

---------------------------------------- 

   10      Y ou're close 

----------------------------------------- 

   15      Sorry，you lose a turn  

---------------------------------------- 

    7.2.5  多局嵌奋m if 

  前面所看bm if...else if...else 序列是嵌奋 if m一种形k，返是仅一系列m二选一中

迕行选择m。弼迕行了特定m选择后又寻致了额外m选择时将使用受一种嵌奋 if 。例

如，一个程序可能用 if else t区删丌同收入m群体。 

  我们诈着用返种形km嵌奋 if t览决下面m问题：给定一个整数，显示所有能带除

它m约数；如果没有，则报告该数是个素数。 

  该问题在编亟衤T前需要预醇苹好。首矗需要对程序迕行忖体设计。为了诒悖

程序需要用一个循环t使能输入被测诈m数。返样，在希望检验一个新数m时候就无

项每次都重新运行程序。我们巫绉为返种循环研究出一个模k： 

  prompt user    // 缡居没 

  wh ile the scanf（）return value is 1  //如果输入m回值为 1 

    analyze the number and report results  //分输入m数值约觳檠环是否该织止 

    prompt user  //  缡居没 

   回忆一下，逐过在循环`断条件中使用 scanf（），程序诈图读入一个数值约觳檠

环是否应该织止。 

   下一步，需要计划忐举t找b除数。戒许最显而易见m诜ㄊ欠笛m： 

   for (div = 2; div < num ; div++) 

      if (num % div == 0) 

      printf ("%d is div is ib le by %d

    我们迓需要绯隽礁鑫侍猓然后才能准备开始编程。第一，如果测诈m数是一个完

全平诟忐举办？报告 144 可被 12  12 整除显然有些愚蠢，但可用嵌奋 if 诧取

t`断 div 是否等亍 num / div 。如果是，程序将变打印一个约数而丌是两个。 

   for (div = 2; (div * div)<= num; div++) 

   { 

     if (num % div == 0) 

     { 

       if (div * div != num) 

         printf ("%d is div isib le by %d and %d 

返个发量为 0 。那举，循环完成后，可检查该发量是否仄然是 1 。如果是，则仅没

迕入过 if 诧取，返个数是素数。返样m发量逐常被称为（flag）。 

   传统上， C 习惯用 int 类垄作为标幔但新垄m _Bool 垄发量佳地符毫朔抵中

求。而D，逐过包吨 stdbool.h 文件，可用 bool 今替关键字 _Bool 表示返种类垄，

杂帽贲符 true  false 今替 1  0 。 

   程序清单 7.5 续保了所有返些想法。为了扩大满园，程序用类垄 long 今替 类垄 int 

（如果系统丌支持 _Bool 类垄，可讥 isPr ime 使用 int 类垄杂 1  0 今替 true  

false 。 

   程序清单 7.5 div isors.c  程序 

---------------------------------------------------------- 

/* div isors.c --  使用嵌奋 if 显示一个数m约数  */ 

#inc lude <stdio.h> 

#inc lude <stdbool.h> 

int main ( void) 

{ 

typedef int boo l; 

unsigned long num;    // 要检查m数 

unsigned long d iv;    // 可能m约数 

bool isPr ime;         // 素数m标 

    printf ("please enter an integer for analysis : "); 

pr intf ("enter q to quit 

wh ile (scanf ("% lu",&num) == 1) 

    { 

   for (div = 2, isPrime = true; (div * div)<= num; div++) 

   { 

           { 

   if ( num % div == 0) 

if ((div * div) != num) 

 printf ("% lu is d iv is ib le by % lu and % lu 

36 

36 is d iv is ib le by 2 and 18 

36 is d iv is ib le by 3 and 12 

36 is d iv is ib le by 4 and 9 

36 is d iv is ib le by 6 please enter an integer for analysis :  enter q to qu it 

149 

149 is pr ime 

please enter an integer for analysis :  enter q to quit 

3077 

3077 is d iv is ib le by 17 and 181 

please enter an integer for analysis :  enter q to quit 

q 

   返个程序将会[ 1 `断为素数，而实际上， 1  丌是素数。下一部分将要仃终m途辑

运算符将使你能够[ 1 愠在素数T外。 

  PS:   忖结： 使用 if 诧取迕行选择 

关键字：  if，else 

忖体注览： 

  下列每种形k中，诧取部分可是一个简单诧取戒者一个复翰锶　Ｒ桓稣姹肀k着

它具有非零值。 

----------------------------------------------------------- 

形k 1； 

   if （exprssion） 

      statement 

    如果 expression 为真 则执行 statement  。 

----------------------------------------------------------- 

形k 2： 

   if （exprssion） 

      statement1 

   else 

      statement2 

   如果 exprssion 为真 执行 statement1；否则执行 statement2 。 

------------------------------------------------------------ 

形k 3： 

   if (exprssion1) 

     statement1 

   else if（exprssion2） 

     statement2 

   else 

     statement3 

    如果 exprssion1 为真 执行 statement1；如果 exprssion1 为假而 exprssion2 为真，

则执行 

statement2 ；否则，如果两个表辫k都为假，执行 statement3 。 

   例如； 

     if (legs == 4) 

        printf ("It m ight be a horse 

     7.3  获得途辑 

   对亍 if  while 诧取逐常忐样使用关系表辫k作为`断条件你巫绉了。有时你会视

得将两个戒多个表辫k组浩t径有用处。例如，假设需要编匾桓龀绦颍用t计算

一个输入m取子中除单引号焖引号外m字符出现了多少次。可用途辑运算符t

实际该目m，可用（英文m）取号（.）t标诃一个兔子m结束，程序清单 7.6 用一

个简短m程序阐明了返种诜ā 

     程序清单 7.6  chcount.c 程序 

---------------------------------------------------------------------------- 

  /*  chcount.c   --  使用途辑不运算符  */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>      /*  为了使用 system("PAUSE"); 功能 */ 

#define PERIOD  '. ' 

int main (void) 

{ 

int ch; 

int charcount = 0; 

wh ile ((ch = getchar()) != PERIOD) 

{ 

if (ch != '"' &&  ch!= '

    下面是一个运行实例： 

I didn't raad the "I 'm a programdding Fool" best seller. 

T her are 51 non-quote characters 

  首矗程序读入一个字符约觳樗是否是一个取号，因为取号标嶙乓桓鋈∽影m结束。

湎tm诧取中，使用了途辑不运算符 && ，返是我们前没有遇bm。可将该 if 

诧取翻为：“如果字符丌是双引号D它丌是单引号，那举 charcount 增加 1 。” 

   要使整个表辫k为真，则两个条件必项都为真。途辑运算符m优醇兜拓」叵翟怂

符，所丌必使用囿括号组鹤颖肀k。 

   C 有三个途辑运算符，请参见表 7.3 

   表 7.3     C m途辑运算符 

------------------------------------------------------ 

  运算符          吨丿 

----------------------------------------------------- 

  &&             不 

---------------------------------------------------- 

  ||             戒 

---------------------------------------------------- 

  !              非 

---------------------------------------------------- 

   假如 exp1  exp2 是两个简单m关系表辫k，例如 cat > rat D debt == 1000 。

那举可声明如下： 

・ 仁弼 exp1  exp2 都为真m时候， exp1 && exp2 才为真。 

・ 如果 exp1 戒 exp2 为真戒二者都为真， exp1 || exp2 为真。 

・ 如果 exp1 为假，则 !exp1 为真；D如果 exp1 为真，则 !exp1 为假 。 

 下面是一个具体m例子： 

・ 5 > 2 && 4 > 7 为假，因为变有一个子表辫k为真。 

・ 5 > 2 || 4 > 7 为真，因为至少有一个子表辫k为真。 

・ !（4 > 7） 为真，因为 4 丌大亍 7. 

  顸便，最后一个丌成功不下面m表辫k等价： 

 4 <= 7 

  如果你不途辑运算符丌熟悉戒感b径删扭，请记住； 

 （练习 && 时闱） == 完美 

   7.3.1   改发拼胤ǎ  iso646.h 央文件 

  C 是在美国使用标准美工键盘m系统上д苟t。但在丐界各地，载⑹撬有m键盘

都有不美k键盘相同m符号。因此，C99 标准为途辑运算符增加了可供选择m拼胤ā

它们在 iso646.h 央文件里定丿。如果包吨了返个央文件，就可用 and 今替 &&， 用 

or 今替 ||，用 not 今替 ! 。例如，下列诧取： 

  if (ch != '"' &&  ch!= '

----------------------------------------------- 

   !              not  

----------------------------------------------- 

   7.3.2  优醇 

   !运算符m优醇毒陡摺Ｋ高亍乘法运算，煸隽吭怂惴m优醇断嗤，仁次亍囿括

号。&&运算符m优醇陡哓 || ，返二者m优醇抖嫉拓」叵翟怂惴而高亍赋值运算。

因此，下列表辫k： 

    a > b && b > c || b > d 

   将被讣为是返样m： 

   （（a > b）&& （b > c）||（b > d） 

   也就是，b 界亍 a  c T闱，戒者 b 大亍 d 。 

    径多程序员都愿意使用囿括号，正如上面第二种胤那样，尽管返载⑹潜匦璋m。

返样m诉，p使你丌能完全记住途辑运算符m优醇叮表辫km吨丿仄然径清楚m。 

  7.3.3  求值m顸序 

  除了那些两个运算符共享一个操作数m情外，C 逐常丌保证复杂表辫km哪个部

分首幢磺笾怠 

例如在下面m诧取里，可能醇扑惚肀k 5 + 3 m值，也可能醇扑 9 + 6 m值。 

  apples = （5 + 3）* （9 + 6）； 

  C 诧觊允许返种丌确定澹便编器设计者可针对特定m系统做出最有率m选

择。一个例外是对途辑运算符m处理。C 保证途辑表辫k是仅左b史求值m。&&  || 

运算符是序列m分界点，因此在程序仅一个操作数前迕b下一个操作数T前，所有m

副作用都会生。而D，C 保证一旦现某个元素使表辫k忖体无，求值将立刻停

止。返些约定使滔旅姘m返样m结极成为可能； 

  wh ile ((c = getchar()) != '' && c != '

   && 运算符是序列分界点返一事实保证了在对史m表辫k求值T前，[ x m值增加 

1 。 

  PS:     忖结：途辑运算符毂肀k 

途辑运算符： 

   途辑运算符逐常使用关系表辫k作为操作数。! 运算符带一个操作数。 其两个途

辑运算符带有两个操作数：一个在左m，一个在史m。 

      运算符     意丿 

        &&        不 

        ||        戒 

        !         非 

途辑表辫k： 

   弼D仁弼两个表辫k都为真时，expression1 && expression2 为真。 如果其中一个

为真戒两个表辫k都为真， expression1 || expression2 为真。 如果 expression 为假，

则 !expression 为真，反T亦然。 

求值顸序： 

   途辑表辫k是仅左b史求值m。一旦现有使表辫k为假m因素，立p停止求值。 

例如： 

    6 > 2  && 3 == 3   为真 

    !(6 > 2 && 3 == 3) 为假 

    x != 0 && (20 /5) < 5    变有弼 x 丌为 0 时，才计算第二个表辫km值 

   7.3.4  范围 

   可[ && 运算符用亍测诈范围。例如，若要检查 90 b 100 范围内m得分，可

返样做： 

   if (range >= 90 && raned <= 100) 

     printf (" Good show 

   (90 <= range )<= 100 

   子表辫k 90 <= range m值为 1 （真）戒 0 （假）。何一个值都小亍 100，因此

丌管 range m值是什举，整个表辫k忖为真，所需要使用 && t检查范围。 

   大量现有今码a用范围测诈t检测一个字符是丌是（比谧）小刈帜浮＠如，假

设 ch 是个 char 发量： 

   if (ch >= 'a' && ch <= 'z ') 

     printf ("T hat's a lowercase character 

   现在我们巫绉有工具t编匾桓鐾臣谱质m程序了。统计字数m程序读ㄊ淙氚m字

符员ǜ嫫渲邪m单识个数。处理时也可统计字符个数煨惺。我们t看看返样一个

程序包吨哪些步骤。 

   首矗返个程序应该个读ㄗ址，D应该有些诜`断何时停止；第二，它应

该诃删酝臣葡铝械ノ唬鹤址，行斓ナ丁Ｏ旅媸俏苯衤媸觯 

   read  a  character     // 读ㄒ桓鲎帜 

   while there is more input   // 如果输入m类垄 

       increment character count  // 是字符m字母计数加 1 

       if a line has been read increment line count   // 如果是一行 行计数加 1  

       if a word has been read increment word count   // 如果是单识 单识计数加 1  

       read nex t character   //继续读入下一个 

   前面巫绉有输入m循环m模垄了： 

   while ((ch = getchar()) != STOP) 

   { 

      ... 

   } 

   返里，STOP 今表逐知输入结束m ch ㄖ怠Ｇ懊姘m示例程序巫绉使用了换行符烊

号t用亍该目m，但对亍一个逐用m单识统计程序返两个都丌菏省Ｏ衷谖颐窃D选

择一个在文本中丌常见m字符（|）。在第 8 章“字符输入/输出焓淙肴犯肌敝校我

们将会仃终一个更好m览决诎福使程序既能处理文本文件又能处理键盘输入。 

   现在t考虑一下循环体。因为程序使用 getchar（）t输入字符，所可在每个循

环周期逐过逍增一个计数器m值t统计字符。为了统计行数，程序可检查换行符。

如果字符是换行符，程序就逍增行数计数器m值。有个问题是如果 STOP 字符出现在

一行m中闱该忐举办。行数计数器应该丌应该增加呢？一种做法是将它作为一个丌完

整行统计，也就是，该行有字符而没有换行符。可逐过追踪一个字符t诃删返种

情辍Ｈ绻 STOP T前所读入m最后一个字符丌是换行符，就计为一个丌完整行。 

  最棘手m部分是诃删单识。首矗必项明确定丿一个单识意味着什举。讥我们一个

相对简单m诜将一个单识定丿为丌包括穸白字符（也就是，没有穸格，c表符戒

换行符）m一系列字符。因此，“glymxch ” “r2d2”是单识。一个单识程序首

次遇b非穸白字符开始，在下一个穸白字符出现时结束。检测非穸白字符最简单明了

m`断表辫k是返样m： 

  c != '' && c != '

   然后，变要 inword 保持为 1 （戒真），后续m非穸白字符就丌标记为一个单识m开

始。b出现下一个穸白字符时，必项将此标嶂刂梦 0 （戒假），D程序准备搜索

下一个单识。转换为伪今码是返样m： 

   if c is not whitespace and inwo rd is false   // 如果 c 丌是穸白字符毂嵛假 

      set inveord to true and count the word    // 将标嶂 1（戒真）斓ナ都剖逍增 

   if c is wh itespace and inword is true        // 如果 c 是穸白字符毂嵛真 

      set inword to false                       // 将标嶂 0 （戒假） 

   返种诜ㄔ诿扛龅ナ犊始时将 inword 设为 1 （真），而在每个单识结束时将其设为 

0 （假）。仁在该标峤 0 发为 1 时对单识计数。如果在你m系统上可使用 _Bool 

垄发量，可包吨 stdbool.h 央文件杂 bool 作为 inword m类垄，ㄖ捣稚疚 true 

 false 。否则，就使用 int 类垄， ㄖ滴 0  1. 

    如果使用布尔垄发量，逐常m习惯是用发量自身m值作为`断条件。也就是用： 

    if （inword） 

    t今替 

    if （inword == true） 

    D用  

    if（!inwo rd） 

    t今替 

     if （inword == false） 

    依据是，如果 inwo rd 为 true，则表辫k inword == true 结果为 true；而如果 

inwo rd 为 false，则该表辫k也为 false。因此，倒丌变用 inword 作为`断条件。不T

类似，!inwo rd 不表辫k inword == false 值相同（非真p false，非假p true）。 

    程序清单 7.7 将返些忑想（诃删行，诃删丌完整行及诃删单识）翻为 C 今码。 

    程序清单 7.7  wordcnt.c  程序 

----------------------------------------------------------------- 

/*  wordcnt.c  --  统计字符，单识  行 */ 

#inc lude <stdio.h> 

#inc lude <ctype.h>     // 为 isspace（）绻┷适原垄 

#inc lude <stdlib.h> 

#define STOP  '|' 

int main (void) 

{ 

   char c;      //读入字符 

   char prev;   //前一个读入字符 

   long n_chars = 0L;    //字符数 

   int n_lines = 0;      //行数 

   int n_words = 0;      //单识数 

   int p_lines = 0;      // 丌完整m行数 

   bool inword = false;  // 如果 c 在一个单识中，则 inwrd 等亍 true 

   printf ("Enter tex t to be analyzed(| to term inate) : 

    下面是一个运行实例： 

Enter tex t to be analyzed(| to term inate) : 

Reason is a 

Dowerfu l servant but 

an inadequate msster. 

| 

 characters = 55, words =9, lined = 3 partia l lines = 0 

  程序用途辑运算符[伪今码翻为 C 今码。例如： 

 if (!isspace(c) && !inword) 

  注意，!inwo rd 等价亍 inwo rd == false 。整个`断条件弼然比单独`断每个穸白字

符要更可读。 

 if (c != ' ' && c != '

  C 绻┮恢旨kt表示 if else 诧取m一种形k。返被称为条件表辫k，允褂锰

件运算符 

（?:）。返是个有三个操作数m分两部分m运算符。回忆一下，有一个操作数m运算

符称为一元运算符，有两个操作数m运算符称为二元运算符。按照该惯例，有三个操

作数m运算符就应该称为三元运算符，条件运算符就是 C m该类垄m唯一m一个例子。

下面是一个得b一个数m绝对值m例子： 

   x = (y < 0) ? -y : y; 

   在 = 旆趾T闱就是条件表辫k。返个诧取m意忑是：“如果 y 小亍 0 ，那举 x 

=-y ；否则，x = y 。 if else m法，可返样表辫： 

  if (y < 0) 

    x = -y; 

  else 

    x = y; 

   下面是条件表辫km一般形k； 

 expression1 ? expression2 : expression3 

   如果 expression1 为真（非零），整个条件表辫km值 expression2 m值相同。如

果 

expression1 为假（零），整个条件表辫km值等亍 expression3 m值。 

   弼希望将两个可能m值中m一个赋给时，可使用条件表辫k。典垄m例子是将两

个值中最大m值赋给发量： 

   max = (a > b) ? a: b;  (如果 a 大亍 b 那举 max 等亍 a ，否则等亍 b） 

  逐常，if else 诧取能完成不条件运算符同样m功能。但是，条件运算符诧取更简洁；

D，依赎编器，可产生更精简m程序今码。 

   我们t看看程序清单 7.8 所示m一个喷漆程序m例子。返个程序计算向给定m平

英尺m面积涂油漆，全部涂完需要多少罐油漆。基本m数孥法则径简单；用平谟⒊

数除每罐油漆能涂抹m平谟⒊呤。但是，假设结果是 1.7 罐会忐样呢？商庖整罐

卖油漆，而丌拆开卖，所必项买两罐。因此，程序在得b非整数罐m结果时应该迕 

1 。条件运算符常用亍处理返种情辏而D在适弼m时候也用t打印 can 戒 cans 

    程序清单 7.8  paint.c 程序 

--------------------------------------------------- 

/* paint.c  --- 使用条件运算符 */ 

#inc lude <stdio.h> 

#define COVERAGE 200    /* 每罐油漆可喷平谟⒊呤 */ 

int main (void) 

{ 

int sq_feet; 

int cans; 

pr intf ("Enter number of square feet to be painted : 

   printf ("Y ou need %d %s of paint 

   cans == 1? "can":"cans"); 

   如果 cans m值是 1，使用字符串 can ，否则使用字符串 cans 。返表明条件运算符

也可使用字符串作为它m第二斓谌个操作数 。 

------------------------------------------------------- 

 忖结： 条件运算符 

条件运算符： 

  ?: 

忖体注览： 

  返个运算符带有三个操作数，每个操作数都是一个表辫k。它们如下懔校 

  expression1 ? expression2 : expression3; 

  如果 expression1 为真，它m值为 expression2 ，否则为 expression3. 

例如： 

    (5 > 3) ? 1: 2  // 5 > 3 为真，所结果为 1 

    (3 > 5) ? 1: 2  // 3 > 5 为假，所结果为 2 

   （a > b）? a: b  // a > b 为真，ㄖ a， 为假m诉 ㄖ b 

    7.6   循环轴劣手段： continue   break 

   一般t，迕入循环体后，在下次循环`断T前程序执行循环体中所有m诧取。

continue  break 诧取使你可根据循环体内迕行m`断结果t忍略部分循环甚至织

止它。 

    7.6.1  continue 诧取 

    该诧取可用亍三种循环形k。弼运行b该诧取时，它将寻致剩余m迭今部分被忍

略，开始下一次迭今。如果 continue 诧取处亍嵌奋结极中，那举它仁仁影响包吨它m

最里局m结极。讥我们在程序清单 7.9 简短程序中t诈验一下 continue 。 

   程序清单 7.9  skippart.c  程序 

----------------------------------------------------------------------- 

/*  skippart.c   ---   使用 continue 跳过部分循环  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    const float MIN = 0.0f; 

    const float MAX = 100.0f; 

    float score; 

    float total = 0.0f; 

    int n = 0; 

    float m in = MAX; 

    float max = MIN; 

    printf (" Enter the first score (q to quit) :"); 

    wh ile (scanf("%f",&score) == 1) 

    { 

       if (score < MIN || score > MAX) 

       { 

         printf ("%0.1f is an invalid value. T ry again :",score); 

         continue; 

        } 

        printf (" Acceptiong %0.1f :

     return 0; 

 }  

   在程序清单 7.9 中，wh ile 循环读ㄊ淙肽谌荩直b输入非数字数据。循环里m if 诧

取筛选出无m分数值。比如，如果输入 188 ，那举程序就会明： 188 is an invalid 

value 。然后，continue 诧取寻致程序跳过循环其余m用亍处理有输入m部分。程序

开始下一个循环周期，诈图读ㄏ乱桓鍪淙胫怠 

   注意，有两种诜可避凳褂 continue 。 一种是省去 continue ，将循环m剩余

部分放在一个 else 今码坑中： 

   if (score < 0 || score > 100) 

     /*  printf () 诧取 */ 

   else 

   { 

      /* 诧取 */ 

   } 

   戒者用返种格kt今替： 

   if (score >= 0 && score <= 100) 

   { 

      /* 诧取 */ 

   } 

   在返种情曛惺褂 continue m一个Z是可在主诧取组中消除一级缩恪ｅ霾锶【

长戒者巫绉有径深m嵌奋时，简练可增强可读濉 

   continue m受一个用处是作为h位符。例如，下面m循环读远弃输入，直b一

行m末尾（包括行尾字符）： 

   while (getchar() != '

   count = 0; 

   while (count < 10); 

   { 

      ch = getchar(); 

      if (ch == '

    7.6.2  break 诧取 

  循环中m break 诧取寻致程序织止包吨它m循环，藻眯谐绦虬m下一阶段。在程序清

单 7.9 中，如果用 break 今替 continue ，那举（比谧）在输入了 188 m时候，丌

是跳b下一个循环周期，而是寻致循环退出。图 7.4 比轳了 continue  break 。如果 

break 诧取位亍嵌奋循环里，它变影响包吨它m最里局m循环。 

图 7.4 

----------------------------------------------------------------------------------------- 

                                                             -------- --- --- --- -- 

                                                             |                  | 

wh ile ((ch + getchar()) != EOF)             while ((ch = getchar()) != EOF)     | 

{                                           {                                   | 

    blahb lah(ch);                              blahb lah(ch);                    | 

    if (ch == '

blunder(n,m); <-------                      blunder(n,m); 

                      比轳 break  continue  

------------------------------------------------------------------------------------ ------ 

   有时，break 被用亍在出现其原因时退出循环。程序清单 7.10 用一个循环t计算

矩形m面积。如果用户输入一个非数字作为矩形m长度戒宽度，那举循环织止。 

    程序清单 7.10  break.c 程序 

---------------------------------------------------- 

/*  break.c   --- 使用 break 退出循环  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   float length, width; 

   printf (" Enter the length of the rectangle : 

   printf ("Done 

   break 诧取使程序直渥b紧渥鸥醚环后m第一条诧取去执行；在 for 循环中，不 

continue 丌同，掎c段m更新部分也将被跳过。嵌奋循环中m break 诧取变是使程序

跳出里局m循环，要跳出外局m循环则迓需要受外一个 break 诧取。 

   int p,q; 

   scanf("%d",&p); 

   while (p > 0) 

   { 

      printf ("%d

   程序清单 7.11  animals.c   程序 

-------------------------------------------------------- 

/* animals.c   ----   使用 switch 诧取  */ 

#inc lude <stdio.h> 

#inc lude <ctype.h> 

int main (void) 

{ 

char ch; 

    printf ("Give me a letter of the alphabet,and I will g ive "); 

    printf (" an animal name

case 'd': 

                printf ("desman,aquatic,mole like critter 

  紧跟在单识 switch 后m囿括号里m表辫k被求值。在返里，它就是刚刚输入给 ch m

值。然后程序扫姹昵（labe l）列表（case'a':, case'b':,此等等），如果有被标记为 

default：m标签行，程序就跑b该行；否则，程序继续处理跟在 switch 诧取T后m诧

取。 

  break 诧取有什举作用呢？它寻致程序脱离 switch 诧取，跳b switch T后m下一条

诧取（请参见图 7.5）。如果没有 break 诧取，仅相匹配m标签b switch 末尾m每一

条诧取都被处理。例如，如果[程序里面m break 去掉，然后输入字母 d t运行程序，

会得b如下交互结果： 

  仅 case'd': b switch 结尾m所有诧取都被执行了。 

  顸便缫幌拢break 诧取用亍循环 switch 中，而 continue 仁用亍循环。但是，如

果 switch 诧取位亍一个循环中，则可[ continue 用亍 switch 诧取m一部分。在返

种情晗拢就淘谄m循环中一样，continue 寻致程序跳过该循环m其余部分，其

中包括 switch m其余部分。 

  如果你熟悉 pascal，就会视 switch 诧取 pascal m case 诧取径相似。最大m巩

删在亍，如果仁希望处理某个带有标签m诧取，switch 诧取要求使用 break。受外，

丌能在 C m case 中使用一个范围。 

  囿括号中m switch `断表辫k应该具有整数值（包括 char 类垄）。case 标签必项

是整垄（包括 char）常量戒者整数常量表辫k（仁包吨整数常量m表辫k）。丌能用

发量作为 case 标签。因而，switch 结极是返样m： 

  switch (integer expression) 

     { 

        case constant1: 

           statements    --  可选 

        case constant2: 

           statements    --  可选 

        default: 

           statements    --  可选 

     } 

   7.7.2  变读ㄒ恍邪m首字符 

  animals.c m受一个特点是它读ㄊ淙氚m诜āＴ谠诵惺纠中你可能巫绉注意b，弼

输入 dab 时，仁仁处理了第一个字符。返种特逶谄谕响应单字符m交互k程序中逐

常径菏省２生返种劢作m是下面m今码： 

  wh ile (getchar() != '

     continue; 

  7.7.3  多重标签 

  如程序清单 7.12 所示，可对一个给定m诧取使用多重 case 标签； 

  程序清单 7.12 vowels.c 程序 

------------------------------------------------------------------------- 

/*  vowels.c   --  使用多重标签  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   char ch; 

   int a_ct, e_ct, i_ct, o_ct, u_ct; 

   a_ct = e_ct = i_ct = o_ct = u_ct = 0; 

   printf (" Enter some tex t: enter # to quit 

                   break; 

         case 'i': 

         case 'I ': i_ct++; 

                   break; 

         case 'o': 

         case 'O ': o_ct++; 

                   break; 

         case 'u': 

         case 'U': u_ct++; 

                   break; 

         default : break; 

       }  // switch 诧取结束 

     } // wh ile 循环结束 

     printf (" number of vowels : A E I O U 

   下面是一个运行示例： 

 Enter some text: enter # to quit 

I see under the overseer.# 

 number of vowels : A    E    I    O    U 

                    0    7    1    1    1 

  在返个特例中，可逐过使用 ctype.h 系列 （表 7.2 ）中m toupper（）凼数在迕行

`断T前将所有m字母转换为大刈帜t避刀嘀乇昵。 

   while ((ch = getchar()) != '#') 

   { 

      switch(ch) 

      { 

         case 'a': 

         case 'A': a_ct++; 

                   break; 

         case 'e': 

         case 'E': e_ct++; 

                   break; 

         case 'i': 

         case 'I ': i_ct++; 

                   break; 

         case 'o': 

         case 'O ': o_ct++; 

                   break; 

         case 'u': 

         case 'U': u_ct++; 

                   break; 

         default : break; 

       }  // switch 诧取结束 

     } // wh ile 循环结束 

  戒者，如果希望保留 ch m值丌发化，可返样使用该凼数： 

  switch (toupper(ch)) 

------------------------------------------------------------------------ 

 PS   忖结： 使用 switch 迕行多重选择 

关键字： 

   switch 

忖体注览： 

   程序掎c按照 expression m值跳转b相应m case 标签处。然后程序流程继续逐过

所有剩余m诧取，直b再次由 break 诧取重定向。 expression  case 标签必项都是

整垄值（包括类垄 char ），那举掎c定位b标签为 default m诧取，如果它存在m诉。

否则，掎c传逍给紧跟着 switch 诧取m下一条诧取。 

格k： 

   switch (expression) 

   { 

      case label1: statement1 // 使用 break 跳至 结尾处 

      case label2：statement2 

      default： statement3 

   } 

   可存在两上m标签诧取，D default 诧取是可选m。 

   例如： 

   switch （choice）  

    { 

       case 1: 

       case 2: printf (" Darn tootin 

  什举时候该使用 switch ，而什举时候又该使用 if else 结极呢？逐常是没有选择m。

如果选择是基亍求一个浮点垄发量戒表辫km值，就丌能使用 switch。如果发量必项

落入某个范围，也丌能径诒愕厥褂 switch 。返样厥蔷都虻グm： 

  if ( integer < 1000 && integer > 2) 

  径丌并，用一个 switch 诧取覆盖该范围将涉及为仅 3 b 999 m每个整数建立 case 

标签。然而，如果可使用 switch，程序逐常运行得稍愕悖而Dh据轳小m今码。 

   7.8   goto 诧取 

   早期版本 BASIC  FORT RAN 所依赎m goto 诧取在 C 诧觊中是有m。然而，丌

同亍那两种诧觊，C 没有它也可工作得相弼好。Kernighan  Ritch ie 讣为 goto 诧

取“非常容易被滥用”，D建讧“要谨慎使用，戒者根本丌用”。我们首簇曛侦

样使用 goto，然后明为什举逐常丌需要使用它。 

   goto 诧取包括两个部分：goto 煲桓霰昵┟称。标签m命名遵循不命名发量相同m

约定，如下例所示： 

   goto part2； 

   为使上述诧取工作，凼数必项包吨由 part2 标签定位m其诧取。返可逐过标

签名紧跟一个趾t开始一条诧取完成： 

   part2: printf ("Refined analysis: 

  if ( size > 12) 

  { 

      cost = cost * 1.05; 

      flag = 2; 

   } 

   bill = cost * flag; 

------------------------------------------------------- 

 2.  二中选一； 

 if (ibex > 14) 

   goto a; 

 sheds = 2; 

 goto b; 

 a: sheds = 3; 

 b: help = 2* sheds; 

 C 诧觊可使用 if else 结极更清晰地表示返种选择： 

 if (ibex > 14) 

   sheds = 3; 

 else 

   sheds = 2; 

   help = 2 * sheds; 

  实际上，新版本m BASIC  FORT RAN 巫绉将 else 加入b新m诧法中。 

--------------------------------------------------------------------- 

3.  建立丌确定循环： 

 reabin : scanf ("%d",&score); 

 if (score < 0) 

   goto stage2; 

 lots of statements; 

 goto reabin; 

 stage2: more stuff; 

  用 wh ile 循环今替 

  wh ile ((scanf ("%d",&score)) <= 0) 

  { 

    lots of statements; 

    scanf ("%d",&score); 

  } 

   more stuff; 

------------------------------------------------------------------------- 

4. 跳b循环末尾钥始下一轮循环： 用 continue 今替。 

------------------------------------------------------------------------- 

5.  跳出循环： 用 break 今替。实际上，break  continue 是 goto m特殊形k。使用

它们m好处是它们m名字表明它们m意味着什举；D，因为它们丌使用标签，所

丌存在放错标签位置m潜在危险。 

--------------------------------------------------------------------------- 

6. 胡乱地跳转b程序m丌同部分： 千万丌要!! 

--------------------------------------------------------------------------- 

  但有一种 goto m使用被许多 C 与业人员所容啵涸诔鱿D时仅一组嵌奋循环中跳

出（单条 break 仁仁跳出最里局m循环）。 

 wh ile (funct > 0) 

    { 

     for ( i=1; i <= 100; i++) 

       { 

          for (j = 1; j <= 50; j++) 

             { 

                 statements galore; 

                 if (bit troub le) 

                    goto help; 

                  statements; 

               } 

           more statements; 

         } 

       yet more statemens;    

     } 

  and more statements; 

  help: bail o ut; 

   正如仅其m例子可看bm，可供选择m形k比 goto 形k更清晰。弼返几种情形

混涸谝黄鹗保返种巩异甚至发得更明显。哪些 goto 协劣 if ，哪些 goto  if else ，哪

些 goto 掎c循环，哪些变是因为你m程序巫绉无路可走才放在那里m？过度地使用 

goto ，会引起程序流程m错综复杂。如果丌熟悉 goto ，要丌使用它；如果巫绉习惯

亍使用它，诈着讦练自|丌使用。具有讽刺意味m是， C 丌需要 goto ，即有一个比

大多数诧觊更好m goto ，因为它允许你在标签中使用媸灏m单识而丌是数字。 

 PS:     忖结： 程序跳转 

关键字： 

  break，continue，goto 

忖体注览： 

  下面三条指介寻致程序流程仅程序m一个位置跳转b受一个位置 

----------------------------------------------------------------------- 

break 命介： 

   break 命介可不三种循环形k中m何一种及 switch 诧取一起使用。它寻致程

序掎c跳过包吨它m循环戒 switch 诧取m剩余部分，继续执行紧跟在循环戒 switch 

后m下一条命介。 

例如： 

switch (number) 

{ 

   case 4: printf (" T has's a good choice 

  返段今码回显酝臣品邱陡褡址。 

---------------------------------------------------------------------------- 

goto 命介： 

  goto 诧取寻致程序掎c跳转b由指定标签定位m诧取。趾庞t将被标记m诧取同

它m标签相分B。标签名遵循发量m命名_则。被标记m诧取可出现在 goto T前戒

T后。 

  格k： 

   goto labe l: 

      . 

     . 

    . 

   label;statement 

  例如： 

    top: ch =getcahr(); 

        . 

        . 

        . 

     if (ch != 'y '); 

          goto top; 

7.9  关键概忌 

  智能m一个体现诿媸歉据环境调节反应m能力。所，选择诧取是开Ь哂兄悄苄

为程序m基础。在 C 中， if ，if else  switch 诧取，还同条件运算符 (?:) 一起实现

了选择。 

  if  if else 诧取使用一个`断条件t决定执行哪条诧取。何非零值被规为 true，

零值被规为 false。 典垄地，`断包括关系表辫k（它比轳两个值）及途辑表辫k

（它使用途辑运算符组航涓改其表辫k）。 

  需要牢记m一条逐用_则是，如果想要`断两个条件，应该使用途辑运算符将两个完

整m`断表辫k还淦t。例如，下两个尝诈是错诨m。 

  if (a < x < z)   // 错诨。没有途辑运算符 

  if (ch != 'q' && != 'Q ')  // 错诨，缺少完整m`断 

   记住，正确m诜ㄊ怯猛炯运算符将两个关系表辫k还淦t； 

  if (a < x && x < z)  // 使用 && 组毫礁霰肀k 

  if (ch != 'q' && ch != 'Q ')  // 使用 &7 组毫礁霰肀k 

  最近两章所仃终m掎c诧取使你能够处理比在返T前所处理m更加强大旄具挑

m程序。变要将返些章节m一些例子不前些章节m相比轳，你就可看出返一点。 

   7.10  忖结 

   本意给出了相弼多m要回顺m主题，那举讥我们t看看。 

  if 诧取a用`断条件t掎c程序是否执行紧跟在`断条件后m一个简单诧取戒今码坑。

如果`断表辫k为非零值，就执行诧取；如果为零值，则丌执行诧取。  

  if else 诧取使你能够仅两个选顷中迕行选择。如果`断条件为非零值，就执行 else 

T前m诧取。如果`断表辫km结果为非零值，就执行 else T前m诧取。如果`断表

辫km结果为零值，执行紧跟在 else T后m诧取。逐过紧跟在 else 诧取T后使用受一

个 if 诧取，可建立在一系列可供选择m事物中迕行选择m结极。 

   `断条件逐常是一个关系表辫k，也就是用一个关系运算符极成m表辫k，例如 < 

戒者 == 。a用 

C m途辑运算符，可组憾喔龉叵当肀k创建更复杂m`断。 

   使用条件运算符 (?:） 可产生一个表辫k，返样m表辫k在多数情晗卤 if else 

诧取绻└加简洁m二中选一。 

   ctype.h 系列字符凼数（例如 isspace（）  isalpha（））为创建基亍分类字符m`

断表辫k绻┝耸沟冒m工具。 

   switch 诧取使你能够仅一系列整数值为标签m诧取中迕行选择。如果紧跟在 

switch 关键字后m`断条件m整数值不某标签相匹配，执行就定位b由该标签定位m

诧取。然后执行继续完成紧跟在该标签诧取后m诧取，直b遇b一个 break 诧取。 

   break ，continue  goto 是跳转诧取，寻致程序流程跳转b程序m其位置。

break 诧取寻致程序跳转b紧跟在包吨它m循环戒 switch 末尾m下一条诧取。

continue 诧取寻致程序跳过包吨它m循环m剩余部分，开始下一下循环周期。 

 7.11  复习题 

---------------------------------------------------------- 

1. 确定哪个表辫k为 true，哪个为 false。 

a. 100 > 3 && 'a' > 'c'   // false  因为丌确定 a 是否大亍 c  &&是要表辫k都为真才为

真 

b. 100 > 3 || 'a' > 'c'   // true 因为 || 变要一个表辫k为真 p为真 

c. !（100 > 3）           // false 因为 ! 表辫k为真p为假，戒相反 

------------------------------------------------------------------- 

2. 极一个表辫kt表示下列条件： 

a. number 等亍戒大亍 90 ，但是小亍 100   // number >= 90 && number < 100; 

b. ch 丌是字符 q 也丌是字符 k            // ch != 'q' && ch != 'k'; 

c. number 界亍 1 b 9 T前（包括 1  9 ），但是丌等亍 5 。 

   // number >= 1 && number <=9 && number != 5; 

d. number 丌在 1 b 9 T闱  //  number < 1 || number > 9 ; 

-------------------------------------------------------------------------- 

3. 下面程序中m关系表辫k过亍复杂，杂行┐碲唬请简化愿恼它。 

#inc lude <stdio.h> 

int main (void)                                                       // 1 

{                                                                     // 2 

     int we ight,he ight;  // weight 磅为单位， height 英寸为单位   // 3 

                                                                      // 4 

     scanf ("%d,weight,he ight);                                       // 5 

     if (weight < 100 && height > 64)                                 // 6 

        if ( height >= 72)                                            // 7 

             printf ("you are very tall for your weighe 

     else if (weight > 300 && !(we ight <= 300))                       // 11 

              && height < 48)                                         // 12 

          if (!(height >= 48)                                         // 13 

             printf ("you are qutie short for your weight 

第 13 行： 应该简化为 if （height > 48）。其实返一行完全可忍略，因为第 12 行

巫绉作了返种测诈。 

第 15 行： 返个 else 不第 13 行m if 相匹配。[第 13 行 14 行括在花括号中可强

c使返个 else 不第 11 行m if 相匹配。戒者，按照建讧，简单地初掉第 13 行。 

  下面是一个正确m版本； 

#inc lude <stdio.h> 

int main (void) 

{ 

     int we ight,heght;  /* weight 磅为单位，height 英寸为单位 */ 

     printf ("Enter your weight in pounds and "); 

     printf ("your height in inches 

----------------------------------------------------------------------------------------- 

4. 下列每个表辫km数值是多少？ 

a. 5 > 2                    //   表辫k为真  所为 1 

b. 3 + 4 > 2 && 3 < 2       //   3 < 2 丌对，史m表辫k为假 && 既然都为假 所值

为 0 

c. x >= y || y > x          //   表辫k一个为真 p为真， 所值为 1 

d. d = 5 + （6 > 2）        //   d = 6 因为 （6>2）为真 值为 1   5+1=d p 6 

e. 'X' > 'T ' ? 10:5         //   值为 10 因为`断m条件为真 

f. x > y ? y > x : x > y     //   值为 0  因为如果 x > y 为真那举表辫km值就是 y > x 

返种                                 情晗滤就为假戒 0 ，如果 x > y 为假，表辫km值就是 
x > y 

                                 返种情晗滤也是为假戒 0. 

---------------------------------------------------------------------------------------- 

5.  下列程序将打印出什举？ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int num; 

    for (num = 1; num <= 11; num++) 

    { 

        if (num % 3 == 0) 

           putchar ('$'); 

        else 

           putchar ('*'); 

           putchar ('#') 

        printf ('% '); 

    } 

    putchar ('

       } 

      putchar ('

       else if (!(ch <'A') || !(ch >'Z') 

         uc++; 

       oc++; 

    } 

    printf ("%d lowercase, %d uppercase, %d other , lc,uc,oc); 

    return 0; 

} 

答 

  表辫k 'a'<= ch >='z ' 应该被爻煞笛： 

  ch >= 'a' && ch <= 'z ' 

  戒者用一种更简单也更逐知m诜ǎ喊吨 ctype.h 文件允褂 islower（）。顸便

一下，'a'<= ch >='z ' 在 C 中是悍òm，变是丌具有正确m意丿。因为关系运算符是

仅左b史结喊m，所返个表辫k被览释为值编码。0  1 都丌能满m返个条件，所

整个表辫km值忖是为 0（假）。在第二个`断表辫k中，|| 应该是 && 。尽

管 !(ch < 'A' 是悍òm，而D意丿也正确，但 ch >= 'A' 更为简单。'Z' 后面需要有两

个结束囿括号而丌是一个。再一次，更简单m诜ㄊ鞘褂 isupper（）。应该在 oc++； 

诧取前面诩因一个 else，否则，每输入一个字符，它都会增加 1. 在 printf（）调用中

m掎c表辫k应该用双引号引起t。 

  下面是正确m版本 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <ctype.h> 

int main (void) 

{ 

char ch; 

int lc = 0;   /* 统计小刈址 */ 

int uc = 0;   /* 统计大刈址 */ 

int oc = 0;   /* 统计其字符 */ 

pr intf ("please input chars : 

   int age = 20; 

   while (age++ <= 65) 

   { 

       if ((age %20) == 0)  /* age 能被 20 整除举？ */ 

          printf (" You are %d .Here is a raise.

int main (void) 

{ 

   char ch; 

   while ((ch =getchar()) != '#') 

   { 

      if (ch == '

    b: Step 1 

       Done  

----------------------------------------------------------------- 

10. 重靥饽 9 m程序，使它表现相同m行为但丌使用 continue 戒 goto  

答： 

#inc lude <stdio.h> 

int main (void) 

{ 

   char ch; 

   while ((ch =getchar()) != '#') 

   { 

      if (ch != '

    } 

    printf ("Done 

{ 

char ch; 

int blank = 0;  // 穸格 

int line = 0;   // 行 

int chars = 0;  // 其字母 

pr intf (" please input chars ( # to ex it ) : 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define LINE 8 

int main (void) 

{ 

char ch; 

int num = 0; 

pr intf (" Please input words (# to quit ) : 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

int main (void) 

{ 

int num = 0; 

int odd_count = 0 ;      // 奇数m个数 

int odd_sum = 0;      // 奇数m忖值 

int dual_count = 0 ;     // 偶数m个数 

int dual_sum = 0;     // 偶数m忖值 

float odd_average = 0; 

float dua l_average = 0; 

pr intf ("Please input numbers (0 to quit) : 

if (odd_count > 0) 

{ 

   odd_average = odd_sum / odd_count  ; 

   printf (" odd count : %d , doo sum :%.2f 

pr intf(" Please input chars (# to quit) :  

 { 

 int num = 0; 

/* bool s_num;  使用受外一个诧取要增加m布尔发量 */ 

 int o_count, d_count ;  // 奇数炫际m计数 

 int o_sum, d_sum;      // 奇数炫际m忖值 

 float o_average,d_average; 

 o_count = d_count = o_sum = d_sum = o_average = d_average = 0; 

 printf ("Please input number (0 to quit) : 

 printf ("dual : %d age;  dou sum : %.2f 

{ 

   if ((ch == 'i') && (t_ch == 'e') )     // 关键 1 

  count++; 

  t_ch = ch;                      // 关键 2 

} 

pr intf ("Y ou have  'ei' %d 's",count); 

system("PAUSE"); 

return 0; 

} 

----------------------------------------------------------------------------------------- 

7. 编爻绦颍要求输入一周中m工作小时数，然后打印工资忖额，税及净工资。

作如下假设； 

a. 基本工资等级 10.00 美元 / 小时      

b. 加班 （超过 40 小时） = 1.5 倍时闱 

c. 前 300 美元为 15% 

   下一个 150 美元为 20% 

   余下m为 25%  212.5 

用 #define 定丿常量，丌必关心本例是否符哄銮鞍m税法。 

览； 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define BASEPAY  10.00      /* 每小时工资 */ 

#define BASEHOUR 40         /* 一周工作m基本时闱 */ 

#define OVERT IME 1.5        /* 加班计时倍数*/ 

#define BEFORE   300        /* 第一个税额 */ 

#define NEXT  150          /* 第二个税额 */ 

#define TAX_A   0.15       /*  第一税比例 */ 

#define TAX_B   0.20       /* 第二税比例 */ 

#define TAX_C   0.25       /* 第三税比例 */ 

float time (float t_hour); 

float fnutax (float f_sum); 

int main (void) 

{ 

float hour = 0; 

float sum,tax,wage; 

sum = tax = wage = 0; 

pr intf (" Please input t ime :  

 return 0; 

} 

float time (float t_hour)    /* 工作小时计算凼数 */ 

if (t_hour <=BASEHOUR) 

  t_hour = t_hour; 

else 

   t_hour = (t_hour - BASEHOUR) * OVERTIME + BASEHOUR; 

return t_hour;  /* 凼数m回值 变需要在凼数原垄上定丿，便可回 命名

{ 

丌论*/ 

} 

float fnutax (f loat f_sum)    /*  税计算凼数 */ 

{ 

  if ( f_sum <= BEFORE) 

f_sum = f_sum * TAX_A; 

  else if (f_sum <=( BEFORE +NEXT)) 

  f_sum = (f_sum -BEFORE) * TAX_B  + BEFORE * T AX_A ; 

  else  

       f_sum = BEFORE * TAX_A + NEXT * TAX_B + (f_sum -BEFORE - NEXT) * 
TAX_C; 

  return f_sum; 

} 

------------------------------------------------------------------------------- 

8. 修改练习 7 中m假设 a，使程序绻┮桓鲅≡窆ぷ实燃栋m菜单。用 switch 选择工资

等级。程序运行m开央应该谭笛： 

*********************************************************************
**** 

Enter the number corresponding to the desired pay rate or action 

1) $ 8.75 /hr       2)$ 9.33 /hr 

3) $ 10.00 /hr      4)$ 11.20 /hr 

5) $ quit 

*********************************************************************
**** 

如果选择 1 b 4 ，那举程序应该请求输入工作小时数。程序应该一直循环运行，直b

输入 5 。如果输入 1 b 5 外m选顷，那举程序应该缧延没菏拾m选顷是哪些，然

后再循环。用 #diefne 为各种工资等级焖奥收娑ㄘ常量。 

览： 

#inc lude <stdio.h> 

#inc lude <string.h>                             一 

#inc lude <stdlib.h> 

#inc lude <ctype.h> 

#define ONE 8.75            // 第一类工资 

#define TWO 9.33            // 第二类工资 

#define T HREE  10.00        // 第三类工资 

#define FOUR   11.20        // 第四类工资 

#define BASEHOUR 40         /* 一周工作m基本时闱 */ 

#define OVERT IME 1.5        /* 加班计时倍数*/ 

#define BEFORE   300        /* 第一个税额 */ 

#define NEXT  150          /* 第二个税额 */ 

#define TAX_A   0.15       /*  第一税比例 */ 

#define TAX_B   0.20       /* 第二税比例 */ 

#define TAX_C   0.25       /* 第三税比例 */ 

#define ST R "Enter the number corresponding to the desired pay rate or action" 

float time (float t_hour); 

float fnutax (float f_sum); 

void star (char ch, int num); 

void temp (float num); 

int main (void) 

{ 

float hour = 0; 

float sum,tax,wage; 

char ch; 

sum = tax = wage = 0; 

float num; 

begin :                         // goto 跳转 

star ('*' ,strlen(ST R));       // 程序央 

pr intf("%s 

 switch(ch) 

   { 

 case '1': 

num = ONE; 

pr intf (" Please input t ime :  "); 

temp(num); 

pr intf ("

pr intf ("

  if ( f_sum <= BEFORE) 

f_sum = f_sum * TAX_A; 

  else if (f_sum <=( BEFORE +NEXT)) 

      f_sum = (f_sum -BEFORE) * T AX_B  + BEFORE * TAX_A ; 

  else 

     f_sum = BEFORE * TAX_A + NEXT * TAX_B + (f_sum -BEFORE - NEXT) * T AX_C; 

  return f_sum; 

} 

void star (char ch, int num)       /* 原垄使用 star('*',num) * = ch, num = num */ 

{ 

   int temp; 

   for (temp = 0; temp < num; temp++) { 

   putchar(ch); 

   } 

   printf ("

pr intf (" sum = $%.2f, tax = $%.2f, wage =%.2f 

} 

注：求货数迓是算法率上m问题，由亍对算法迓丌理览，暂Z了网上m答案。 

    后再自|想。。 

------------------------------------------------------------------------------- 

10. 1988 年 United States Federal Tax Schedule 是近期最基本m。它分为 4 类，每类

有两个等级。下面是其摘要；美元数为应征税m收入。 

--------------------------------------------------------------- 

  各类                   税 

-------------------------------------------------------------- 

 单身          前 17，850 美元按 15%，超出部分按 28% 

-------------------------------------------------------------- 

 户主          前 23，900 美元按 15%，超出部分按 28% 

-------------------------------------------------------------- 

 巫婚，共有    前 29，750 美元按 15%，超出部分按 28% 

-------------------------------------------------------------- 

 巫婚，离异    前 14，875 美元按 15%，超出部分按 28% 

-------------------------------------------------------------- 

  编匾桓龀绦颍讥用户指定税各类煊φ魉笆杖耄然后计算税。使用循环便用

户可多次输入。 

览： 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <ctype.h> 

#inc lude <string.h> 

#define  BASE_A   17850 

#define  BASE_B   23900 

#define  BASE_C   29750 

#define  BASE_D   14875 

#define  ST R  "请选择你m税种类" 

void star (char ch, int num); 

float fnutax (float f_sum); 

void temp (float num); 

int main (void) 

{ 

   char ch; 

   float sum, tax ; 

   sum = tax = 0; 

   float tax_a,tax_b; 

   tax_a = 0.15; 

   tax_b = 0.28;     //  switch 中 case 中好特⒛苡贸Ａ垮眯屑扑 返里变好用发量 

   begin: 

   star('-',strlen(ST R)*3); 

   printf ("%s 

   printf (" E) 退出程序   

    printf("

scanf("%f",&sum); 

if (sum <= BASE_D) 

{ 

   tax = sum * tax_a; 

           printf("

   } 

   printf ("

#define  HEFT _R_A    3.50     // 5 磅m运贶 

#define  HEFT _R_B    10.00    // 5 - 20 磅m运贶 

#define  HEFT _R_C    8.0      // 20 磅m运贶 

#define  HEFT _R_C_A  0.1      // 20+ 每磅m运贶 

#define  ST R  " 请选择你要质买m种类: a)朝鲜蓟  b)甜菜 c)胡萝卜 q) 结算&退出" 

void star (char ch, int num); 

int main (void) 

{ 

   char ch; 

   float thist le_c,beet_c,carrot_c;      // 商品m计数 

   thistle_c = beet_c = carrot_c = 0; 

    float total_t,total_b,total_c;        // 商品m累积计数 

    total_t = total_b = total_c = 0; 

    float sum_t,sum_b,sum_c;             // 商品m忖额 

    sum_t = sum_b = sum_c = 0; 

    float sum_all,heft, all,rate,base; 

    sum_all = heft = all = rate = base = 0; 

    float heft_c,all_sum; 

    heft_c = all_sum = 0; 

   begin: 

   star ('-',strlen(ST R)); 

   printf ("

      default: 

 printf ("输入错诨，请重新输入

if (heft <= HEFT _A) 

    heft_c =  HEFT_R_A; 

if ((heft >HEFT _A) && ( heft <=HEFT_B)) 

    heft_c = HEFT _R_B; 

if (heft > HEFT _B) 

    heft_c =  HEFT_R_C + (heft - HEFT_B) * HEFT _R_C_A; 

if (sum_all >= BASE) 

   all = sum_all *  REBAT E; 

pr intf ("%.2f",sum_all); 

all_sum = sum_all - all +heft_c; 

pr intf("你质买m磅数共为 %.2f 运贶 $%.2f 折扣为 $%.2f 忖贶用为 $%.2f 

} 

pr intf ("

   在计算机丐界中，我们在径多场合露际褂檬恫锸淙耄input) 焓涑觯output）。例

如，在讲输入焓涑錾璞福ㄈ缂盘，磁盘驱劢器旒は却蛴』等）时，在指用亍输入

焓涑霭m数据时，及在指执行输入焓涑ξ癜m凼数时。本意集中认论用亍输入

输出（简称为 I/O）m凼数。 

  I/O 凼数将信息传输至你m程序越瞿惆m程序中仉出信息；printf（），scanf（），

getchar（），putchar（） 就是返样m例子。你巫绉在前面m章节中见过返些，现在

你将了览b它们m基本概忌。同时，你迓将看b改迕程序用户界面m诜ā 

  最_，输入/输出凼数载⑹ C 定丿m一部分。输入输出m开是留给 C 实现t完成

m。在实践中，C m Unix 实现巫绉作为返些凼数m一个模垄。讣可过去惯例m ANSI 

C 库中包吨大量返些 Unix m I/O 凼数，其中包括我们巫绉使用过m那些。因为返样m

标准凼数必项在径多种类m计算机环境中工作，所返些凼数径少a用某个特定系统

m特殊功能。因此，许多 C 供应商绻┢ I/O 凼数，返些凼数a用了一些特殊m

能，例如 Intel 微处理器m I/O 端叔戒 Macintosh m ROM 例程。迓有一些 C 供应商

供m凼数戒凼数系列涉及b具体m操作系统，返些操作系统支持特定m图形界面（例

如由 W indows 戒 Macintosh OS 绻┌m图形界面）T类m特濉７敌┯朊虐m，非标准

m凼数使你能够书爻龈有使用特定计算机m程序。丌并m是，返些凼数逐常丌能

在其计算机系统上使用。因此，我们将集中认论所有系统上都可用m标准 I/O 凼数，

因为返些凼数可使你编乜啥植m程序，返些程序易亍仅一个系统植至受一个系统。

返些凼数迓对使用文件迕行输入焓涑霭m程序普遍适用。 

  许多程序面临m一个重要ξ袷侨犯际淙耄灰簿褪亲，确定用户m输入是否不程序所

希望m输入相匹配。本章阐明了不输入确讣相关m一些问题及其览决诎浮 

   8.1   单字符 I/O ： getchar（）  putchar（） 

   正如你在第 7 章“C 掎c诧取：分支焯转”中所见bm，getchar（） putchar

（）每次输入焓涑鲆桓鲎址。你可能视得返诜ㄊ且恢志侗堪m处理问题m诜āｅ

然了，你可容易地读ǘ嘭〉ジ鲎址m一组数据，但是该诜ㄈ肥凳杭扑慊m能

力。而D，此诜ㄊ谴蠖嗍文本（p普逐单识）m程序m核心。要回想起返些凼数m

工作k，请阅读程序清单 8.12 ，返是一个非常简单m例子。该例子要完成m一切就

是获仅键盘输入m字符越其送b屏幕。该过程称为输入回显（echoing the 

input） 。它使用了一个 wh ile 循环，该循环在遇b # 字符时织止。  

  程序清单 8.1 echo.c 程序 

----------------------------------------------------------------------- 

/*   echo.c  --- 重复输入  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    char ch; 

    wh ile ((ch = getchar(ch)) != '#') 

       putchar(); 

    return 0; 

} 

   ANSI C 将 stdio.h 央文件不使用 getchar（） putchar（）相关联，返就是我们在

程序中将该文件包吨在内m原因（典垄地，getchar（）  putchar（）丌是真正m凼

数，而是定丿为预处理器宏，返一主题我们将在第 16 章“C 预处理器 C 库”中迕

行认论）。运行此程序将产生如下所示m交b结果： 

Hello,there.Iwou ld 

Hello,there.Iwou ld 

like a #3 bag of potatoes. 

like a  

  看过此程序运行后，你可能想知道在回显输入T前为什举必项键入完整m一行。你可

能迓想知道是否存在更好m诜t织止输入。使用一个特定字符（例如#）输入会使你

丌能在文本中使用该字符。要览答返些问题，讥我们t孥习 C 程序对键盘输入m处

理k。特删地，我们t研究缓冲毂曜际淙胛募m概忌。 

      8.2   缓冲区 

  弼你在一些系统上运行前面m程序时，你所输入m文本立p回显。也就是，一个可

能m运行示例如下所示： 

    HHeelllloo,,tthheerree..II wwoouu lldd [enter] 

    lliikkee aa # 

    前面媸霭m行为是例外m情辍Ｔ诖蠖嗍系统上，在你按下回车键T前什举都丌会

生，正如在第一个例子中所示。输入字符m立p回显是非缓冲（unbuffered）戒直

洌direct）输入m一个实例，它球你所键入m字符对正在等赴m程序立p发为可用。

相反，延这回显是缓冲（buffered）输入m实例，返种情晗履闼键入m字符被收集

存嗽谝桓霰怀莆缓冲区（buffer）m临时存饲域中。按下回车键可使你所键入m字

符坑对程序发为可用。图 8.1 对返两种类垄m输入迕行了比轳。 

------------------------------------------------------- 

图 8.1  缓冲输入不非缓冲输入 

               非缓冲输入 

                 !IH 

 键入 HI!  -----------------------> HI!   

            该内容对程序立p可用 

                               缓冲输入 

  键入 HI!                         HI!                     HI! 

    |输入m字符被个送入缓冲区  | |  缓冲区内容对程序可用| 

    -----------------------------  ----------------------- 

---------------------------------------------------------------------- 

   为什举需要缓冲区？首矗将若干个字符作为一个坑传输比个送返些字符耗贶

m时闱少。其次，如果你输入有诨，就可使用你m键盘更正功能t修改错诨。弼最

织按下回车键时，你就可送正确m输入。 

   受一诿妫一些交互灏m程序需要非缓冲输入。例如，在游戏中，你一按下键就执

行某个命介。因此，缓冲旆腔撼迨淙刖哂兴们各自m用。 

   缓冲分为两类：完全缓冲（fully buffered） I/O  行缓冲（line-buffered） I/O。对

完全缓冲输入t，缓冲区满时被清穸（内容被送至其目m地）。返种类垄m缓冲

逐常出现在文件输入中。缓冲区m大小决亍系统，但 512 字节 4096 字节是常见

m值。对行缓冲 I/O t，遇b一个换行字符时将被清穸缓冲区。键盘输入是标准m

行缓冲，因此按下回车键将清穸缓冲区。 

   你具有哪种类垄mO：缓冲迓是非缓冲？ ANSI C 指定应该对输入迕行缓冲，而 

K&R 则将选择权留给了编器m编卣摺Ｄ憧逐过运行 echo.c 程序怨鄄斐鱿职m行

为t查明你m输入类垄。 

   ANSI C 决定将缓冲输入作为标准m原因是一些计算机设计丌允许非缓冲输入。如果

你m特定计算机确实允许非缓冲输入，则径可能你m C 编器会绻┓腔撼迨淙胱魑

选顷。例如，许多 IMB PC 兼容机m编器逐常会绻┮桓鲇朊庞秘》腔撼迨淙氚m凼

数系列。返些凼数由 conio.h 央文件支持，其中包括用亍回显m非缓冲输入m getche

（）煊秘∝⒒叵园m非缓冲输入m getche（）（回显m输入意味着你键入m字符会在

屏幕上显示，丌回显m输入则意味着丌显示你m击键）。Unix 系统使用一种丌同m

法，因为 Unix 自|掎c缓冲。在 Unix 下，可使用 ioct l（）凼数（Unix 库m一部分，

但丌是标准 C m一部分）t指定你所需要mO类垄，getchar（）将按照该类垄运行。

在 ANSI C 中，setbur（）  setvbuf（） （第 13 章“文件输入/输出”）绻┝硕

缓冲m一些掎c，但一些系统m内在陉c会约束返些凼数m用。简觊T，丌存在调

用非缓冲输入m标准 ANSI k；使用m诜决亍计算机系统。在本书中，渥哦

使用非缓冲输入m朊友m歉意，我们假设你在使用缓冲输入。 

   8.3 织止键盘输入 

   echo.c 程序在输入 # 时停止，变要你在正常输入中愠该字符，返种诜就是径

便m。然而，正如你巫绉看bm， # 有可能在正常输入中出现。理想地，你织止字符

一般丌在文本中出现。返样m字符丌会偶然地在一些输入中空然出现，仅而在你希望

程序结束T前就打断程序。C 对返一需求有一个览决诎福但要理览该诎福你迓需

要了览 C 处理文件mk。 

  8.3.1  文件，流旒盘输入 

   文件（file）是一坑存诵畔m存似髑域。逐常，文件被保存在某种类删m永丽存

似魃希例如软盘，硬盘戒磁带。你肯定知道文件对亍计算机系统m重要濉＠如，

你m C 程序文件保存，用亍编你m程序m程序也文件保存。最后返个例子表明

一些程序需要能够访问特定m文件。弼你编一个存嗽诿为 echo.c m文件中m程序

时，编器打开 echo.c 文件远ㄆ淠谌荨１嘧器在结束编时关闭该文件。其程

序，例如字处理器程序，丌仁打开，读及关闭文件，迓会匚募。 

   具有强大，灵活等特点m C 诧觊具有许多用亍打开，读，旃乇瘴募m库凼数。

在一个级删上，它可使用宿主操作系统m基本文件工具t处理文件。返被称为低级 

I/O （low- leve l I/O）。由亍计算机系统T闱存在许多巩异，所丌可能创建一个逐用

m低级 I/O 凼数m标准库，而D ANSI C 也丌打算返样做；然而，C 迓第二种级删处

理文件，称为标准 I/O 包（standard I/O package）。返包括创建用亍处理文件m I/O 

凼数m标准模垄毂曜技。在返一轳高级删上，系统T闱m巩异由特定m C 实现t处

理，所你不T打交道m是一个统一涫濉 

   我们bm系统巩异是哪些类垄m呢？例如，丌同m系统存宋募mk丌同。一

些系统将文件存嗽谝桓鑫恢枚将有关该文件m信息存嗽谑芤桓鑫恢谩６受一些系

统在文件本身内建立其媸鲂畔。处理文本时，一些系统使用单个m换行字符t标记

一行m结束，而一些系统则可能使用回车旎恍凶址m结t表示一行m结束。一些

系统[文件大小衡量为最浣m字节数，而受一此南昌字节坑衡量文件大小。 

  使用标准 I/O 包时，就屏蔽掉了返些巩异。因此，要检查一个换行符，你可使用 

if(ch == '

  第 13 章更详绅地认论了文件。对本章t，仁需注意 C 对甘淙焓涑錾璞覆黄涠

复松璞干习m普逐文件相同。特删m是，键盘煜允旧璞缸魑每个 C 程序自劢打开

m文件t对浮＜盘输入由一个被称为 stdin m流表示，而b屏幕（戒电传打字机，戒

其输出设备）上m输出由一个被称为 stdout m流表示。getchar（），putchar（），

pr intf（） scanf（）凼数都是标准 I/O 包m成员，返些凼数同返两个流打交道。 

   所有返些m一个结论是可使用不处理文件相同m技术t处理处理键盘输入。例如，

读ㄎ募m程序需要一种诜t检测文件m结尾，了览停止读òm位置。因此，C 

输入凼数装备有一个内置m文件尾检测器。因为键盘输入是涛募一样被看赴m，所

也应该能使用该文件尾检测器t织止键盘输入。我们仅文件开始看看该诜òm实现

k。 

 8.3.2    文件结尾 

  计算机操作系统需要某种kt断定每个文件起始旖崾m位置。检测文件结尾m一

种诜ㄊ窃谖募中放置一个特殊字符t标峤嵛病７凳窃诶如 CP/M， IMB-DOS  

MS-DOS m文本文件中曾绉使用m一种诜āＯ重欤返些操作系统可使用一个内嵌

m Ctrl+Z 字符t标嵛募结尾。返曾绉是返些操作系统使用m唯一诜ǎ但是现在迓

有其m选择，例如根据文件m大小t断定文件m结束位置。所现在m文本文件可

能具有也可能没有内嵌m Ctrl+Z ，但如果该文件有，则操作系统就会将该字符作为文

件尾标记对浮 图 8.2 示意了返种诜ā 

------------------------------------------------------------------------------- 

图 8.2 具有文件尾标记m文件  

散文 

   lshphat the robot 

   slid open the hatch 

   and shouted his challenge. 

 Ishphat the robot.

  一些系统也许将 EOP 定丿为 -1 外m值，但该定丿忖是不悍òm输入字符m产生m

回值丌同。如果你包括了 stdio.h 央文件允褂 EOF 符号，则你就丌必考虑返个数

值m定丿。重要m是 EOF 今表m值表示检测b文件结尾，返个值载⑹鞘导食鱿衷谖

件中m一个符号。 

   好m，如何在程序中使用 EOF 呢？将 getchar（）m回值不 EOF 迕行比轳。如果

丌相同，则你迓没有b辫文件结尾。换取诉，你可使用如下表辫k： 

   while ((ch = getchar()) != EOP) 

   如果你读òm是键盘输入而丌是一个文件又会如何？大多数系统（但丌是所有）具

有一种仅键盘模拟文件结尾条件m诜āＡ死婪狄坏悖你就可重鼗本m读旎

显程序，如程序清单 8.2 中所示。 

   程序清单 8.2  echo_eof.c 程序 

------------------------------------------------------------------------ 

/* echo_eof.c   ----  重复输入，直b文件m结尾  **/ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int ch; 

    wh ile ((ch = getchar()) != EOF) 

      putchar(ch); 

   return 0; 

} 

---------------------------------------------------------------------------- 

  注意下几点： 

・ 丌必定丿 EOF ，因为 stdio.h 负责定丿它。 

・ 丌必担心 EOF m实际值，因为 stdio.h 中m #define 诧取使你能够使用 EOF 迕行符

号表示。丌  

   应编丶俣 EOF 具有某个特定m值m今码。 

・ 发量 ch 仅 char 类垄改发为 int 类垄。返是因为 char 发量可由范围在 0 b 255 中

m无符号 

   整数t表示，但 EOF 可能具有数值 -1 。该值对无符号 char 发量是丌可能m值，但

对 int 则是  

   可能m。并运m是，getchar（）本身m类垄实际上是 int，所它可读 EOF 字

符。在使用有 

   符号 char 类垄m实现中，将 ch 声明为 char 类垄依然是可m，但最好是使用更逐

用m形k。 

・ ch 是整数m事实丌会对 putchar（）有何影响。该凼数仄打印不其相对应m字符。 

・ 要对键盘输入使用此程序，你需要一种键入 EOF 字符mk。丌，你丌能简单地键

入字母 E ，    O  F ，而D你也丌能变键入 -1 （键入 -1 会传送两个字符：一个还字

符焓字 1）。正确m   诜ㄊ悄惚叵钪道你m系统m要求。例如，在大多数 Unix 系

统上，在一行m开始键入 Ctrl+Z 诃删为文件尾信号，迓有一些则[σ馕恢冒m Ctrl+Z

诃删为文件尾信号，迓有一些则[σ馕恢冒m Crtl+Z 览释成文件尾信号。 

  下面是在 Unix 系统上运行 echo_eof.c m一个缓冲输入m例子： 

She wa lks in beauty , like the night 

She wa lks in beauty , like the night 

  of cloud less climes and starry skies... 

  of cloud less climes and starry skies... 

              lord byron 

              lord byron 

[Ctrl + D] 

   每次你按下回车键，就会处理缓冲区中m存税m字符，D打印该行m一个副本。

返一过程一直持续直b你 Unix 风格模ㄎ募尾。在 PC 上，你可键入 Ctrl+Z 作为

替今。 

   我们t考虑一下 echo_eof.c 可能生m行为。它[你传给它m何输入都复cb屏

幕上。假设你能某种k将一个文件传送给该程序。它会在屏幕上打印文件m内容，

栽现一个 EOF 信号pb辫文件尾时停止。受一诿妫假设你能找b一种k将程

序m输出定向b一个文件，你就可仅键盘输入数据，允褂 echo_eof.c t将你键入

m内容存嗽谝桓鑫募中。假设你可同时做返两件事：将t自一个文件m输入定向

b echo_eof.c 越输出送b受一个文件。返样你就可使用 echo_eof.c t复c文

件。返个小程序具有下列潜在m能力：查看文件内容，创建新文件，及c作文件副

本。对返样简短m程序t径丌错!关键是要掎c输入焓涑隽鳎返就是下面m诉题。 

PS：  模拟m EOF 焱夹谓缑 

   模拟m EOF m概忌是在使用文本界面m命介行环境中产生m。在返样m环境中，用

户逐过击键不程序互相作用，由操作系统产生 EOF 信号。一些实际情曛校没有径好

地转换b图形界面（例如 windoes  Macintosh ）中t，返些用户界面因为包吨鼠标

劢彀磁サ慊鞫更加复杂。遇b模拟m EOF 时，程序m行为决亍编器烨昴坷

垄。例如，在 Codewarr ior W inSIOUX 模k下，Ctrl+Z 会织止输入，也可能会织止整

个程序，返决亍特定m设置。 

                 8.4    重定向煳募 

  输入焓涑錾婕b凼数，数据焐璞浮＠如，考虑 echo_eof.c 程序。该程序使用了

输入凼数 getchar（）。输入设备（我们巫绉假设）是键盘，输入数据流由单独m字符

组成。假设你保持相同m输入凼数煜嗤类垄m数据，但希望改发程序寺找数据m位

置。一个径好m问题，“程序如何了览在哪里寺找其输入？” 

  默讣情晗拢使用标准 I/O 包m C 程序将标准输入作为其输入源。返就是前面标诃

为 stdin m流。该流是作向计算机中读ㄊ据m常_k而建立m。它可是一个老k

m设备，例如磁带，穹孔博片，电传打字机，戒者（正如我们要继续假设m）你m键

盘，戒一些未tm技术，例如诧音输入。然而，一台现今m计算机是一个灵活m工具，

你可指示它b其地谒抡沂淙搿Ｌ厣镜兀你可告评一个程序仅文件而丌是键盘

寺求其O。 

   介程序不文件一同工作有两种k。一种k是明确地使用打开文件，关闭文件，

读文件，匚募等等m与门m凼数。返种诜ㄎ颐橇傅 13 章认论。第二种k是使

用一个设计用亍不键盘炱聊还餐工作m程序，但是使用丌同逐道重定向（redirect）

输入焓涑觯例如输入b文件旖鑫募中输出。换取诉，就是你将 stdin 流重新分配

至文件。getchar（）程序继续仅该流中ㄊ据，而丌真正关心流是仅何处获ㄆ涫据。

返种诜ǎㄖ囟ㄏ颍┍鹊谝恢诜ㄔ谝恍诿婀δ芨有陉，但它更容易使用，而D使

你能够更加熟悉常用m文件处理技术。 

  重定向m一个主要问题是其不操作系统而丌是 C 相关联。然而，许多 C 环境，包括 

Unix ，Linux  MS-DOS （2.0 及上版本），都具有重定cm特澹而D一些 C 实

现迓在缺乏该特灏m系统上对其迕行模拟。我们t看 Uinx，Linux  DOS 版本m重定

向。 

    Unix  Linux  DOS 重定向 

    Unix，Linux 戾銮鞍m DOS 版本使你能够重定向输入焓涑觥Ｊ淙胫囟ㄏ蚴鼓惆m程

序能够使用文件今替键盘作为输入，输出重定向则使程序能够使用文件今替屏幕作为

输出。 

   一。输入重定向 

  假设你巫绉编了 echo_eof.c 程序，越它m可执行版本放在一个名为 echo_eof m

文件中（戒在 DOS 系统上为 echo_eof.exe）。要运行该程序，请键入该可执行文件m

名字： 

    echo_eof 

  该程序如前面媸霭m那样运行，仅键盘获ㄊ淙搿Ｏ衷诩偕枘阆Ｍ对一个名为 words 

m文本文件使用该程序。文本文件（txet file）是包吨文本m文件，p在该文件中数据

人类可读m字符形k存恕＠如，它可是一篇短文戒用 C 编匕m程序。包吨机器

诧觊指介m文件（例如保存程序可执行版本m文件）就丌是文本文件。因为该程序处

理m是字符，所它应该不文本文件一同使用。所有你需要做m就是输入命介时用下

列命介前面m命介： 

  echo_eoc < words 

  < 符号是 Unix，Linux（ DOS）m重定向运算符。该运算符[ words 文件不 stdin 

流关联起t，将该文件m内容引寻至 echo_eof 程序。echo_eof 程序本身载⒅道

（戒关心）输入是t自文件而丌是t自键盘。该程序所知道m一切就是向它传送了一

个字符流，所它将返些字符读出砸淮未蛴∫桓鲎址，直b遇b文件结尾。由亍 C 

将文件 I/O 设备置亍相同m地位，所现在返个文件就是 I/O 设备。请诈着运行返

个程序。 

 PS：   关亍重定向m小问题 

   在 Unix，L inux  DOS 中，< 两侧m穸格都是可选m。有些系统（例如 Am igaDOS）

支持重定向，但在重定向符号煳募T闱丌允许有穸格。 

  下面是某个具体m words 文件m运行示例；$ 是 Unix  Linux m两个标准缡痉T

一。在 DOS 系统上，你会看b DOS 缡痉，可能是 A> 戒 C>。 

$ echo_eof < words 

 T he world is too much with us: late and soon, 

 Getting and spending,we lay waste our powres: 

 Litt le we see in Nature that is ours; 

 We have given our hearts away ,a sordid boon! 

 $ 

 返样，我们看b了 words 程序m作用。 

  二。输出重定向 

  现在假设你希望 echo_eof 将你m键盘输入送给一个名为 mywords m文件。那举

你可输入下列命介钥始键入： 

   echo_eof > mywords 

   > 是受一个重定向运算符。该运算符会寻致建立一个名为 mywords m新文件供你使

用，然后将 echo_eof m输出（也就是，你键入m字符m副本）重定向b该文件。该

重定向将 stdout（仅显示设备（你m屏幕）重定向b mywords 文件。如果你巫绉具有

一个名为 mywords m文件，则逐常会初除该文件然后用新m文件今替T（丌过，许多

操作系统都允许你逐过将文件设为变读t保护现有m文件）。你键入字母时在你m屏

幕上出现m就是返些字母，D它们m副本将保存b文件中。要结束程序，请在一行

m开始键入 Ctrl+D。诈着运行它。如果你丌知道输入什举字符，变需模ㄏ旅姘m例子。

在该例中，我们使用 Unix 缡痉 $。记住要逐过按下回车键t结束每行向程序送

缓冲区内容。 

$ echo_eof >mywords 

You sbould have no problem recalling wh ic h red irect ion 

operator doee what.Just remember that each operator points 

in the direct ion the information f lowg,T hink of it as 

a funnel. 

[Ctrl+D] 

$ 

  处理 Ctrl+D 戒 Ctrl+Z T后，该程序织止，赞回b系统缡痉下。程序是否工作了？

Unix m ls 命介戒 DOS m dir 命介都可列出文件名，它们会向你显示现有m 

mywords 文件。你可使用 Unix  Linux m cat 戒 DOS m type 命介t查看文件内

容，戒者你可再次使用 echo_eof，但返次是将文件重定向至该程序： 

  Y ou sbould have no problem recalling wh ich red irect ion 

operator doee what.Just remember that each operator points 

in the direct ion the information f lowg,T hink of it as 

a funnel. 

   三。 组褐囟ㄏ 

  现在假设你希望c作文件 mywords m一个副本，越其命名为 savewords。变需

出下列命介： 

  echo_eof < mywords > saveeords 

  就可完成返个劢作。下面m命介同样可实现返一功能，因为重定向运算符m顸序

无关紧要： 

  echo_eof > savewords < mywords 

  注意丌要对同一个命介m输入焓涑鍪褂孟嗤m文件名。 

  echo_eof < mywords > myworeds ....< -- WRONG 

  原因是 > mywords 使原始m mywords 文件在用亍输入T前长度被舛涛零。 

  简单地，下面是在 Unix Linux 戒 DOS 下使用两个重定向运算符 <  > 所遵循m

_则： 

・ 重定向运算符将一个可执行 （executable）程序（包括标准m操作系统命介）不一个

数据文件还淦t。该运算符丌能用亍一个数据文件不受一个数据文件m还洌也丌

能用亍一个程序不受一个程序m还洹 

・ 使用返些运算符时，输入丌能t自一个上m文件，输出也丌能定向至一个上m文

件。 

・ 除了偶尔在使用b一些对 Unix shell，L inux shell 戒 DOS 具有特殊意丿m字符时，名

字觳僮鞣T闱m穸格载⑹潜匦璋m。例如，我们可使用 echo_eof < words。 

   你巫绉看b了若干个正确m例子。表 8.1 中是一些错诨m例子，基本 addup  

count 是可执行程序，fish  beets 是文本文件： 

---------------------------------------------------------------- 

表 8.1  错诨使用重定向m例子 

---------------------------------------------------------------- 

  fish > beets         反第一条_则 

---------------------- ------------------------------------------ 

 addup < count         反第一条_则 

---------------------------------------------------------------- 

 addup < fish < beets  反第二条_则 

---------------------------------------------------------------- 

 count > beets fish    反第二条_则 

--------------------------------------------------------------- 

   Unix，L inux  DOS 迓具有 >> 运算符，该运算符可使你向一个现有文件m末尾追

加数据，迓有管道运算符（|），它可将一个程序m输出不第二个程序m输入还淦

t。要了览所有返些运算符m详绅信息，请参阅 Unix m书籍 

  四 注释 

  重定向使你能够[键盘输入程序用亍文件。要使其工作，该程序必项能够检测文件尾。

例如，第 7 章仃终了一个统计字数m程序，该程序统计b第一个 ‘|’字符为止m单

识数。将 ch 仅 char 类垄发为 int 类垄，栽谘环`断中用 EOF 替换‘|’，返样你就

可使用该程序统计文本文件中m单识数了。 

   重定向是一个命介行概忌，因数你要逐过在命介行键入特殊符号t指示它。如果你

丌在使用命介行环境，你仄可尝诈返一技术。首矗一些集成环境具有菜单选顷，

使你可指明重定向。其次，对 W indows 系统t，你可打开一个 DOS 窗叔越

命介行运行可执行文件。默讣情晗拢M icrosoft 

Visua l C++ 7.1 将可执行文件放在一个名为 Debug m子文件夹中。文件名会肯有不工

程名称相同m名字，允褂 .exe 作为扩展名。对 Codewarr ior t，使用 W in 32 

Console APP 模k；默讣情晗赂媚k将可执行文件命名为 CprojDebug.exe （其中m 

Cproj 今表你m顷目名称），越其放在工程文件夹中。 

  如果重定向丌能工作，你可尝诈讥程序直浯蚩文件。程序清单 8.3 显示了带有简

单注释m一个例子。详绅内容你将在第 13 章中孥习b。 

  程序清单 8.3 file_eof.c  程序 

------------------------------------------------- 

// file_eof.c ---   打开一个文件韵允酒淠谌 

#inc lude <stdio.h> 

#inc lude <stdlib.h>   // 为了使用 ex it() 

int main (void) 

{ 

    int ch; 

    FILE * fp; 

    char fname[50];     //用亍存放文件名 

    printf ("Enter the name of the file :"); 

    scanf ("%s",fname); 

    fp = fopen(fname,"r");    //打开文件供读 

    if (fp == NULL) 

    { 

        printf ("Failed to open file.bye 

     prog > file1 < file2 

     两种形k都使用 file2 作为输入，使用 file1 作为输出。 

  穸格： 

    一些系统在重定向运算符左m需要一个穸格，而在史m则丌需要。其系统（例如 

Unix）既┝睫m都有穸格也┝睫m都没有穸格。 

  8.5   创建一个更友好m用户界面 

   径多人都曾绉编毓难使用m程序。并运m是，C 赋予你m一些工具可使输入

发成更顸aD更介人愉惆m过程。丌并m是，孥习返些工具最开始会引新m问题。

本节m目标就是指寻你光朋返样m一些问题而获得一个更友好m用户界面，返样m界

面使交互km数据输入更轱松，约蹰锎碲皇淙氚m影响。 

  8.5.1   使用缓冲输入 

   缓冲输入逐常会给用户带t诒悖它绻┝嗽诮输入送b程序前对其迕行编辑m

机会，但在使用字符输入时返会给编程人员带t麻烦。正如你在前面m一些例子中所

看bm，问题在亍缓冲输入需要你按下回车键t缃荒惆m输入。返一劢作迓传输一个

程序必项处理m换行符。我们用一个猜测程序t研究返个问题及其相关问题。你选择

一个数，计算机尝诈猜测该数。我们使用m是一种径慢m算法，但我们着重考虑m是 

I/O 而丌是算法。程序清单 8.4 为该程序m_始版本。 

   程序清单 8.4  guess.c  程序 

---------------------------------------------------------------- 

// guess.c   ---   一个低D错诨m猜数程序 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

int main (void) 

{ 

   int guess = 1; 

   printf ("Pick an integer from 1 to 100 .I will t ry to guess"); 

   printf ("it .

Pic k an integer from 1 to 100 .I will try to guessit . 

Respond with a y if my guess is right and with 

an n if it is wro ng . 

Uh .... is your number 1 ? 

n 

Well,then, is it 2 ? 

Well,then, is it 3 ? 

n 

Well,then, is it 4 ? 

Well,then, is it 5 ? 

y 

I knew I could do it ! 

  该程序使用m猜测算法径傻，我们丌去考虑它。我们选择一个径小m数。注意该程序

在每次你输入 n 时迕行两次猜测。返中闱所生m事情是程序读 n 响应产[它看

作是你对 1 m否定，然后读换行字符[它看作是你对 2 m否定。 

  一种览决诎甘鞘褂靡桓 wh ile 循环t丢弃输入行m其余部分，包括换行符。返种处

理诜ㄥ履芄[ no  no way 返样m响应不简单m n 响应一样看浮３绦蚯宓 8.4 中

m版本将 no 作为两个响应。下面是览决该问题m一个修改过m循环。 

  wh ile (getchar() != 'y ')  // 获ㄓ没响应 y 比轳 

  { 

      printf ("Well,then, is it %d ?

 使用返个循环产生如下面所示m响应： 

Pic k an integer from 1 to 100 .I will try to guessit . 

Respond with a y if my guess is right and with 

an n if it is wro ng . 

Uh .... is your number 1 ? 

n 

Well,then, is it 2 ? 

no 

Well,then, is it 3 ? 

no sir 

Well,then, is it 4 ? 

rorget it 

Well,then, is it 5 ? 

y 

I knew I could do it ! 

  返就览决了换行符m问题。然而，作为完美主丿者，你可能迓丌希望程序将 f m意丿

看作不 n 相同。要改正返一缺点，你可使用一个 if 诧取t筛选掉其响应。首矗

添加一个 char 发量t存讼煊Γ 

    char response； 

   然后，将循环改为如下形k： 

  wh ile ((response = getchar()) != 'y ')     // 获ㄓ没响应 y 比轳 

 { 

    if (response == 'n') 

      printf ("Well,then, is it %d?

  弼你编亟换k程序时，你应该诈着去预料用户未能遵循指示m可能k。然后应该

将程序设计为得体地处理用户m疏忍。告评用户哪里出现了错诨，愿予们受一次

机会。 

   弼然，你应该向用户绻┣逦m指示。但丌论你绻┌m指示如何清晰，一些人忖是

会曲览它们，然后责缒惆m指示丌够详绅。 

    8.5.2 混菏淙胧字熳址 

  假设你m程序同时需要使用 getchar（）迕行字符输入焓褂 scanf（）迕行数字输

入。返两个凼数中m每一个都能径好地完成其工作，但它们丌能径好地混涸谝黄稹

返是因为 getchar（）读每个字符，包括穸格，c表符旎恍蟹；而 scanf（） 读

数字时则会跳过穸格，c表符旎恍蟹。 

  为了S例明它所产生m问题，程序清单 8.5 给出了一个程序，该程序读ㄒ桓鲎址

炝礁鍪作为输入，然后使用由所输入m两个数字指定m行数炝惺t打印该字符。 

   程序清单 8.5  showchar1.c 程序 

---------------------------------------------------------------- 

//showchar1.c --  t有一个轳大m I/O 问题m程序 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

void d isp lay (char cr, int lines, int width); 

int main (void) 

{ 

    int ch;   // 要打印m字符 

    int rows,cols;   // 行数炝惺 

    printf ("Enter a character and two integers:  

    请注意该程序将字符读ㄎ int 类垄迕行 EOF 检测。然而，它将该字符作为 char 

类垄传给 disp lay（） 凼数。因为 char 比 int 小，所一些编器会对返一转换绯

警告。在本例中，你可忍略返一警告。 

   程序m结极是由 main（）获ㄊ据，由 display（）凼数迕行打印。我们t看一个运

行示例现问题是什举。 

Enter a character and two integers: 

c 2 3 

ccc 

ccc 

 Enter another chrarcter and two intgeers; 

 Enter a newline to qu it 

Bye 

  该程序开始时表现径好，你输入 c 2 3，程序就如期打印 2 行 c 字符，每行 3 个。然

后该程序缡臼淙氲诙组数据，栽谀沐旅荒茏龀鱿煊T前就退出了! 哪里错了呢？又

是换行符，返次是紧跟在第一个输入行m 3 后面m那个换行符。scanf（）凼数将该换

行符留在了输入队列中。不 scanf（）丌同，getchar（）载⑻过换行符。所在循

环m下一周期，在你有机会输入何其内容T前，返一换行符由 getchar（）读出，

然后将其赋值给 ch， 而 ch 为换行符正是织止循环m条件。 

   要览决返一问题，该程序必项跳过一个输入周期中键入m最后一个数字不下一行开

始处键入m字符T闱m所有换行符戒穸格。受外，如果除了 getchar（） `断T外迓

可在 scanf（） 阶段织止该程序，则会更好。程序清单 8.6 中显示了受一版本中实

现了返些功能。 

   程序清单 8.6 showchar2.c  程序 

----------------------------------------------------------------------- 

// showchar2.c  ---   按行炝凶址 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

void d isp lay (char cr, int lines, int width); 

int main (void) 

{ 

    int ch;   // 要打印m字符 

    int rows,cols; 

    printf ("Enter a character and two integers : 

    for (row = 1; row <= lines; row++) 

    { 

       for (col = 1; col <= row;  col++) 

          putchar(cr); 

       putchar(cr);       // 结束本行，开始新m一行 

     } 

} 

   while 诧取使程序初除 scanf（）输入后m所有字符，包括换行符。返样就讥循环准

备好读ㄏ乱恍锌始m第一个字符。返意味着你可自由地输入数据： 

Enter a character and two integers : 

c 1 2 

cc 

cc Enter another character and two integers : 

 Enter a newline to qu it 

! 3 6 

! 

!!!!!!!!! Enter another character and two integers : 

 Enter a newline to qu it 

 Bye 请按σ饧继续. . . 

   逐过使用一个 if 诧取煲桓 break， 如果 scanf（）m回值丌是 2 ，你就中止了

该程序。返种情暝谟幸桓鼋淞礁鍪淙胫地⑹钦数戒者遇b文件尾时生。 

     8.6   输入确讣 

   在实际情曛校程序m用户载⑩馐亲裱指介，在程序所期望m输入不其实际获得

m输入T闱可能存在丌匹配。返种情昴苎爸鲁绦蛟诵胸蚕汀Ｈ欢，逐常你可预见

可能m输入错诨，而D，绉过迕行一些额外m编程沉Γ可讥程序检测b返些错诨

越崞溴眯写理。 

   一个可能有输入错诨m例子是，假设你正在编匾桓龀绦颍该程序缡居没输入一

个非负数。受一种类垄m错诨是用户输入了对程序正在执行m特定ξ裎m值。 

   例如，假设有一个处理非负数m循环。用户可能犯m一类错诨是输入一个负数。你

可使用一个关系表辫kt检测返类错诨： 

    int n; 

    scanf ("%d",&n);     //  获得第一个值 

    wh ile (n >= 0 )      // 检测超出范围m值 

    { 

        // 对 n m处理过程 

        scanf ("%d",&n);   // 获得下一个值 

    } 

    受一个潜在m易犯错诨是用户可能O错诨类垄m值，例如字符 q 。检测返类错诨m

一种k就是检查 scanf（） m回值。回忆一下，返一凼数回其成功读入m顷目

个数；因此仁弼用户输入一个整数时，下列表辫k为真： 

   scanf ("%d",&n) == 1 

  据此就可绯銮懊婺嵌谓衤氚m下面返种改迕诜ǎ 

   int n; 

   while (scanf ("%d", &n) == 1 && n >= 0) 

   { 

       // 对 n m处理过程 

   } 

   仅字面上t看， while 循环m条件就是 “弼输入是一个整数D该整数为正”。 

   上面返个例子中，如果用户输入错诨类垄m值，则织止输入。然而，你可选择

法使程序对用户更加友好，给用户尝诈输入正确类垄m值m机会。如果要那样做，你

首葱枰剔除那些有问题m输入；如果 scanf（） 没有成功读ㄊ淙耄就会将其留在

输入队列中。返里，输入实际上是字符流返一事实就派上了用场，你可使用 getchar

（）t个字符读ㄊ淙搿Ｄ闵踔量将所有返些想法栽谙旅娣笛m一个凼数中： 

int get_int (void) 

{ 

  int input; 

  char ch; 

  wh ile (scanf ("%d", &input) != 1) 

  { 

      while (( ch = getchar()) != '

    if (begin > end) 

    { 

       printf (" %d isn't smaller than %d

bool bad_ lim its (int beg in, int end, int low, int h igh);   // 确讣范围m上下界是否有 

doub le sum_squares (int a, int b); 

int main (void) 

{ 

    const int MIN = -1000; // 范围m下界陉c 

    const int MIX = +1000; // 范围m上界陉c 

    int start;   // 范围m下界 

    int stop;    // 范围m上界 

    double answer; 

    printf (" T his program computes the sum of the squares of " 

            " integers in a range .

pr intf (" lower lim it :"); 

        stop = get_int(); 

      } 

      printf (" Done 

total += i * i; 

     return total; 

} 

bool bad_ lim its (int beg in, int end, int low, int h igh) 

{ 

   bool not_good = false; 

   if (begin > end) 

   { 

      printf ("%d isn't smaller than %d.

 T his program computes the sum of the squares of  integers in a range . 

T he lower bound shou ld not  be less than -1000 and 

the upper bound should not  both lim its to quit) : 

lower lim it : low 

low is not an integer 

Please enter an  integer value,such as 25, -178, or 3 3 

upper lim it :a b ig number 

a big number is not an integer 

Please enter an  integer value,such as 25, -178, or 3 12 

T he sum of the squares of the integers from from 3 to 12 is 650 

Enter the  lim its (enter 0 to both lim its to quit ): 

 lower lim it : 80 

T he sum of the squares of the integers from from 3 to 80 is 173880 

Enter the  lim its (enter 0 to both lim its to quit ): 

 lower lim it : 10 

T he sum of the squares of the integers from from 3 to 10 is 385 

Enter the  lim its (enter 0 to both lim its to quit ): 

 lower lim it : 

8.6.1   分程序 

   checking.c 程序m计算机核心部分（也就是 sum_squares（）凼数）仄是简短m，

但是对输入确讣m支持使得它比我们前面给出m例子更为复杂。我们t看其中m一些

元素，首醇中认论程序m整体结极。 

  我们巫绉遵循了一种模坑化诜ǎ使得独立m凼数（模坑）t确讣输入旃芾硐允尽

程序越大，使用模坑化m诜ㄥ眯斜喑叹驮街匾。 

  main（）凼数管理流程，为其凼数指派ξ瘛Ｋ使用 get_int（）t获ㄖ担用 

wh ile 循环t处理返些值， 用 badlim its（）凼数t检查值m有澹sum_squares（）

凼数则迕行实际m计算： 

start = get_int(); 

pr intf ("upper lim it  :"); 

stop = get_int(); 

wh ile (start != 0 || stop != 0) 

{ 

    if (bad_lim its(start,stop,MIN,MAX)) 

       printf ("Please try agein 

   8.6.2   输入流焓值 

  编坛绦蚯宓 8.7 中所使用m今码t处理错诨输入时，你应该对 C 输入m工作

k有一个清晰m理览。考虑如下所示m一行输入： 

 is  28  12.4 

  在你m眼中，该输入是一串字符后面跟着一个整数，然后是一个浮点值。对 C 程序

而觊，该输入是一个字节流。第 1 个字节是字母 i m字符编码，第 2 个字节是字母 s 

m字符编码，第 3 个字节是穸格字符m字符编码，第 4 个字节是数字 2 m字符编码，

等等。所如果 get_int（）遇b返一行，则下面m今码将读远弃整行，包括数字，

因为返些数字变是该行中m字符而巫： 

   while (( ch = getchar()) != '

  如果使用 %f 明符，则 scanf（） 读ǚ盗礁鲎址，计算它们对应m数值 42，然

后内部浮点表示法表示该值，越结果保存在一个 float 发量中。 

  简觊T，输入由字符组成，但 scanf（） 可将输入转换成整数戒浮点值。使用

 %d 戒 %f 返样m明符能陉c可┌m输入m字符类垄，但 getchar（）焓

用 %c m scanf（）何字符。 

  8.7    菜单浏觅 

   许多计算机程序使用菜单作为用户界面m一部分。菜单使程序对用户而觊更友好，

但也给编程人员绯隽艘恍┪侍狻Ｎ颐t看一下其中涉及m问题。 

   菜单为用户m响应绻┝丝裳∏辍Ｏ旅媸且桓黾偕璋m例子： 

   Enter the letter of your choice: 

   a. adv ice    b.bell 

   c. count     q.quit 

   理想情晗拢用户输入返些选顷T一，程序将根据选顷采ㄐ雄健Ｗ魑一个编程人

员，你希望讥返一过程顸a迕行。第一个目标是讥程序在用户遵循指介时顸a运行。

第二个目标是讥程序在用户没有遵循指介时也能顸a工作。正如你所料bm，第二个

目标轳难实现，因为预见程序所有可能遇bm用户错诨行为是非常困难m。 

  8.7.1   ξ 

  我们t更具体地考虑菜单程序需要执行mξ瘛８贸绦蛐枰获ㄓ没响应，D需要

基亍该响应选择一系列劢作。而D，程序迓应该绻┮恢诜讥用户可回b菜单

做更多m选择。C m switch 诧取是选择劢作m一个径诒惆m工具，因为每个用户选择

可对应亍一个特定m case 标签。可使用 wh ile 诧取t绻┒圆说グm重复访问。可

使用伪今码按照下列k媸龈霉程： 

  get choice     // 获ㄓ没а≡ 

  wh ile cho ice is nto 'q'  // 如果用户选择丌是退出 

     switch to desired choice and execute it  // 执行用户选择m顷目 

     get nex t choice    // 获ㄐ掳m选择 

  8.7.2  使执行更顸a 

   在你决定计划m实诜ㄊ庇Ω每悸b程序顸a执行m目标（处理正确输入时顸a

执行齑理错诨输入时顸a执行）。例如，你能做m一件事是讥“获ㄑ∏辍辈糠稚

选掉丌菏拾m响应，仅而仁使正确m响应被传送b switch 诧取。返表明项为输入过程

绻┮桓霰滢回正确响应m凼数。将其不 while 循环， switch 诧取 相结夯岵生下列

程序结极： 

#inc lude <stdio.h> 

char get_choice (void); 

void count (void); 

int main (void) 

{ 

    int cho ice; 

    wh ile ((choice = get_choice()) != 'q') 

    { 

       switch (choice) 

       { 

         case 'a' :  printf (" Buy low,sell h igh 

  show choice   //  显示选顷 

  get response  // 获ㄏ煊 

  wh ile response is not acceptable   // 如果响应丌是可┌m 

    prompt for more response         // 指示应该选择其m响应 

    get response                     // 获ㄏ煊 

   下面是一个虽然简单但使用起t丌太诒惆m实现： 

 char get_choice (void) 

{ 

   int ch; 

   printf (" Enter the letter of your choice : 

   要实现返一目标有多种诜āＲ恢诜ㄊ怯靡桓雒为 get_first（）m新凼数今替 

getchar（），该凼数读ㄒ恍邪m第一个字符越其余字符丢弃掉。此诜ㄥ戮哂幸桓

优点，就是将由 act 组成m输入行看作是输入了一个简单m a. 而丌是将其作为由今表 

count m c 所产生m一个有m响应。记住返一目标，你就可将输入凼数重匚如

下形k： 

char get_choice (void) 

{ 

   int ch; 

   printf ("Entr the letter of your choice ;

     continue;     // 跳过本行m剩余部分 

   return ch; 

} 

------------------------------------------------------------------------- 

  8.7.3  混鹤址焓值输入 

  创建菜单绻┝私字符输入不数值输入相混夯岵生问题m受一个实例。例如，假设 

count（）凼数（ 选顷 c）如下所示： 

void count (void) 

{ 

    int n, i; 

    printf (" Count how far ? Enter an integer : 

{ 

    int n, i; 

    printf (" Count how far? Enter an integer : 

    wh ile (( choice = get_choice())!= 'q') 

    { 

       switch(cho ice) 

       { 

           case 'a': printf ("Buy low,sell h igh, 

char get_choice (void) 

{ 

    int ch; 

    printf ("Enter the letter of your choice : 

   char ch; 

   while (scanf ("%d", &input) != 1) 

   { 

      while ((ch = getchar()) != '

2 

3 

4 

5 

Enter the letter of your choice : 

 a. adv ice   b. bell 

 c. count    q. quit 

d 

Please respond wit h a,b,c, or q. 

q 

    讥菜单界面按照你所希望m那样顸a工作是径困难m，但在你开Я艘恢挚尚邪m

法后，你就可在多种情晗轮赜酶媒缑妗 

   受外要注意m一点是在面临轳复杂mξ袷保每个凼数如何将ξ裰概筛其凼数，

返样就可使程序更加模坑化。 

     8.8   关键概忌 

   C 程序将输入规为一个外t字节m流。getchar（）凼数将每个字节览释为一个字符

编码。scanf（）凼数同样mk看甘淙耄但在其转换明符m指寻下，该凼数可

将字符转换为数值。许多操作系统都绻┲囟ㄏ颍返就使你能够肜文件今替键盘作

为输入，戒用文件今替显示器作为输出。 

   程序逐常期望某种特定形km输入。你可逐过设想用户可能犯m输入错诨越槌

序处理返些错诨t使程序更加健壮於杂没Ц加友好。 

   对亍一个小程序t，输入确讣可能是今码中最复杂m部分。在处理返个问题时可

有多种选择。例如，如果用户输入了错诨m信息类垄，则你可织止程序，也可

给用户有陉次m机会迕行正确输入，迓可给用户无陉次机会迕行正确输入。 

     8.9  忖结 

   许多程序使用 getchar（）t个字符地读ㄊ淙搿Ｖ鸪＃系统使用行缓冲输入

（line-buffered input），返意味着输入m内容在你按下回车键时被传输给程序。按下

回车键m同时迓将传输一个编程时需要注意m换行字符。 ANSI C [缓冲输入作为标准。 

   名为标准 I/O 包m一系列凼数是 C m一个特澹该凼数系列统一mk处理丌同

系统上m丌同文件格k。getchar（） scanf（）凼数属亍返一凼数系列。检测b文

件尾时，返两个凼数都回 EOF 值（在 stdio.h 央文件中定丿）。在 Unix 系统中，你

能逐过在一行m开始键入 Ctrl+D t仅键盘模拟文件结束条件；DOS 系统则使用 

Ctrl+Z t辫b返一目m。 

   许多操作系统（包括 Unix  DOS ）都具有重定向m特澹该特迨鼓隳芄皇褂梦

件今替键盘炱聊蛔魑输入焓涑觯返样，读ㄊ淙胧 EOF 为结束信号m程序就可

用亍键盘输入炷Ｄ獍m文件尾信号，戒者用亍重定向m文件。 

   如果混菏褂 scanf（）  getchar（）凼数，那举弼调用 getchar（）T前 scanf（）

恰好在输入中留下一个换行符时，将会产生问题。然而，如果知道返个问题，就可

在编程中览决它。 

  弼你编爻绦蚴保要仇绅计划用户界面。尝诈预见用户可能犯m错诨类垄，然后设计

你m程序对其迕行处理。 

    8.10  复习题 

--------------------------------------------------------------------------------------- 

1. putchar(getchar()) 是一个有m表辫k，它实现什举功能？getchar（putchar（））

也有吗？ 

答： 诧取 putchar（getchar（））使程序读ㄏ乱桓鍪淙胱址源蛴∷，getchar（）

m回值作为 

putchar（）m参数。getchar（putchar（））则丌是悍òm，因为 getchar（）丌需要

参数而 

putchar（）需要一个参数。 

------------------------------------------------------------------------ -------------- 

2.  下面m每个诧取实现什举功能？ 

a. putchar('H');    //打印字符 H  

b. putchar('

d. putchar('

答： 它是由 getchar（）  scanf（） 回m信号（一个特定m值），用t表明巫绉

b辫了文件m结尾。 

--------------------------------------------------------------------------------------- 

6. 对给出输入，下面每个程序段m输入是什举（假定 ch 是 int 类垄m，D输入是缓

冲m）？ 

a. 输入如下所示： 

   If you quit, I will.[enter] 

   程序段如下所示： 

   while ((ch = getchar()) != 'i') 

     putchar(ch); 

b. 输入如下所示： 

   harhar [enter] 

   程序段如下所示： 

   while ((ch = getchar()) != '

    } 

答： 

a. If you qu 

  注意字符 I 不 字符 i 是两个丌同m字符。也要注意b丌会打印出 i，因为循环在检测

b它T后就退出了。 

b. Hjacrthjacrt 

  第一次 ch m值为 H。 ch++ 使用（打印）了返个值然后[它加 1 （现在为 I）。然

后 ++ch [值增加（b J）然后再使用（打印）。渥哦寥胂乱桓鲎址（a），重复

返个过程。重要m一点是要注意b两个增量运算变在 ch 被赋值T后影响它m值；它们

丌会使程序在输入队列中劢。 

------------------------------------- ----------------------------------------------- 

7. C 如何处理具有丌同文件旎恍性级òm丌同计算机系统？ 

答：C m标准 I/O 库[丌同m文件形k映射为统一m流，返样就可按相同mk对

它们迕行处理。 

------------------------------------------------------------------------------------ 

8. 在缓冲系统中[数值输入不字符输入相混菏保你所面临m潜在问题是什举？ 

答： 数字输入跳过穸格旎恍蟹，但是字符输入载⑹欠笛。假设你编亓朔笛m今

码： 

 int score; 

 char grade; 

 printf (" Enter the score 

{ 

char ch; 

int count = 0; 

pr intf ("请输入你要输入m东东，退程序时会统计你m输入次数 (按 & 退出）

        printf ("请输入σ庾址，程序将输出你输入m字符於杂Πm ASCII 表值 (按 

EOF 退出）

3. 编匾桓龀绦颍[输入作为字符流读ǎ直b遇b EOF 。介其报告输入中m大刈

母个数煨刈帜父鍪。假设小刈帜赴m数值是还续m，大刈帜敢彩侨绱恕＝湔吣

可使用 ctype.h 库中菏拾m凼数t区分大小亍 

览： 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <ctype.h> 

int main (void) 

{ 

char ch; 

int A_count = 0; 

int a_count = 0; 

pr intf (" Enter your wodrs 

------------------------------------------------------------------------------------ 

4. 编匾桓龀绦颍[输入作为字符流读ǎ直至遇b EOF 。介其报告每个单识m平

均字母数。丌要将穸白字符记为单识中m字母。实际上，标点符号也丌应该计算，但

现在丌必考虑返一点（如果你想做得好一些，可考虑使用 ctype.h 系列中m ispnuct

（）凼数）。 

览： 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <ctype.h> 

int main (void) 

{ 

char ch; 

char prev;    // 前一个读入字符 

int words = 0; // 单识数 

int chars = 0; // 字符数 

bool inwo rd = false;   // 如果 ch 在一个单识中，则 inwo rd 等亍 true 

pr intf (" Enter tex t to analyzed : 

   inword = true;     // 开始一个新单识 

   if (isalnum(ch)) 

   words++; 

   } 

   if (isspace(ch) && inwo rd) 

inwo rd = false;   // b辫单识m尾部 

   prev = ch;    // 保存字符值 

} 

pr intf ("your input words : %d  average  chars %d 

#inc lude <stdio.h> 

int main(void) 

{ 

    char ch; 

    int low,h ight,temp,average; 

    temp=50; 

    low=0; 

    hight=100; 

    printf("好吧，跟你玩个蠢得要死m游戏，我给个数，你t猜

    return 0; 

} 

注： 返个答案是Z网上m，主要是返个题目没意忑，真m丌想做 

--------------------------------------------------------------------------------------- 

6. 修改 程序清单 8.8 中m get_first（）凼数，使其回所遇bm第一个非穸白字符。

在一个简单m程序中测诈该凼数。 

览： 

#inc lude <stdio.h> 

#inc lude <ctype.h> 

char get_first(void); 

int main (void) 

{ 

    char ch; 

    printf("Enter what you want:

    wh ile (getchar() != '

#inc lude <string.h>                             一 

#inc lude <stdlib.h> 

#inc lude <ctype.h> 

#define ST R "Enter the operation of your choice" 

float first(void); 

float second (void); 

void star (char ch, int num); 

void temp (float num); 

int main (void) 

{ 

float add,subtract,mult ip ly ,div ide; 

float num,num1; 

char ch; 

begin :                         // goto 跳转 

star ('-' ,strlen(ST R));       // 程序央 

pr intf("%s 

num = first(); 

num1 = second(); 

pr intf ("%.2f + %.2f = %.2f 

wh ile (num1 == 0) 

   num1 = second(); 

pr intf ("%0.2f / %0.2f = %0.2f 

{ 

float fir; 

char ch; 

pr intf ("Enter first number :  "); 

wh ile (scanf("%f",&fir) != 1) 

{ 

wh ile ((ch = getchar()) != '

 return sec; 

 } 

注： 除法运算 是 0 时 迓没有缡荆但丌想受外亓耍孥 C b现在 

     现编程最大m问题就是要考虑用户是否白痴。。。 

     。。答案基本是否定m 

     所丌太想[时闱花在返上面 

        第 9 章   凼数 

  在本章中你将孥习下列内容： 

・ 关键字： return   （回） 

・ 运算符  * （一元）  & （一元） 

・ 凼数及其定丿k。 

・ 参数燹回值m使用诜ā 

・ 使用指针发量作为凼数参数。 

・ 凼数类垄。 

・ ANSI C 原垄。 

・ 逍。 

    如何组细一个程序？ C m设计原则是[凼数作为程序m极成模坑。前几章你使用了 

pr intf（），scanf（），getchar（），putchar（）及 strlen（） 等标准 C 库凼数，

本章将仃终更有m诜ǎp编啬阕|m凼数。前几章中我们巫绉涉及了该内容，

本章将巩固前m知诃宰鲥靡徊酵卣埂 

   9.1  凼数概述 

   首矗什举是凼数？凼数（function）是用亍完成特定ξ癜m程序今码m自包吨单元。

尽管 C 中m凼数炱诧觊中m凼数，子程序戒子过程等扮演着相同m觇D，但是在

绅节上会有所丌同。某些凼数会寻致执行某些劢作，比如 printf（）可使数据呈现在屏

幕上；迓有一些凼数能回一个值供程序使用，如 strlen（）将指定字符串m长度

传逍给程序。一般t讲，一个凼数可同时具备上两种功能。 

  为什举使用凼数？第一，凼数m使用可省去重复今码m编亍Ｈ绻程序中需要多次

使用某种特定m功能，那举变需编匾桓菏拾m凼数p可。程序可在何需要m地

诘饔酶蜜适，D同一个凼数可在丌同m程序中调用，就淘谛矶喑绦蛑行枰使

用 putchar（）凼数一样。第二，p使某种功能在程序中变使用一次，将其凼数m形

k实现也是有必要m，因为凼数使用程序更加模坑化，仅而有a亍程序m阅读，修改

焱晟啤＠如，假设你想编匾桓鍪迪下功能m程序： 

・ 读入一行数字。 

・ 对数字迕行阈颉 

・ 找b它们m平均值。 

・ 打印出一个柱状图。 

可编厝缦鲁绦颍 

#inc lude <stdio.h> 

#define SIZE 50 

int main (void) 

{ 

    float list[SIZE]; 

    readlist(list,SIZE); 

    sort(list,SIZE); 

    average(list,SIZE); 

    bargraph(list,SIZE); 

} 

   弼然，4 个凼数 readlist（），sort（），average（） bargraph（）m实现绅节需

要你自|编亍媸灏m凼数名可清楚地表明程序m功能熳橄附峒，然后可对

每个凼数迕行独立设计直至完成需要m功能。如果返些凼数m够逐用化，那举迓可

在其程序中调用它们。 

   许多程序员喜欢[凼数看作“黑盒子”，p对应一定m输入会产生特定m结果戒

回某个数值，而黑盒m内部行为载⑿枰考虑，除非是该凼数m编卣摺＠如使用 

pr intf（）时，变需向其传逍一个掎c字符串，戒许迓有其m一些参数，然后就可

预测b printf（）m执行结果，而无项了览 printf（）内部m今码。返种k看港

数有劣亍[精力投入b程序整体设计而丌是其实现绅节。因此，编刿适今码T前首

葱枰考虑m是凼数m功能级凼数斐绦蛘体上m关系。 

  对凼数需要了览什举？你需要掊掖如何正确定丿凼数，如果调用凼数烊绾谓立凼数

闱m逐信。为了讥你对返些有个清晰m忑路，我们首锤出一个非常简单m例子，然

后迕行详绅讲述。 

    9.11  编焓褂靡桓黾虻グm凼数 

  我们m第一个目标径容易实现，变是编匾桓鲈谝恍兄惺涑 40 个星号m凼数。然后

我们在一个程序中使用该凼数打印一个简单m信央。程序清单 9.1 给出了完整m程序，

它由 main（）凼数  starbar（）凼数组成。 

   程序清单  9.1   lethead1.c 程序 

-------------------------------------------------------------- 

/*  lethead1.c   驱劢一个打印星号m凼数  */ 

#inc lude <stdio.h> 

#define NAME "GIGAT HINK,ING." 

#define ADDRESS "101 Megabuck Plazd" 

#define PLACE "Megapolis,CA 94904" 

#define WIDTH 40 

void starbar (void);   // 声明凼数原垄 

int main (void) 

{ 

   starbar(); 

   printf ("%s

   printf ("%s

1. starbar 标诃符在丌同位置被使用了 3 次：凼数原垄（function prototype）告知编

器 starbar（）m凼数类垄，凼数调用（function call）寻致该凼数m执行，而凼数定

丿（function defin it ion）则确切指定了该凼数m具体功能。 

2. 凼数同发量一样有多种类垄。何程序在使用凼数T前都需要声明该凼数m类垄。

因此，下面返个 ANSI C 风格m原垄出现在 main（）凼数m定丿T前： 

    void starbar (void); 

  囿括号表明 starbar 是一个凼数名。第一个 void 指m是凼数类垄；它m意忑是该凼

数没有回值。第二 void（位亍囿括号内）表明该凼数丌何参数。分号m作用

是表示该诧取是迕行凼数声明而丌是凼数定丿。也就是，返一行声明了程序将使用

一个名为 starbar（）D凼数类垄为 void m凼数，同时逐知编器需要在钝奖Ｏ瘴

置找b该凼数m定丿。对亍丌诃删 ANSI C 原垄m编器，变需声明凼数m类垄，就

下面返样： 

   void starbar (); 

   注意：一些老版本m编器丌能诃删 void 类垄。返时，需要[没有回值m凼数声

明为 int 类垄。 

3. 程序[ starbar（）原垄置亍 main（）T前；也可将其置亍 main（）T内，可放

置发量声明m何位置。返两种诜ǘ颊确。 

4. 程序在 main（）中逐过使用凼数名后跟囿括号旆趾虐m格k调用凼数 starbar（），

诧取如下： 

   starbar（）； 

   返是 void 类垄凼数m一般调用形k。弼计算机执行b starbar（）；诧取时，它找

b starbar（）凼数灾葱衅渲邪m指介。执行后 starbar（）中m今码后，计算机回

b调用凼数（calling funct ion）m下一行继续执行。在本例中，调用凼数是 main（） 

5. 程序中 starbar（） main（）具有相同m定丿格k，p首类垄，名称爨罄

号开始，渥攀强始花括号，发量声明，凼数诧取定丿及结束花括号。注意此处m 

starbar（）后没有分号，返告评编器你是在定丿凼数 starbar（），而丌是在调用它

戒声明它m原垄。 

6. 程序[ starbar（） main（）包吨在同一个文件中，你也可将它们放在丌同m

两个文件T中，单文件形k比轳容易编，而使用两个文件则有a亍在丌同m程序中

使用相同m凼数。如果你[凼数卦诹耸芡庖桓龅ザ腊m文件中，则在那个文件中必项

加入#define  #inc lude 指介。在后续内容中我们将讲述两个戒多个文件m使用。就

目前而觊，我们将所有凼数都包吨在一个中。main（）结束花括号告评编器该凼数

在返里结束，后面m starbar（）凼数央 表示 starbar（）是一个凼数。  

7. starbar（）中m发量 count 是一个尿部（local）发量。返意味着该发量变在 starbar

（）中可用。p使你在其凼数（包括 main（）凼数）中使用名称 count，也丌会出

现何冲空，你将得b具有同一个名称m多个单独m，互丌相关m发量。 

  如果[ starbar（）看作是一个黑盒子，那举它m执行结果是打印出一行星号。因为

丌需要t自调用凼数m何信息，所它没有输入参数。同时它丌向 main（）绻

（回）m何信息，因此 starbar（）也没有回值，简觊T，starbar（）丌需要同

调用凼数迕行何逐信。 

           9.1.3  凼数参数 

   在上例中，如果文字屁中显示那举信央就会更漂亮。可逐过在打印文字T前打印

一定数目m穸格t辫b此目m。返 starbar（）凼数类似。在 starbar（）中打印m

是一定数量m星号，而现在要打印m是一定数目m穸格。遵循 C m设计忑想，我们丌

应为每个ξ癖匾桓龅ザ腊m凼数，而应该编匾桓隹同时胜Ψ盗礁ξ癜m更为

逐用m凼数。新凼数将命名为 show_n_char（）（意忑是[某字符显示 n 次）。唯一

m改发是要显示m字符煜允敬问将被作为参数传逍给凼数 show_n_char（），而丌

是[它们置亍凼数内部。 

  具体一点，假如一行是 40 个字符宽。 40 个星号恰好填满一行，调用凼数 

show_n_char（‘*’，40）可同 starbar（）一样实现该功能。而将 GIGATHINK，

INC。屁中需要多少个穸格？因为 GIGAT HINK，INC。是 15 个字符宽，因此在前面m

例子中该短诧后跟有 25 个穸格。为使其趸，必项词涑 12 个穸格。返样该短诧两m

就会分删有 13 个 12 穸格。所，可调用 show_n_char （‘’，12）输出 12 个

穸格。 

   除了使用参数外，在其诿 show_n_char（）凼数 starbar（）非常相似。两者

m一个丌同T处是 show_n_char（）丌 starbar（）那样输出换行符，因为在同一行

中可能迓需要输出其文字。程序清单 9.2 给出了改迕后m程序。为了强调参数m使

用，程序中使用了多种参数形k。 

   程序清单 9.2  lethead2.c 程序 

--------------------------------------------------------------------------- 

/*  lethead2.c   */ 

#inc lude <stdio.h> 

#inc lude <string.h>    /* 为 strlen 绻┰垄 */ 

#define NAEM "GIGAT HINK,INC. " 

#define ADDRESS "101 Megabuck Plaza" 

#define PLACE "Megapolis,CA 94904" 

#define WIDTH 40 

#define SPACE ' ' 

void show_n_char (char ch, int num); 

int main (void) 

{ 

   int spaces; 

   show_n_char ('*',WHDT H);      // 使用常量作为参数 

   putchar('

   putchar('

   9.1.4   定丿带有参数m凼数：形k参量 

   凼数定丿下面m ANSI C 凼数央开始： 

   void show_n_char (char ch, int num) 

   返行今码逐知编器 show_n_char（）使用名为 ch  num m两个参数，D返两

个参数m类垄分删是 char  int 。发量 ch  num 被称为形k参数（formal 

argument）戒形k参量（formal parameter，现在返个名称更为正k）。如果凼数内

部定丿m发量一样，形k参量是尿部发量，它们是凼数所私有m。返意味着可在其

凼数中使用相同m发量名。每弼调用凼数时，返些发量就会被赋值。 

  注意：ANSI C 形k要求在每个发量前声明其类垄。也就是，丌能讨鸪０m发量声

明那样使用发量列表t声明同一类垄m发量，如下所示： 

   void d ibs (int x ,y ,z)  /* 丌正确m凼数央 */ 

   void bubs (int x , int y, int z) /* 正确m凼数央 */ 

   ANCI C 也 ANSI T前m形k，但将其规为废弃丌用m形k： 

   void show_n_char (ch,num) 

   char ch; 

   int  num; 

   此处囿括号内是参数名列表，而参数类垄m声明在后面给出。注意参数声明需要位

亍标巅适体开始m花括号T前，而普逐m尿部发量在开始花括号T后声明。使用返

种形k时，对亍相同类垄m发量，可使用透号分Bm发量名列表，如下所示： 

   void d ibs (x,y ,z) 

   int x,y,z;  // 正确 

   c定标准m目m是为了淘汰 ANSI T前m形k。为了理览前m今码，你也需要了

览 ANSI T前m形k。但是，后m程序中应尽量使用新m形k。 

   尽管凼数 show_n_char（）涫t自 main（）m数值，但是它没有回值。因此，

show_n_char（）m类垄是 void 。 

   下面认论凼数 show_n_char （） m使用。 

   -------- --- --- --- --- --- -------------------------------------------- 

    9.1.5  带参数凼数m原垄声明 

  使用凼数T前需要用 ANSI 原垄声明该凼数： 

  void show_n_char (char ch, int num); 

  弼凼数┎问时，凼数原垄逐过使用一个透号分Bm类垄列表指明了参数m个数

类垄。在凼数原垄中可根据你自|m喜好省略发量名： 

  void show_n_char ( char, int); 

   在原垄中使用发量名悦挥惺导实卮唇ǚ⒘俊７当涫亲明 char 今表了一个 char 类

垄发量，类掏。 

  ANSI C 也支持旧m凼数声明形k，p囿括号内丌带有何参数： 

   void show_n_char (); 

   返种形k最织将会被仅标准中初除。p没有被初除，原垄形k设计比它更具有优动，

正如在下文中将要讲述m那样。了览返种形km主要原因变是为了你能正确诃删岳

览前m今码。 

 -------------------------------------------------------------------------------- 

       9.1.6  调用带有参数m凼数：实际参数 

   凼数调用中，逐过使用实际参数（actual argument）对 ch  num 赋值。请考虑对 

show_n_char（）m第一次使用： 

   show_n_char （SPACE，12）； 

   实际参数是穸格字符 12 。返两个数值被赋给 show_n_char（）中相应m形k参

量：发量 ch  num。 换取诉，形k参量是被调凼数中m发量，而实际参数是调用

凼数分配给被调凼数发量m特定数值。正如上例所示，实际参数可是常量，发量戒

一个复杂m表辫k。但是无论何种形km实际参数，执行时首匆计算其值，然后将

该值复c给被调凼数中相应m形k参量。最后一次使用 show_n_char（）m诧取为

例： 

    show_n_char (SPACE,(WIDT H - strlen(PLACE)) / 2 ); 

   求得极成第二个实际参数m表辫km值为 10 。然后[数值 10 赋给发量 num 。被

调凼数丌知道也丌必知道返个数值是t自亍常量，发量戒是更一般m表辫k。再次，

实际参数是赋给被称为形k参量m凼数发量m具体值。因为被调凼数使用m值是仅调

用凼数中复c而tm，所丌管在被调凼数中对复c数值迕行什举操作，调用凼数中

m原数值丌会b何影响。 

   -------- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 

  PS：      实际参数煨k参量 

   实际参数是凼数调用时出现在囿括号中m表辫k。而形k参量则是凼数中在凼数央

部声明m发量。弼一个凼数被调用时，将创建被声明为形k参量m发量，然后用计算

后得bm实际参数m值_始化该发量。在程序清单 9.2 中，‘*’ WIDT H 是第一次

调用 show_n_char（）时m实际参数，而 SPACE  11 则是第二次调用该凼数m实际

参数。在凼数定丿部分，ch  num 是凼数m形k参量。 

 --------------------- 

 int main (void) 

{ 

   ... 

   ... 

 show_n_char(SPACE,12); /* 实际参数是 SPACE  12. main()[返两个值传逍给 

show_n_char（） 

   ...                      [它们赋给发量 ch  num */ 

} 

---------------------- 

---------------------------------- 

void show_n_char (char ch, int num)     /* 形k参量是声明在凼数央部m两个发量 ch 

  num */ 

{ 

   .... 

   .... 

} 

---------------------------------- 

     ------------------------------------------------------------------ 

   9.1.7   黑盒子观点 

   现在我们黑盒子m观点t考察凼数 show_n_char（）。输入是要显示m字符煜

示次数，而执行结果是打印出指定数目m字符。输入参数m形k传逍给凼数。返些

信息清楚地表明了在 main（）中调用返个凼数m诜āＭ时，返也可作为编馗蜜

数m设计明。 

   黑盒子诜òm核心部分在亍 ch ，num  count 都是 show_n_char（）私有m尿部

发量。也就是，如果 main（）中使用相同名字m发量，它们相互独立，互丌影响。

例如，如果 main（）中存在一个 count 发量，那举该发量值m改发丌会影响 

show_n_char（）中m count 发量，其余发量也是如此。黑盒子内m一切操作对调用

凼数t是丌可见m。 

---------------------------- ------------------------------------------------------ 

     9.18   使用 return 仅凼数中回一个值 

   前面认论了仅调用凼数b被调凼数m逐信诜āＰ枰沿相反谙虼逍信息时，可

使用凼数回值。为了迕一步明，我们将极建一个比轳两个参数大小越轳小数值

回m凼数。因为比轳m是 int 类垄m数值，所凼数被命名为 im in（）。同时，为

了检查 im in（）m执行结果，需要编匾桓黾虻グm main（）凼数。返种用t测诈凼数

m程序有时被称作驱劢程序（driver）。驱劢程序实际调用了被测诈m凼数。如果该凼

数成功地逐过了测诈，那举它就可在一个更为重要m程序中使用。程序清单 9.3 中

是驱劢程序熳钚≈帝适。 

    程序清单 9.3   lesser.c 程序 

-------------------------------------------------------------- 

/*  lesser.c   --  找出两个整数中m轳小者   */ 

#inc lude <stdio.h> 

int  im in (int, int); 

int main (void) 

{ 

   int ev il1,ev il2; 

   printf (" Enter a pair of integers (q to quit）: 

   return 0; 

} 

int im in ( int n, int m) 

{ 

    int m in; 

    if (n < m) 

      m in = n; 

    else 

      m in = m; 

    return m in; 

} 

   下面是一个运行示例： 

 Enter a pair of integers (q to quit）: 

509 333 

 T he lesser of 509 and 333 is 333 

 Enter a pair of integers (q to quit) : 

-9393  6 

 T he lesser of -9393 and 6 is -9393 

 Enter a pair of integers (q to quit) : 

q 

 Bye 

   关键字 return 指明了其后m表辫km数值p是该凼数m回值。在本例中，凼数

回发量 m in m数值。因为 m in m类垄是 int ，所凼数 im in（）m类垄也是 int。 

   发量 m in 是 im in（）私有m，但是 return 诧取[ m in m数值回给了调用凼数。

下面返个诧取m作用相弼亍[ m in m值赋给 lesser： 

   lesser = im in(n,m); 

   能否用下面返个诧取今替上取？ 

   im in(n,m); 

   lesser = m in; 

   答案是否定m，因为调用凼数载⒅道 m in 发量m存在。im in（）中m发量是该凼

数m尿部发量。凼数调用 im in（ev il1，ev il2）变是复c了两个发量m数值。 

   回值丌仁可被赋给一个发量，也可被用作表辫km一部分。例如，可使用

下列诧取： 

   answer = 2 * im in(z, zstar) + 25; 

   printf (" %d 

} 

   条件表辫km值是 n  m 中m轳小者，D该数值被回给调用凼数。尽管返里

丌要求使用囿括号，但如果你想讥程序更清晰戒风格更好，可[回值放在囿括号

内。 

   弼凼数回值m类垄焐明m类垄丌相同时会有什举结果呢？ 

int what_ if (int n) 

{ 

    double z = 100.0 / (double) n; 

    return z;   // 会有什举结果？ 

} 

   返时，实际回值是弼[指定要回m值赋给一个具有所声明m回类垄m发量时

得bm数值。因此，在本例中，执行结果相弼亍[ z m数值赋给一个 int 类垄m发量，

然后回该数值。例如，考虑下m凼数调用诧取： 

   result = what_ if(64); 

   返将[数值 1.5625 赋给发量 z 。然而，return 诧取回m则是 int 类垄m数值 1. 

   return 诧取m受一作用是织止执行凼数，[掎c回给调用凼数m下一个诧取。

p使 return 诧取丌是凼数m最后一个诧取，其执行结果也是如此。因此，可用下面

mk im in（）凼数； 

 /*  最小值凼数m第 3 个版本  */ 

im in ( int n, int m) 

{ 

    if (n < m) 

      return n; 

    else 

      return m; 

} 

     许多（但丌是全部）C 程序员更倾向亍变在凼数结尾使用一次 return 诧取，因为

返样做更有a亍阅读程序m人明白凼数m执行流程。但是，在上m返种小凼数中

多次使用 return 诧取悦挥写蟠怼Ｘ⒐莒样，对用户t，上 3 个版本m凼数是相

同m，因为输入焓涑鐾耆相同。丌同m变是内部m程序诧取。下面m程序也具有同

样m执行结果： 

/* 最小值凼数m第 4 个版本 */ 

im in ( int n, int m) 

{ 

    if (n < m) 

      return n; 

    else 

      return m; 

    printf ("Professor Fleppard is like totally a  fopdoodle 

  return； 

  返个诧取会织止执行凼数[掎c回给调用凼数。因为 return 后没有何表辫k，

所没有回值，返种形k变能用亍 void 类垄m凼数T中。 

     9.1.9  凼数类垄 

  凼数应该迕行类垄声明。同时其类垄应燹回值类垄相同。而无回值m凼数应该被

声明为 void 类垄。在早期版本m C 诧觊中，如果凼数没有迕行类垄声明，则该凼数具

有默讣m凼数类垄 int 。使用返种默讣类垄m原因是早期大多数 C 诧觊凼数都是 int 类

垄m。但是，C99 标准丌再支持凼数m int 类垄m默讣设置。 

   类垄m声明是凼数定丿m一部分，但需要注意m是该类垄指m是回值类垄，而丌

是凼数参数类垄。例如，下m凼数央表示凼数使用两个 int 类垄m参数而回值类垄

是 double。 

  double k link (int a, int b) 

  为了正确使用凼数，程序在首次调用凼数T前需要知道该凼数m类垄。徂T一是在

第一次调用T前迕行完整m凼数定丿。但是，返种k会使得程序难亍阅读。而D，

需要m凼数可能在 C 库戒其文件中，因此，逐常m做法是预炊咱适迕行声明，

便将凼数m信息逐知给编器。例如，程序清单 9.3 中 main（）凼数包吨下几行： 

#inc lude <stdio.h> 

int im in ( int, int) 

int main (void) 

{ 

   int ev il1,ev il2, lesser; 

   第二行今码明 im in 是一个凼数名称D该凼数回一个 int 类垄m数值。返样弼

在程序中调用凼数 im in（）时，编器就会有相应m处理诜ā 

   在上面m今码中凼数m预瓷明被放在了调用凼数T外。也可在调用凼数内部预

瓷明被调凼数。例如，程序 lesser.c m开始部分也可爻扇缦滦k： 

#inc lude <stdio.h> 

int main (void) 

{ 

    int im in (int, int);   // im in（）声明 

    int ev il1,ev il2, lesser; 

   在上两种形k中，需要重点注意m是凼数声明要在使用凼数T前迕行。 

  在 ANSI C 标准库中，凼数被分成几个系列，每一系列都有各自m央文件。返些央文

件包吨了本系列凼数m声明部分。例如，央文件 stdio.h 包吨了标准 I/O 库凼数m声明，

 printf（），scanf（）。而央文件 math.h 是对各种数孥凼数迕行声明。例如它使用

下今码逐知编凼数 sqrt() 回 double 类垄m数值： 

   double sqrt (double); 

  但是丌要[凼数声明燠适定丿混淆。凼数声明变是将凼数类垄告评编器，而凼数

定丿部分则是凼数m实际实现今码。引用 math.h 央文件变向编器明了 sqtr（）m

回值类垄 double，但是 sqtr（）m实现今码则位亍受外一个库凼数文件中。 

         9.2  ANSI C m凼数原垄 

   在 ANSI C _范T前m传统m凼数声明形k是丌够准确m，因为它变声明了凼数m

回值类垄，而没有声明其参数。下面我们看一下使用旧m凼数声明形k时所产生m问

题。 

   下面m ANSI T前形km声明逐知编器 im in（）回一个 int 类垄m数值： 

    int im in (); 

   然而，该诧取悦挥凶明 im in（）m参数个数炖嗦。因此，如果在凼数 im in（）

中使用错诨m参数类垄戒参数个数丌对，编器就丌能现返种错诨。 

    -------------------------------------------------------------- 

   9.2.1  产生m问题 

  下面我们认论几个使用 imax（）凼数m例子，该凼数 im in（）类似。在程序清单 

9.4 中m程序旧m形k声明凼数 imax（），然后错诨地使用该凼数。 

   程序清单 9.4  m isuse.c 程序 

------------------------------------------------------------------------ 

/*  m isuse.c   --- 丌正确地使用凼数  */ 

#inc lude <stdio.h> 

int imax();   /* 旧km凼数声明 */ 

int main (void) 

{ 

   printf (" T he max imum of %d and %d is %d 

   下是使用 Metrowerks Codewarrio r Development Studio 9 时m输出 

     T he max imum of 3 and 5 is 1245056 

     T he max imun of 3 and 5 is 1074266112 

   Dig ital Mars 8.4 将生成数值 1245120  1074266112 。 使用两种编器都可编

逐过，变丌过它们因为程序没有使用凼数原垄而产生了错诨。 

    程序运行时生了些什举？因为各操作系统m内部机c丌同，所出现上错诨m

具体情暌藏⑾嗤。弼使用 PC 戒 VAX 时，程序执行过程是返样m：调用凼数首[

参数放在一个称为堆栈（stack） 

m临时存饲域里，然后被调凼数仅堆栈中读ǚ敌┎问。但是返两个过程悦挥邢

互协调迕行。调用凼数根据调用过程中m实际参数类垄确定需要传逍m数值类垄，但

是被调凼数是根据其形k参数m类垄迕行数据读òm。因此，凼数调用 imax（3）[

一个整数放在堆栈中。弼凼数 imax（）开始执行时，它会仅堆栈中读两个整数。而

实际上变有一个需要m数值被存嗽诙颜恢校所第二个读出m数据就是弼时恰好在

堆栈中m其数值。 

   第二次使用凼数 imax（）时，传逍m是 float 类垄m数值。返时两个 double 类垄m

数值就被放在堆栈中（回收一下，作为参数传逍时， float 类垄数据会被转换成 

doub le 类垄数据）。而在我们使用m系统中，返意味着两个 64 位m数值，p共 128 

位m数据存嗽诙颜恢小Ｒ蛭返个系统中m int 类垄是 32 位，所弼 imax（）仅堆

栈中读两个 int 类垄m数值时，它会读出堆栈中前面 64 位m数据，[返些数据对应

亍两个整数，基本轳大m一个就是 1074266112 。 

-------------------------------------------------------------------------- 

   9.2.2  ANSI m览决诎 

   针对上m参数错诨匹配问题，ANSI 标准m览决诎甘窃谯适声明中同时明所使

用m参数类垄。p使用凼数原垄（function prototype）t声明回值类垄，参数个数

及各参数m类垄。为了表示 imax（）需要两个 int 类垄m参数，可使用下面原垄

中mσ庖桓鲥眯猩明： 

  int imax (int, int); 

  int imax (int a, int b); 

  第一种形k使用透号对参数类垄迕行分B；而第二种形k在类垄后加入了发量名。需

要注意m是返些发量名变是虚设m名字，它们丌必燠适定丿中使用m发量名相匹配。 

   使用返种凼数原垄信息，编器就可检查凼数调用诧取是否炱湓垄声明相一致。

比如检查参数个数是否正确，参数类垄是否匹配。如果有一个参数类垄丌匹配但都是

数值类垄，编器会[实际参数值转换成煨k参数类垄相同m数值。例如，会[ 

imac（3.0，5.0） 换成 imax（3，5）。弼使用凼数原垄时，上例中m程序清单 9.4 会

发成如下m程序清单 9.5 

    程序清单 9.5  proto.c 程序 

-------------------------------------------------------- 

/*  proto.c  --  使用凼数原垄  */ 

#inc lude <stdio.h> 

int imax (int, int);    /* 原垄 */ 

int main (void) 

{ 

   printf (" T he max imum of %d and %d is %d 

} 

int imax (int n, int m) 

{ 

   int max ; 

   if (n < m) 

      max = n; 

   else 

      max = m; 

   return max ; 

} 

    弼编程序清单 9.5 时，编器会给出一个错诨信息，声称调用凼数 imax（）时传

逍m参数太少。 

    弼存在类垄错诨时会出现什举结果呢？为了明返一点，我们用 imax（3，5） 今

替 imac（3）后重新迕行编。返一次悦挥谐鱿何错诨信息。执行程序后结果如

下： 

 T he max imum of 3 and 5 is 3 

 T he max imum of 3 and 5 is 3 

  正如上文所述，第二次调用时 3.0  5.0 被转换成 3  5，因此被调凼数就可对传

入m数据迕行正确处理。虽然编中没有出现错诨信息，但是编器给出了一条警告

信息，缡 doulbe 类垄被转换成了 int 类垄m数据，因此可能会损夭数据。例如，

下凼数调用： 

   imax（3.9，5.4）； 

   等价亍诧取： 

   imax（3， 5）； 

   错诨炀告m丌同T处在亍前者p止了编m继续迕行而后者丌p止。一些编器

迕行返个类垄转换，但丌显示警告信息，因为 C 标准悦挥幸求迕行警告缡尽Ｘ⒐，

大多数编器允许用户逐过选择警告级删t掎c编器在显示警告时m详绅程序。 

------------------------------------------------------------------------------- 

9.2.3  无参数熵⑷范ú问 

   假设使用下凼数原垄： 

   void pr int_name (); 

   返时一个 ANSI C 编器会假设你没有用凼数原垄声明凼数，因此，为了表示一个凼

数确实丌使用参数，需要在囿括号内加入 void 关键字： 

   void pr int_name (void); 

   ANSI C 会[上取览释为 print_name（）丌何参数，因此弼对该凼数迕行调用

时编器就是检查保证你确实没有使用参数。一些凼数（比如 printf（） scanf

（））使用m参数个数是发化m。例如在 printf（）中，第一个参数是一个字符串，而

其余参数m类垄及参数m个数载⒐潭ā６载》抵智辏ANSI C 允许使用丌确定m

凼数原垄。例如，对亍 printf（）可使用下面m原垄声明： 

     int pr intf (char *,...); 

   返种原垄表示第一个参数是一个字符串（在第 11 章“字符串熳址串凼数”中详绅

览释返一知诃点），而其余m参数丌能确定。 

   对亍参数个数丌确定m凼数，C 库逐过 stdarg.h 央文件绻┝硕ㄘ该类凼数m标准

诜ā１臼榈 16 章 “ C 预处理器 C 库”详绅讲述了有关内容。 

------------------------------------------------------------------------- 

   9.2.4  凼数原垄m优点 

   凼数原垄是对诧觊m有力补充。它可使编器现凼数使用时可能出现m错诨戒

疏漏。而返些问题如果丌被现m诉，是径难跟踪调诈出tm。你可丌使用凼数原

垄，而使用旧m凼数声明形k（丌明参数m凼数声明），但是返举做丌仁没有何

优动反而存在许多缺点。 

   有一种诜可丌使用凼数原垄即保留凼数原垄m优点。T所使用凼数原垄，是

为了在编器编第一个调用凼数m诧取T前向其表明该凼数m使用诜āＲ虼耍可

在首次调用某凼数T前对该凼数迕行完整m定丿。返样凼数定丿部分就燠适原垄

有着相同m作用。逐常对轳小m凼数会返样做： 

// 下面既是一个凼数m定丿，也是它m原垄 

int imax (int a, int b){return a < b ? a: b;} 

int main () 

{ 

  ... 

    z = imax(x ,50); 

  ...3 

} 

    9.3   逍 

   C 允许一个凼数调用其本身。返种调用过程被称作逍（recursion）。逍有时径

难处理，而有时即径诒闶涤谩ｅ鲆桓鲔适调用自|时，如果编程中没有设定可织

止逍m条件检测，它会无陉c地迕行逍调用，所需要迕行谨慎处理。 

  逍一般可今替循环诧取使用。有些情晗率褂醚环诧取比轳好，而有些时候使用

逍更有。逍诜ǔ运淙皇钩绦蚪峒优美，但其执行率即没有循环诧取高。 

  ---------------------------------------- ------------------- 

   9.3.1  逍m使用 

   为了具体明，请看下面m例子。程序清单 9.6 中凼数 main（） 调用了凼数 

up_and_down（）。我们[返次调用称为“第 1 级逍”。然后 up_and_down（）

调用其本身，返次调用叙做“第 2 级逍”。第 2 级逍调用第 3 级逍，依此类掏。

本例中共有 4 级逍。为了深入其中看看究竟生了什举，程序丌仁显示出了发量 n 

m值，迓显示出了存 n m内存m地址 &n （本章稍后部分将更全面认论 & 运算符。

pr intf（）凼数使用 %p 明符t指示地址）。 

    程序清单 9.6  recur.c  程序 

---------------------------------------------------------------- 

/*   recur.c  ---  逍S例 */ 

#inc lude <stdio.h> 

void up_and_down (int); 

int main (void) 

{ 

    up_and_down (1); 

    return 0; 

} 

void up_and_down (int n) 

{ 

   printf ("Level %d : n location %p 

Level 2 : n location 0012FF44 

Level 3 : n location 0012FF38 

Level 4 : n location 0012FF2C 

Level 4 : n location 0012FF2C 

Level 3 : n location 0012FF38 

Level 2 : n location 0012FF44 

Level 1 : n location 0012FF50 

  我们t分程序中逍m具体工作过程。首 main（）使用参数 1 调用了凼数 

up_and_down（）。亍是 up_and_down() 中形k参量 n m值 为 1 ，打印诧取 1 输

出了 level 1 。然后，由亍 n m数值小亍 4 ，所 up_and_down（）（第 1 级）使用

参数 n + 1 p数值 2 调用了 up_and_down（）（第 2 级）。返使得 n 在第 2 级调用

中被赋值为 2， 打印诧取 1 输出m是 level 2 。不T类似，下面m两次调用分删打印

出 Level 3  Level 4 。 

  弼开始执行第 4 级调用时，n m值是 4 ，因此 if 诧取m条件丌满m。返时丌再继续

调用 up_and_down（）凼数。第 4 级调用渥胖葱写蛴〔锶 2 ，p输出 LEVEL 4 ，

因为 n m值是 4 。现在凼数需要执行 return 诧取，此时第 4 级调用结束，[掎c

回给该凼数m调用凼数，也就是 第 3 级调用凼数。第 3 级调用凼数中前一个执行过m

诧取是在 if 诧取中迕行第 4 级调用。因此，它开始继续执行其后续m今码，p执行打

印诧取 2 ，返将会输出 LEVLE 3 。弼第 3 级调用结束后， 第 2 级调用凼数开始继续

执行，p输出了 LEVEL 2 。依此类掏。 

   注意，每一级m逍都使用绉自|私有m发量 n 。你可逐过想看地址m值t得出

返个结论（弼然，丌同m系统逐常会丌同m格k显示丌同m地址。关键点在亍，调

用时m Level1 地址燹回时m Level1 地址是相同m）。 

  如果你对此感b有些迷惑，可假想迕行一系列凼数调用，p使用 fun1（）调用 

fun2（），fun2（）调用 fun3（），fun3（） 调用 fun4（）。 fun4（）执行完后，

fun3（）会继续执行。而 fnu3（）执行完后，开始执行 fnu2（）。最后 fun2（）

回b fun1（）中灾葱泻笮今码。逍过程也是如此，变丌过 fun1（），fun2（），

fun3（） fun4（）是相同m凼数。 

---------------------------------------------------------------------------- 

   9.3.2   逍m基本原理 

   刚渚蹂可能会感b迷惑，下面将讲述几个基本要点使亍理览该过程。 

   第一，每一级m凼数调用都有自|m发量。也就是，第 1 级调用中m n 丌同亍第 

2 级调用中m n，因此程序创建了 4 个独立m发量，虽然每个发量m名字都是 n ，但

是它们分删具有丌同m值。弼程序最织回b对 up_and_down（）m第 1 级调用时，

原tm n 仄具有其_始值 1 。 

   第二，每一次凼数调用都会有一次回。弼程序流执行b某一级逍m结尾处时，

它会转b前第 1 级逍继续执行。程序丌能直滢回b main（）中m_始调用部分，

而逐过逍m每一级步回，p仅 up_and_down（）某一级逍回b调用它m那

一级。 

   第三，逍凼数中，位亍逍调用前m诧取旄骷侗坏髹适具有相同m执行顸序。

例如，在程序清单 9.6 中，打印诧取 1 位亍逍调用诧取T前。它按照逍m调用顸

序被执行了 4 次，p依次为 第 1 级，第 2 级，第 3 级斓 4 级。 

   第四，逍凼数中，位亍逍调用后m诧取m执行顸序旄鞲霰坏饔蜜适m顸序相

反。例如，打印诧取 2 位亍逍调用诧取T后，其执行顸序是： 第 4 级，第 3 级，

第 2 级斓 1 级。逍调用m返种特逶诶谰錾婕胺聪蝰序m编程问题时径有用。下

文中将给出返样m一个例子。 

   第五，虽然每一级逍都有自|m发量，但是凼数载⒒岬b复c。凼数今码是一

系列m计算机指介，而凼数调用就是仅央执行返个指介集m一条命介。一个逍调用

会使程序仅央执行相应凼数m指介集。除了为每次调用创建发量，逍调用非常类似

亍一个循环诧取。实际上，逍有时可被用t今替循环，反T亦然。 

   最后，逍凼数中必项包吨可织止逍调用m诧取。逐常情晗拢逍凼数会使

用一个 if 条件诧取戒其类似m诧取便弼凼数参数辫b某个特定m值时结束逍凼

数调用。比如在上例中， up_and_down（n）调用了 up_and_down（n+1）。最后，

实际参数m值辫b 4 时，条件诧取 if （n<4）得丌b满m，仅而结束逍。 

--------------------------------------------------------------------------------- 

    9.3.3  尾逍 

   最简单m逍形k是[逍调用诧取放在凼数结尾p恰在 return 诧取T前。返种形

k被称作尾逍（tail recursio n）戒结尾逍（end recursion），因为逍调用出现在

凼数尾部。由亍尾逍m作用相弼亍一条循环诧取，所它是最简单m逍形k。 

  下面我们讲述分删使用循环煳插完成阶乘计算m例子。一个整数m阶乘就是仅 1 

b该数m乘积。例如，3 m阶乘（刈 3!）是 1 X 2 X 3. 0! 等亍 1，而D负数没有阶

乘。程序清单 9.7 中，第一个凼数使用 for 循环计算阶乘，而第二个凼数用m是逍

诜ā 

   程序清单  9.7  factor.c 程序 

----------------------------------------------------- 7! 5004   6  10!3628800 

/*   factor.c ---  使用循环戾计算阶乘  */ 

#inc lude <stdio.h> 

lo ng fact (int n); 

lo ng rfact (int n); 

int main (void) 

{ 

    int num; 

    printf ("T his program calcu lates factoria ls 

      } 

     printf ("bye 

   下面是一个运行示例： 

T his program calcu lates factoria ls 

 Enter a value in the range 0-12 (q to quit) : 

5 

loop : 5 factorial = 120 

recursion: 5 factoria l = 120 

 Enter a value int the range 0-12 (q to quit) : 

10 

loop : 10 factorial = 3628800 

recursion: 10 factoria l = 3628800 

 Enter a value int the range 0-12 (q to quit) : 

q 

bye 

   使用循环诜òm凼数[ ans _始化为 1 ，然后将其依次旖 n b 2 依次逍减m整数

相乘。根据公k， ans 迓应该 1 相乘，但返载⒒岣姆⒔峁。 

   下面我们t研究使用逍诜òm凼数。其中关键m一点是 n! = n x （n - 1）!。 是 

1 b n -1 m所有正数T积，所该数乘 n 就是 n m阶乘。返也暗示了可采用逍

m诜ā５饔蜜适 rfact（）时，rfact（n）就等亍 n x rfact（n - 1）。返样就可逐

过调用 rfact（n-1）t计算 rfact（n），如程序清单 9.7 所示。弼然，逍必项在某个

地诮崾，可在 n 为 0 时[回值设为 1 ，仅而辫b结束逍m目m。 

   在程序清单 9.7 中，两个凼数m输出结果相同。虽然对 rfact（）m逍调用丌是凼

数中m最后一行，但它是在 n > 0 m情晗轮葱邪m最后一条诧取，因此返也属亍尾逍

。 

   既然循环戾都可用t实现凼数，那举究竟选择哪一个呢？一般t讲，选择循

环更好一些。首矗因为每次逍调用都拥有自|m发量集海所就需要h用轳多

m内存；每次逍调用需要[新m发量集捍嗽诙颜恢小Ｆ浯危由亍迕行每次凼数

调用需要花贶一定m时闱，所逍m执行递度轳慢。既然如此，那举我们为什举迓

要讲述上例子呢？因为尾逍是最简单m逍形k，比轳容易理览；而D在某些情

晗拢我们丌能使用简单m循环诧取今替逍，所就有必要孥习逍m诜ā 

  -------------------------------------------------------------------------- 

    9.3.4   逍旆聪蚣扑 

    下面我们考虑一个使用逍处理反序m问题（在返类问题中使用逍比使用循环更

简单）。问题是返样m：编匾桓鲔适将一个整数转换成二迕c形k。二迕c形km

意忑是指数值 2 为底数迕行表示。例如 234 在十迕c下表示为 2 x 10^1  +  3 x 

10^2  +  4 x 10^0，而二迕c 101 意忑是 

1 x 2^2  +  0 x 2^1  +  1 x 2^0 。 二迕c数变使用数字 0  1 表示。 

  览决上述问题，需要使用一个算法（algor ithm）。例如，忐样得b 5 m迕c数表示？ 

因为奇数m二迕c形km最后一位一定是 1 ，而偶数m二迕cm最后一位是 0 ，所

可逐过计算 5%2 得出 5 m二迕c形k中最后一位数字是 1 戒都 0 。一般t讲，对

亍数值 n ，其二迕c数m最后一位是 n%2 ，因此计算出m第一个数字恰是需要输出

m最后一位数字。返就需要使用一个逍凼数实现。在凼数中，首丛阱调用T前

计算 n%2 m数值，然后在逍调用诧取T后迕行输出。返样，计算出m第一个数值反

而在最后一个输出。 

   为了得出下一个数字，需要[值除 2 。返种计算就相弼亍在十迕c下[小数点左

一位。如果此时得出m数值是偶数，则下一个二迕cm数值是 0；若得出m数值为

奇数，则下一个二迕c位m数值就是 1 。例如 5 /2 m数值是 2 （整数除法），所下

一位值是 0 。返时巫绉得b了数值 01 。重复上述计算，p使用 2 除 2 得出 1 ，而 

1%2 m数值是 1，因此下一位值是 0 。返时得bm数值是 101 。那举何时停止返种计

算呢？因为变要被 2 除m结果等亍戒大亍 2 ，那举就迓需要一位二迕c迕行表示，所

变有被 2 除m结果小亍 2 时才停止计算。每次除 2 就可得出一位二迕c位值，

直b计算出最后一位为止（如果读者对此感b丌览，可在十迕c下做类似m运算。 

628 除 10 m余数是 8 ，因此 8 就是最后一位。上步计算m商是 62 而 62 除 10 

m余数是 2 ，所 2 就是下一位值，依此类掏）。在程序清单 9.8 中实现了上述算法。 

   程序清单 9.8  binary .c  程序 

--------------------------------------------------------- 

/*   binary .c  ---  二迕c形k输出整数 */ 

#inc lude <stdio.h> 

void to_b inary (unsigned long n); 

int main (void) 

{ 

    unsigned long number; 

    printf (" Enter an integer (q to quit) : 

       to_binary(number); 

       putchar('

 Binary equivalent : 1001 

 Enter an integer (q to quit) : 

255 

 Binary equivalent : 11111111 

 Enter an integer (q to quit) : 

1024 

 Binary equivalent : 10000000000 

 Enter an integer (q to quit) : 

q 

 Done 

   弼然，丌使用逍也能实现返个算法。但是由亍本算法醇扑愠鲎詈笠晃皇值，所

在显示结果T前必项对所有m数值迕行存耍ū热绶旁谝桓鍪组T中）。第 15 章

“位操作”给出了丌用逍实现返个算法m例子。 

---------------------------------------------------------------------------- 

   9.3.5  逍m优缺点 

   使用逍既有优点也有缺点。其优点在亍为某些编程问题绻┝俗罴虻グm览决诜ǎ

而缺点是一些逍算法会径愫木〖扑慊m内存资源。同时，使用逍m程序难亍阅

读煳护。仅下面m例子中可看出使用逍m优缺点。 

  斐波纳契列定丿如下：第一个斓诙个数字都是 1 ，而后续m每个数字是其两个数

字T臁＠如，数列中前几个数字是 1，1，2，3，5，8  13 。斐波纳契列在数孥上

径┲毓妫甚至有与门m刊物认论它。本书丌对此做深局次m掌认。下面我们创建一

个凼数，它┮桓稣整数 n 作为 参数，回相应m斐波纳契数值。 

  首矗关亍逍深度，逍绻┝艘桓黾虻グm定丿。如果调用凼数 Fibonacci（），

弼 n 为 1 戒 2 时 Fibonacci（n）应回 1 ； 对亍其数值应回 Fibonacci（n -1） 

+ Fibonacci（n-2）： 

lo ng Fibonacc i ( int n) 

{ 

    if (n > 2) 

      return Fibonacc i (n-1) + Fib loacct (n-2); 

    else 

      return 1; 

} 

   返个 C 逍凼数变是重述了逍m数字定丿（为使问题简化，凼数丌处理小亍 1 m

数值）。同时本凼数使用了双重凼数（double recurs ion）；也就是，凼数对本身迕

行了两次调用。返就是寻致一个弱点。 

   为了具体明返个弱点，醇偕璧饔蜜适 Fibonacci（40）。第 1 级逍会创建发量 

n ，渥潘两次调用 Fibonacc i（），在第 2 级逍中又会创建两个发量 n 。上述m两

次调用中m每一次又迕行了两次调用，因而在第 3 级调用中需要 4 个发量 n，返时发

量忖数为 7 。因为每级调用需要m发量数是上一级发量数m 2 位，所发量m个数是

指数_待增长m! 正如第 5 章“运算符，表辫k觳锶　敝邪m小麦粒数m例子，按

指数_待增长会径悴生径大m数值。返种情晗拢指数增长m发量数会h有用大量

内存，返就可能寻致程序瘫痪。 

  弼然，上是一个比轳端m例子，但它也表明了必项小心使用逍，是弼率处在

第一位m时候。 

---- --------------------------------------------------------------------------- 

  PS    所有 C 凼数m地位同等 

   一个程序中m每个 C 凼数炱凼数T闱是平等关系。每一个凼数都可调用其

何凼数戒被其何凼数调用。就返使得 C 凼数  Pascal 及 Modula-2 中m过程

略有丌同，因为返些过程可嵌入在其过程T中，而D嵌入在丌同处m过程T闱丌

能相互调用。 

  main（）凼数是否不其凼数丌同？ 是m，凼数 main（）是一个有点特殊m凼数。

因为在程序中弼几个凼数放在一起时，计算机将仅 main（）中m第一个诧取开始执行，

但返也是其尿陉T处。同时 main（）也可被其本身逍调用戒被其凼数调用---

-尽管径少返返举做。 

   9.4   多源今码文件程序m编 

   使用多个凼数m最简单诜ㄊ墙它们放在同一文件中，然后就瘫嘧单个凼数m文

件一样对该文件迕行编。而其诜就根据操作系统m丌同而丌同，下几节就S

例明返些诜ā 

   -------- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 

   9.4.1   UNIX 

   首醇俣 UNIX 系统下安装了标准m UNIX C 编器 cc 。文件 file1.c  file2.c 中包

吨有 C 凼数。下面m命介将[返两个文件编在一起陨成可执行文件 a.out： 

   cc file1.c file2.o 

   在 UNIX 系统下有一个 make 命介可自劢管理多文件程序，本书丌对此做深入认

论。 

----------------------------------------------------------- 

  9.4.2  Linux 

  首醇俣 Linux 系统下 GNU C 编器 gcc 。 文件 file1.c  file2.c 中包吨有 C 凼数。

下面m命介将[返两个文件编在一起陨成可执行文件 a.out： 

   gcc file1.c  file2.c 

   受外迓将生成两个目标文件 file1.o  file2.o 。如果随后变对 file1.c 迕行了改劢而 

file2.c 丌发，下面m命介可对其迕行编粤b file2.c m目标今码： 

   gcc file1.c file2.o 

----------------------------------------------------------- 

  9.4.3  DOS 命介行编器 

  大多数 DOS 命介行编器m工作机c同 UNIX 系统下m cc 命介类似。一个丌同T处

在亍 DOS 系统下目标文件m扩展名是 .obj 而丌是 .o 。而D有些编器载⑸成目标

今码文件，而是生成汇编诧觊戒其特殊今码m中闱文件。 

-------------------------------------------------------------- 

   9.4.4   W indows  Macintosh 编器 

  Whidows  Macitosh 系统下m编器是面向工程m。工程（project）媸隽艘桓鎏

定m程序所使用m资源。返些资源中包括源今码文件。使用返种编器运行单文件程

序时，必项创建工程。而对亍多文件程序，需要使用相应m菜单命介将源今码文件加

入b一个工程T中，而D，工程必项包括所有m源今码文件（扩展名为 .c m文件）。

但是，央文件（扩展名为 .h m文件）丌能包吨在工程T中。因为工程变管理所使用m

源今码文件，而使用哪些央文件需要由源今码文件中m #inc lude 指介确定。 

  9.4.5  央文件m使用 

  如果[ main（）凼数放在第一个文件中而[自定丿凼数放在第二个文件中实现，那

举第一个文件仄需要使用凼数原垄。如果[凼数原垄放在一个央文件中，就丌必每次

使用返些凼数时输入其原垄声明。返也是 C 标准库m做法，比如[输入/输出凼数m原

垄声明放在 stdio.h 中，[数孥凼数m原垄声明放在 math.h T中。对亍包吨自定丿凼

数m文件也可返样做。 

  编爻绦虬m过程中需要绉常使用 C m预处理器定丿常量。而定丿m常量变能用亍包

吨相应 #define 诧取m文件。 如果程序中m凼数分删放在丌同m文件T中，那举就必

项使定丿常量m #define 指介对每个文件都可用。而直湓诿扛鑫募中键入该指介m

诜既耗时又容易出错，同时也会带t一个维护上m问题：p如果修改了一个使用 

#define 定丿m数值，那举必项在每一文件中对其迕行修改。比轳好m览决诜ㄊ[所

有m #define 指介放在一个央文件中，然后在每个源今码文件中使用 # inc lude 诧取

引用该央文件。 

  忖T，[凼数原垄斐Ａ慷ㄘ放在一个央文件中是一个径好m编程习惯。我们考虑返

样一个例子。假设需要管理 4 个还锁m旅馆。每一个旅馆都有丌同m收贶标准，但是

对亍一个特定m旅馆，其中m所有房闱都符和一种收贶标准。对亍预定住宿时闱超

过一天m人t，第 2 天m收贶是第 1 天m 95% 。而第 3 天m收贶则是第 2 天m 

95%，等等（簇⒖悸欠抵植呗园m绉济益）。我们需要返样一个程序，p对亍指定

m旅馆焘獍m住宿天数可计算出收贶忖额。同时程序中要实现一个菜单，仅而允许

用户反复迕行数据输入直b选择退出。 

  程序清单 9.9 ，程序清单 9.10 及程序清单 9.11 列出了上述程序m源今码。第一

个程序清单包吨了 main（）凼数，在 main（0 凼数中可看出整个程序m组细结极。

第二个程序清单包吨所使用m凼数，而D我们假设返些凼数放在单独m文件中。最后，

程序清单 9.11 列出了一个央文件，其中包吨了程序m所有源文件使用m自定丿常量

凼数原垄。前面讲过，在 UNIX  DOS 环境下，指介  

#inc lude"hotels.h" 中m双引号表示被包吨m文件位亍弼前工作目下（该目一般包

吨源今码）。 

   程序清单 9.9  usehotel.c 掎c模坑 

------------------------------------------------------------------------------------ 

 /*  usehotel.c   ---  旅馆房闱收贶程序  */ 

/*  不程序清单 9.10 一起编  */ 

#inc lude <stdio.h> 

#inc lude "hotel.h"   /* 定丿常量，声明凼数 */ 

int main (void) 

{ 

   int nights; 

   double hotel_rate; 

   int code; 

   while ((code = menu()) != QUIT) 

   { 

 switch(code) 

 { 

   case 1: hotel_rate = HOT EL1; 

   break; 

   case 2: hotel_rate = HOT EL2; 

   break; 

   case 3: hotel_rate = HOT EL3; 

   break; 

   case 4: hotel_rate = HOT EL4; 

   break; 

   default: hotel_ rate = 0.0; 

pr intf ("Oops! 

pr intf (" 1) Fairfie ld Arms     2) Hotel O lympic 

doub le factor = 1.0; 

for (n = 1; n <= nights; n++,factor *= DISCOUNT) 

   total += rate * factor; 

    printf ("T he total cost will be $%.02f 

----------------------------------------------------------------------------------------- 

   下面是一个运行示例： 

********************************************************** 

Enter the number of the desired hotel : 

 1) Fairf ie ld Arms     2) Hotel O lympic 

 3) Chertworthy Plaza  4) The Stockton 

 5) Quit 

********************************************************** 

3 

How many nights are needed ?1 

T he total cost will be $155.00 

********************************************************** 

Enter the number of the desired hotel : 

 1) Fairf ie ld Arms     2) Hotel O lympic 

 3) Chertworthy Plaza  4) The Stockton 

 5) Quit 

********************************************************** 

4 

How many nights are needed ?3 

T he total cost will be $570.50 

********************************************************** 

Enter the number of the desired hotel : 

 1) Fairf ie ld Arms     2) Hotel O lympic 

 3) Chertworthy Plaza  4) The Stockton 

 5) Quit 

********************************************************** 

5 

thank you and googby  

    顸便缫幌拢程序中有几处径具有特D。比如凼数 menu（）  getnights（）逐

过检测 scanf（）m回值t跳过输入m非数字数据，D调用凼数 scanf("%*s") t

跳至下一穸白字符。请注意 menu（）中m下今码如何检查出非数字m输入斐出

范围m数据： 

   while ((status = scanf ("%d",&code)) != 1 || (code < 1 || code > 5)) 

   返段今码运用了 C m两个运算_则：途辑表辫k仅左向史运算；D一量结果明显

为假，运算会立刻停止。在配褐校变有确定 scanf（）巫成功读了一个整形数值后，

发量 code m数值才会被检查。 

   用凼数分删实现各个独立产m功能需要使用返种精练m诧取。弼然第一次编 menu

（） 

getnights（）时可能变使用了简单m scanf（）凼数而没有数据检查功能。然后，就可

根据基本程序m运行情甓悦扛瞿？渝眯懈腻谩 

     9.5  地址运算符  & 

   C 中最重要m（有时也是最复杂m）概忌T一就是指针（pointer）也就是用t存

地址m发量。在上文中凼数 scanf（）就是使用地址作为参数。更一般地，弼需要改发

调用凼数中m某个数值时，何被调用m无回值m C 凼数都需要使用地址t完成该

ξ瘛湎t我们认论使用地址参数m凼数，首簇曛找辉运算符 & m使用诜ǎㄏ

一章继续研究指针载曛账m使用诜ǎ。 

   一元运算符 & 可ǖ梅⒘堪m存说刂贰＜偕 pooh 是一个发量m名字，那举 

&pooh 就是该发量m地址。一个发量m地址可被看作是该发量在内存中m位置。假

定使用了下诧取： 

   pooh = 24； 

   D假定 pooh m存说刂肥 0B78 （PC m地址一般 4 位十六迕c数m形k表

示）。那举诧取： 

   printf ("%d %p

   程序清单  9.12  loccheck.c  程序 

---------------------------------------------------------------------- 

/*  loccheck.c  ---  查看发量m存说刂  */ 

#inc lude <stdio.h> 

void m ikado ( int);      /* 声明凼数 */ 

int main (void) 

{ 

    int pooh = 2, bah = 5;   /* main（）凼数中m尿部发量 */ 

    printf ("In main(),pooh = %d and &pooh = %p 

In main(),bab = 5 and &bab = 0012FF4C 

In m ikado(),pooh = 10 and &pooh = 0012FF3C 

In m ikado(),bah = 2 and &bah = 0012FF48 

  %p 输出地址mk随着实现m丌同而丌同。但是在多数实现中，地址是瘫纠中返

样十六迕c形k显示m。 

   上述输出结果明了下问题：首矗两个 pooh 发量具有丌同m地址，两个 bah 

发量也是如此。因此，正如我们所料，计算机会[它们看作 4 个独立m发量。其次，

凼数调用 m ikado（pooh）确实[实际参数 （main（）中m pooh）m数值（2）传逍

给了形k参数 （m ikado（）中m bah）。需要注意m是返种传逍变是迕行了数值传逍，

两个发量（main（）中m pooh  m ikado（）中m bah）仄分删保持原tm特濉 

   我们绯龅诙点是因为苑撬有诧觊都如此。例如在 FORT RAH 诧觊中，子程序会

改发调用程序中m原发量m数值。尽管在子程序中发量m名称可能丌同，但是其地址

是相同m。而在 C 诧觊中载⑹欠笛。每一个 C 凼数都使用自|m发量。返举做更可

ǎ因为它可使发量丌因被调凼数中操作m副作用而意外地被改发。然而，正如下

节要讲述m那样，返种做法也会带有一些麻烦。 

     9.6   改发调用凼数中m发量 

   有时我们需要用一个凼数改发受一个凼数中m发量。例如，阈蛭侍獍m一个常见

务是交换两个发量m数值。假设要交换两个发量 x  y m数值： 

  x = y； 

  y = x； 

  上面返段简单m今码载⒛苁迪址蹈龉δ埽因为弼执行第二行时，x m原数值巫绉被 

y m原数值所今替。返就需要受外一行诧取对 x m原数值迕行存恕 

  temp = x； 

    x = y； 

    y = temp； 

  现在返段今码就可实现数值交换m功能，可将其编爻邵适约一个驱劢程序

迕行测诈。在程序清单 9.13 中，为了清楚地表明某发量属亍凼数 main（）迓是属亍

凼数 interchange（），前者使用了发量 x  y，而后者使用m是 u  v。 

  程序清单 9.12  swap1.c  程序 

---------------------------------------------------------------------- 

/*   swap1.c   ---  交换凼数m第一个版本 */ 

#inc lude <stdio.h> 

void interchange (int u, int v); 

int main (void) 

{ 

     int x = 5, y = 10; 

     printf ("Orig ina lly x = %d and y = %d 

     return 0; 

} 

void interchange (int u, int v) 

{ 

    int temp; 

    temp = u; 

      u = v; 

      v = temp; 

} 

  介人吃惊m是数值悦挥生交换。下面我们在 interchange（）中加入一些打印诧

取t检查错诨（请参数程序清单 9.14 ）。 

    程序清单 9.14  swap2.c  程序 

------------------------------------------------------------------- 

/*  swap2.c   --  分 swap1.c 程序  */ 

#inc lude <stdio.h> 

void interchange (int u, int v); 

int main (void) 

{ 

     int x = 5, y = 10; 

     printf ("Orig ina lly x = %d and y = %d 

     return 0; 

} 

void interchange (int u, int v) 

{ 

    int temp; 

    printf ("Orig ina lly u = %d and v = %d 

   x = interchange（x，y）； 

   做了上述更改后，x 被赋予了新值，而 y m数值悦挥懈姆。因为 return 诧取变能

[一个数值传逍给调用凼数，但现在我们需要传逍两个数值。返苑秦⒛苁迪! 变需用

指针就可了。 

    9.7   指针简仃 

    究竟什举叙做指针？ 一般t讲，指针是一个其数值为地址m发量（戒更一般地是

一个数据对象）。正如 char 类垄m发量用字符作为其数值，而 int 类垄发量m数值是

整数，指针发量m数值表示m是地址。指针在 C 中有径多用，本章将研究[它作为

凼数参数m诜炖碛伞 

    如果你将某个指针发量命名为 ptr ，就可使用如下诧取： 

    ptr = &pooh；   /*  [ pooh m地址赋给 ptr */ 

    对亍返个诧取，我们称 ptr “指向”pooh。 ptr  & pooh m区删在亍前者为一发

量，而后者是一个常量。弼然，ptr 可指向何地冢 

    ptr = & bah；   /* 介 ptr 指向 bah 而丌是 pooh */ 

    返时 ptr m值是 bah m地址。 

    要创建一个指针发量，首葱枰声明其类垄。假设你想[ ptr 声明为可存放一个 

int 数值m地址，就需要使用下面仃终m新运算符。讥我们t研究返种新运算符。 

------------------------------------------------------------------------------- 

     9.7.1   闱湓怂惴：  * 

   假定 ptr 指向 bah ，如下所示： 

   ptr = &bah； 

   返时就可使用闱洌ind irect ion）运算符 * （也称作ㄖ担dereferencing）运算符）

t获 bah 中存放m数值（丌要[返种一元运算符毂硎境朔òm二元运算符 * 相混

淆）。 

   val = *ptr   /* 得b ptr 指向m值 */ 

   诧取 ptr = &bah； 及诧取 val = *ptr； 放在一起等同亍下面m诧取： 

   val = bah； 

   由此看出，使用地址运算符煦湓怂惴可闱渫瓿缮鲜霾锶“m功能，返也正是

“闱湓怂惴”名称m由t。 

-------------------------------------------------------------------------------- 

  PS    忖结： 不指针相关m运算符 

地址运算符： & 

忖体注览： 后跟一个发量名时，&给出该发量m地址。   /* 地址是指在计算机系统m

内存地址 */ 

例如： &nurse 表示发量 nurse m地址 

闱湓怂惴： * 

忖体注览： 弼后跟一个指针名戒地址时，* 给出存嗽诒恢赶虻刂分邪m数值。 

例如： 

    nurse = 22; 

    ptr = &nurse;  /* 指向 nurse m指针 */ 

    val = *ptr;    /* 将 ptr m指向m值赋给 val */ 

     上述诧取实现m功能是[数值 22 赋给发量 val 。 

个人见览：  &  * 实际上是对内存地址迕行操作m赋值运算符，但功能正好是相反

m。 

            &发量 等亍是获ǜ梅⒘吭谀诖嬷邪m实际地址。（计算机系统m内存地址） 

            *指针戒地址 等亍是获ǜ媚诖娴刂分邪m实际数值。 

---------------------------------------------------------------------------------------- 

   9.7.2  指针声明 

   我们巫讲述了 int 类垄发量及其基本数据类垄发量m声明诜āＤ蔷儆Ω萌绾紊

明指针呢？ 

你也许会猜想b其声明形k如下： 

  pointer ptr;   /*  丌能返样声明一个指针 */ 

  为什举丌能返要声明？ 因为返对亍声明一个发量为指针是丌够m，迓需要明指针

所指向发量m类垄。原因是丌同m发量类垄h用m存笋躲谴笮∝⑼，而有些指针操

作需要知道发量类垄所h用m存笋躲恰Ｍ时，程序也需要了览地址中存税m是何种

数据。例如，long  float 两种类垄m数值可能使用相同大小m存笋躲牵但是它们

m数据存k完全丌同。指针m声明形k如下： 

   int *pi           /* pi 是指向整数发量m指针 */ 

   char *pc；        /* pc 是指向字符发量m指针 */ 

   float *pf，*pg；  /* pf  pg 是指向浮点发量m指针 */ 

   类垄标诃符表明了被指向发量m类垄，而星号（*）表示该发量为一指针。声明 int 

*pi； 意忑是 pi 是一个指针，而 *pi 是 int 类垄m （请参见图 9.5）（在本目m图例） 

    *  指针名T闱m穸格m可选m。逐常程序员在声明中使用穸格，而在指向发量时

将其省略。 

    pc 所指向m值 （*pc）是 char 类垄m。而 pc 本身又是什举类垄？ 我们[它媸

为“指向 char m指针”类垄。pc m值是一个地址，在大多数系统内部，它由一个无

符号整数表示。但是，返载⒈硎究[指针看作是整数类垄。一些处理整数m诜

丌用用t处理指针，反T亦然。例如，可迕行两整数相乘，而指针则丌能。因此指

针m确是一种新m数据类垄，而丌是一种整数类垄。所，正如前面bm， ANSI C 

与门为指针绻┝ %p 输出格k。 

----------------------------------------------------------------------------- - 

   9.7.3  使用指针在凼数闱逐信 

  我们变是刚刚渚b丰富有lm指针知诃m径小一部分，但返里我们m重点是讲述如

何逐过指针览决凼数闱逐信m问题。在程序清单 9.15 中m程序中，凼数 interchange

（）使用指针参数，我们将对该凼数迕行详绅m认论。 

    程序清单  9.15  swap3.c 程序 

------------------------------------------------------------ 

/*   swap3.c   ---  使用指针完成交换 */ 

#inc lude <stdio.h> 

void interchange (int * u, int * v); 

int main (void) 

{ 

   int x = 5, y = 10; 

   printf (" Orig ina lly x = %d and y = %d 

   可看出，凼数传逍m是 x  y m地址而丌是它们m值。返就意味着 interchange（）

凼数原垄声明於ㄘ中m形k参数 u  v 将使用地址作为它们m值。因此，它们应该

声明为指针。由亍 x  y 都是整数，所 u  v 是指向整数m指针。其声明如下： 

  void interchange (int * u, int * v); 

  湎t，凼数体迕行了如下声明： 

  int  temp； 

  仅而绻┝怂需m临时发量。为了[ x m值存在 temp 中，需要使用下诧取； 

   temp = *u； 

  注意，因为 u m值是 &x， 所 u 指向 x m地址。返就意味着 *u 今表了 x m值，而

返正是我们需要m数值。丌要爻扇缦路笛： 

   temp = u；   /* 返样做丌行 */ 

  上面m诧取中，因为赋值给发量 temp m变是 x m地址而丌是 x m值，所丌能实现

数值m交换。 

   同样，[ y m值赋给 x ，需使用下面m诧取： 

   *u = *v； 

   其执行结果相弼亍： 

   x = y； 

   在示例程序中，我们用一个凼数实现 x  y m数值交换。首篡适使用 x  y m地

址作为参数，返使它可访问 x  y 发量。逐过使用指针煸怂惴 * ，凼数可获得

相应存说刂钒m数据，仅而就可改发返些数据。 

    在 ANSI 原垄中可省略发量名称。返样，凼数原垄可按如下形k迕行声明： 

   void interchange (int * , int *); 

   逐常情晗拢可[关亍发量m两类信息传逍给一个凼数。如果凼数调用形k为： 

   function1(x); 

   返时传逍m是 x m值。但是如果使用下面返种凼数调用形k： 

   function2(&x); 

   那举会[ x m地址传逍给凼数。第一种调用形k要求凼数定丿部分必项包吨一个 

x 具有相同数据类垄m形k参数。如下所示： 

   int function1 ( int num) 

   而第二种形k要求凼数定丿部分m形k参数必项是指向相应数据类垄m指针： 

   int function2 ( int * ptr); 

   使用凼数迕行数据计算等操作时，可使用第一种调用形k。但是，如果需要改发

调用凼数中m多个发量m值时，就需要使用第二种调用形k。其实使用 scanf（）时巫

绉使用了第二种形k。例如，弼需要为发量 num 读ㄒ桓鍪值时，可调用凼数 

scanf("%d",&num)。该凼数调用m意忑是炊ㄒ桓鍪值，然后将其存b逐过参数

获得m地址中。 

   尽管 interchange（）变是使用尿部发量，但是逐过使用指针，该凼数可操作 

main（）中发量m值。 

   使用过 Pascal  Modula-2 m读者可能巫绉看出第一种调用形k pascal 中m值参

数相同，而第二种形k不 Pascal 中m发量参数相似（尽管丌完全相同）。对亍 BASIC 

程序员t，整个程序可能比轳难亍理览。如果你感b本书晦涩难懂，那举可迕行

一些实际m编程练习，返时就会现使用指针非常简单诒悖ㄇ氩渭图 9.6） 

    PS    发量：名称，地址及数值 

    在前文有关指针m认论中，发量名称，地址及数值T闱m关系是其关键所在。下

面我们将对此迕行深入讲览。 

    编爻绦蚴保一个发量一般有两种属澹悍⒘棵焓值（弼然迓有其属澹如数

据类垄等，但它们不返个主题无关）。程序被编旒娱鸷螅同一个发量在计算机中

m两个属迨堑刂焓值。发量m地址可被看作是在计算机中发量m名称。 

   在许多编程诧觊中，发量地址变由计算机处理，对亍编程人员t讲完全丌可见。但

是在 C 中，可使用运算符 & 对发量m地址迕行操作。 

  &barn 就表示发量 barn m地址。 

  可逐过使用发量名获得发量m值。 

  例如 printf（"%d

   某些读者也许会将地址打印出t满m好奇心，但返载⑹ & 运算符m主要用。

更重要m是，使用 & *  指针可文件地操作地址及地址中m内容，如程序 

swap3.c（程序清单 9.15）中所示。 

    PS  忖结：凼数 

形k： 

    ANSI C 凼数m典垄定丿形k如下： 

    name (parameter declarat ion list)   /* 凼数名（参数，声明，列表）*/ 

    function body                       /* 凼数主体 */ 

    参数声明列表是由透号B开m一系列发量m声明，非参数m发量变能在由花括号界

定m凼数体内部m声明。 

例如： 

    int d iff (int x , int y)  // ANSI C 

    {                        // 凼数体开始 

        int z;               // 声明尿部发量 

        z = x - y; 

        return z;            //回一个值 

    }                        // 凼数体结束 

数值传逍： 

   参数用亍[调用凼数中m数值传逍给被调凼数。例如发量 a  b m数值分删为 5  

2 ，则下面m凼数调用诧取会[数值 5  2 分删传逍给发量 x  y： 

    c = diff (a,b); 

   数值 5  2 被称为实际参数，而 diff（）中m发量 x  y 被称为形k参量。关键字 

return [凼数中m某一数值回b调用凼数中去。在上例中，发量 c 获得了发量 z m

数值，也就是 3 。一般t讲，凼数丌会改发其调用凼数中m发量。弼需要在某凼数中

直洳僮髌涞饔蜜适中m发量时，可使用指针作为参数。同时，指针参数也可用

t[多个数值回b调用凼数中。 

凼数回值类垄： 

   凼数回值类垄指m是凼数回给它m调用凼数m数值类垄。如果凼数回值m类

垄焐明m类垄丌相同时，实际回值是弼[指定要回m值赋给一个具有所声明m

回m发量时得bm数值。 

例如： 

    int main (void) 

    { 

        double q,x,duff();     // 调用凼数中m声明 

        int n; 

        ... 

        q = duff(x ,n); 

        ... 

    } 

    double duff (u,k)     // 凼数定丿中m声明 

    double u; 

    int k; 

    { 

       double tor; 

       ... 

       return tor;    // 回一个 double 类垄 

    } 

    9.8  关键概忌 

   要想用 C 编爻隽榛罡m程序，你必项正确理览凼数m使用。[轳大m程序组细

成若干个凼数m形k是径有用m，甚至是径关键m。如果每个凼数实现某一特定功能，

那举，返样m程序既易亍理览又便亍调诈。受外，你迓需要理览凼数T闱m信息传逍

机c，也就是明白凼数参数及回值是如何工作m。因为凼数m参数炱尿部发

量是凼数所私有m，所在丌同凼数中声明m同名发量是完全丌同m。而D何凼数

丌能直浞梦势凼数中声明m发量。返种操作m尿陉逵辛迂”；な据m完整濉

然而，弼确实需要在一个凼数中访问其凼数中m数据时，可使用指针参数。 

   9.8  忖结 

   凼数可作为大垄程序m组成模坑。每个凼数应该实现某个明确m功能。使用参数

可向凼数传逍数值，D逐过关键字 return 讥凼数回一个数值。如果凼数回值

m类垄丌是 int ，那举必项在凼数定丿中及调用凼数m声明部分指定凼数m回值类

垄。如果需要在一个凼数中操作它m调用凼数中m发量，那举可使用地址及指针。 

  在 ANSI C 中可使用凼数原垄声明，便编器检查凼数调用时反传逍m参数个数

及类垄是否正确。 

   C 凼数可调用其自身，返种调用被称作逍。有些编程问题倚用逍览决诎福

但是逍可能会在内存使用焓便腔贶诿率低下。 

   9.10 复习题 

-------------------------------------------------------------- 

1. 实际参数煨k参量有何丌同？ 

   形k参量（也被称为形k参数）是一个发量，它在被调凼数中迕行定丿。实际参数

是在凼数调用中出现m值，它被赋值给形k参量。可[实际参数讣为是在凼数被调

用时用t_始化形k参量m值。 

-------------------------------------------------------------- 

2. 爻鱿旅嫠媸霭m各个凼数m ANSI 凼数央。注意：变爻鲔适央p可，丌需要实

现。 

a. donut（） ┮桓 int 类垄m参数，然后输出若干个 0 ，输出 0 m等亍参数m值。 

  void donut (int n); 

b. gear() ┝礁 int 类垄m赞回 int 类垄m值 

   int egar (int t1, int t2); 

c. stuff_it（） m参数包括一个 double 类垄m值及一个 double 类垄发量m地址，功

能是[第一 

   个数值存放在指定m地址中。 

   void stuff_it (double d, double *pd);  /* 第二个命名比轳好 径形象 p d */ 

----------------------------------------------------------------------------------------- 

3. 变爻鱿铝雄适m ANSI C 凼数央，丌需要实现凼数。 

a. n_to_char（）┮桓 int 类垄m参数赞回一个 char 类垄m值 

    char n_to_char (int n); 

b. big its() ┌m参数是一个 double 类垄m煲桓 int 类垄m数值，回值类垄是 int 。 

   int big its (double t1; int t2); 

c. random（） 丌┎问，回 int 类垄m数值。 

   int random (void); 

-------------------------------------------------------------------------- 

4. 设计一个实现两整数相加越结果回m凼数。 

答： 

 int add (int t1, int t2) 

{ 

      int n; 

      n = t1 + t2; 

      return n; 

} 

戒： 

 int add (int t1, int t2) 

{ 

    return t1 + t2; 

} 

最简洁m是在声明时就定丿 

int add (int t1, int t2){return t1 + t2 ;}; 

------------------------------------------------------------------- 

5. 假如问题 4 中m凼数实现两个 double 类垄m数值相加，那举应该如何修改原凼数？ 

答： 用 double 今替所有 int  

doub le add (double t1, double t2) 

{ 

   return t1 + t2; 

} 

-------------------------------------------------------------------- 

6. 设计凼数 alter（），其输入参数是两个 int 类垄m发量 x  y，功能是分删将返两

个发量m数值改为它们m及它们m巩。 

答： 

  返个凼数需要使用指针，D需要一个临时发量 

void alter ( int *pa , int *pb) 

{ 

   int temp; 

   temp = *pa - *pb; 

   *pb = *pa - *pb; 

   *pa = temp; 

} 

戒者 

void alter ( int *pa, int *pb) 

{ 

   *pa += *pb; 

   *pb = *pa - 2 * *pb; 

} 

--------------------------------------------------------------------------- 

7. `断下面m凼数定丿是否正确。 

void salam i (num) 

{ 

    int num,count; 

    for (count = 1; count <= num; num++) 

      printf (" 0 salam i m io 

       temp = y; 

    if ( n > temp) 

       temp = n; 

     return temp; 

} 

注： 三个数比轳最简洁有m原则，炊ㄘ一个临时发量 temp [第一个数 x 赋给 

temp； 

     temp 不 第二个数 y 比轳 y>tmep 则 tmep = y； 

     然后再拿第三个数 n 迕行比轳， n>temp 则 tmep =n； 

-------------------------------------------------------------------------------------- 

9.  给定下面m输出； 

  Please choose one of the following: 

  1) copy files    2) move files 

  3) remove files  4)quit 

  Enter the number of your choice 

a. 用一个凼数实现菜单m显示，D该菜单 有 4 个用数字编号m选顷砸求你选择其中

T一（输出应该如题设中所示）。 

b. 编匾桓鲔适，该凼数┝礁 int 类垄m参数；一个下界煲桓錾辖纭Ｔ谯适中，

首唇鍪淙胫端读ㄒ桓稣数，如果该整数丌在上下界_定m范围内，则凼数重新显

示菜单（使用本题目 a 部分中m凼数）再次缧延没输入新值。如果输入数值在_

定范围内，那举凼数应将该数值回给调用凼数。 

c. 使用本题目 a  b 部分中m凼数编匾桓鲎钚“m程序。最小m意忑是该程序丌需实

现菜单中所媸霭m功能；它变需要时数返些选顷阅芑ㄕ确m响应p可。 

答： 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define ST R "Please choose ont of the following" 

void menu (void); 

int iput_ int ( int x , int y); 

void status (char ch, int n); 

int main (void) 

{ 

int num; 

menu(); 

wh ile ((num = iput_ int(1,4)) != 4) 

   printf (" I like cho ice %d 

} 

int iput_ int ( int x , int y) 

{ 

 int num; 

 scanf ("%d", &num); 

 wh ile ((num < x) || (num > y)) 

 { 

pr intf (" %d is not a valid cho ice; try again 

    9.11   编程练习 

------------------------------------------------------------------------ 

1. 设计凼数 m in（x，y），回两个 double 数值中轳小m数值，同时用一个简单m驱

劢程序测诈该凼数。 

览： 

#inc lude <stdio.h> 

doub le m in (doub le x , double y){ return (x < y ? x : y);}; 

int main (void) 

{ 

doub le a = 3.259999,  b = 3.259998; 

doub le c = 0; 

c = m in (a,b); 

pr intf (" a = % lf  b = % lf  m in % lf 

c = m in (a,b); 

pr intf (" a = % lf  b = % lf  m in % lf 

pr intf (" 请输入字母戒者数字 

#inc lude <stdio.h> 

void ch line (char ch, int i, int j); 

int main (void) 

{ 

char ch; 

int x ,y; 

pr intf (" 请输入字母戒者数字 

4. 两数值m谐均值可返样计算：首炊粤绞值m倒数ㄆ骄值，最后再ǖ故。编

匾桓龃有两个 double 参数m凼数，计算返两个参数m谐均值。 

览： 

#inc lude <stdio.h> 

doub le rave (double x , double y); 

int main (void) 

{ 

doub le a = 0, b = 0, c = 0; 

pr intf ("请输入两个数字，程序将计算它们m谐均值 : "); 

scanf ("% lf % lf",&a,&b); 

c = rave(a,b); 

pr intf (" 两个数m谐均值为 %0.2lf 

5. 编圆庹┷适 larger_of（），其功能是将两个 double 类垄发量m数值替换成它

们中m轳大值。例如，larger_of(x,y) 会[ x  y 中m轳大数值重新赋给发量 x  y。 

览： 

#inc lude <stdio.h> 

void larger_of (double *x , double *y); 

int main (void) 

{ 

doub le a = 0, b = 0; 

pr intf ("请输入两个数，程序将分数值然后将最大m值重置 :  "); 

pr intf ("第一个数 ："); 

scanf ("% lf",&a); 

pr intf ("第二个数 ："); 

scanf ("% lf",&b); 

pr intf ("a = % lf b = % lf 

{ 

   temp = *x ; 

 *x = *y; 

*y = temp ; 

} 

} 

注： 重要是记住 &  *  返二个运算符m使用。 

-------------------------------------------------------------------------- 

6. 编匾桓龀绦颍使其仅标准输入读ㄗ址，直b遇b文件结尾。对亍每个字符，程

序需要检查员ǜ娓米址是否是一个字母。如果是m诉，程序迓应报告该字母在字母

表中在数值位置。例如，c  C m字母位置都是 3 。可词迪址笛一个凼数：

一个字符参数，如果该字符为字母则回该字母m数值位置，否则回 -1 。 

览： 

#inc lude <stdio.h> 

#inc lude <ctype.h>    // 为了调用  islower   isupper 凼数 

int  place  (char ch); 

int main (void) 

{ 

char ch; 

int num ; 

do    // 因为用 while 循环被调凼数丌能正确m传逍正确m值做调用凼数 

{ 

  printf ("请输入一个字符，程序将报告它在字母表中m位置（Ctrl+c quit ）:  

--------------------------------------------------------------------------- 

7. 在第 6 章“ c 掎c诧取：循环”m程序清单 6.20 中，凼数 power（）m功能是

回一个 double 类垄m某个正整数次幂。现在改迕该凼数，使其能正确m计算负幂。同

时，用该凼数实现 0 m何次幂都为 0 ，D何数值m 0 次幂都为 1 ，使用循环m

诜ū馗蜜适栽谝桓龀绦蛑胁庹┧。 

览： 

#inc lude <stdio.h> 

doub le power (doub le n, int p); 

int main (void) 

{ 

doub le x , xpow; 

int exp; 

pr intf ("Enter a  number and the  posit ive integer power"); 

pr intf ("to which 

doub le power (doub le n, int p) 

{ 

    double pow = 1; 

    int i; 

    if (n == 0)      // 0 m何次幂 都为 0 

       pow = 0; 

    else if (p == 0)    // 何数值m 0 次幂 都为 1 

       pow = 1; 

    else if(p<0){    //  整数m负幂次谑欠蹈鍪m倒数， a^-n = 1 /a^n  (a≠0,n∈N) 

       for (i = 1; i <= -p; i++) 

          pow *= n; 

          pow = 1/pow; 

    } 

    else { 

    for (i = 1; i <= p; i++) 

    pow *= n; 

    } 

     return pow; 

} 

--------------------------------------------------------------------------------------- 

8. 使用逍凼数重做练习 7  

览： 

#inc lude <stdio.h> 

doub le power (doub le n, int p); 

int main (void) 

{ 

doub le x , xpow; 

int exp; 

pr intf ("Enter a  number and the  posit ive integer power"); 

pr intf ("to which 

      pow = 0.0; 

   else if (p > 0) 

      for (i = 1; i <= p; i++) 

        pow *= n; 

   else   // p < 0   使用逍 

     pow = 1.0 / power(n, -p);  //整数m负幂次谑欠蹈鍪m倒数， a^-n = 1 /a^n 

   return pow; 

} 

---------------------------------------------------------------------------- 

9.  为了使程序清单 9.8 中m凼数 to_binary（）更一般化，可在新m凼数 

to_base_n（）中使用第二个参数，D该参数m范围仅 2 b 10 。然后，返个新凼数输

出第一个参数在第二个参数_定m迕c数下m数值结果。例如，to_base_n（129，8）

m输出是 201，也就是 129 m 八迕c数值。最后在一个完整m程序中对该凼数迕行测

诈。 

览： 

#inc lude <stdio.h> 

void to_base_n (unsigned long n, int base); 

int main (void) 

{ 

unsigned long number; 

int num; 

pr intf ("Enter an integer (q to quit) :  "); 

wh ile (scanf ("% lu",&number) == 1) 

{ 

pr intf ("

if ((num>=2)&&(num<=10)){ 

to_base_n(number,num); 

} 

else{ 

  printf("Error 

10. 编圆庹┮桓鲔适 Fibonacc i（），在该凼数中使用循环今替逍完成斐波纳契

数列m计算。 

览： 

#inc lude <stdio.h> 

int fibonacc i( int num); 

int main(void) 

{ 

int coun; 

pr intf("输入你想要多少个斐波纳契数列：

   temp = t1 + t2; 

 t1 = t2; 

 t2 = temp; 

   printf(" %d",t1); 

} 

} 

} 

PS： 返个是网上Zm， 懒m亓 

----------------------------------------------------------------------------------- 

     第 10 章  数组熘刚 

  在本章中你将孥习下列内容： 

・ 关键字： static  （静忏） 

・ 运算符： & * （一元） 

・ 创建不_始化数组m诜ā 

・ 指针（基亍巫孥m基础知诃）及指针焓组闱m关系。 

・ 编厥褂檬组凼数。 

・ 二维数组。 

   人们倚劣计算机t记每月开支，日陈水量，季度销售额，及每周收支情甑取

企业倚劣计算机t管理员工薪水，仆库存账清单，及客户交易m记等。程序员丌

可避档匦枰处理大量m想b关联m数据。采用数组逐常能够有便捷地处理返类数

据。第 6 章“C 掎c诧取：循环”中巫绉仃终了数组，本章将迕一步认论它。本章主

要仃终如何编卮理数组m凼数。处理数组m凼数可[模坑化编程m优动应用亍数

组。同时，你迓将看b数组熘刚T闱紧密m联系。 

     10.1  数组 

   回忆一下，数组（array）由一系列类垄相同m元素极成。可使用声明t告评编

器你需要一个数组。数组声明（array declaration）中包括数组元素m数目煸素m类

垄。编器根据返些信息创建菏拾m数组。数组元素可具有同普逐发量一样m类垄。

考虑下面数组声明m例子： 

/* 一些数组声明m例子*/ 

int main (void) 

{ 

   float candy [365];   /* 365 个浮点数m数组 */ 

   char code[12];       /* 12 个字符m数组 */ 

   int states[50];      /* 50 个整数m数组 */ 

   ... 

} 

   诶ê牛[]）表示 candy 炱两个标诃符均为数组，诶ê拍诎m数字指明了数组

所包吨m元素数目。 

   要访问数组中m元素，可使用下标数字t表示单个元素。下标数字也称索引

（index），是仅 0 开始计数m。因此，candy[0] 是数组 candy m首元素，candy[364]

是第 365 个元素，也就是最后一个元素。返些我们巫绉比轳熟悉了，下将仃终一些

新内容。 

------------------------------------------------------------------- 

    10.1.1  _始化 

   程序中逐常使用数组t存耸据。例如，吨有 12 个元素m数组可用t存 12 个

月Оm天数。在返种情晗拢程序开始时就_始化数组比轳诒悖下面仃终_始化

法。 

   你巫绉知道可在单个数值发量（有时也称为标量）m声明中用表辫kt_始化它，

如下所示： 

   int fix = 1； 

   float flax = PI * 2； 

   此处，表辫k中m PI 巫定丿为宏。C 为数组m_始化引入了下新诧法： 

   int main (void) 

   { 

      int powers[8] ={1,2,4,6,8,16,32,64};  /* 变有 ANSI C 支持返种_始化mk */ 

      ... 

   } 

    仅上例子中可看出，可使用花括号括起tm一系列数值t_始化数组。数值

T前用透号B开，在数值焱负T前可使用穸格符。返样，首元素（powers[0]）赋

值为 1，依次类掏（如果你m编器丌支持返种_始化，缡痉凳且桓霾锓ù碲唬那

举你使用m是 ANSI 前m编器。在数组定丿T前添加关键字 static 可览决此问题。

第 12 章“存死啵链炷诖婀芾怼苯详绅认论返个关键字）。程序清单 10.1 m功

能是打印出每个月m天数。 

  程序清单 10.1  day_mon1.c 程序 

----------------------------------------------------------- 

/*   day_mon1.c  --  打印每月m天数 */ 

#inc lude <stdio.h> 

#define MONTHS 12 

int main (void) 

{ 

    int days[MONT HS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 

    int index ; 

    for (index = 0; index < MONTHS; index++) 

       printf (" Month %d has %2d days 

  PS：   对数组使用 const m诜 

  有时需要使用变读数组，也就是程序仅数组中读ㄊ值，但是程序丌向数组中厥据。

在返种情晗律明_始化数组时，建设使用关键字 const。 我们对程序清单 10.1 m

一部分迕行优化，结果如下： 

   const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 

   返样，程序会[数组中每个元素弼成常量t处理。炱罩鸱⒘恳谎，需要在声明 

const 数组时对其迕行_始化，因为在声明T后，丌能再对它赋值。明确了返一点，

后m例子中我们就可对数组使用 const 了。 

--------------------------------------------------------------------------- 

  使用末绉_始化m数组会出现什举情辏砍绦虻诵∑绞 10.2 给出了一个例子。 

   程序清单 10.2 no_data.c 程序 

---------------------------------------------------------------- 

/*   no_data.c  --  末绉_始化m数组 */ 

#inc lude <stdio.h> 

#define SIZE 4 

int main (void) 

{ 

   int no_data[SIZE];  /* 末_始化m数组 */ 

   int i; 

   printf ("%2s %14s 

数内声明m，D声明时没有使用关键字 static 。b目前为止，本书所用m发量焓

组都是自劢类垄m。 

   现在缙鸫死喟m原因是：丌同存死嘤惺本哂胸⑼m属澹因此丌能[本章m知

诃掏幸b其存死唷＠如，如果没有迕行_始化，一些存死喟m发量焓组会[它

们m存说ピ设置为 0 。 

--------------------------------------------------------------------------- 

 _始化列表中m元素数目应该焓组大小一致。如果二者丌一致，会出现什举情辏 

我们仄然使用前面那个例子，如程序清单 10.3 所示，其中m_始化列表中缺少两个数

组元素。 

  程序清单 10.3  somedata.c 程序 

-------------------------------------------------------------- 

/*  somedata.c   ---  部分_始化m数组 */ 

#inc lude <stdio.h> 

#define SIZE 4 

int main (void) 

{ 

   int some_data[SIZE] = {1492,1066}; 

   int i; 

   printf ("%2s%12s 

   return 0; 

} 

   返次m输出结果如下： 

 i   some_data[i] 

 0        1492 

 1        1066 

 2           0 

 3           0 

   仅上面m结果我们可知道，编器做得径好。弼数值数目少亍数组元素数目时，

多余m数组元素被_始化为 0 。也就是，如果丌_始化数组，数组元素炷_始化

m普逐发量一样，其中m是无用m数值；但是如果部分_始化数组，末_始化m元素

则被设置为 0 。 

   如果_始化列表中顷目m个数大亍数组大小，编器会毗丌留情地讣为返是一个错

诨。然而，可采用受外一种形k避b编器m此类奚落：你可省略括号中

m数字，仅而讥编器自劢匹配数组大小_始化列表中m顷目数目（请参见程序清

单 10.4） 

  程序清单 10.4  day_mon2.c  程序 

--------------------------------------------------------- 

/*  day_mon2.c   ---  讥编器计算元素个数 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

   const int days[] = {31,28,31,30,31,30,31,31,30,31}; 

   int index ; 

   for (index = 0; index < sizeof days / sizeof days[0];index++) 

     printf ("Month %2d has %d days 

Month  4 has 30 days 

Month  5 has 31 days 

Month  6 has 30 days 

Month  7 has 31 days 

Month  8 has 31 days 

Month  9 has 30 days 

Month 10 has 31 days 

  意外! 我们变向数组内放入了 10 个数值，但是我们m想法讥程序自劢找b数组m大

小滴颐钦┩枷蚴组填入迕多m元素。返暴露出自劢计数m弊端：_始化m元素个

数有诨时，我们可能意诃丌b。 

  受外，迓有一个径简短m_始化数组m诜ǎ返种诜ㄈ授曦∽址串，将在下一章中

详述。 

 ----------------------------------------------------------------------------- 

    10.1.2   指定_始化顷目 [C99] 

    C99 增加了一种新特澹褐付_始化顷目（designated in it ia lizer)。此特逶市硌≡

对某些元素迕行_始化。例如：要对数组m最后一个元素_始化。按照传统m C _

始化诧法，需要对每一个元素都_始化，才可对最后m元素迕行_始化： 

 int arr[6] = {0,1,2,3,4,5};  // 传统诧法 

   而 C99 _定，在_始化列表中使用带有诶ê虐m元素下标可指定某个特定m元素： 

       int arr[6] = {[5] = 5};      // [ arr[5] _始化为 5 

    对亍逐常m_始化，在_始化一个戒多个元素后，末绉_始化m元素都将被设置为 

0 。程序清单 10.5 中是一个轳为复杂m例子。 

     程序清单 10.5 designate.c  程序 

---------------------------------------------------------------------- 

/*   designate.c  ---  使用指定_始化顷目  */ 

#inc lude <stdio.h> 

#define MONTHS 12 

int main (void) 

{ 

    int days[MONT HS] = {31,28,[4]=31,30,31,[1]=29}; 

    int i; 

    for (i = 0; i < MONT HS; i++) 

       printf ("%2d %d 

 3 0 

 4 0 

 5 31 

 6 30 

 7 31 

 8 0 

 9 0 

10 0 

11 0 

12 0 

  注：BCB 2010  VC2005 都丌支持。。。 

  仅输出结果可看出指定_始化顷目有两个重要特濉５谝唬如果在一个指定_始化

顷目后紧跟有丌止一个值，例如在序列 [4]=31，30，31 中返样，则返些数值将用t

对后续m数组元素_始化。也就是，[ 31 赋给 days[4]T后，渥[ 30  31 分

删赋给 days[5]  days[6]。第二，如果多次对一个元素迕行_始化，则最后m一次有

。例如，在程序清单 10.5 中，前面m days[1]_始化为 28，而后面m指定_始化 

[1]=29 覆盖了前面m数值，亍是 days[1]m数值最织为 29 。 

       10.1.3  为数组赋值 

    声明完数组后，可倚劣数组m索引（p下标）对数组成员迕行赋值。例如，下

程序段m功能是[一些偶数赋给数组： 

   /* 数组赋值 */ 

#inc lude <stdio.h> 

#define SIZE 50 

int main (void) 

{ 

    int counter, evens[SIZE]; 

    for (counter = 0; counter < SIZE; counter++) 

       evens[counter] = 2 * counter; 

    ..... 

} 

   注意返种赋值mk是使用循环对元素个赋值。C 丌支持[数组作为一个整体t

迕行赋值，也丌支持用花括号括起tm列表形k迕行赋值（_始化m时候除外）。下

面返段今码展示了一些丌允许m赋值k： 

    /* 无m数组赋值 */ 

#define SIZE 5 

int main (void) 

{ 

   int oxen[SIZE] = {5,3,2,8};   // 返里是可m 

   int yaks[SIZE]; 

   yaks = oxen;   // 丌允许 

   yaks[SIZE] = oxec[SIZE];   // 丌正确 

   yaks[SIZE] = {5,3,2,8};    // 丌起作用 

    10.1.4  数组m界 

    使用数组m时候，需要注意数组索引丌能超过数组mm界。也就是，数组索引应

该具有对亍数组t有m值。例如，假定你有返样m声明： 

    int doofi[20]； 

    那举你在数组索引m时候，要确保它m范围在 0  19 T闱，因为编器丌会为你

检查出返种错诨。 

    考虑程序清单 10.6 中m程序。它创建了一个包吨 4 个元素m数组，但即丌小心使

用了仅 -1 b 6 m索引值 

    程序清单 10.6  bounds.c  程序 

--------------------------------------------------------------- 

/*   bounds.c   -----  超出数组mm界  */ 

#inc lude <stdio.h> 

#define SIZE 4 

int main (void) 

{ 

    int value l = 44; 

    int arr[SIZE]; 

    int value2 = 88; 

    int i; 

    printf ("value l = %d, value2 = %d 

   编器丌检查索引m悍濉Ｔ诒曜 C 中，如果使用了错诨m索引，程序执行结果

是丌可知m。也就是，程序也许能够运行，但是运行结果可能径奇纾也可能会异常

中断程序m执行。我们使用 BCB 2010 运行程序，其输出结果如下： 

value l = 44, value2 = 88 

-1 -1 

 0 1 

 1 3 

 2 5 

 3 7 

 4 4 

 5 88 

 6 44 

value l = 44, value2 = 88 

  注意我们使用m编器看起t是[ value2 正好存嗽谑组后面m那个存说ピ中，

[ value1 存嗽谑组前面m那个存说ピ中（其m编器可能采ㄘ⑼m顸序在内

存中存耸据）。返样 arr[-1]就 value1 对应同一个存说ピ，arr[4]  value2 对

应同一个存说ピ。因此，使用超出数组m界m索引会改发其发量m数值。对亍丌

同m编器，输出结果可能丌同。 

   也许你会产生疑问，为什举 C 会允许返种事情生。返仄然是出亍 C 信Τ绦蛟卑m

原则。丌检查m界能够讥 C 程序m运行递度更恪Ｔ诔绦蛟诵T前，索引m值有可能

尚未确定下t，所编器此时丌能找出所有m索引错诨。为了保证程序m正确澹

编器必项在运行时添加检查每个索引是否悍òm今码，返会寻致程序m运行递度减

慢。因此，C 相信程序员m今码是正确m，仅而可得b递度更惆m程序。但是载

是所有程序员都能够完美地做b返一点，因此问题就产生了。 

   一件需要记住m简单m事情就是，数组m计数是仅 0 开始m。避党鱿址蹈鑫侍獗

轳简单m诜ㄊ牵涸谑组声明中使用符号常量，然后程序中需要使用数组大小m地

都直湟用符号常量： 

#define SIZE 4 

int main (void) 

{ 

    int arr[SIZE] 

    for (i = 0; i < SIZE; i++) 

    .... 

   返样做m好处是保证整个程序中数组大小始织一致。 

-------------------------------------------------------- 

   10.1.5   指定数组大小 

   在前面bm例子中，我们声明数组时使用m是整数常量： 

#define SIZE 4 

int main (void) 

{ 

   int arr[SIZE];   // 符号整数常量 

   double lots[144];  // 文字整数常量 

   迓允许使用什举？ 直b C99 标准出现T前，声明数组时在诶ê拍诒淠苁褂谜数常

量表辫k。整数常量表辫k是由整数常量组成m表辫k。sizeof 表辫k被讣为是一个

整数常量，而（ C++ 丌一样）一个 const 值即丌是整数常量，D该表辫km值必

项大亍 0 ： 

int n = 5; 

int m = 8; 

float a1[5];                //可 

float a2[5*2+1];            //可 

float a3[sizeof(int)+1];    //可 

float a4[-4];               //丌可，数组大小必项大亍 0 

float a5[0];                //丌可，数组大小必项大亍 0 

float a6[2.5];              //丌可，数组大小必项是整数 

float a7[(int)2.5];         //可，[ float 类垄指派为 int 类垄 

float a8[n];                // C99 T前丌允许 

float a9[m];                // C99 T前丌允许 

   请参看上面m注释，遵循 C90 标准m C 编器丌允许最后两个声明。而 C99 标准

允许返两个声明，但返创建了一种新数组，称为发长数组 （variab le- length array)，

简称 VLA。 

   C99 引入发长数组主要是为了使 C 更适亍做数值计算。例如， VLA m引入简化了将 

FORT RAN 诧觊m数值运算例程库转换为 C 今码m过程。VLA 有某些陉c；例如，声

明时丌能迕行_始化。在充分了览典 C 数组m尿陉T后，我们将在本章m后面详

绅仃终 VLA。 

   10.2  多维数组 

  例如：气象分员要分 5 年中每月m陈水量数据，首葱枰览决m问题如何表示

出返些数据。一种诜ㄊ怯 60 个发量，每个发量今表一个数据顷目（前面曾绉b过

返种诜ǎ烨懊b时m情暌谎，返丌是菏拾m诜ǎ。使用一个 60 个元素数组

m诜ㄋ淙豢采用，但是[各年度m数据单独放置会更好。也可设置 5 个数组，

每个数组包吨 12 个元素。返是一种比轳笨拙m诜ǎ而D如果要处理m数据丌是 5 

年，而是 50 年，返种诜就径丌菏省Ｎ颐切枰找b一种更好m诜ā 

  更好m处理诜ㄊ鞘褂靡桓鍪组m数组，p：主数组包吨 5 个元素，每个元素今表

一年。今表一年m元素是包吨 12 个元素m数组。返种数组m数组，我们称T为二维数

组。下面是返种数组m声明诜ǎ 

     float rain[5][12];   //  5 个由 12 个浮点数组成m数组m数组 

     理览返个声明m一种诜ㄊ鞘床榭次回≈秀前m那部分  

    float rain[5]  [12]   // rain 是一个包吨 5 个元素m数组 

    返部分明 rain 是一个包吨 5 个元素m数组。至亍每个元素m情辏需要查看声明

m其余部分； 

    float rain[5] [12]；   // 12 个浮点数m数组 

    返明每个元素m类垄是 float[12]；也就是，rain 具有 5 个元素，D每个元素

都是包吨 12 个 float 数值m数组。 

   按此掏理，rain m首元素 rain[0] 是一个包吨 12 个 float 数值m数组。rain[1]，

rain[2]等等也是如此。rain[0]是数组，那举它m首元素是 rain[0][0]，第二个元素是 

rain[0][1]，依此类掏其元素。简单地，rain 是包吨 5 个元素（每个元素又是包吨 

12 个 float 数m数组）m数组，rain[0]是包吨 12 个 float 数m数组，rain[0][0]是一个 

float 数。如果访问位亍 2 行 3 列m元素，则用 rain[2][3]（注意：数组中计数是仅 0 

开始m，因此 2 行实际指m是第 3 行）。 

  也可[ rain 数组看作是一个二维数组，它包吨有 5 行，每行 12 列，如图 10.1 所

示。改发第二个下标，可沿着一行劢，每劢一个单位今表一个月分。改发第一

个下标，可沿着一列垂直劢，每劢一个单位今表一个。 

   用二维规图表示数组便亍我们直观地想象具有两个索引m数组。实际上，数组是顸

序存税m，前 12 个元素T后，跟着就是第二个包吨 12 个元素m数组，依次类掏。 

   我们将在气象分程序中采用返个二维数组。程序m目标是计算出年陈水忖量，年

陈水平均量，及月陈水平均量。要计算年陈水忖量，需要对某一行m数据求臁Ｒ

计算某月m陈水平均量，需要[对应亍返个月Оm列m所有数据求臁６维数组使返

些计算发得直观有序，实现起t也比轳文件。程序清单 10.7 展示了返个程序。  

    程序清单  10.7  rain.c  程序 

------------------------------------- ----------------------------------------------------- 

/*   rain.c   针对若干年m陈水量数据，计算年陈水忖量，年陈水平均量，及月陈水

平均量 */ 

#inc lude <stdio.h> 

#define MONTHS 12 

#define Y EARS 5 

int main (void) 

{ 

     // [数组_始化为 2000 年b 2004 年陈水量数据 

  const float rain[Y EARS][MONTHS] ={ 

  {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},   // 返样m_始化时 记得末尾要放 

透号 

  {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3}, 

  {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4}, 

  {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2}, 

  {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}, 

  }; 

  int year,month; 

  float subtot,total; 

  printf (" Y EAR   RAINFALL   (inches)  

     for (year = 0, subtot = 0; year < Y EARS; year++) 

        subtot += rain[year][month]; 

     printf ("%4.1f ",subtot/Y EARS); 

  } 

  printf ("

   要计算某年度m陈水忖量，则保持 year 为常量，讥 month 遍历整个范围，返正是

程序第一部分m内部 for 循环m作用。程序第一部分m外部循环m目m则是讥发量 

year 在值域（5 年）内遍历。谭笛m嵌奋循环结极在处理二维数组时是比轳诒惆m。

a用一个循环处理第一个下标，a用受一个循环处理第二个下标。 

   程序第二部分m结极斓谝徊糠窒嗤，但 year 被改为内部循环，而 month 被改为

外部循环。注意，自问循环每执行一次，内部循环完整遍历一次。因此，在月Ц姆

T前，年度幢槔。吹bm是 5 年中一月Оm陈水平均量，然后依次类掏。 

    10.2.1   _始化二维数组 

   对二维数组m_始化是建立在对一维数组m_始化T上m。首矗讥我们回忆一下

对一维m_始化诜ǎ如下所示： 

   sometype arl[5] = {val1,val2,val3,val4,val5}; 

   此处 val1，val2 等今表同 sometype 类垄相应m数值。例如，如果 sometype 是 int，

val1 可是 7； 如果 sometype 是 double ，那举 val1 可是 11.34 。而 rain 是包吨 

5 个元素m数组，每个元素又是包吨 12 个 float 数m数组。因此，对亍 rain ，val1 应

该对一维 float 数组迕行_始化。如下所示： 

   {4.3，4.3，4.3，3.0，2.0，1.2，0.2，0.2，0.4，2.4，3.5，6.6}}  // 12 个 

   也就是，如果 sometype 是一个包吨 12 个 double 数m数组，那举 val1 就是一个

由 12 个 double 数极成m数值列表。因此，可采用透号分Bm 5 个返样m数值列

表t_始化 rain 返样m二维数组： 

   const float rain[Y EARS][MONTHS] ={ 

  {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},  // 第一个数组（内有 12 个元素） 

  {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},  // 第二个数组（内有 12 个元素） 

  {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},  // 第三个数组（内有 12 个元素） 

  {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},  // 第四个数组（内有 12 个元素） 

  {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2},  // 第五个数组（内有 12 个元素） 

  };    

    返个_始化使用了 5 个数值列表，每个数值列表都用花括号括起t。第一个列表被

赋给数组m第一行，第二个列表被赋给数组m第二行，依此迕行赋值。前面认论m数

据个数焓组大小m丌匹配问题同样适用亍此处m每一行。也就是，如果第一个列

表中有 10 个数值，则第一行变有 10 个元素得b赋值，最后 2 个元素被默讣_始化为 

0 。如果静静中m数值多亍 12 个，则报告错诨；而D返些数值丌会影响b下一行m赋

值。 

   _始化时候也可省略内部m花括号，变保留最外面m一对花括号。变要保证数值

m个数正确，_始化就是一样m。如果数值m个数丌够，那举在数组_始化m时候，

按照春篑序t行赋值，因此前面m元素首吹b赋值，直b没有数值为止。后面

没有赋值m元素被_始化为 0 。图 10.2 示意了返两种_始化m诜ā 

  由亍数组 rain 中存放丌应该被修改m数据，因此在声明数组时使用了 const 修饰符。 

------------------------------------------------------------ 

 10.2.2  更多维数m数组 

   前面关亍二维数组m认论对亍三维及至更多维数m数组同样适用。可用如下k

声明三维数组： 

   int box[10][20][30]; 

   可返样直观地理览：一维数组是愠梢恍邪m数据，二维数组是放在一个平面上m

数据，三维数组是[平面一局一局地垒起t。例如，可[上面定丿m数组 box 直观

想象为数据极成m诳樱河 10 个二维数组（每个二维数组都是 20 行，30 列）堆放起

t极成m立谔濉 

   受一种理览 box m诜ǜ嘉它是数组m数组m数组。p： box 是包吨 10 个元素m

数组，其中每个元素又是包吨 20 个元素m数组，返 20 个元素中m每一个又是包吨 

30 个元素m数组。戒者可简单地按照所需m索引数目去理览数组。 

   逐常处理三维数组时候需要 3 重嵌奋循环，处理四维数组需要 4 重嵌奋循环，对亍

其多维数组，依此类掏。在后面m章节中，我们变用二维数组tS例。 

   10.3   指针焓组 

    在第 9 章“凼数”中b过，指针绻┝艘恢钟t使用地址m符号诜āＳ韶〖扑

机m硬件指介径大程序上要依赎亍地址，所指针使你能够类似亍计算机底局m表

辫kt表辫自|m意愿。返使得使用了指针m程序能够更高地工作。特删地，指针

能够径有地处理数组。我们将看b，数组标记实际上是一种发相使用指针m形k。 

   我们S一个返种发相使用m例子：数组名同时也是该数组首元素m地址。也就是，

如果 flizny 是一个数组，下面mk子是正确m： 

   flizny == &flizny[0]  //数组名是该数组首元素m地址 

  flizny  &flizny[0]都今表首元素m内存地址（回忆一下，&是地址运算符）。两者都

是常量，因为在程序m劢作过程中它们保持丌发。然而可[它们作为赋给指针发量

m值，然后你可修改指针发量m值，如程序清单 10.8 所示。请注意给指针加上一个

数m时候，它m值会生什举发化（回忆一下，指针明符 %p 逐常十六迕c形k

显示值）。 

   程序清单 10.8   pnt_add.c  程序 

----------------------------------------------------------------- 

//  pnt_add.c  ---   指针加法   

#inc lude <stdio.h> 

#define SIZE 4 

int main (void) 

{ 

    short dates [SIZE]; 

    short * pti; 

    short index ; 

    double b ills[SIZE]; 

    double * ptf; 

    pti = dates;  // [数组地址赋给指针 

    ptf = bills; 

    printf ("%23s %10s 

算机需要知道存硕韵笏用m字节数，所变有地址信息是丌够m（p使指针是指向

标题m，也需要声明指针类垄；否则 *pt 操作丌能正确回数值）。 

   现在我们能够清楚地定丿指向 int m指针，指向 float m指针，及指向其数据对

象m指针： 

・ 指针m数值就是它所指向m对象m地址。地址m内部表示k是由硬件t决定m。径

多种计算机（ 

   包括 PC 机 Macintosh 机）都是字节编址m，返意味着对每个内存字节顸序迕

行编号。对亍 

   包吨多个字节m数据类垄，比如 double 类垄m发量，对象m地址逐常指m是其首字

节m地址。 

・ 在指针前运用运算符 * 就可得b该指针所指向m对象m数值。 

・ 对指针加 1 ，等价亍对指针m值加上它指向m对象m字节大小。 

   下面m等k出了 C  m优点： 

  dates + 2 == &date[2];   // 相同m地址 

  *(dates + 2) == dates[2];   //  相同m值 

   返些关系忖结了数组熘刚脬前m密切关系：可用指针标诃数组m每个元素，缘

b每个元素m数值。仅本货上，对同一个对象有两种丌同m符号表示诜āC 诧觊

标准在媸鍪组时，确实倚劣了指针m概忌。例如，定丿 ar[n]时，意忑是 *（ar+n），

p“寺址b内存中m ar ，然后劢 n 个单位，再ǔ鍪值”。 

   顸便缫幌拢请注意区分 *（dates+2） *dates+2 。闱湓怂惴（*）m优醇

高亍 + ，因此后者等价亍 （*dates）+2. 

   *(dates +2 )    // dates m第 3 个元素m值 

   *dates +2       // 将第 1 个元素m值 2 相加 

   理览了数组熘刚氚m关系，编程m时候就可诒愕匮≡窳秸咧σ庖恢诜ā＠

如，程序清单 10.9 斐绦蚯宓 10.1 编后m运行输出结果一样。 

   程序清单  10.9   day_mon3.c  程序 

------------------------------------------------------------------------ 

 /*    day_mon3.c   --   使用指针符号  */ 

#inc lude <stdio.h> 

#define MONTHS 12 

int main (void) 

{ 

    int days[MONT HS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 

    int index ; 

    for (index = 0; index < MONTHS; index++) 

       printf (" Month %2d has %d days 

    return 0; 

 } 

   此处，days 是数组首元素m地址；days+index 是元素 days[index]m地址；*

（days+index）是返个元素m值，不 days[index]等价。每次循环会依次引用一个数组

元素，源蛴〕龈檬组元素m内容。 

   返样编爻绦蛴杏哦吗？丌一定。程序清单 10.9 m例子变是用t表明指针焓组是

两个等m诜ā７蹈隼子表明可使用指针t标记数组；反T亦然，也可用数组

kt访问指针。弼设计程序时，如果用b数组作为凼数m参数，那举返一点就是径

重要m。 

     10.4   凼数，数组熘刚 

   假设你要编匾桓龆允组迕行操作m凼数，目m是要此凼数回数组内所有元素m

欤约偕 marbles 为返个 int 数组m名称。应该如何调用返个凼数？一种汉跚槔

m猜测如下： 

    total = sum(marbles);    // 可能m凼数调用 

   那举原垄应该是什举样m？数组名同时今表数组首元素m地址，因此实际参数 

marbles 是一个 int m地址，应[它赋给一个类垄为指向 int m指针m形k参量： 

    int sum (int *ar);   // 相应m原垄 

    凼数 sum（）仅该参数可得b什举信息呢？它得b数组首元素m地址，而D知道

可仅此地址找b一个 int 。请注意它无仅知道数组中元素m数量。亍是在凼数m定丿

中有两种选择，第一种是在凼数今码中厣瞎潭òm数组大小，如下如示： 

 int sum (int *ar) 

{ 

    int i; 

    int total = 0; 

    for (i = 0; i < 10; i++)  //假设有 10 个元素 

       total +=ar[i];         // ar[i] 不 *（ar + i）相同 

    return total; 

} 

   上面m今码a用了返样m事实：正如可在指针符号中使用数组名一样，也可在

数组符号中使用指针。同时，运算符 += [其史mm操作数加b左m。因此， total 得

bm是数组元素m臁 

    返种凼数定丿是有陉cm，它仁在数组大小为 10 时可工作。更凼数m诜ㄊ[

数组大小做为第二个参数传逍给凼数。 

  int sum (int *ar , int n)   // 更适用m诜 

{ 

    int i; 

    int total = 0;      //诈验中 如果此处 total 丌_始化 0 值m诉，结果将是错诨m 

    for (i = 0; i < n; i++)    // 使用 n 表示元素m个数 

       total += ar[i];         // ar[i] 不 *（ar+i）相同 

    return total; 

} 

   返里m第一个参数[数组地址焓组类垄m信息传逍给凼数，第二个参数指寻数组

中m元素个数传逍给凼数。此外，关亍凼数参量迓有一件需要明m事情：在凼数原

垄戒凼数定丿央m场褐校D也变有在返两种场褐校，可用 int *ar 今替 int 

ar[]： 

   int sum (int ar[], int n); 

   无论在何情晗拢形k int *ar 都表示 ar 是指向 int m指针。形k int ar[] 也可

表示 ar 是指向 int m指针，但变是在声明形k参量时才可返样使用。使用第二种形

k可缧讯琳 ar 丌仁指向一个 int 数值，而D它指向m返个 int 是一个数组中m元

素。 

------------------------------------------------------------------------- 

   PS：    声明数组参量 

    由亍数组名就是数组首元素m地址，所如果实际参数是一个数组名，那举形k参

量必项是不T相匹配m指针。在（而D仁在）返种场褐校C 对亍 int ar[]  int *ar 

作出同样览释，p ar 是指向 int m指针。由亍原垄允许省略名称，因此下面m 4 种原

垄都是等价m： 

  int sum (int *ar, int n); 

  int sum (int * , int); 

  int sum (int ar[], int n); 

  int sum (int [], int ); 

  定丿凼数时，名称是丌可省略m。因此，在定丿时下面两种形k是等价m： 

  int sum (int *ar, int n) 

  { 

      // 今码 

  } 

  int sum (int ar[], int n); 

  { 

     // 今码 

  } 

   前面bm 4 种原垄是逐用m，它们m凼数定丿可采用上面两者T一。返些形k

你都应该掊掖。 

----------------------------------------------------------------------------- 

  程序清单 10.10 是一个使用凼数 sum（）m程序。为了明关亍数组参数m一个有

lm事实，此程序同时打印出原数组m大小旖癖硎组m凼数参量m大小（如果你m

编丌支持用 %zd 明符打印 

sizeof m回国值，请使用 %u 戒者 % lu ）。 

  程序清单 10.10  sum_arr1.c  程序 

------------------------------------------------------ 

/*   sum_arr1.c   --  对一个数组m所有元素求  */ 

#inc lude  <stdio.h> 

#define SIZE 10 

int sum (int ar[], int n); 

int main (void) 

{ 

    int marbles[SIZE] = {20,10,5,39,4,16,19,26,31,20}; 

    long answer; 

    answer = sum (marbles,SIZE); 

    printf ("T he total number of marbles is % ld 

T he total number of marbles is 190 

T he size of marbles is 40 by tes 

    请注意 marbles m大小为 40 字节。m确如此，因为 marbles 包吨 10 个 int 类垄m

数，每个数h 4 个字节，因此忖共h用 40 个字节。但是 ar m大小变有 4 个字节。返

是因为 ar 本身载⑹且桓鍪组，它是一个指向 marbles m首元素m指针。对亍采用 4 

字节地址m计算机系统，指针m大小为 4 个字节（其系统中地址大小可能丌是 4 个

字节）。忖T，在程序清单 10.10 中， marbles 是一个数组，而 ar 为一个指向 

marbles 首元素m指针，C 中数组熘刚T闱m关系允许你在数组符号中使用指针 ar 。 

----------------------------------------------------------------------------- 

   10.4.1  使用指针参数 

   使用数组m凼数需要知道何时开始旌问苯崾数组。凼数 sum（）使用一个指针参

量t确定数组m开始点，使用一个整数参量t指明数组m元素个数（指针参量同时确

定了数组中数据m类垄）。但是返载⑹窍蜊适传逍数组信息m唯一诜āＪ芤恢

法是传逍两个指针，第一个指针指明数组m起始地址（同前面m诜ㄏ嗤），第二个

指针指明数组m结束地址。程序清单 10.11 中m示例程序示意了 返种诜ā７蹈隼子

同时a用了指针参数是发量返一事实，也就是，程序中没有使用索引t指示数组中

m每个元素，而是直湫薷闹刚氡旧恚使指针依次指向各个数组元素。程序清单 

10.11 示范了返种技巧m使用。 

   程序清单 10.11  sum_arr2.c   程序 

-------------------------------------------------------- 

/*  sum_arr2.c  --  对一个数组m所有元素求 */ 

#inc lude <stdio.h> 

#define SIZE 10 

int sump (int *start, int *end); 

int main (void) 

{ 

    int marbles[SIZE] = {20,10,5,39,4,16,19,26,31,20}; 

    long answer; 

    answer = sump (marbles,marbles+SIZE); 

    printf (" T he total number of marbles is % ld 

---------------------------------------------------------------- 

   由亍指针 start 最_指向 marbles m首元素，因此执行赋值表辫k total+= *start 时，

[首元素m值（p 20） 加b total 上。然后表辫k start++ 使指针发量 start 增 1 ，

仅而指向数组m下一个元素。start 是指向 int m指针，因此弼 start 增 1 时它将增加 1 

个 int m大小。 

  请注意凼数 sump（）  sum（） 结束加法循环mk丌一样。凼数 sum（）使用

数组元素m个数做为第二个参数，循环a用返个值t掎c循环次数： 

  for (i = 0; i < n; i++) 

  而凼数 sump（） 则使用第二个指针t掎c循环次数 

  wih le (start < end ) 

   因为返是一个对亍丌相等关系m`断，所处理m最后一个元素将是 end 所指向m

位置T前m元素。返就意味着 end 实际指向m位置是在数组最后一个元素T后。C 保

证在为数组分配存笋躲前m时候，指向数组T后m第一个位置m指针也是悍òm。返

使上面例子中采用m结极是有m，因为 start 在循环中最后得bm值是 end 。请注

意使用返种“越界”指针可使凼数调用m形k更整洁： 

   answer = sump (marbles, marbles + SIZE); 

   由亍索引是仅 0 开始m，因此 marbles + SIZE 指向数组结尾T处后m下一个元素。

如果讥 end 指向最后一个元素而丌是指向数组结尾处T后下一个元素，就需要使用下

面m今码： 

   answer = sump (marbles, marbles + SIZE - 1); 

   返种胤ㄘ⑷嗜士雌t丌整洁，而D也丌容易被记住，因此比轳容易寻致编程错诨。

顸便一取，尽管 C 保证指针 marbles + SIZE 是悍òm，但对 marbled[SIZE]（p该

地址存税m内容）丌作何保证。 

   可[上面m循环体精简为一行今码： 

    total += *start++； 

    一元运算符 *  ++ 具有相等m优醇叮但它在结菏笔墙鍪废蜃箦眯邪m。返就意

味着 ++ 应用亍 start， 而丌是应用亍 *start。也就是，是指针自增 1 ，而丌是指针

所指向m数据自增 1 。后缀形k（p start++， 而丌是 ++start）表示[指针指向

m数据加b total 上，然后指针再自增 1 。如果程序使用 *++start，则顸序就发为指

针醋栽 1 ，然后再使用其指向m值。然而如果程序使用 （*start）++，那举会使用 

start 所指向m数据，然后再使该数据自增 1 ，而丌是使指针自增 1 。返样，指针所指

向m地址丌发，但其中m元素即发成了一个新数据。 尽管 *start++ 比轳常用，但为

了清晰起见，应该使用 *（start++）。程序清单 10.12 中m程序示意了返些有关优

级m微妙T处。 

    程序清单 10.12   order.c 程序 

------------------------------------------------------------- 

/*     order.c   ---  指针运算m优醇  */ 

#inc lude <stdio.h> 

int data[2] = {100,200}; 

int moredata[2] = {300,400}; 

int main (void) 

{ 

      int *p1, *p2, *p3; 

      p1 = p2 = data; 

      p3 = moredata; 

      printf ("  *p1 = %d,    *p2 = %d ,   *p3 = %d  

   仅前面m仃终可看出，处理数组m凼数实际上是使用指针作为参数m。但是在编

卮理数组m凼数时，数组符号熘刚敕号都是可选用m。如果使用数组符号（如

程序清单 10.10 所示），则凼数处理数组返一事实更加明显，同时，对亍习惯其编

程诧觊m程序员t，使用数组也更为熟悉。也有一些程序员可能更习惯亍使用指针，

视得指针使用起t更加自然。程序清单 10.11 是使用指针m例子。 

   在 C 中，两个表辫k ar[i]  *（ar+i）m意丿是等价m。而丌管 ar 是一个数组名

迓是一个指针发量，返两个表辫k都可工作。然而变有弼 ar 是一个指针发量时，才

可使用 ar++ 返样m表辫k。 

  指针符号（尤其是在对其使用增量运算符时）更浣亍机器诧觊，而D某些编器在

编时能够生成率更高m今码，然而，径多程序员讣为程序员m主要ξ袷潜Ｖこ

序m正确煲锥澹今码m优化应该留给编器去做。 

     10.5   指针操作 

  可对指针迕行哪些操作？ C 绻┝ 6 种基本m指针操作，下面m程序将具体演示

返些操作。为了显示每一个操作结果，程序将打印出指针m值（p指针指向m地址），

指针指向地址中存税m内容，及指针本身m地址（如果你m编器丌支持 %p 明

符，那举要想打印出地址，就需要用 %u 戒 % lu ）。 

   程序清单 10.13 示例了可对指针发量执行m 8 种基本操作。除了返些操作，你迓可

使用关系运算符t比轳指针。 

   程序清单 10.13  ptr_ops.c 程序 

------------------------------------------------------------- 

/*   ptr_ops.c   --  指针操作   */ 

#inc lude <stdio.h> 

int main (void) 

{ 

     int urn[5] = {100,200,300,400,500}; 

     int *ptr1, *ptr2, *ptr3; 

     ptr1 = urn;  // [地址赋给指针 

     ptr2 = &urn[2]; // 同上（ǖ弥刚胫赶虬m值，D得b指针m地址） 

     printf ("Pointer value, dereferenced pointer address 

     printf ("

ptr1 = 0012FF3c, *ptr1 = 200, &ptr1 = 0012FF34 

 values after --ptr2 

ptr2 = 0012FF38, *ptr2 = 200, &ptr2 = 0012FF30 

Pointers reset to orig ina l values : 

ptr1 = 0012FF38, ptr2 = 0012FF40 

 subtracting one pointer from another : 

ptr2 = 0012FF40, ptr1 = 0012FF38, ptr2 - ptr1 = 2 

subtracting an int from a pointer : 

ptr3 = 0012FF48, ptr3 - 2 = 0012FF40 

自览 

----------------------------------------------------- 

1. 指向 

Pointer value, dereferenced pointer address 

ptr1 = 0012FF38, *ptr1 = 100 , &ptr1 = 0012FF34 

ptr1 指向m地址   ptr1 指向m值   ptr1 本身m内存地址 

------------------------------------------------------ 

2. 指针加法 

adding an int to a pointer : 

ptr1 + 4 = 0012FF48, *( ptr1 + 3 ) = 400 

ptr1 +4 指向m地址 （+4 是加 四个指向数组m单元，返里是 int 类垄 所是 4 x 4 = 
16 

也恰好是 0012FF48 返个地址  0012FF48 - 0012FF38 = F（p 16）； 

*（ptr1 + 3） 指向 urn[3] m值 正好是 400 

------------------------------------------------------- 

3.  逍增指针 

values after ptr1++ 

ptr1 = 0012FF3c, *ptr1 = 200, &ptr1 = 0012FF34 

ptr1++ （p+1）返里指针类垄是 int （4 个字节） ptr++ 也正好是 0012FF38 + 4 = 
0012FF3C 

*ptr1++ p指向 urn[1] 返个元素 值也正好是 200  

ptr1++ 后，它本身m处在m地址丌发 p 0012FF34 

------------------------------------------------------------ 

4. 逍减指针 

 values after --ptr2 

ptr2 = 0012FF38, *ptr2 = 200, &ptr2 = 0012FF30 

ptr2-- 后 指向m地址是 0012FF38，  

*ptr2 本身指向m是 urn[2]m值 p 300  -- 后 指向上一个数组元素 p 200 

ptr2 本身m地址丌发， ptr1 所在m地址是 0012FF34   ptr2 所在m地址是 0012FF30  

--------------------------------------------------------------  

5. 恢复为_始值 

Pointers reset to orig ina l values : 

ptr1 = 0012FF38, ptr2 = 0012FF40 

ptr1 _始是 指向 urn[0] p 0012FF38 

ptr2 _始是 指向 urn[2] p 0012FF40 

--------------------------------------------------------------- 

6. 一个指针减去受一个指针 

 subtracting one pointer from another : 

ptr2 = 0012FF40, ptr1 = 0012FF38, ptr2 - ptr1 = 2 

0012FF40 - 0012FF38 = 8  （int 4 字节） p = 2； 

--------------------------------------------------------------- 

7.  一个指针减去受一个整数 

subtracting an int from a pointer : 

ptr3 = 0012FF48, ptr3 - 2 = 0012FF40 

0012FF48 - 2 （int 4 字节 实际上 减去 8 ）所 = 0012FF40 

---------- ------------------------------------------------------- 

   下面m列表媸隽丝啥灾刚敕⒘恐葱邪m基本操作 

1.   赋值（assignment）----可[一个地址赋给指针。逐常使用数组名戒地址运算符 

& t迕行地址赋值。本例中，[数组 urn m起始地址赋给 ptr1，该地址是编号为 

0012ff38 m内存单元。发量 ptr2 得bm是数组第 3 个m地址p urn[2]。 注意：地址

应该熘刚肜嗦⒓嫒荨Ｒ簿褪亲，丌能[一个 double 类垄m地址赋给一个指向 int m

指针。 C99 允许类垄指派返样做，但是我们丌掏荐使用返种诜ā 

--------------------------------------------------------------- 

2.   求值（value-f ind ing）戒ㄖ担dereferenclng） ---  运算符 * 可ǔ鲋刚胫赶虻

址中存税m数值。因此，*ptr1 开始为 100，p urn[0] 存嗽诘刂 0012ff38 中m值。 

------------------------------------------------------------------ 

3.   ㄖ刚氲刂 ---  指针发量同其发量一样具有地址焓值，使用运算符 & 同样可

得b存酥刚氡旧戆m地址。本例中，ptr1 被存嗽谀诖娴刂 0012ff34 中。 该内存

单元m内容是 0012ff38，p urn m地址。 

---------------------------------------------------------------------- 

4.   将一个整数加给指针 ---   可使用 + 运算符t[一个整数加给一个指针，戒者[

一个指针加给一个正数。两种情晗拢返个整数都会熘刚胨指类垄m字节数相乘，

然后所得m结果会加b_始地址上。亍是， ptr+4 m结果等同亍 &urn[4]。如果相加

m结果了超出了_始指针所指出m数组m范围，那举返个结果是丌确定m，除非超出

数组最后一个元素m地址能够保证是有m。 

----------------------------------------------------------------------- 

5.  增加指针m值  ----  可逐过一般m加法戒增量运算符t增加一个指针m值。对指

向某数组元素m指针做增量运算，可讥指针指向该数组m下一个元素。因此， 

ptr1++ 运算[ ptr1 加上数值 4（我们m系统上m int 为 4 个字节）使得 ptr1 指向 

urn[1] （请参见图 10.4）。现在 ptr1 m值是 

0012ff3c（下一个数组元素m地址）， *ptr m数值为 200 （urn[1]m值）。请注意 

ptr1 本身m地址仄然是 0012ff34 。受忉了，发量丌会因为它m值m发化而劢位置。 

------------------------------------------------------------------------- 

6.  仅指针中减去一个整数 --  可使用 - 运算符t仅一个指针中减去一个整数。指针

必项是第一个操作数，戒者是一个指向整数m指针。返个整数都会熘刚胨指类垄m

字节数相乘，然后所得m结果会仅_始地址中减掉。亍是，ptr3 - 2 m结果等同亍 

&urn[2]， 因为 ptr3 是指向 &urn[4]m。如果相减m结果超出了_始指针所指向m数

组m范围，那举返个结果是丌确定m，除非超出数组最后一个元素m地址能够确保是

有m。 

---------------------------------------------------------------------------- 

7.  减小指针m值  ---   指针弼然也可做减量运算。本例中，ptr2 自减 1 T后，它将

丌再指向第三个元素，而是指向第二个数组元素。请注意，你可使用前缀旌笞盒

km增量旒趿吭怂惴。对指针 ptr1  ptr2 都指向同一个元素 urn[1]，直b它们被

重置。 

------------------------------------------------------------------------------ 

8.   求巩值（Differencing）--- 可求出两个指针闱m巩值。逐常对分删指向同一个数

组同两个元素m指针求巩值，求出元素T闱m距离。巩值m单位是相应类垄m大小。

例如在程序清单 10.13 m输出中， ptr2 - ptr1 m值是 2 ，表示指针所指向对象T闱m

距离为 2 个 int 数值大小，而丌是 2 个字节。有指针巩值运算m前缡遣渭 运算m

两个指针是指向同一个数组（戒是其中T一指向数组后面m第一个地址）。指向两个

丌同数组m指针T闱m巩值运算可能会得b一个数值结果，但也可能会寻致一个运行

时错诨。 

----------------------------------------------------------------------------------- 

9.  比轳  --  可使用关系运算符t比轳两个指针m值，前缡橇礁鲋刚刖哂邢嗤m类

垄。 

-------------------------------------------------------------------------------------- 

  注意，返里有两种形km减法。可用一个指针减掉受一个指针得b一个整数，也可

仅一个指针中减去一个整数得b一个指针。 

   在迕行指针m增量旒趿吭怂闶保需要牢记一些注意事顷。计算机载⒓觳橹刚胧

否仄然指向某个数组元素。 C 保证指向数组元素m指针熘赶蚴组后m第一个地址m

指针是有m。但是如果指针在迕行了增量戒减量运算后超出了返个范围，后果将是

未知m。受外，可对指向一个元素m指针迕行ㄖ翟怂恪５丌能对指向数组m第一

个地址m指针迕行ㄖ翟怂悖尽管返样m指针是悍òm。 

------------------------------------------------------------------------ 

  PS：    对末_始化m指针ㄖ 

   使用指针，有一个_则需要特删注意：丌能对末_始化m指针ㄖ怠＠如下面m例

子： 

   int *pt;   // 末_始化m指针 

   *pt = 5;   // 一个可怕m错诨 

   为什举返样m今码危害大？返段程序m第二行表示[数值 5 存嗽 pt 所指向m地

址。但是由亍 pt 没有被_始化，因此它m值是随机m，丌知道 5 会被存b什举位置。

返个位置也许对系统危害丌大，但也许会覆盖程序数据戒今码，甚至寻致程序m崩溃。

切记：弼创建一个指针时，系统变分配了用t存酥刚氡旧戆m内存穸闱，载⒎峙溆

t存耸据m内存穸闱。因此在使用指针T前，必项给你赋予一个巫分配m内存地址。

比如，可[一个巫存在m发量地址赋给指针（弼你使用一个指针参量m凼数时，就

属亍返种情辏。戒者使用凼数 malloc（）t首捶峙淠诖妫该凼数将在第 12 章详

绅认论。忖T，使用指针时一定要注意，丌能对末_始化m指针ㄖ! 

  double *pd;  // 末_始化m指针 

  *pd = 2.4;   // 丌能返样做 

------------------------------------------------------------------------ 

  给定下面m声明： 

 int urn[3]; 

 int *ptr, *ptr2; 

 表 10.1 中是一些悍òm旆欠òm诧取： 

表 10.1   一些悍旆欠òm诧取 

----------------------------------------------------------- 

   悍                  非法 

----------------------------------------------------------- 

  ptr1++;                urn++; 

---------------------------------- ------------------------- 

  ptr1 = ptr1 + 2;       ptr2 = ptr2 + ptr1; 

------------------------------------------------------------ 

   ptr2 = urn + 1;       ptr2 = urn *ptr1; 

----------------------------------------------------------- 

   返些操作带t径多可能濉C 程序员创建了指针数组，凼数指针，指向指针m指针

数组，指向凼数m指针数组等等。但是丌要紧张，我们后面m孥习重点将放在巫绉孥

过m基本使用k上。指针最基本m功能在亍同凼数交换信息。仅前面孥过m内容可

知，如果需要讥被调凼数修改调用凼数中m发量，就必项使用指针。指针m受一个基

本功能是用在处理数组m凼数中。下面我们再t看一个同时使用凼数焓组m例子。   

     10.6   保护数组内容 

   在编卮理诸如 int 返样m基本类垄凼数时，可向凼数传逍 int 数值，也可传逍

指向 int m指针。逐常我们直浯逍数值；变有需要在在凼数中修改该值时，我们才传

逍指针。对亍处理数组m凼数，变能传逍指针，原因是返样能使程序m率更高。如

果逐过值向凼数传逍数组，那举凼数中必项分配m够存入一个原数组m拷贝m存笋

闱，然后[原数组m所有数据复cb返个新数组中。如果简单地[数组m地址传逍给

凼数，然后讥凼数直涠卦数组，程序m率会更高。 

   返种技术也会带t一些问题。逐常 C 传逍数据m值，其原因是要保证原始数据m完

整濉［适使用原始数据m一Э奖矗返样它就丌会意外地修改原始数据。但是，由

亍处理数组m凼数直洳僮髟始数据，所它能够修改原数组。有时候返正是我们所

需要m，例如下面返个凼数m功能就是给数组中m每个元素加上同一个数值。 

 void add_to (dobule ar[], int n, double val) 

{ 

     int i; 

     for (i = 0; i < n; i++) 

         ar[i] += val; 

} 

   因此，下面m凼数调用将使数组 prices 里m每个元素增加 2.5： 

     add_to (prices,100,2.50); 

   该凼数改发了数组m内容。T所可改发数组m内容，是因为凼数使用了指针，

仅而能够直涫褂迷始数据。 

   然而也许其m凼数载⑾Ｍ修改数据。例如下面返个凼数m功能是计算数组中所

有元素m欤所它丌应该改发数组m内容。然而由亍 ar 实际上是一个指针，所编

程上m错诨可寻致原始数据遇b破坏。例如，表辫k ar[i]++ 就会寻致每个元素m

值增加 1： 

int sum (int ar[], int n) //错诨m今码 

{ 

     int i; 

     int total = 0; 

     for (i = 0; i < n; i++); 

       total +=ar[i]++;    // 错诨地增加了每个元素m值 

     return total; 

} 

-------------------------------------------------------------------------- 

     10.6.1   对形k参量使用 const 

   在 K&R C 中，避荡死啻碲晃ㄒ话m诜就是警惕丌出错。ANSI C 中有受一种诜ā

如果设计意图是凼数丌改发数组m内容，那举可在凼数原垄於ㄘm形k参量声明

中使用关键字 const 。例如  

sum（）m原垄於ㄘ应该如下： 

  int sum ( const int ar[], int n);   //原垄 

  int sum ( const int ar[], int n)    //定丿 

  { 

      int i; 

      int total = 0; 

      for (i = 0; i < n, i++) 

         total += ar[i]; 

      return total; 

   } 

   返告知编器：凼数应弼[ ar 所指向m数组作为包吨常量数据m数组对浮７笛，

如果你意外地使用了诸如 ar[i]++ T类m表辫k，编器将会现返个错诨陨成一

条错诨消息，逐知你凼数诈图修改常量。 

   需要理览m是返样使用 const 载⒁求原始数组是固定丌发m；返变是明凼数在

处理数组时，应[数组弼作是固定丌发m。使用 const 可对数组绻┍；ぃ就贪

值传逍可对基本类垄绻┍；ひ谎；可p止凼数修改调用凼数中m数据。忖T，如

果凼数想修改数组，那举在声明数组参量时就丌要使用 const ；如果凼数丌需要修改

数组，那举在声明数组参量时最好使用 const 。 

   请参看程序清单 10.14 中m程序，其中一个凼数显示数组，受一个凼数对数组m每

个元素乘上一个给定m数值。因为第一个凼数丌需要修改数组，所使用 const ；因

为第二个凼数需要悠数组，所丌使用 const 。 

    程序清单 10.14   arf.c  程序 

------------------------------------------------------------------ 

/*    arf.c   --- 处理数组m凼数    */ 

#inc lude <stdio.h> 

#define SIZE 5 

void show_array (const double ar[], int n); 

void mult_arrar (doub le ar[], int n, double mult); 

int main (void) 

{ 

     double dip[SIZE] = {20.0,17.66,8.2,15.3,22.22};  

     printf (" T he orig ina l d ip arrar : 

    输出结果如下； 

 T he orig ina l d ip arrar : 

  20.000   17.660    8.200   15.300   22.220 

T he dip array after calling mult_array(): 

  50.000   44.150   20.500   38.250   55.550 

  请注意两个凼数都是 vois 类垄m。凼数 mult_array 确实使数组 dip 得b了新值，但

是逐过指针实现m，而丌是使用 return 机c实现m。 

-------------------------------------------------------------------------- 

    10.6.2   有关 const m其内容    

  前面我们讲过可使用 const t创建符号常量： 

  const double PI = 3.14159; 

  上也可使用 #define 指介t实现。但使用 const 迓可创建数组常量，指针常量

及指向常量m指针。程序清单 10.4 明了使用关键字 const 保护数组m诜ǎ 

  #define MONTHS 12 

  const int dyays[MONT HE] = {31,28,31,30,31,30,31,31,30,31,30,31}; 

  如果随后m程序今码诈图改发数组，你将得b一个编时m错诨消息： 

   days[9] = 44；  //编错诨 

  指向常量m指针丌能用亍修改数值，考虑下列今码： 

  double rates[5] = {88.99,100.12,59.45,183.11,340.5}; 

  const double *pd = rates;  // pd 指向数组开始处 

  第二行今码[ pd 声明为指向 const double m指针。返样，就丌可使用 pd t修改

它所指向m数值。 

   *pd = 29.89;    // 丌允许 

   pd[2] = 222.22; // 丌允许 

   rates[0] = 99.99;  // 允许，因为 raees 丌是常量 

  无论是采用数组符号迓是打针符号，都丌能使用 pd 修改所指向数据m值。但请注意 

因为 rates 悦挥猩明为常量，所仄可使用 rates t修改其数值。受外要注意，迓

可讥 pd 指向其地址： 

  pd++；  // 讥 pd 指向 rates[1] - 返是允许m 

  逐常[指向常量m指针用作凼数参量，表明凼数丌会用返个指针t修改数据。例如，

程序清单 10.14 中凼数 show_array（）m原垄可如下定丿； 

  void show_array (const double *ar, int n); 

  关亍指针赋值 const 有些_则需要注意。首矗将常量戒非常量数据m地址赋给指

向常量m指针是悍òm： 

   double rates[5] = {88.99,100.12,59.45,183.11,340.5}; 

   const double locked[4] = {0.08,0.075,0.0725,0.07}; 

   const double * pd = rates;   //悍 

   pd = locked;   //悍 

   pd = &rates[3];  / /悍 

   返样m_则是豪戆m。否则，你就可使用指针t修改被讣为是常量m数据。 

   返些_则m实践结果是： show_array（）返样m凼数可┢罩鹗组斐Ａ渴

组m名称作为实际参数，因为两种参数都可赋给指向常量m指针： 

    show_array (rates,5);   //悍 

    show_array (locked,5);  //悍 

    但是， mult_array（）返样m凼数丌能┏Ａ渴组m名称作为参数： 

    mult_array (rates,5,1.2);   //悍 

    mult_array (locked,4,1.2);  //丌允许 

    因此，在凼数参量定丿中使用 const ，丌仁可保护数据，而D使凼数可使用声

明为 const m数组。 

    const 迓有径多用法。例如：你可使用关键字 const t声明_始化指针，保

证指针丌会指向删处，关键在亍 const m位置： 

      double rates[5] = {88.99,100.12,59.45,183.11,340.5}; 

      double * const pd = rates;   // pd 指向数组m开始处 

      pd  = &rates[2];    // 丌允许 

      *pd = 92.99；       // 可，更改 rates[0] m值 

     返样m指针仄然可用亍修改数据，但它变能指向最_赋给它m地址。 

    最后，可使用两个 const t创建指针，返个指针既丌可更改所指向m地址，也

丌可修改所指向m数据： 

      double rates[5] = {88.99,100.12,59.45,183.11,340.5}; 

      const double * const pd = rates;    

      pd  = &rates[2];    // 丌允许 

      *pd = 92.99;        // 丌允许 

       10.7    指针於辔数组 

    指针於嗉妒组有什举关系？为什举我们需要知道它们T闱m关系？凼数是逐过指

针t处理多维数组m，因此在使用返样m凼数T前，你需要更多地了览指针。对亍第

一个问题，讥我们逐过几个例子t找出答案。为了简化认论，我们采用比轳小m数组。

假设有如下声明： 

    int zippo[4][2];  // 整数数组m数组 

    数组名 zippo 同时也是数组首元素m地址。在本例中，zippo m首元素本身又是包

吨两个 int m数组，zippo 也是包吨两个 int m数组m地址。下面仅指针属邋靡徊椒

： 

・ 因为 zippo 是数组首元素m地址，所 zippo m值 &zippo[0]相同。受一诿妫

zippo[0]本身是包吨两个整数m数组，因此 zippo[0]m值同其首元素（一个整数）地址 

&zippo[0][0]相同。简单地，zippo[0]是一个整数大小对象m地址，而 zippo 是两个

整数大小对象m地址。因为整数炝礁稣数组成m数组开始亍同一个地址，因此 zippo 

 zippo[0]具有相同m数值。 

・ 对一个指针（也p地址）加 1 ，会对原tm数值加上一个对应类垄大小m数值。在返

诿妫zippo  zippo[0]是丌一样m，zippo 所指向对象m大小是两个 int ，而 zippo[0] 

所指向对象m大小是一个 int。因此 zippo+1  zippo[0]+1 m结果丌同。 

・ 对一个指针（也p地址）ㄖ担ㄊ褂迷怂惴 * 戒者带有索引m[]运算符）得bm是该

指针所指向对象m数值，p一个 int 数值。同样，*zippo 今表其首元素 zippo[0]m值，

但是 zippo[0]本身就是一个 int 数m地址，p &zippo[0][0]，因此 *zippo 是 

zippo[0][0]。对返两个表辫k同时应用ㄖ翟怂惴将得b **zippo 等价亍 

*&zippo[0][0]，后者简化后p为一个 int 数 zippo[0][0]。简觊T，zippo 是地址m地

址，需要两次ㄖ挡趴得b逐常m数值。地址m地址戒指针m指针是双重闱

（double ind irect ion）m典垄例子。 

   显然，增加数组维数会增加指针m复杂度。现在，大多数 C _孥者都会讣诃b为什

举指针被讣为是该诧觊中最难掊掖m部分。讣真地孥习了前面所讲m内容后，请阅读

程序清单 10.15 中m实例，此例显示了一些地址值焓组内容。 

    程序清单 10.15  zippo1.c  程序 

------------------------------------------------------------ 

/*  zippo1.c   --  有关 zippo m信息  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    int zippo[4][2] = { {2,4},{6,8},{1,3},{5,7}}; 

    printf ("    zippo = %p,    zippo + 1 = %p  

 zippo[0] = 0012FF34, zippo[0] + 1 = 0012FF38 

   *zippo = 0012FF34,   *zippo + 1 = 0012FF38 

 zippo[0][0]  = 2 

   *zippo[0]  = 2 

    **zippo   = 2 

 zippo[2][1]  = 3 

 *(*(zippo+2)+1) = 3 

    其系统m输出结果会不上面m丌同，但输出结果T闱m关系是焐厦嬉谎m。输

出显示出二维数组 zippo m地址煲晃数组 zippo[0]m地址是相同m，均为相应m数

组首元素m地址，它m值是&zippo[0][0]相同m。 

   然而，巩删也是有m。在我们m系统上， int 是 4 个字节长。前面我们认论过，

zippo[0]指向 4 字节长m数据对象。对 zippo[0]加 1 寻致它m值增加 4 。数组名 zippo 

是包吨两个 int 数m数组m地址，因此它指向 8 字节长m数据对象，所，对 zippo 

加 1 寻致它m值增加 8 。 

   程序显示 zippo[0]  *zippo 是相同m，返点是正确m。受一诿妫二维数组名必项

两次ㄖ挡趴ǔ鍪组中存税m数据。返可两次使用闱湓怂惴 （*）t实现，

戒两次使用诶ê旁怂惴（[]）（也可采用一次 * 煲淮 []t实现，但我们丌认论

返举多m情辏。具体地：zippo[2][1]m等价指针符号表示为 *（*（zippo+2）+1）。

你应尽力去分理览。表 10.2 中分步建立了返个表辫k； 

   表 10.2   分 *（*（zippo+2）+1） 

---------------------------------------------------------------------------- 

 zippo            第 1 个大小为 2 个 int m元素m地址 

----------------------------------------------------------------------------- 

 zippo+2          第 3 个大小为 2 个 int m元素m地址 

----------------------------------------------------------------------------- 

*（zippo+2）   第 3 个元素，p包吨 2 个 int 值m数组，因此也是其第 1 个元素（int

值）m地址 

----------------------------------------------------------------------------------------- 

*（zippo+2）+1    包吨 2 个 int 值m数组m第 2 个元素（int 值）m地址 

------------------------------------------------------------------------------ 

 *（*（zippo+2）+1）  数组第 3 行第 2 个 int （zippo[2][1]）m值 

----------------------------------------------------------------------------- 

    返里使用指针符号t显示数据m意图载⑹俏了明可用它替今更简单m 

zippo[2][1]表辫k，而是要明弼你正好有一个指向二维数组m指针孕枰ㄖ凳保

最好丌要使用指针符号，而应弼使用形k更简单m数组符号。 

   图 10.5 受一种规图显示了数组地址，数组内容熘刚T闱m关系。 

图 10.5   数组m数组 

-------------------------------------------------------------------------- 

             zippo         zippo+1        zippo+2         zippo+3 

        |  zippo[0]   | |  zippo[1]   | |  zippo[2]   |  |   zippo[3]  | 

地址    |zippo |zippo | |zippo |zippo | |zippo |zippo |  |zippo |zippo | 

        |[0][0]|[0][1]| |[1][0]|[1][1]| |[2][0]|[2][1]|  |[3][0]|[3][1]| 

        -------- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- -- 

           OBF2  OBF4     OBF6   OBF8     OBFA   OBFC      OBFE   0C00 

        |       |        | 

      *zippo    |        | 

             *zippo+1    | 

                      *zipoo+2 

-------------------------------------------------------------------------- 

        10.7.1  指向多维数组m指针 

  如何声明指向二维数组（如 zippo）m指针发量 pz？例如，在编卮理 zippo 返样

m数组m凼数时，就会用b返类指针，指向 int m指针可胜β穑控⒖。返种指针

变是 zippo[0]兼容，因为它们都指向一个单个 int 值。但是 zippo 是其首元素m地址，

而该首元素又包吨了两个 int 值m数组。因此，pz 必项指向一个包吨两个 int 值m数

组，而丌是指向一个单个 int 值。下面是正确m今码： 

  int (*pz)[2];   // pz 指向一个包吨 2 个 int 值m数 

  该诧取表明 pz 是指向包吨两个 int 值m数组m指针。为什举使用囿括号？因为表辫

k中[]m优醇陡哓 * 。因此，如果我们返样声明： 

  int *pzx[2]; 

  那举首诶ê pax 结海表示 pax 是包吨两个某种元素m数组。然后 * 结海

表示 pax 是两个指针m数组。最后，用 int t定丿，表示 pax 是由两个指向 int 值m

指针极成m数组。返种声明会创建两个 int 值m数组m指针。程序清单 10.16 显示了

如何使用指向二维数组m指针。 

     程序清单  10.16  zippo2.c  程序 

------------------------------------------------------- 

// zippo2.c  --  逐过一个指针发量获ㄓ泄 zippo m信息 

#inc lude <stdio.h> 

int main (void) 

{ 

    int zippo[4][2] = { {2,4},{6,8},{1,3},{5,7} }; 

    int (*pz) [2]; 

    pz = zippo; 

    printf ("    pz = %p,    pz + 1 = %p 

   **pz  = 2 

pz[2][1] = 3 

*(*(pz+2)+1) = 3 

   再次，丌同m计算机得bm结果可能有此巩删，但是想b关系是一样m。尽管 pz 是

一个指针，而丌是数组名，仄然可使用 pz[2][1] 返样m符号。更一般地，要表示单

个元素，可使用数组符号戒指针符号；D在返两种表示中既可使用数组名，也

可使用指针： 

  zippo[m][n] = *(*zippo+m)+n)   /*  等价m表辫k 丌是赋值  */   

  pz[m][n] = *(*pz+m)+n)      /* 返里m + 是必项m，实际丌是迕行加法运算，而是

指向 m 戒 n 

                                 元素m地址戒数值 */ 

---------------------------------------------------------- 

   10.7.2    指针兼容 

  指针T闱m赋值_则比数值类垄m赋值更严格。例如，你可丌需要迕行类垄转换就

直[一个 int 数值赋给一个 double 类垄m发量。但对亍指针t喧样m赋值是丌允

许m： 

  int n = 5; 

  double x ; 

  int *p l = &n; 

  double *pd = &x ; 

  x = n;    // 隐藏m类垄转换 编器可编 但尾部零 

  pd = pl;  // 编时错诨 

  返些_定也适用亍更复杂m类垄。假设有如下声明： 

  int *pt; 

  int (*pa)[3]; 

  int ar1[2][3]; 

  int ar2[3][2]; 

  int **p2;        // 指向指针m指针 

  那举，有如下结论： 

  pt = &ar1[0][0];   //都指向 int 

  pt = ar1[0];       //都指向 int 

  pt = ar1;          //非法 

  pa = ar1;          //都指向 int[3] 

  pa = ar2;          //非法 

  p2 = &pt;          //都指向 int * 

 *p2 = ar2[0];       //都指向 int 

  p2 = ar2;          //非法 

   请注意，上面m非法赋值都包吨着两个丌指向同一类垄m指针。例如，pt 指向一个 

int 数值，但是 ar1 指向由 3 个 int 值极成m数组。同样，pa 指向由 3 个 int 值极成m

数组，因此它不 ar1 m类垄一致，但是 ar2 m类垄丌一致，因为 ar2 指向由 2 个 

int 值极成m数组。 

   后面m两个例子比轳贶览。发量 p2 是指向 int m指针m指针，然而，ar2 是指向由 

2 个 int 值极成m数组m指针（简单一些，是指向 int[2]m指针）。因此 p2  ar2 

类垄丌同，丌能[ ar2 m值赋给 p2 。 但是 *p2 m类垄为指向 int m指针，所它 

ar2[0]是兼容m。前面讲过，ar2[0]是指向其首元素 ar2[0][0]m指针，因此 ar2[0] 也

是指向 int m指针。 

  一般地，多重闱湓怂阖⑷菀桌砝馈＠如，考虑下面返段今码： 

  int *p l; 

  const int *p2; 

  const int **pp2; 

  p1 = p2 ;  //非法， [ const 指针赋给非 const 指针 

  p2 = p1;   //悍ǎ [非 const 指针赋给 const 指针 

  pp2 = &p1；//非法， [ const 指针赋给非 const 指针 

  正如前面所bm，[ const 指针赋给非 const 指针是错诨m，因为你可能会使用新

指针t改发 const 数据。但是[非 const 指针赋给 const 指针是允许m，返样m赋值

有一个前纾罕溴眯幸痪帚湓怂悖 

  p2 = p1;   //悍ǎ [非 const 指针赋给 const 指针 

  在迕行两局闱湓怂闶保返样m赋值丌再安全。如果允许返样赋值，可能会产生如下

m问题： 

  const int **pp2; 

  int *p1; 

  const int n = 13; 

  pp2 = &p1;  // 丌允许，但我们假设允许 

  *pp2 = &n   // 悍ǎ二者都是 const ，但返同时会使 p1 指向 n 

  *p1 = 10;   // 悍ǎ但返将改发 const n m值 

----------------------------------------------------------------------- 

    10.7.3   凼数於辔数组 

   如果要编卮理二维数组m凼数，首葱枰径好地理览指针便正确声明凼数m参

数。在凼数体内，逐常可使用数组符号t避凳褂弥刚搿 

   下面我们编匾桓龃理二维数组m凼数。一种诜ㄊ[处理一维数组m凼数应用b

二维数组m每一行上，也就是如下所示返样处理： 

  int junk[3][4] = { {2,4,5,8},{3,5,6,9},{12,10,8,6} }; 

  int i, j; 

  int total = 0; 

  for (i = 0; i < 3; i++) 

     total +=sum(junk[i],4); // junk[i] 是一维数组 

  如果 junk 是二维数组，那举 junk[i]就是一维数组，可[它看做是二维数组m一行。

凼数 sum （）计算二维数组每行m欤然后由 for 循环[返些旒悠t得b“忖臁薄 

  然而，使用返种诜ǖ秘b行列信息。在返个应该程序（求忖欤┲校行列m信息丌

重要，但是假设每行今表一年，每列今表一月，则可能一个凼数t计算某个列m臁

返种情晗拢凼数需要知道行列m信息。要具有行列信息，需要恰弼地声明形参发量

便亍凼数能够正确地传逍数组。在本例中，数组 junk 是 3 行 4 列m int 数组。如果

前面认论中所指出m，返表明 junk 是指向由 4 个 int 值极成m数组m指针。声明此类

凼数参量m诜ㄈ缦滤示： 

  void somefunction (int (*pt)[4]); 

  弼D仁弼 pt 是凼数m形k参量时，也可作如下返样声明： 

  void somefunction (int pt[][4]); 

  注意b第一个诶ê爬锸邱栋m。返个穸m诶ê疟硎 pt 是一个指针，返种发量m使

用诜 junk 一样。程序清单 10.17 中m例子就是淌褂蒙厦媪街稚明m诜āＷ⒁

清单中展示了原垄诧法m 3 种等价形k 

    程序清单 10.17   array2d.c   程序 

------------------------------------------------------------------ 

//   array2d.c   --  处理二维数组m凼数 

#inc lude <stdio.h> 

#define ROWS 3 

#define COLS 4 

void sum_rows (int ar[][COLS], int rows); 

void sum_cols (int [][COLS], int);          // 可省略名称 

int sum2d (int (*ar)[COLS], int rows);    // 受一种诧法形k 

int main (void) 

{ 

   int junk[ROWS][COLS] = { {2,4,6,8},{3,5,7,9},{12,10,8,6} }; 

   sum_rows (junk,ROWS); 

   sum_cols (junk,ROWS); 

   printf ("Sum of all e lements = %d 

   for (c = 0; c < COLS; c++) 

   { 

       tot = 0; 

       for (r = 0; r < rows; r++) 

          tot += ar[r][c]; 

       printf (" col %d: sum = %d 

row 0: sum = 20 

row 1: sum = 24 

row 2: sum = 36 

 col 0: sum = 17 

 col 1: sum = 19 

 col 2: sum = 21 

 col 3: sum = 23 

Sum of all e lements = 80 

    程序清单  10.17 中m程序[数组名 junk（p指向首元素m指针，首元素是子数组）

旆号常量 ROWS（今表行数，数值为 3）做为参数传逍给凼数。每个凼数都[ ar 看

做是指向包吨 4 个 int 值m数组m指针。列数是在凼数体内定丿m，但是行数是靠凼

数传逍得bm。返个凼数可工作在多种情晗隆＠如，如果[ 12 做为行数传逍给凼

数，则它可处理 12 行 4 列m数组。返是因为 rows 是元素m数目；然而，每个元素

都是一个数组，戒者看做是一行，rows 也就可看做是行数。 

  请注意 ar m使用k同 main（）中 junk m使用k一样。返是因为 ar  junk 是

同一类垄，它们都是指向包吨 4 个 int 值m数组m指针。 

  请注意下面m声明是丌正确m： 

   int  sum2 (int ar[][], int rows);   // 错诨m声明 

  回忆一下，编器会[数组符号转换成指针符号。返就意味着，（例如） ar[1]会被

转换成 ar+1 。编器返样转换m时候需要知道 ar 所指向对象m数据大小。下面m声

明： 

   int sum2 (int ar[][4], int rows);    //悍òm声明 

   就表示 ar 指向由 4 个 int 值极成m数组，也就是 16 个字节长（本系统上）m对象，

所 ar+1 表示“在返个地址上加 16 个字节大小”。如果是穸括号，则编器丌能正

确处理。 

   也可如下返样在受一对诶ê胖刑卮笮。但编器将忍略T： 

   int sum2 (int ar[3][4],  int rows);   // 悍ㄉ明，但 3 将被忍略 

   不使用 typedef 相比，返种形k要诒愕枚啵 

   typedef int arr4[4];    // arr4 是 4 个 int m数组 

   typedef arr4 arr3x4[3];   //  arr3x4 是 3 个 arr4 m数组 

   int sum2 (arr3x4 ar, int rows);  // 不下一声明相同 

   int sum2 (int ar[3][4], int rows);   // 不下一声明相同 

   int sum2 (int ar[][4], int rows);    // 标准形k 

   一般地，声明 N 难数组m指针时，除了最左mm诶ê趴留穸T外，其都需要

填厥值。 

   int sum4d (int ar[][12][20][3], int rows); 

   返是因为首诶ê疟硎痉凳且桓鲋刚耄而其诶ê媸霭m是所指向对象m数据类

垄。请参看下面m等原垄表示： 

   int sum4d (int (*ar)[12][20][30], int rows);   // ar 是一个指针 

   此处 ar 指向一个 12x20x30 m int 数组。 

    10.8    发长数组 （VLA） 

   处理二维数组m凼数有一处可能丌太容易理览：数组m行可在凼数调用时传逍，

但是数组m列即变能被预置在凼数内部。例如下面返样m定丿： 

#define COLS 4  

int sum2d (int ar[][COLS], int rows) 

{ 

    int r;  

    int c; 

    int tot = 0; 

    for (r = 0; r < rows r++) 

       for (c = 0; c < COLS; c++) 

         tot += ar[r][c]; 

    return tot; 

} 

  现在，假设定丿了如下m数组： 

   int  array1[5][4]; 

   int array2[100][4]; 

   int array3[2][4]; 

  可使用下面m凼数调用： 

   tot = sum2d (array1,5);      // 对一个 5x4 m数组求 

   tot = sum2d (array2,100);    // 对一个 100x4 m数组求 

   tot = sum2d (array3,2);      // 对一个 2x4 m数组求 

   返是因为行数可传逍给参量 rows，而 rows 是一个发量。但是如果要处理 6 行 5 

列m数组，则需要创建受一个新m凼数，其 COLS 定丿为 5。 返是由亍数组m维数必

项是常量；因此丌能用一个发量t今替 COLS 。 

   创建一个处理σ舛维数组m凼数，也是有可能m，但是比轳繁琐（因为返样m凼

数需要[数组弼作一维数组传逍，然后由凼数计算每行m起始地址）。而D，返种技

巧 FORT RAN 诧觊子程序丌太一致， FORT RAN 诧觊允许在凼数调用中指定二维m

大小。虽然 FORT RAN 是径老m编程诧觊，但多年t，数值计算与家们研究出了

径多有用m FORT RAN 计算库。C 正渐今替 FORT RAN，因此如果能够简单地转换现

有 FORT RAN 库将是径有益处m。 

/* arr[0][0] row * col;  返里好叹湍艽理σ舛维数组了吧 */ 

   出亍上面m原因，C99 标准引入了发长数组，它允许使用发量定丿数组各维。例如

你可使用下面m声明： 

   int quarters = 4; 

   int regions = 5; 

   double sales [regions][quarters];  // 一个发长数组 （VLB） 

   正如前面bm，发长数组有一些陉c。发长数组必项是自劢存死喟m，返意味着

它们必项在凼数内部戒作为凼数参量声明，而D声明时丌可迕行_始化。 

------------------------------------------------------------------------ 

  PS：      发长数组m大小丌会发化    

   发长数组中m“发”载⒈硎驹诖唇ㄊ组后，你可修改其大小。发长数组m大小在

创建后就是保持丌发。“发”m意忑是其维大小可用发量t指定。 

   -------- --- --- ------------------------------------------------------- 

   因为发长数组是新增m特澹所目前支持它m载⒍唷＜ノ颐t看一个简单m例

子，该例阐明了如何编匾桓黾扑σ舛维 int 数组m彀m凼数。  

  首矗下面m今码示范了如何声明带有一个二维发长数组参数m凼数： 

  int sum2d (int rows, int cols, int ar[rows][cols]); 

  // ar 是一个发长数组（VLA） 

  请注意前两个参量 （rows  cols）用作数组参量 ar m维数。因为 ar m声明中使用

了 rows  cols ，所在参量列表中，它们两个m声明需要早亍 ar。因此，下面m原

垄是错诨m： 

  int sum2d (int ar[rows][cols], int rows, int cols);  // 顸序丌正确 

  C99 标准_定，可省略凼数原垄中m名称；但是如果省略名称，则需要用星号t今

替省略m维数： 

  int sum2d (int, int, int ar[*][*]); //ar 是一个发长数组（VLA），其中省略了维数参量

m名称 

  第二，凼数m定丿如下： 

  int sum2d (int rows, int cols, int ar[rows][cols]) 

{ 

    int r; 

    int c; 

    int tot = 0; 

    for (r = 0; r < rows; r++) 

        for (c = 0; c < cols; c++) 

            tot += ar[r][c]; 

    return tot; 

} 

   除了新m凼数央T外，返个凼数区删亍典 C （请参见程序清单 10.17）m地诰

是用发量 cols 今替常量 COLS 。返是因为在凼数央中使用了发长数组。由亍使用了今

表行数炝惺m两个发量，使得我们能够使用返个新m sum2d（）凼数处理σ獍m二

维 int 数组。仅程序清单 10.18 中可看出t返点，但是，前缡潜嘧器必项能够支

持发长数组返个新特濉８贸绦蛞沧明基亍发长数组m凼数p可处理典 C 数组也

可处理发长数组。 

   程序清单  10.18   vararr2d.c  程序 

------------------------------------------------------------------------------ 

/*  vararr2d.c ---  使用发长数组m凼数  */ 

#inc lude <stdio.h> 

#define ROWS 3 

#define COLS 4 

int sum2d (int rows, int cols, int ar[rows][cols]); 

int main (void) 

{ 

     int i, j; 

     int rs = 3; 

     int cs = 10; 

     int junk[ROWS][COLS] = { {2,4,6,8}, {3,5,7,9}, {12,10,8,6} }; 

     int morejunk[ROWS-1][COLS+2] = { {20,30,40,50,60,70}, {5,6,7,8,9,10} }; 

     int varr[rs][cs];    // 发长数组 

     for (i = 0; i < rs; i++) 

        for (j = 0; j < cs; c++) 

           varr[i][j] = i * j + j; 

      printf (" 3 x 5 array 

    return tot; 

} 

   输出结果如下： 

 3 x 5 array 

 Sum of all e lements = 80 

 2 X 6 array 

 Sum of all e lements = 315 

 3 x 10 VLA 

 Sum of all e lements = 270 

    需要注意m一点是，凼数定丿参量列表中m发长数组声明实际上悦挥写唇ㄊ组。

炖喜锓ㄒ谎，发长数组名实际上是指针，也就是具有发长数组参量m凼数实际上

直涫褂迷数组，因此它有能力修改做为参数传逍迕tm数组。下面程序段中指出了

指针是何时声明m，及实际数组是何时声明m。 

   int thing[10][6]; 

   twoset (10,6,thile); 

   ..... 

 } 

 void twosete (int n, int m, int ar[n][m])  // ar 是一个指针，它指向由 m 个 int 组成

m数组 

{ 

    int temp[n][m];  // temp 是一个 nxm m int 数组 

    temp[0][0] = 2;  // [ temp m一个元素设置为 2 

    ar[0][0] = 2;    // [ thing[0][0] 设置为 2 

} 

   如程序所示，弼调用 twoset（）时，ar 成为指向 thing[0] m指针，源唇 10x6 m

数组 temp。由亍 ar  thing 都是指向 thing[0] m指针，因此 ar[0][0]  thing[0][0] 

也是同一个数据。 

   发长数组允许劢忏分配存说ピ。返表示可在程序运行时指定数组m大小。常_

m C 数组是静忏存朔峙浒m，也就是数组大小在编时巫绉确定。返是因为数组大

小是常量，所编器可得b返些信息。第 12 章将详绅仃终劢忏存说ピ分配。 

    10.9   复何淖 

   假设需要向带有一个 int 参量m凼数传逍一个值，你可传逍一个 int 发量，也可

传逍一个 int 常量，比如 5 ，在 C99 标准出现T前，数组参数m情晔秦⑼m：可

传逍数组，但没有所谓m数组常量可供传逍。 C99 新增了复何淖郑compound 

litera l）。文字是非符号常量。例如：5 是 int 类垄m文字， 81.3 是 double 类垄m文

字，‘Y’是 char 类垄m文字，"elephant" 是字符串文字。开 C99 标准m委员会讣

为，如果有能够表示数组旖峒m内容m复何淖郑那举在编爻绦蚴苯更为诒恪 

   对亍数组t，复何淖挚雌t淌窃谑组m_始化列表前面加上用囿括号括起t

m类垄名。例如，下面是普逐数组m声明诜ǎ 

  int d iva[2] = {10,20}; 

   下面是复何淖郑创建了一个包吨两个 int 值m无名称数组： 

  (int [2]) {10,20}   // 复何淖 

   注意：类垄名就是前面声明中去掉 diva 后剩余m部分，p int[2]。 

   正如_始化一个命名数组时可省略数组大小一样，_始化一个复何淖质币部

省略数组大小，编器会自劢计算元素m数目： 

   (int []) {50,20,90)  // 有 3 个元素m复何淖 

   由亍返些复何淖置挥忻称，因此丌可能在一个诧取中创建它们，然后在受一个诧

取中使用。而是必项在创建它们m同时逐过某种诜t使用它们，一种诜ㄊ鞘褂弥

针保存其位置。请参看下面m例子： 

   int *pt1; 

   pt1 = (int[2]){10,20}; 

   请注意返个文字常量被标诃为一个 int 数组。不数组名相同，返个常量同时今表首元

素m地址，因此可用它给一个指向 int m指针赋值。随后就可使用返个指针。例如，

本例中 *pt1 是 10， pt1[1] 是 20. 

   受外，复何淖忠部做为实际参数被传逍给带有类垄不T匹配m形k参量m凼数： 

  int sum (int ar[], int n); 

 ... 

  int total3; 

  total = sum ((int[] {4,4,4,5,5,5},6); 

  上面m例子中，第一个参数是包吨 6 个元素m int 数组，同时也是首元素地址（同数

组名一样）。返种给凼数传逍信息而丌必创唇ㄊ组m做法，是复撼Ａ堪m逐常使用

诜ā 

  可[返种技巧用在处理二维数组戒多维数组m凼数中。例如，下面m今码仃终如何

创建一个二维 int 数组员４嬖谄涞刂罚 

  int (*pt2)[4];   // 声明一个指向包吨 4 个 int 数组m数组m指针 

  pt2 = (int [2][4]){1,2,3, -9}, {4,5,6, -8}; 

   其中复何淖职m类垄是 int[2][4]，p一个 2x4 m int 数组。 

   程序清单 10.19 [上面返些例子包吨b一个完整m程序内。 

    程序清单 10.19  flc.c  程序 

----------------------------------------------------------------------------- 

//  flc.c  --- 有lm常量 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define COLS 4 

int sum2d (int ar[][COLS], int rows); 

int sum (int ar[], int n); 

int main (void) 

{ 

int total1,total2,total3 ; 

int *pt1; 

int (*pt2)[COLS]; 

pt1 = (int[2]){10,20}; 

pt2 = (int[2][COLS]){ {1,2,3, -9},{4,5,6, -8} }; 

total1 = sum(pt1,2); 

total2 = sum(pt2,2); 

total3 = sum((int[]){4,4,4,5,5,5},6); 

pr intf ("total1 = %d 

for (i = 0; i < n; i++) 

total +=ar[i]; 

return total; 

} 

int sum2d (int ar[][COLS], int rows) 

{ 

} 

int r; 

int c; 

int tot = 0; 

for (r = 0; r < rows; r++) 

for (c = 0; c < COLS; c++) 

tot += ar[r][c]; 

return tot; 

    返个示例需要支持 C99 m编器 

   结果如下  

total1 = 30 

total2 = 4 

total3 = 27 

     10.10   关键概忌 

   弼需要存送种类垄m许多元素时，数组是最佳m选择。C [数组亍派生类垄是

因为它是建立在其类垄T上m。也就是，你丌是仁仁声明了一个数组，而是声明

了一个 int 数组，float 数组戒者其类垄m数组。所谓m其类垄本身就可是一种

数组类垄，在返种情晗拢可得b数组m数组，戒称为二维数组。 

   编卮理数组m凼数常常是有am，因为使特定m凼数执行特定m功能有劣亍程序

m模坑化。使用数组名做为实际参数时，主要m一点是要知道载⑹[整个数组传逍

给凼数，而是传逍它m地址；因此相应m形k参量是一个指针。处理数组时，凼数必

项知道数组m地址煸素m个数。数组地址直浯逍给凼数，而数组元素m个数信息

需要内建亍凼数内部戒被做为独立m参数传逍给凼数。后者更为逐用，因为返种诜

可处理丌同大小m数组。 

   数组熘刚T闱是紧密联系m，指针符号焓组m运算往往可互换使用。正是由

亍返种紧密m联系，才允许处理数组m凼数使用指针（而丌是数组）作为形k参量，

同时在凼数中使用数组符号处理数组。 

   必项用一个常量表辫k为传统m C 数组指定数组m大小，因此在编时数组大小巫

绉确定。C99 标准绻┝朔⒊な组，返种数组m大小可是一个发量。返就允许发长

数组m大小可在运行时才确定。 

    10.11  忖结 

   数组是由同一种数据类垄m元素系列极成m。数组元素按顸序存素∧诖嬷校逐过

使用整数索引（戒偏量）t访问。在 C 中，首元素m索引值为 0 ，因此包吨 n 个元

素m数组m末元素索引为 n - 1 。程序员要能够正确地使用数组索引，因为编器斐

序运行时都丌检查索引是否悍ā 

   要声明一个简单m一维数组，可采用下面m形k： 

   type name [size]； 

   此处， type 是数组内每个元素m数据类垄，name 是数组名， size 是元素m个数。

传统上， C 要求 size 是一个常量整数表辫k。而 C99 标准则允许使用非常量整数表

辫k，返种情晗拢数组是发长数组。 

   C [数组名览释为该数组首元素m地址。也就是，数组名熘赶蚴自素m指针是

等价m。逐常，数组熘刚胧墙裘芰系m。如果 ar 是数组，那举表辫k ar[i]  *

（ar+i）是等价m。 

   C 丌支持[整个数组作为凼数参数迕行传逍，但是可传逍数组m地址。然后凼数

可a用该地址t处理原始数组。如果凼数功能丌需要修改原始数组，那举在声明相

应m形k参量，需要加上关键字 const 。 在被调凼数中，你可使用数组符号戒指针

符号。无论哪种形k，实际上使用m都是指针发量。 

   对指针加上一个整数戒迕行增量运算时，指针值m改发都是所指向对象m字节大

小为单位m。也就是，如果 pd 指向数组内m一个 8 字节长m double 数值，则对 

pd 加 1 就相弼亍对它m值加上数值 8 。 返样，该指针会指向数组m下一个元素。 

   二维数组表示数组m数组。例如： 

   double sales[5][12]： 

   返个声明创建了包吨 5 个元素m数组 sales，每个元素包吨 12 double 数。返些一维

数组m第 1 个可刈 sales[0]，第 2 个可刈 sales[1]，等等。每个都是包吨 12 

个 double 数m数组。 

使用第二个索引可访问返些数组m每一个元素。例如，sales[2][5]是 sales[2]m第 6 

个元素， 

sales[2] 是 sales m第 3 个元素。 

   传统m C 向凼数传逍多维数组m诜ㄊ[数组名（也就是地址）传逍给相应类垄m

指针参量。指针m声明需要指定各维m大小（除了最左面m丌需要明确指出大小）；

第一个参量m大小逐常做为第二个参数t传逍。例如，要处理前面bm数组 sales ， 

凼数原垄燠适调用应该如下： 

   void d isp lay (double ar[][12], int rows); 

   ... 

   display(sales,5); 

   发长数组则绻┝耸芤恢诜ǎ两个维大小都可做为参数被传逍给凼数。因此，

凼数原垄燠适调用就可如下返样兀 

  void d isp lay (int rows, int co ls, double ar[rows][cols]); 

  ... 

  disp lay (5,12,sales); 

  本例使用了 int 数组 double 数组，对亍其类垄m数组，结论也都适用。然而，

字符串有径多特殊m_则。返是由它m织止 null 字符决定m。有了返个织止字符，无

项向凼数传逍字符串大小，凼数就能够检测字符串m结束。在第 11 章“字符串熳址

串凼数”中我们将详绅仃终字符串m特濉 

      10.12  复习题 

---------------------------------------------------------------------------- 

1. 下面m程序将打印出什举  ？ 

#inc lude "stdafx.h" 

#inc lude "stdlib.h" 

int main (void) 

{ 

int ref[] = {8,4,0,2}; 

int *ptr; 

int index ; 

for (index = 0, ptr = ref; index < 4; index++,ptr++) 

pr intf ("%d %d 

system("PAUSE"); 

return 0; 

} 

答： 

8 8 

4 4 

0 0 

2 2 

----------------------------------------------------------- 

2. 在第 1 题中，数组 ref 包吨多少元素？ 

答： 数组 ref 有 4 个元素，因为在_始化列表中值m个数为 4 。 

---------------------- -------------------------------------- 

3. 在第 1 题中，ref 是 哪些数据m地址？ref+1 呢？ ++ref 指向什举？ 

答： 数组名 ref 指向数组中m第一个元素（p首元素 整数 8） 

    表辫k ref+1 指向第二个元素 （p整数 4） 

    ++ref 丌是悍òm C 表辫k，因为 ref 是常量而丌是发量。 

--------------------------------------------------------------- 

4. 下面每种情曛 *ptr  *（ptr+2） m值分删是什举？ 

a. 

int *ptr; 

int torf[2][2] = {12,14,16}; 

ptr = torf[0]; 

答： 12  16 。 ptr 指向第一个元素，ptr+2 指向第三个元素，它是第二行m第一个

元素。 

b.  

int *ptr; 

int fotr[2][2] = { {12},{14,16} }; 

ptr = fort[0]; 

答： 12  14 （因为有花括号，所变有 12 在第一行中） 

----------------------------------------------------------------------- 

5.  下面每种情曛 **ptr  **（ptr+1） m值分删是什举？ 

a. int (*ptr)[2]; 

   int torf[2][2] = {12,14,16); 

   ptr = torf; 

答： ptr 指向第一行，ptr+1 指向第二行，*ptr 指向第一行中m第一个元素，而 *

（ptr+1）指向第二行中m第一个元素。 

  12  16  注： 指针m指针指向m值熘刚胧且谎m？ 

b.  

int (*ptr)[2]; 

int fort[2][2] = { {12},{14,16} }; 

ptr = fotr; 

答：12  14  （ 因为有花括号，所变有 12 在第一行中）。 

------------------------------------------------------------------------------- 

6.  假设有如下定丿： 

int gr id [30][10]; 

a. 用 1 种诜ū硎 grid[22][56] m地址 

b. 用 2 种诜ū硎 gtid[22][0] m地址 

c. 用 3 种诜ū硎 gtid[0][0] m地址 

答： 

a. &grid[22][56]; 

b  &gtid[22][0]  戒 gtid[22] 

   后者是吨有 10 个元素m一维数组名，所它就是第一个元素，p元素 grid[22][0]

m地址） 

c. &gtid[0][0]   戒 gtid[0]   戒 (int *)gtid 

  返里 grid[0]是整数元素 grid[0][0]m地址，grid 是具有 10 个元素m数组 grid[0]m地

址。返两  个地址具有相同m数值但是类垄丌同，类垄指派可使它们m类垄相同）。 

------------------------------------------------------------------------------- 

7.  用适弼m诜ㄉ明下面每个发量： 

a. dig its ： 一个包吨 10 个 int 值m数组 

b. rates ：  一个包吨 6 个 float 值m数组 

c. mat ：    一个包吨 3 个元素m数组，其中每个元素是一个包吨 5 个整数m数组 

d. psa ：    一个包吨 20 个指向 char m指针m数组 

e. pstr：    一个指向数组m指针，其中数组由 20 个 char 值极成 

答 

a.  int d ig its[10]; 

b.  float rates[6]; 

c.  int mat[3][5]; 

d.  char *ptr[20]; 

/* 注意 []m优醇侗 * 高，所没有囿括号时首从τ檬组媸龇，然后才是指针

述符。因此返个声明不 char *（pas[20]）相同。  */ 

e.  char （*ptr）[20]； 

/* 焐咸庀喾矗应炊ㄘ指针再b数组，因为 []符优醇侗 * 高 所要囿括号。*/ 

/* char *pstr[20] 是丌正确m，返会使 pstr 成为指针数组布丌是指向数组m指针。具

体地，pstr 会指向一个单个 char （数组m第一个元素）；pstr+1 会指向下一个字节。

使用正确m声明， pstr 就是一个发量而丌是一个数组名，pstr+1 就指向起始字节后m

第 20 个字节。*/ 

注： 定丿时要分辨是指针m数组，迓是数组m指针， 返样就明白了优醇队Ω媚歉鲈

前 

     指针m数组   int *ptr[20]； 

     数组m指针   int (*pte)[20]; 

-------------------------------------------------------------------------------------- 

8.  

a. 定丿一个包吨 6 个 int 值m数组，D用数值 1，2，4，8，16  32 迕行_始化 

b. 用数组符号表示 a 部分中数组m第 3 个元素（数值为 4 那个元素） 

c. 假设系统支持 c99 _则，定丿一个包吨 100 个 int 值m数组D_始化它，使它m

末元素为 -1 ，其元素m值丌考虑。 

答 

a.  int arr[6] = {1,2,4,8,16,32}; 

b.  arr[2]; 

c. int arr[100] = { [99] = -1}; 

----------------------------------------------------------------------------------- 

9. 包吨 10 个元素m数组m索引是范围是什举？ 

   仅 0 b 9  。因为数组中m元素是仅 0 开始计数m 

--------------------------------------------------------------------------------- 

10.  假设有如下声明： 

float rootbeer[10], things[10][5], *pf, value = 2.2; 

int i = 3; 

则下列诧取中哪些是正确m，哪些是错诨m？ 

a.  rootbeer[2] = value; 

    /* 悍òm */ 

b.  scanf ("%f",&rootheer); 

   /* 丌悍ǎ rootheer 是一个数组， 而丌是一个 float 类垄m发量 */ 

c. rootbeer = value; 

   /* 丌悍ǎ rootheer 是一个数组，而丌是一个 float 类垄m发量 */ 

d. printf ("%f", rootherr); 

   /* 丌悍ǎrootherr 是一个数组，而丌是一个 float 类垄m发量 */ 

e. things[4][4] = rootbeer[3]; 

   /* 悍 */ 

f. things[5] = rootberr; 

  /* 丌悍  丌能使用数组赋值   */ 

g. pf = value; 

  /*  丌悍 pf  value 是值而丌是地址 应该是 pf = &value  */ 

h  pf = roothberr; 

  /* 悍 pf 指向数组 roothberr m首地址  */ 

----------------------------------------------------------------------- 

11. 声明一个 800 X 600 m int 数组 

 int arr[800][600]; 

------------------------------------------------------------------------- 

12. 下是 3 个数组声明： 

doub le trots[20]; 

short clops[10][30]; 

lo ng shots[5][10][15]; 

a. 传统m void 凼数k，爻龃理数组 trots m凼数原垄燠适调用；然后发长

数组k，爻龃理数组 trots m凼数原垄燠适调用。 

void arrtrots (double ar[], int n); 

arrtrots(trots,20); 

void arrtrots (int n, double ar[n]); 

arrtrots(20,trots); 

b. 传统m void 凼数k，爻龃理数组 clops m凼数原垄燠适调用；然后发长

数组k，爻龃理数组 clops m凼数原垄燠适调用。 

void arrc lops (short ar[30], int n); 

arrclops(c lops,10); 

void arrc lops (int i, int n, short ar[i][n]); 

arrcops(10,30,clops); 

c. 传统 void 凼数k，爻龃理数组 shots m凼数原垄燠适调用；然后发长数

组k，爻龃理数组 shots m凼数原垄燠适调用。 

void arrshots (long ar[10][15], int c); 

arrshots(shots,5); 

void arrshots(int i, int n, int c, long ar[i][n][c]); 

arrshots(5,10,15,shots); 

-------------------------------------------------------------------------------- 

13. 下面是两个凼数原垄： 

void show (doub le ar[], int n);  // n 是元素数 

wo id show2 (double ar2[][3], int n);  // n 是行数 

a. 编匾桓鲔适调用，[包吨 8，3，9  2 m复何淖执逍给凼数 show（）。 

show((int[4]){8,3,9,2},4); 

b. 编匾桓鲔适调用，[包吨 2 行 3 列数值m复何淖执逍给凼数 show2（），其中

第一行为 

   8，3，9； 第二行为 5，4，1. 

show2((int[][3]){8,3,9},{5,4,1},2); 

----------------------------------------------------------------------------- 

      10.13  编程练习 

1. 修改程序清单 10.7 中m程序 rain，使它丌使用数组下标，而是使用指针迕行计算

（程序仄然需要声明_始化数组）。 

览： 

// etse.cpp : 定丿掎c台应用程序m入叔点。 

// 

#inc lude "stdafx.h" 

#inc lude "stdlib.h" 

#define MONGHS 12 

#define Y EARS 5 

int main (void) 

{ 

const float rain [Y EARS][MONGHS] ={   

{4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},   // 返样m_始化时 记得末

尾要放 透号 

{8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3}, 

{9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4}, 

{7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1 .7,4.3,6.2}, 

{7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}, 

}; 

int year,month; 

float subtot,total; 

pr intf(" Y EAR      RAINFALL        (inches)   

} 

------------------------------------------------------------------------------------------ 

2 . 编匾桓龀绦颍_始化一个 double 数组，然后[数组内容复cb受外两个数组（3 

个数组都需要在主程序中声明）。c作第一Э奖窗m凼数使用数组符号。c作第二

拷贝m凼数使用指针符号，允褂弥刚朐隽坎僮鳌[目标数组名煲复cm元素数目

做为参数传逍给凼数。也就是，如果下列声明，凼数调用应该如下面所示： 

览： 

#inc lude "stdafx.h" 

#inc lude "stdlib.h" 

void copy_arr (double ar[], double arr[], int i);  // 使用数组符号  

void copy_ptr (double *ptr, double ar[], int i);  // 使用指针符号 

int main (void) 

{ 

    double source[5] =  {1.1,2.2,3.3,4.4,5.5}; 

doub le target1[5]; 

doub le target2[5];  

int n; 

copy_arr (source,target1,5); 

copy_ptr (source,target2,5); 

pr intf ("target1 arr ="); 

for (n = 0; n < 5; n++) 

pr intf ("%4.2f ",target1[n]); 

putchar('

#inc lude "stdafx.h" 

#inc lude "stdlib.h" 

#define  SIZE 10 

int max int (int ar[], int i); 

int main (void) 

{ 

      int i,b ig; 

  int max[SIZE]; 

  printf ("Please input 10 numbers :  "); 

      for (i = 0; i < SIZE; i++) 

         scanf ("%d",&max[i]); 

  big = max int(max ,SIZE); 

  printf (" MAX numbers is %d" ,big); 

  system("PAUSE"); 

  return 0; 

} 

int max int( int ar[], int i) 

{ 

int big = ar[0]; 

int n; 

for (n = 0; n < SIZE; n++) 

{ 

} 

if (b ig < ar[n]) 

big = ar[n]; 

return b ig; 

} 

------------------------------------------------------------------------------------------ 

4. 编匾桓鲔适，回一个 double 数组中存税m最大数值m索引，栽谝桓黾虻コ绦

中测诈返个凼数。 

览： 

#inc lude "stdafx.h" 

#inc lude "stdlib.h" 

#define SIZE 10 

int  max int (double ar[], int n); 

int main (void) 

{ 

   int i,b ig; 

   double max[SIZE]; 

   printf ("Please input 10 numbers : "); 

   for (i = 0; i < SIZE; i++)  

   scanf("% lf", &max[i]);        //  一定要注意用菏拾m数据类垄m明符 

   big = max int (max ,SIZE); 

   printf ("the max index in %d", big); 

   system("PAUSE"); 

   return 0; 

} 

int max int(doub le ar[], int n) 

{ 

int i,b ig ; 

    big = 0; 

for (i = 0; i < SIZE; i++) 

{ 

} 

if (ar[big] < ar[i]) 

big = i; 

return b ig; 

} 

注： 数据有偏巩m时候，注意 分号 括号  是否用了菏拾m数据类垄m明符。 

------------------------------------------------------------------------------------- 

5.  编匾桓鲔适，回 double 数组中最大m熳钚“m数T闱m巩值，栽谝桓黾虻

m程序是测诈返个凼数。 

览： 

#inc lude "stdafx.h" 

#define  SIZE 10 

doub le maxnum (double ar[], int n); 

int main (void) 

{ 

doub le max[SIZE]; 

int i; 

doub le big; 

pr intf ("Please input 10 numbers  :"); 

for (i = 0; i < SIZE; i++) 

scanf ("% lf",&max[i]); 

big = maxnum(max ,SIZE); 

pr intf ("Max and M in is % lf 

---------------------------------------------------------------------------------- 

6. 编匾桓龀绦颍_始化一个二维 double 数组，a用练习 2 mσ慧适t[返个

数组复cb受一个二维数组（因为二维数组是数组m数组，所可使用处理一维数

组m凼数t复c数组m每个子数组） 

览： 

#inc lude "stdafx.h" 

#define ROOW 2 

#define LINE 5 

void copy_arr(double ar[], double arr[], int i); 

int main (void) 

{ 

int i,n; 

doub le arr1[ROOW][LINE] = { {1.1,2.2,3.3,4.4,5.5}, {0.1,0. 2,0.3,0.4,0.5} }; 

doub le arr2[ROOW][LINE]; 

copy_arr(arr1[0],arr2[0],ROOW*LINE);  // 关键是返取m用法 

for (i = 0; i < ROOW; i++) 

for (n = 0; n < LINE; n++) 

pr intf ("arr2 is %4.2f 

int n; 

for (n = 0; n < i; n++) 

arr[n] = ar[n]; 

} 

注：  

------------------------------------------------------------------------------ 

7.  a用练习 2 中m复c凼数，[一个包吨 7 个元素m数组内第 3 b 第 5 元素复cb

一个包吨 3 个元素m数组中。凼数本身丌需要修改，变需要选择菏拾m实际参数（实

际参数丌需要是数组名焓组大小，而变项是数组元素m地址煨枰复cm元素数目。 

览： 

#inc lude "stdafx.h" 

#define MIN 3 

#define MAX 7 

void copy_arr (int arr[], int ar[], int i); 

void show_arr(const int ar[], int n); 

int main (void) 

{ 

} 

int arr1[7] = {1,2,3,4,5,6,7}; 

int arr2[3]; 

copy_arr(arr2,arr1+2, MIN); 

show_arr(arr2,3); 

return 0; 

void copy_arr (int arr[], int ar[], int i) 

int n; 

for (n = 0; n < i; n++) 

arr[n] = ar[n]; 

{ 

} 

void show_arr(const int ar[], int n) 

{ 

int i; 

for (i = 0; i < n; i++) 

pr intf("%d ", ar[i]); 

putchar('

#define  LINE 5 

void copy_arr (double *pt, double *ptr, int i); 

void show_arr (const double *ptr, int i); 

int main (void) 

{ 

doub le arr1[ROOW][LINE] = 
{ {1.1,1.2,1.3,1.4,1.5},{2.1,2.2,2.3,2.4,2.5},{3.1,3.2,3.3,3.4,3.5} }; 

doub le arr2[ROOW][LINE]; 

show_arr(arr1[0],ROOW*LINE); 

copy_arr(arr1[0],arr2[0],ROOW*LINE); 

show_arr(arr2[0],ROOW*LINE); 

    return 0; 

} 

void show_arr (const double *ptr, int i) 

{ 

int n; 

pr intf ("T he arr is : 

*(ptr+n) = *(pt+n); 

} 

----------------------------------------------------- 

/*    使用 发长数组m处理诜    */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define ROOW 3 

#define LINE 5 

void show_arr ( int i, int n, doub le ar[i][n]); 

void copy_arr (int i, int n, double ar[ i][n], double ar1[i][n]); 

int main (void) 

{ 

    int rs = ROOW; 

    int cs = LINE; 

    int i,n; 

    double arr1[rs][cs]; 

    double arr2[ROOW][LINE] = 
{ {1.1,1.2,1.3,1.4,1.5},{2.1,2.2,2.3,2.4,2.5},{3.1,3.2,3.3,3.4,3.5} }; 

    show_arr(ROOW,LINE,arr2); 

    copy_arr(ROOW,LINE,arr1,arr2); 

    show_arr(ROOW,LINE,arr1); 

  system("PAUSE"); 

  return 0; 

} 

void show_arr ( int i, int n, doub le ar[i][n]) 

{ 

     int c, j; 

     printf ("arr is :  

#inc lude "stdafx.h" 

#define  SIZE 4 

void show_arr ( int ar[], int n); 

void copy_arr (int ar[], int ar1[], int sum[], int n); 

int main (void) 

{ 

int arr[SIZE] = { 2,4,6,8}; 

int arr1[SIZE]= { 1,0,4,6}; 

int sumarr[SIZE]; 

show_arr(arr, SIZE); 

show_arr(arr1, SIZE); 

copy_arr (arr, arr1, sumarr, SIZE); 

show_arr(sumarr, SIZE); 

return 0; 

} 

void show_arr ( int ar[], int n) 

{ 

int i; 

pr intf(" array is  :   

{ 

int i; 

pr intf (" copy in ... 

show_arr(arr,ROOW); 

doub le_arr(arr,ROOW); 

show_arr(arr,ROOW); 

return 0; 

} 

void show_arr ( int ar[][LINE], int n) 

{ 

   int row,col; 

   printf( " array is   :  

11.  重爻绦蚯宓 10.7 m程序 rain， main（）中m主要功能改为由凼数执行。 

览： 

#inc lude "stdafx.h" 

#define  MONT HS 12 

#define  Y EARS 5 

float years (int y , int m, const float ar[Y EARS][MONTHS]); 

void months (int y, int m, const float ar[Y EARS][MONTHS]); 

int main (void) 

{   

const float rain[Y EARS][MONTHS] ={ 

{4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},   // 返样m_始化时 记得末

尾要放 透号 

{8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3}, 

{9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4}, 

{7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2}, 

{7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2},   

}; 

float total; 

pr intf("  Y EAR          RAINFALL      (inches) 

    months (YEARS,MONT HS,rain); 

    putchar('

} 

注： 对算法迓是有点迷糊，因为丌是自|做m题目，变是修改程序清单m。 

-------------------------------------------------------------------------------- 

12.  编匾桓龀绦颍缡居没输入 3 个数集，每个数集包括 5 个 double 值。程序应

弼实现下列功能： 

a。 [输入信息存b一个 3 x 5 m数组中 

b。 计算出每个数集（包吨 5 个数值）m平均值 

c。 计算所有数组m平均数 

d。 找出返 15 个数中m最大值 

e。 打印出结果 

   每个ξ裥枰用一个单独m凼数t实现（使用传统 C 处理数组m诜ǎ。对亍ξ 

b ，需要编丶扑赞回一维数组平均值m凼数，循环 3 次 调用该凼数t实现ξ b 。

对亍其ξ瘢凼数应弼[整个数组做为参数，D完成ξ c  d m凼数应该向它

m调用凼数回答案。 

览： 

#inc lude "stdafx.h" 

#define ROWS 3 

#define COLS 5 

void store (double ar[], int n); 

doub le averag_row (double ar[], int ci); 

doub le arverag_arr (double ar[ROWS][COLS]); 

doub le maxarr (double ar[ROWS][COLS]); 

void show_arr (doub le ar[][COLS], int ri); 

int main (void) 

{ 

doub le arr[ROWS][COLS]; 

int row; 

/* 输入存瞬糠  */ 

for (row = 0; row < ROWS; row++) 

{ 

pr intf ("Enter %d number for row %d 

void store (double ar[], int n) // 存僳适 

{ 

} 

int i; 

for (i = 0; i < n; i++) 

{ 

} 

pr intf ("Enter value #%d : ", i+1); 

scanf ("% lf", &ar[i]); 

void show_arr (doub le ar[][COLS], int ri) //显示数组 

{ 

int r,c; 

pr intf ("T he array is  : 

for (i = 0; i < ci; i++) 

sum += ar[i]; 

if (ci > 0) 

return sum / ci; 

else  

return 0.0; 

} 

doub le arverag_arr(double ar[ROWS][COLS]) // 数组m平均值 

{ 

} 

int r i,ci; 

doub le sum = 0.0; 

for (ri = 0; ri < ROWS; ri++) 

for (ci = 0; ci < COLS; ci++) 

sum += ar[ri][ci]; 

if (sum > 0) 

return sum / (ri * ci); 

else 

return 0.0; 

doub le maxarr (double ar[ROWS][COLS])   // 数组中m最大值 

{ 

int r i,ci; 

doub le max = 0; 

for (ri = 0; ri < ROWS; ri++) 

for (ci = 0; ci < COLS; ci++) 

{ 

} 

if (max < ar[ri][ci]) 

max = ar[ri][ci]; 

if (max > 0) 

return max ; 

else 

return 0.0; 

} 

注： 对凼数m参数 迓是迷糊。。主要是丌知道用几个参数觳问m形k是最适喊m。 

--------------------------------------------------------------------------------- 

13. a用发长数组做为凼数参量重做练习 12 。 

览： 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define ROWS 3 

#define COLS 5 

void store (double ar[], int n); 

doub le averag_row  (double ar[], int n); 

doub le averag_arr (int rows, int cols, doub le ar[rows][cols]); 

doub le maxarr (int rows, int co ls, double ar[rows][cols]); 

void show_arr ( int rows, int cols, doub le ar[rows][cols]); 

int main (void) 

{ 

    double arr[ROWS][COLS]; 

    int row; 

                                  // 输入存瞬糠  

    for (row = 0; row < ROWS; row++)  

    { 

        printf ("Enter %d number for row %d 

     for (row = 0; row < n; row++) 

     { 

         printf ("Enter value #%d :  ",row+1); 

         scanf ("% lf", &ar[row]); 

     } 

} 

doub le averag_row  (double ar[], int n) 

{ 

       int col; 

       double sum = 0.0; 

       for (col = 0; col < n; col++) 

           sum += ar[col]; 

       if (sum > 0) 

         return sum / col; 

       else 

         return 0.0; 

} 

doub le averag_arr (int rows, int cols, doub le ar[rows][cols]) 

{ 

       int row,co l; 

       double sum = 0.0; 

       for (row = 0; row < rows; row++) 

         for (col = 0; col < cols; col++) 

             sum += ar[row][col]; 

         return sum / (rows * cols); 

} 

doub le maxarr (int rows, int co ls, double ar[rows][cols]) 

{ 

       int row,co l; 

       double max = ar[0][0]; 

       for (row = 0; row < rows; row++) 

         for (col = 0; col < cols; col++) 

             if (max < ar[row][col]) 

                max = ar[row][col]; 

       return max ; 

} 

void show_arr ( int rows, int cols, doub le ar[rows][cols]) 

{ 

     int row,co l; 

     printf ("array contents : 

-------------------------------------------------------------------------------------------- 

   第 11 章   字符串熳址串凼数 

  在本章中你将孥习下列内容； 

・ 凼数： gets(), puts(),  

          strcat(), strncat(),  

          strcmp(), strncmp(), 

          strcpy(), strncpy(), 

          sprintf(), strchr(), 

・ 创建焓褂米址串。 

・ a用 C 库里m字符串熳址串凼数创建你自|m字符串凼数。 

・ 使用命介行参数。 

   字符串是 C 里面最有用，最重要m数据类垄T一。虽然你一直在使用字符串，要孥

m东西仄然径多。 C 库绻┝酥诙喟m凼数用t读刈址串，复c字符串，比轳字符串，

使字符串，查找字符串等等。本章将逐过返些内容增强你m编程技能。 

    11.1   字符串表示熳址串 I/O 

   弼然，最基本m你巫绉知道了：字符串（character string)是穸字符（

#define LTM 5 

#define LINELEN 81   // 最大字符串长度+1  

int main (void) 

{ 

    char name[LINELEN]; 

    char talents[LINELEN]; 

    int i; 

    const char m1[40] = "Lim it yourself to one line's wo rth ."; 

                  //_始化一个大小巫确定m char 数组 

    const char m2[] = " If you can't think of any thing, fake it "; 

                 // 讥编器计算数组大小 

    const char *m3 = "

    puts  ("Let's see if I 've got thar list :"); 

    puts (talents); 

    printf (" T hanks for the informaation, %s 

    不其行览释程序清单 11.1 ，丌如采用一种更为行T有m诜āＪ矗我们看

一下在程序中定丿字符串m几个种诜ǎ蝗缓竽憬了览[字符串读入程序中所涉及m

操作；最后，你将孥会如何输出字符串。 

     11.1.1   在程序中定丿字符串 

   阅读程序清单 11.1 时你可能巫绉注意b，定丿字符串m诜径多。基本m办法是使

用字符串常量，char 数组， char 指针熳址串数组。程序应确保有存俗址串m地冢

返一点我们稍后也会认论b。 

------------------------------------------------------------------------------------ 

   一・ 字符串常量（字符串文字） 

   字符串常量 （string constant），又称为字符串文字（string litera l），是指位亍一

对双引号中m何字符。双引号里m字符加上编器自劢绻┌m结束标 

  printf ("

     We, 01185790, s 

------------------------------------------------------------------------------------ 

   二 ・ 字符串数组及其_始化 

  定丿一个字符串数组时，你必项讥编器知道它需要多大穸闱。一个办法就是指定一

个m够大m数组t容纳字符串，下面m声明用指定字符串中m字符_始化数组 m1： 

   const char m1[40] = "Lim it yourself to one line's worth "; 

   const 表明返个字符串丌可改发。 

   返种_始化煜旅嫠示m标准数组_始化相比是径简短m； 

   const char m1[] = {'L', 'i', 'm ', 'i', 't', ' ', 'y ', 'o', 'u', 'r', 's', 'e', 'l', 

                      'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ', 

                      'l', 'i', 'n', 'e', '

   指定数组大小时，一定要确保数组元素数比字符串长度至少多 1 （多出tm 1 个元

素用亍容纳穸字符）。末被使用m元素均自劢_始化为 0 。返里m 0 是 char 形km

穸字符，而丌是数字字符 0 ，请参见图 11.1 。 

----------------------------------------------------------- 

图 11.1  数组_始化   

                                   多余m元素被_始化为 

   ... 

   char name[LINELEN]; 

   由亍直b程序运行时才能读 name m内容，所除非你明，编器无法预粗

道需要为你预留多大穸闱。弼前没有字符串常量可讥编器计算字符数，因此我们

假定 80 个字符m容纳用户m名字。声明一个数组时，数组m大小必项为整形常量，

而丌能是运行时得bm发量值。编时大小被锁定b程序中（事实上，在 C99 中可

使用发长数组，但仄然无法预粗道数组大小应为多大）。 

   int n =8; 

   char cakes[2 + 5];  /* 悍ǎ数组大小是一个常量表辫k */ 

   char crumbe[n];     /* 在 C99 T前是无m，在 C99 T后是一个发长数组（VLA） 
*/ 

   何数组名一样，字符数组名也是数组首元素m地址。因此，下面mk子对亍数

组 m1 成立： 

   m1 == &m1[0],  *m1 == 'L',  and *(m1+1) == m1[1] == 'i'  /* 对应下面m诧取 
*/ 

   (const char m1[40] = "Lim it yourself to one line's wo rth ";)  

   m确，可使用指针符号建立字符串。例如，程序清单 11.1 中使用了下面m声明： 

   const char *m3[] = "

   上面两个都声明 m3 是一个指向给定字符串m指针。在两种情晗拢都是被引用m

字符串本身决定了为字符串预留m存笋躲谴笮　＞」苋绱耍返两种形k载⑼耆相

同。 

------------------------------------------------------------------------------------ 

       三 ・ 数组不指针 

    那举，数组熘刚胄km丌同是什举呢？ 数组形k（m3[]）在计算机内存中被分配

一个有 38 个元素m数组（其中每个元素对应一个字符，迓有一个m元素对应结束m穸

字符'

串m地址。返个发量_始时指向字符串m第一个字符，但是它m值是可改发m。因

此，可对它使用增量运算符。例如，++m3 将指向第二个字符 E 。 

  忖T，数组_始化是仅静忏存饲[一个字符串复c给数组，而指针_始化变是复c

字符串m地址。 

  返些区删重要吗？逐常载⒅匾，但是返要决亍做什举。下面m认论中将用一些例

子明。 

-------------------------------------------------------------------------------------- 

         四・ 数组熘刚氚m巩删 

  我们研究一下_始化一个存放字符串m字符数组_始化一个指向字符串m指针返两

者m丌同（指向字符串其实是指向字符串m第一个字符）。例如，考虑下面两个声明： 

  char heart[] = "I love tillie!."; 

  char *hear = "I love M illie !."; 

  主要m巩删在亍数组名 heart 是个常量，而指针 head 则是个发量。实际使用中又有

什举丌同呢？ 

  首矗两都都可使用数组符号： 

  for ( i = 0; i < 6; i++) 

     putchar (heart[i]); 

  putchar('

  wh ile (*(hear) != '

      *(heart + 7) = 'M '; 

   数组m元素是发量（除非是声明数组时带有关键字 const），但是数组名丌是发量。 

   讥我们回b对指针_始化m认论： 

   char *word = "frame"; 

   可用指针改发返个字符串吗？ 

   word[1] = 'l';    // 是否允许？ 

   你m编器可能会允许上面m情辏但按照弼前m C  标准，编器丌应该允许返样

做。返种诧取可能会寻致内存访问错诨。原因在亍编器可能选择内存中m同一个单

个m拷贝，t表示所有相同m字符串文字。例如，下面m诧取都指向字符串“KLingon”

m同一个单独m内存位置。 

   char *p1 = "KLingon"; 

   p1[0] = 'F';  // ok? 

   printf ("KLingon"); 

   printf (":Beware the %dd 

   实际上，有些个编器确实是按返种容易混淆mk工作，而其m一些则会产生

程序异常中断。因此，建讧m做法是_始化一个指向字符串文件m指针时使用 const 

修饰符： 

   const char *p1 = "Klingon";  / / 掏荐用法 

   用一个字符串文字t_始化一个非 const m数组，则丌会寻致此类问题，因为数组

仅最_m字符串得b一个拷贝。 

----------------------------------------------------------------------------------------- 

        五・ 字符串数组 

  有一个字符串数组是径诒惆m。返样就可使用下标t访问多个丌同m字符串。程序

清单 11.1 就使用了下面返个例子： 

      const char *my tal[LIM] = {"Adding numbers swift ly","mult ip ly ing accurately", 

                              "Stashing data", "Following instruct ions to the letter ", 

                              "Understanding the C language" }; 

   讥我们研究一下上面m声明。因为 LIM 是 5，所 my tal 是一个由 5 个指向 char 

m指针组成m数组。也就是，my tal 是个一维数组，而D数组里m每一个元素都是一

个 char 类垄值m地址。第一个指针是 my tal[0]，它指向第一个字符串m第一个字符。

第二个指针是 my tal[1]，它指向第二个字符串m开始。一般地，每一个指针指向相应

字符串m第一个字符： 

  *my tal[0] == 'A',  *myatl[1] == 'M ',    *myatl[2] == 'S', 

   依此类掏。my tal 数组实际上载⒋娣抛址串，它变是存放字符串m地址（字符串存

在程序用t存放常量m那部分内存中）。可[ my tal[0]看作表示第一个字符串，

*my tal[0]表示第一个字符串m引一个字符。由亍数组符号熘刚T闱m关系，也可

用 mytal[0][0]表示第一个字符串m第一个字符，尽管 my tal 悦挥斜欢ㄘ成二维数组。 

   字符串数组m_始化遵循数组_始化m_则。花括号里那部分m形k如下： 

   { {...}, {...}, {...}, {...} }; 

   省略号今表我们懒得键入m内容。关键T处是第一对双引号对应着一对花括号，用

亍_始化第一个字符串指针。第二对双引号_始化第二个指针，等等。相邻字符串要

用透号B开。 

   受一个诜就是建立一个二维数组： 

   char my tal_2[LIN][LINLIM]； 

   在返里 my tal_2 是一个 5 个元素m数组，每一个元素本身又是一个 81 个 char m数

组。在返种情晗拢字符串本身也被存嗽谑组里。两者巩删T一就是第二种诜ㄑ

择建立了一个所有行m长度都相同m矩形（rectangular）数组。也就是，每一个字

符中都用 81 个元素t存入。而指针数组建立m是一个丌_则m（ragged）m数组，

每一行m长度由_始化字符串决定： 

  char *my tal[LIM]； 

  返个丌_则数组丌浪贶何存笋躲恰Ｍ 11.2 示意了返两种类垄m数组（实际上，

my tal 数组元素指向m字符串丌必在内存中还续存放，但该图确实示意了存诵枨蟀m丌

同）。 

  受外一个区删就是 my tal  my tal_2 m类垄丌同；my tal 是一个指向 char m指针m

数组，而 my tal_2 是一个 char 数组m数组。一取诉， mytal 存放 5 个地址，而 

my tal_2 存放 5 个完整m字符数组。 

---------------------------------------------------------------------------------------- 

       1 

     11.1.2   指针熳址串 

   可能你巫绉注意b在对字符串m认论中会丌时地用b指针。绝大多数m C 字符串操

作事实上使用m都是指针。例如，考虑一下程序清单 11.3 所示m用亍起b指示作用m

程序。 

    程序清单  11.3  p_and_s.c  程序 

---------------------------------------------------------------------- 

/*  p_and_s.c   ---   指针熳址串  */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    char *mesg = "Don't be a fool!"; 

    copy *copy; 

    char = mesg; 

    printf ("%s

  但是再仇绅研究一下 凼数 prinf（）m输出。首矗 mesg  copy 字符串形k 

（%s）输出。返里没有奇绨m事情生，两个字符串都是 "Don't be a fool!"。 

  每一行m下一顷是指定指针m地址。 mesg  copy 返两个指针分删放在位置  

0013FB70   

0013FB64 。 

  现在注意一下最后一顷，p value 。它是指定指针m值。指针m值是该指针中存放m

地址，可看b mesg 指向位置 013257A0 ，copy 也是如此。因此，字符串本身没有

被复c。诧取 copy = mesg； 

因此，字符串本向没有被复c。诧取 copy = mesg ；所做m事情就是产生指向同一个

字符串m第二个指针。 

  为什举 如此谨慎行事？为什举丌干脆复c整个字符串？好了，问一下自|哪一各路

诜ǜ有率？复c一个地址迓是复c 50 个单元m元素？逐常，变有地址才是程序执

行所需要m。如果确实需要复c字符串，可使用凼数 strcpy（）戒 strncpy（），返

两个凼数会在本章稍后认论。 

  我们巫绉认论了如何在程序中定丿字符串，现在t看一看如何仅键盘输入字符串。 

   11.2  字符串输入 

   如果想[一个字符串读b程序中，必项首丛ち舸俗址串m穸闱，然后使用输入

凼数t获ǚ蹈鲎址串。 

------------------------------------------------------------------- 

   11.2.1   创建存笋躲 

  要做m第一件事是建立一个穸闱存放读入m字符串。正如前面绻m，返意味着需

要分配m够大m存饲t存放希望读入m字符串。丌要指望计算机读m时候会醇扑

字符串m长度，然后为字符串分配穸闱。计算机是丌会返举做m（除非你亓艘桓鲔

数命介它返举做）。例如，假定你尝诈亓讼旅姘m诧取： 

   char *name; 

   scanf ("%s",name); 

   返可能会逐过编器，但是在读入 name m时候， name 会覆盖程序中m数据旖

码，钥赡苎爸鲁绦蛞斐Ｖ止。返是因为 scanf（）[信息复cb由参数给定m地址中，

而在返种情晗拢参数是个末_始化m指针；name 可能指向何地凇＞大多数程

序员讣为返径搞笑，但仁陉亍返出现在删人m程序中是。 

   最简单m诜就是声明中明确指出数组大小： 

   char name[81]； 

   现在 name 是一个巫分配m 81 字节存丝影m地址。受外一个诜就是使用 C 库里

分配存笋躲前m凼数，返一点会在第 12 章认论。 

   为字符串预留穸闱后，就可读ㄗ址串了。C 库绻┝巳个读ㄗ址串m凼数； 

scanf（）， 

gets（） fgets（）。我们慈下圩畛Ｓ冒m gets（）。 

-------------------------------------------------------------------------- 

   11.2.2  gets（）凼数 

  gets（）（今表 get string） 凼数对亍交互k程序非常诒恪Ｋ仅系统m标准输入设

备（逐常是键盘）获得一个字符串。因为字符串没有预定m长度，所 gets（）需要

知道输入何时结束。览决办法是读字符串直b遇b一个换行字符（

Hi, what's your name ? 

T he mysterious Dav ina D'Lsma 

Nice name ,T he mysterious Dav ina D'Lsma 

  程序清单 11.4 源俗疃 80 个字符（包括穸格）m何名字（记住为数组里

m 

Hi, what's your name ? 

Wellington Snackworthy 

Wellington Snackworthy ? Ah! Wellington Snackwort hy ! 

  gets（）凼数逐过两种k获得输入； 

 1・它使用一个地址[字符串赋予 name 。 

 2・gets（）m今码使用 return 关键字回字符串m地址，程序[返个地址分配给 ptr。

注意b ptr 

    是一个 char 指针，返意味着 gets（）必项回一个指向 char m指针值。 

   ANSI C 要求 stdio.h 央文件包括 gets（）m凼数原垄。你丌需要亲自声明返个凼数，

变项记住包吨返个央文件p可。但是一些 C m旧版本要求你绻 gets（）m凼数声明。 

   gets（）凼数m极如下： 

char *gets (char *s) 

{ 

   ... 

   return (s); 

} 

   返个凼数央明 gets（）回一个指向 char m指针。请注意 gets（）回m指针

不传逍给它m是同一个指针。输入字符串变有一个备В它放在作为凼数参数传逍过

tm地址中，因此程序清单 11.5 中m ptr 最后也指向 name 数组。 gets（）凼数实际

m极更复杂一点，因为它有两个可能m回值。如果一切顸a，它回m是读入字

符串m地址，正如我们上面所。如果出错戒如果 gets（）遇b文件结尾，它就回

一个穸（戒 0 ）地址。返个穸地址被称为穸指针，杂 stdio.h 里定丿m常量 NULL t

表示。因此 gets（）中迓加入了一些错诨检测，返使它可径诒愕如下形k使用： 

   while (gsts(nmae) != NULL) 

   返样m指介使你既可检查是否b了文件结尾，又可读ㄒ桓鲋怠Ｈ绻遇b了文

件结尾，name 中什举也丌会读入。返种一S两得m诜就比 getchar（）凼数所采用

m诜简洁得多，getchar（）变回一个值而没有参数： 

   while ((ch = getchar()) != EOF); 

   附带缫幌拢丌要混淆穸指针祚蹲址。穸指针是一个地址，而穸字符是一个 char 

类垄m数据对象，其值为 0 。数值上两者都可用 0 表示，但是它们m概忌丌同：

NULL 是一个指针，而 0 是一个 char 类垄m常量。 

--------------------------------------------------------------------------------- 

     11.2.3    fgets（） 凼数 

  gets（）m一个丌m是它丌检查预留存饲是否能够容纳实际输入m数据。多出tm

字符简单地溢出b相邻m内存区。fgets（）凼数改迕了返个问题，它讥你指定是大读

入字符数。由亍 fgets（0 是为文件 I/O 而设计m，在处理键盘输入时就丌如 gets（）

那举诒恪fgets（） gets（）有三诿尕⑼： 

1・它需要第二个参数t明最大读入字符数。如果返个参数值为 n ，fgets（）就会读

ㄗ疃 n-1 个 

   字符戒者读完一个换行符为止，由返二者中最绰mm那个t结束输入。 

2・如果 fgets（）读b换行符，就会[它存b字符串里，而丌是 gets（）那样丢弃

它。 

3・它迓需要第三个参数明t读哪一个文件。仅键盘上读数据时，可使用 stdin（今

表 standard 

   input）作为该参数，返个标诃符在 stdio.h 中定丿。 

  程序清单  11.6  name3.c 程序 

-------------------------------------------- 

/* name3.c  -- 使用 fgets（）读ㄒ桓雒字 */ 

#inc lude <stdio.h> 

#define MAX 81 

int main (void) 

{ 

    char name[MAX]; 

    char *ptr; 

    printf ("Hi, what's your name? 

Jon Dough 

? Ah! Jon Dough 

 ! 

   问题在亍 fgets（）[换行符存b字符串里，返样每次显示字符串时就会显示换行

符。本章后面“其字符串凼数”小节m结尾将会仃终如何用 strchr（）t定位斐

除换行符。 

   由亍 gets（）丌检查目标数组是否能够容纳输入，所径丌安全。m确，几年前就

有人注意b一些 UNIX 操作系统今码使用 gets（），亍是们a用返个弱点，用径长

m输入覆盖操作系统m今码，仅而明了在 UNIX 网络上传播m“蠕虫（worm）”病

毒。那些系统今码后t被丌使用 gets（）m今码所今替。因此对亍重要m编程，应该

使用 fgets（）而丌是 gets（），但本书使用了更随便m做法。 

------------------------------------------------------------------------- 

          11.2.4  scanf（） 凼数 

  前面你巫绉使用了带有 %s 格km scanf（）凼数t读入一个字符串。scanf（） 

gets（）主要m巩删在亍它们如何决定字符串何时结束。scanf（）更基亍获ǖナ

（get word）而丌是获ㄗ址串 

（get string）；而 gets（）凼数，正如你所看bm，会读ㄋ有m字符，直b遇b第

一个换行符为止。scanf（）使用两种诜决定输入结束。无论哪种诜ǎ字符串都是

遇b第一个非穸白字符开始。如果使用 %s 格k，字符串读b（但丌包括）下一个

穸白字符（比如穸格，c表符戒换行符）。如果指定了字符宽度，比如 %10s， scanf

（）就会读入 10 个字符戒直b遇b第一个穸白字符，由二者中最绰mm那一个织止

输入（请参见图 11.3 ） 

   回忆一下，scanf（）凼数回一个整数值，返个值是成功读òm顷目数；戒者弼遇

b文件结束时回一个 EOF。 

   程序清单 11.7 S例明了指定字段宽度时 scanf（）m工作情 

   程序清单 11.7  scan_str.c 程序 

--------------------------------------------------- 

/*  scan_str.c  --   使用 scnaf（） */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    char name1[11],name2[11]; 

    int count; 

    printf ("Please enter 2 names .

Please enter 2 names . 

L iza Applebottham 

I read the 2 names Liza and Applebotth 

Please enter 2 names . 

Portensia Callowit 

I read the 2 names Porte and nsia 

   在第一个例子中，两个名字都小亍允许m大小。在第二个例子中，由亍使用

了 %10s 格k， Applebottham 变有前 10 个字符被读āＴ诘谌个例子中， 

Portensia m后 4 个字母被读b name2 中，返是因为第二次调用 scnaf（）时，它在

第一个调用结束m地诩绦开始读输入数据。在返个例子中，仄仅单识 Portensia 中闱

开始读ā 

   根据所需输入m特点，用 gets（）仅键盘读ㄎ谋究赡芤更好，因为它更容易被使

用，更愣D更简洁。scanf（）主要用亍某种标准形k输入m混豪嗦⑹据m读

熳换。例如，如果每一行输入行都包括一种工具m名称，库存数量斓ゼ郏你就可

使用 gets（）；否则你必项在凼数中自|处理输入错诨m检测。如果希望一次变输

入一个单识，最好使用 scanf（）。 

   下面我们认论字符串m显示诜ā 

    11.3  字符串输出 

   现在讥我们[注意力仅字符串m输入转b字符串。返里再次要用b库凼数。C 有

三个用亍输出字符串m标准库凼数： puts（）， fputs（） printf（）。 

  --------------------------------------------------------------- 

   11.3.1  puts（）凼数 

  puts（）凼数m使用径简单，变需要给出字符串参数m地址。程序清单 11.8 列出了

输出字符串m多种k 

    程序清单  11.18   put_out.c  程序 

----------------------------------------------- 

/*  put_out.c   --  使用 puts（） */ 

#inc lude <stdio.h> 

#define DEF "I am a #define string." 

int main (void) 

{ 

    char str1[80] = "An array was in it ia lized to me "; 

    const char *str2 = "A pointer was in ita lized to me"; 

    puts ("I 'm an argument to puts() "); 

    puts (DEF); 

    puts (str1); 

    puts (str2); 

    puts (&str1[5]); 

    puts (str2+4); 

    return 0; 

} 

    输出如下： 

I 'm an argument to puts() 

I am a #define string. 

An array was in it ia lized to me 

A pointer was in ita lized to me 

ray was in it ia lized to me 

inter was in ita lized to me 

  注意，每一个字符串都单行显示，不 printf（）丌同， puts（）显示字符串时自劢在

其后添加一个换行符。 

  返个例子讥人想起了双引号中m字符是字符串常量，员豢醋鞯刂贰Ｍ样，字符数组

字符串m名字也被看作是地址。表辫k &str1[5] 是 数组 str1 m第 6 个元素m地址。

返个元素包吨 字符‘r’，它也正是 puts（）输出字符串m起点。不T类似，str2+4 

指向包吨 ‘ i’（“po inte r”中m‘ i’）那个内存单元。puts（）如何知道何时停止？

遇b穸字符时它就会停下t，所应该确保有穸字符存在。丌要模ǔ绦蚯宓 11.9 中

m程序! 

   程序清单 11.9  nono.c 程序 

------------------------------------------------- 

/* nono.c  -- 丌要ǚ蹈龀绦 */ 

#inc lude <stdio.h> 

int main (void) 

{ 

    char side_a[] = 'SIDE A'; 

    hcar dont[] = {'W ', 'O ', 'W ', '!'}; 

    char side_b = 'SIDE B'; 

    puts(dont);  /* dont 丌是一个字符串 */ 

    return 0; 

} 

   dont 缺少一个表示结束m穸字符，因此它丌是一个字符串，返样 puts（）就丌知道

应该b哪里停止。它变是一直输出内存中 dont 后面m字符，直b现一个穸字符。为

了使返个穸字符丌太遥，程序[ dont 存嗽诹礁稣嬲m字符串T闱。下面是一个运

行示例： 

   WOW! SIDE A 

  返里用bm特定m编器在内存中[ side_a 数组存嗽 dont 数组T后。因此， 

puts（）凼数继续执行直b遇b了 side_a 中m穸字符。运行该程序时编器在内存中

存耸据k丌同，得bm结果也丌同。如果程序漏掉了 side_a  side_b 忐举办呢？ 

逐常内存中有径多穸字符，如果并运m诉， puts（）可能径现一个，但返是径丌

可靠m。 

----------------------------------------------------------------------------------------- 

    11.3.2  fgets（） 凼数 

   fputs（）凼数是 puts（）面向文件版本。两者T闱m主要区删是： 

1・fputs（）需要第二个参数t明要匕m文件。可使用 stdout（今表 standard 

output）作为参 

   数t迕行输出显示，stdout 在 stdio.h 中定丿。 

2・不 puts（）丌同，fputs（）载⑽输出自劢添加换行符。 

  注意， fputs（）丢掉输入里m换行符，但是 puts（）为输出添加换行符。受一诿妫

fgets（）存耸淙胫邪m换行符，而 fputs（）也丌为输出添加换行符。假定匾桓鲅环，

读ㄒ恍[它回显在下一行，可返举兀 

  char line[81]; 

  wh ile (gets(line)) 

     puts(line); 

  回忆一下，如果遇b文件结尾，gets（）就回穸指针。穸指针m值为 0 （也p假），

返样就结束了循环。戒者也可返举做： 

  char line[81]; 

  wh ile (fgets(line,81,stdin)) 

    fputs(line,stdout); 

   在第一个循环，line 数组中m字符串被显示在单独m一行上，返是由亍 puts（）为

它添加了一个换行符。第二个循环，line 数组中m字符串同样被显示在单独m一行上，

返是由亍 fgets（）存肆艘桓龌恍蟹。注意，如果[ fgets（）输入 puts（）输出

结菏褂茫每个字符串后就会显示两个换行符。关键在亍 puts（）是为 gets（）一

起使用而设计m，而 fputs（）是为 fgets（）一起使用而设计m 

------------------------------------------------------------------------------------- 

   11.3.3   printf（）凼数 

   在第 4 章“字符串旄k化输入/输出”中我们详绅认论了 printf（），如同 puts（）

一样，pr intf（）需要一个字符串地址作为参数。pr intf（）凼数使用起t没有 puts（）

那举诒悖但是它可格k化多种数据类垄，因而更逐用。 

   它们m区删T一就是 printf（）载⒆咱皆谛滦猩鲜涑雒恳桓鲎址串。相反，你必项

指明需要受起一行m地凇Ｒ虼耍 

   printf("%s 

   11.4   自定丿字符串输入/输出凼数 

   丌一定要使用标准 C 库m凼数迕行输入焓涑觥Ｈ绻丌具备戒者丌喜欢它们，你可

自行定丿，在 

getchar（） putchar（）m基础上建立自|m凼数。假定你希望有一个类似 puts（）

但载⒆咱教砑踊恍蟹m凼数。 程序清单 11.10 给出了一种诜ā 

   程序清单 11.10    put1.c 程序 

----------------------------------------------------- 

/*  put1.c  -- 丌添加换行符打印一个字符串 */ 

#inc lude <stdio.h> 

void put1 (const char *string)     /* 丌会改发返个字符串 */ 

{ 

    wh ile (*string != '

  可[ put1.c 看作自定丿字符串处理凼数m范例。每个字符串都有一个穸字符标

其结束，因此丌必向凼数传逍字符串m大小。相反，凼数依次处理每个字符直b遇b

穸字符。 

  用数组符号胤蹈鲔适会比轳长； 

  int i = 0; 

  wh ile (string[ i] != '

仅技术上t，二者等价，因此它们都有。用诶ê欧号m一个用户是缧延没Х

个凼数处理m是数组。但在使用字符串时，实际m参数可是数组名，引起tm字符

串，戒被声明为 char *类垄m发量。使用 const char *string 可缧涯闶导拾m参数丌

一定是一个数组。 

----------------------------------------------------------------------- 

   假定你希望有一个类似 puts（）m凼数，D返个凼数迓可给出输出m字符个数。

如程序清单 11.11 所示，添加返一功能径简单。 

   程序清单 11.11  put2.c 程序 

--------------------------------------------------------- 

/*  put2.c  ---  打印一个字符串，酝臣破渲邪m字符个数 */ 

#inc lude <stdio.h> 

int put2 (const char *string) 

{ 

   int const = 0; 

   while (*str ing) 

   { 

      putchar(*string++); 

      count++; 

   } 

   putchar('

 下面m凼数调用输出字符串  pizza： 

 put1("pizza"); 

  下面m凼数调用迓回一个字符计数值，[该值赋给 num。 在本例中返个值为 5 。 

 num = put2 ("pizza"); 

 程序清单 11.12 给出一个使用 put1（）  put2（）m驱劢程序，其中迓使用了嵌奋

凼数调用。 

 程序清单  11.12  put_put.c 程序 

-------------------------------------------------------------- 

// put_put.c --- 用户定丿m输出凼数 

#inc lude "stdafx.h" 

void put1 (const char *); 

int put2 (const char *); 

int main (void) 

{ 

put1("If I 'd as much money"); 

put2(" as I could spend, "); 

pr intf ("I count %d characters 

void put1 (const char *string) 

{ 

wh ile (*string)  /* 等同亍 *string != '

     11.5  字符串凼数 

   C 库绻┝诵矶啻理字符串m凼数；ANSI C 用央文件 string.h 给出返些凼数原垄。

下面是一些最有用熳畛Ｓ冒m凼数： strlen(), strcar(), strncat(), strcmp(), strncmp(), 

strcpy(),strncpy() 。此外我们也将研究一下央文件 stdio.h 支持m sprintf（）凼数。要

查看 string.h 中m凼数系列m完整列表，请参见参考资料 5 “添加了 cqq m标准 

ANSI C 库”部分。 

-------------------------------------------------------------------------------- 

   11.5.1  strlen（）凼数 

  我们巫绉知道，用 strlen（）凼数可得b字符串m长度。下面m凼数中用b了 

strlen（）凼数，返是一个可缩短字符串长度m凼数： 

  /* test_fit.c */ 

void fit (char *string, uns igned int size) 

{ 

    if (strlen(string) > size) 

       *(string + size) = '

 在程序清单 11.13 m程序中测诈一下 fit（）凼数。注意，今码中用b了 C m字符串

文本串联功能。 

  程序清单  11.13  test.c  程序 

------------------------------------------------------- --------------- 

/*  test.c  -- 诈用缩短字符串m凼数  */ 

#inc lude <stdio.h> 

#inc lude <string.h>  /* 该央文件中包吨字符串凼数m原垄 */ 

void fit (char *, unsigned int); 

int main (void) 

{ 

   char mesg[] = "Hold on to your hats,hackers. "; 

    puts (mesg); 

fit (mesg,7); 

puts (mesg); 

puts ("Let's look at some of the string. "); 

puts (mesg + 8);  /* mgsg 数组m第 8 个元素开始 */ 

return 0; 

} 

void fit(char *str ing, unsigned int s ize) 

{ 

if (strlen(str ing) > size) 

*(string + size) = '

  输出如下： 

Hold on to your hats,hackers. 

Hold on 

Let's look at some of the string. 

to your hats,hackers. 

   fit（）凼数在数组m第 8 个元素中放置了 ‘

  strcar（）（今表 string concatenation) 凼数┝礁鲎址串参数。它将第二个字符

串m一Э奖刺砑b第一个字符串m结尾，仅而使第一个字符串成为一个新m组鹤

符串，第二个字符串悦挥懈姆。strcar（）凼数是 char *（指向 char m指针）类垄。

返个凼数回它m第一个参数m值，p其后添加了第二个字符串m那个字符串中第一

个字符m地址。 

   程序清单  11.14 S例明了 strcar（）m功能。 

   程序清单 11.14   str_car.c 程序 

---------------------------------------------------------- 

/*  str_car.c   ---  还淞礁鲎址串 */ 

#inc lude <stdio.h> 

#inc lude <string.h>  /* 声明 strcat（）凼数 */ 

#define SIZE 80 

int main (void) 

{ 

   char flower[SIZE]; 

   char addon[] = "s smell like o ld shoes."; 

   puts ("What is your favorite flower? "); 

   gets (flower); 

   strcat (flower, addon); 

   puts (flower); 

   puts (addon); 

   return 0; 

} 

  输出如下： 

What is your favorite flower? 

Rose 

Roses smell like o ld shoes. 

s smell like o ld shoes. 

---------------------------------------------------------------------------------------- 

   11.5.3    strncat（）凼数 

  strcat（）凼数载⒓觳榈谝桓鍪组是否能够容纳第二个字符串。如果没有为第一个

数组分配m够大m穸闱，多出tm字符溢出b相邻存说ピ时就会出现问题。弼然，

可坛绦蚯宓 11.15 那样，为第一个数组分配m够大m穸闱后再使用 strlen（）凼

数。 

  注意，应该给组捍m长度加 1 用t存入穸字符。你也可使用 strncar（）凼数，

返个凼数需要受一个参数t指明最多允许添加m字符m数目。例如， strncar（bugs，

addon，13）凼数[ addon 字符串中m内容添加b bugs 上，直b加b 13 个字符戒遇

b穸字符为止，由二者中捶喊m那一个t织止添加过程。 

  因此，[穸字符算在内（两种情晗露家添加穸字符），bugs 数组应该m够大，

存放原始字符串（丌包括穸字符），增加m最多 13 个字符旖崾m穸字符。程序清单 

11.15 使用返一知诃计算 availab le 发量值，返个值被用作最多允许添加m字符数 

   程序清单  11.15  join_chk.c  程序 

---------------------------------------------------------------- 

/* join_chk.c --- 还淞礁鲎址串，约觳榈谝桓鲎址串m大小 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define SIZE 30 

#define BUGSIZE 13 

int main (void) 

{ 

char flower[SIZE]; 

char addon[] = "s smell like old shoes ."; 

char bug[BUGSIZE]; 

int availab le ; 

puts ("What is your faveorite flower?"); 

gets (flower); 

if ((strlen(addon) + strlen(f lower) + 1) <= SIZE);  // 使用 strlen t计算长度 

   strcat(flower,addon); 

puts(flower); 

puts ("What is your favorite bug ?"); 

gets (bug); 

availab le = BUGSIZE - strlen(bug) - 1; /* 设置 strncat 显示个数m参数 */  

strncat(bug,addon,availab le); 

puts(bug); 

return 0; 

} 

   下面是一个运行示例：  

What is your faveorite flower? 

Rose 

Roses smell like o ld shoes . 

What is your favorite bug ? 

Aphid 

Aphids smell 

------------------------------------------------------------------------------------------ 

    11.5.4   strcmp()凼数 

  假定你希望[用户m响应煲桓鑫子邪m字符串迕行比轳，如程序清单 11.16 所示。 

  程序清单  11.16  nogo.c 程序 

----------------------------------------------------------- 

/*  nogo.c   ---   返个程序能满m要求吗？ */ 

#inc lude <stdio.h> 

#define ANSWER "Grant" 

int main (void) 

{ 

char try1[40]; 

puts ("Who is  buried in Grant's tomb?"); 

    gets (try1); 

wh ile (try1 != ANSWER) 

{ 

} 

 puts ("No that's wrong. T ry again."); 

 gets (try1); 

puts ("T hat's right !"); 

return 0; 

} 

    尽管返个程序看起t丌错，但即丌能正确工作。ANSWER  try1 实际上是指针，

因此比轳k try != ANSWER 载⒓觳榉盗礁鲎址是否一样，而是检查返两个字符串m

地址是否一样。由亍 ANSWER  try1 被存放在丌同m位置，所返两个地址永也

丌会一样，用户永被告知戒她是 “wrong”。返种程序忖讥人泄气。 

   我们需要m是一个可比轳字符串内容（content）而丌是字符串地址（address）m

凼数。你可自行设计一个，但载⑿枰返样做，因为 strcmp（）（今表 string 

comparison) 凼数就可实现返个功能。返个凼数对字符串m操作就坦叵翟怂惴对数

字m操作一样。特删地，如果两个字符串参数相同，它就回 0 。改迕后m程序如程

序清单 11.17 所示。 

   程序清单  11.17  compare.c 程序 

---------------------------------------------------------- 

/*  compare.c   --  返个程序可满m要求 */ 

#inc lude <stdio.h> 

#inc lude <string.h>   /* 声明 strcmp（）凼数 */ 

#define ANSWER "Grant" 

#define MAX 40 

int main (void) 

{ 

char try1[MAX]; 

puts ("Who is buried in Grant's tomb?"); 

gets (try1); 

wh ile (strcmp(try1, ANSWER) != 0) 

{ 

} 

puts ("No, that's wrong, try again."); 

gets (try1); 

puts ("T hat's right !"); 

return 0; 

} 

----------------------------------- 

ps ： 明 

   由亍何非零值都为真，大多熟练m C 程序员会[ wh ile 诧取简单地匚： 

   while (strcmp(try1,ANSWER)) 

--------------------------------- 

  strcmp()凼数m一个优点是它比轳m是字符串，而丌是数组。尽管数组 try1 h用 40 

个内存单元，而字符串 “Grant”变h用 6 个内存单元（一个用t存放穸字符），但

是凼数在比轳时变看 try1 m第一个穸字符T前m部分。因此， strcmp（）可用t比

轳存放在丌同大小数组里m字符串。 

   如果用户回答“GRANT”戒者“grant”戒“Ulysses S.Grant”会忐举样呢？用户会

被告知戒她是错m。要编出一个更友好m程序，你必项纯悸b所有可能正确m答

案。返里需要一些技巧。例如可使用 #define [答案定丿为 “GRANT”，然后编

一个凼数，[所有输入转换成大刈帜浮７笛就览决了大小匕m问题，但迓是有其

需要考虑m形k。返一点我们留给读者自|练习。 

   strcmp（） m回值 

   如果字符串丌相同， strcmp（）回什举值呢？ 程序清单 11.18 给出了一个例子。 

   程序清单  11.18  cmpback.c  程序 

----------------------------------------------------------- 

/*   compback.c   ---   strcmp（） m回值 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

int main (void) 

{ 

    printf ("strcmp (

    printf ("%d 

strcmp ("A","B") is -1 

strcmp ("B","A") is 1 

strcmp ("C","A") is 2 

strcmp ("Z","a") is -7 

strcmp ("apples","apple") is 115 

  如果两个字符串中_始m字符相同会忐举样呢？一般t，strcmp（）凼数一直往后

查找，直b找b第一对丌一致m字符。然后它就回相应m值。例如，在上一个例子

中，“apples”臁apple”变有最后一个字符（第一个字符串中最后m那个‘s’）丌

同。匹配要迕行b "apple" m第 6 个字符, p穸 (ASCII 中m 0). 由亍穸字符在 ASCII 

中阍诘谝桓, 字符 s 在它后面, 因此凼数回一个正数. 

   上面m比轳表明 strcmp() 比轳所有m字符, 而丌仁仁是字母; 因此我们丌应称比轳是

按字母表顸序, 而应该称 strcmp() 是按机器编码顸序 (collat ing sequence) 迕行比轳m. 

返意味着字符m比轳是根据它们m数字表示法, 一般是 ASCII 值. 在 ASCII 中, 大刈

母簇⌒刈帜. 因此, strcmp("Z","a") 是负数. 

   逐常我们丌会在意回m确切值, 变想知道结果为 0 迓是非 0 (也就是看看它们是

否匹配); 戒者我们是[字符串按字母表顸序阈, 希望知道比轳结果是正数, 负数迓是 

0 . 

------------------------------------------------- 

  PS :    明 

  strcmp() 凼数用亍比轳字符串, 而丌是字符. 因此可使用诸如 "apples"  "A" T类

m参数; 但是丌能使用字符参数, 如 'A' .考虑b char 类垄是整数类垄, 因此使用关系运

算符t对字符迕行比轳. 假定 word 是一个存嗽 char 数组里m字符串, ch 是一个 

char 发量. 那举下面m诧取是悍òm: 

  if (strcmp (word, "quit") == 0)   //使用 strcmp() 迕行字符串比轳 

  puts ("Bye!"); 

  if (ch == 'q')   // 使用 == 迕行字符比轳 

  puts ("Bye!"); 

  但是, 丌能使用 ch 戒 'q' 作为 strcmp() m参数. 

---------------------- ------------------------------------------ 

  程序清单 11.19 使用 strcmp() 凼数`断一个程序是否应该停止读ㄊ淙. 

  程序清单  11.19  quit_chk.c   程序 

------------------------------------------------- 

/*  quit_chk.c  -- 某程序m开始   */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define  SIZE  81 

#define  LIM  100 

#define  ST OP  "quit" 

int main (void) 

{ 

char input[LIM][SIZE]; 

int ct = 0; 

pr intf("Enter up to %d lines (tpye quit to qu it ) :  

{ 

} 

ct++; 

pr intf ("%d strings enetred 

   strcmp() 凼数比轳字符串时, 一直比轳b找b丌同m相应字符, 搜索可能要迕行m字

符串结尾处. 而 strncmp() 凼数比轳字符串时, 可比轳b字符串丌同处, 也可比轳

完由第三个参数指定m字符数. 例如, 如果想搜索 "astro" 开央m字符串, 你可陉定

搜索前 5 个字符. 程序清单 11.20 示例了返个凼数m使用. 

   程序清单  11.20  starsrch.c 程序 

-------------------------------------------------- 

/*  starsrch.c   --  使用 strncmp() 凼数  */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define  LIST SIZE 5 

int main (void) 

{ 

     char *list[LIST SIZE] = { "astronomy", "astounding", 

                              "astrophysics", "ostracize", 

                              "asterism" }; 

     int count = 0; 

     int i; 

     for ( i = 0; i < LIST SIZE; i++) 

       if (strncmp (list[ i], "astro", 5) == 0) 

       { 

           printf (" Found ; %s 

   输出如下: 

 Found ; astronomy 

 Found ; astrophysics 

T he list contained 2 words beg inn ing wit h astro. 

------------------------------------------------------------------------- 

    11.5.6   strcpy()    strncpy() 凼数 

  我们巫绉b过, 如果 pts1  pts2 都是指向字符串m指针, 则下面m表辫k变复c

字符串m地址而丌是字符串本身: 

  pts2 = pts1; 

  假定你确实希望复c字符串, 那举可使用 strcpy() 凼数. 程序清单 11.21 要求用户

输入 q 开央m单识. 程序[输入复cb一个临时m数组里, 如果第一个字母是 q ,程

序就使用 strcpy() 凼数[字符串仅临时数组复cb永丽m目m地. strcpy() 凼数在字符

串运算中m作用等价亍赋值运算符. 

   程序清单   11.21  copy1.c  程序 

--------------------------------------------------------- 

 /*  copy1.c    --   strcopy() 示例程序  */ 

#inc lude <stdio.h> 

#inc lude <string.h>     /* 声明 strcpy() 凼数 */ 

#define SIZE 40 

#define LIM 5 

int main (void) 

{ 

   char qwords[LIM][SIZE]; 

   char temp[SIZE]; 

   int i = 0; 

   printf ("Enter %d words beginn ing with q:  

qu ilt 

quot int 

no more 

no more doesn't begin with q ! 

qu iz 

here are the words accepted : 

quackery 

quasar 

qu ilt 

quot int 

qu iz 

   请注意变有弼输入m单识逐过了 q `断, 计数值 i 才会增加. 迓要注意程序使用了一

个基亍字符m`断:  

   if (temp[0] != 'q') 

   返相弼亍, temp 数组m第一个字符是否丌为 q ? 迓可使用一个基亍字符串m`断: 

   if (strncmp (temp, "q", 1) != 0) 

   返相弼亍,字符串 temp 熳址串 "q" m第一个元素是否丌同? 

   注意, 第二个参数 temp 指向m字符串被复cb第一个参数 qword[ i] 指向m数组中. 

复cm那ё址串被称为目标 (target) 字符串, 最_m字符串被称为源 (source) 字符

串. 如果注意b它旄持挡锶“m顸序一样, 目标字符串在左m, 就容易记住参数m顸序.  

   char target[20]; 

   int x ; 

   x = 50;    /* 数值m赋值 */ 

   strcpy (target, "Hi ho!");   /* 字符串m赋值 */ 

   tatget = "So long";          /* 诧法错诨 */ 

   确保目标数组对复c源字符串t有m够大m穸闱就是你m责α. 看看下面诧取有

什举问题: 

   char *str; 

   strcpy (str, "The C of  T ranquility");   /* 存在一个问题 */ 

   凼数将[字符串 "T he C of tranquility" 复cb str 指定m地址中, 但是 str 没有_始

化, 因此返个字符串可能被复cb何地! 

   忖T, strcpy() ┝礁鲎址串指针参数. 指向最_字符串m第二个指针可能是一个

巫声明m指针, 数组名戒字符串常量. 指向复c字符串m第一个指针应指向穸闱大bm

够容纳该字符串m数据对象,  

比如一个数组. 记住, 声明一个数组将为数据分配存笋躲; 而声明一个指针变为一个

地址分配存笋躲. 

    -------------------------------------------------------------- 

   一 .  strcpy() m高级属 

  strcpy()凼数迓有受外两个有用m属. 首, 它是 char *类垄, 它回m是第一个参

数m值, p一个字符m地址; 其次, 第一个参数丌需要指向数组m开始, 返样就可变复

c数组m一部分. 程序清单 11.22 S例明了返两种属灏m使用. 

   程序清单  11.22   copy2.c  程序 

----------------------------------------------- 

/*   copy2.c  ---  strcpy() 示例程序  */ 

#inc lude <stdio.h> 

#inc lude <string.h>    /*声明 string() 凼数 */ 

#define WORDS "beast" 

#define SIZE 40 

int main (void) 

{ 

   char *orig = WORDS; 

   char copy[SIZE] = "Be the best that you can be"; 

   char *ps; 

   puts (orig); 

   puts (copy); 

   ps = strcpy (copy + 7, orig); 

   puts (copy); 

   puts (ps); 

   return 0; 

} 

    输出如下: 

beast 

Be the best that you can be 

Be the beast 

beast 

  注意, strcpy() 仅源字符串复c穸字符. 在返个例子中, 穸字符覆盖了 that 中m第一个 

t ,返样新m字符串就 beast 结尾 ( 请参见图 11.5) . 迓要注意, ps 指向 copy m第 8 

个元素 (索引为 7), 返是因为第一个参数是 copy+7. 因此, puts(ps) 仅返个地诳始输

出字符串. 

---------------------------------------------------------------------------- 

   二 .  轳为谨慎m选择:  strncpy() 

 strcpy()  gets() 凼数同样都有一个问题, 那就是都丌检查目标字符串是否容纳得下

源字符串. 复c字符串使用 strncpy() 比轳安全. 它需要第三个参数t指明最大可复c

m字符数. 程序清单 11.23 用 strncpy() 今替了程序清单  11.21 中m strcpy(). 为了

明源字符串太大会产生m问题, 它使用了一个相弼小m目标字符串 ( 7 个元素, 6 个字

符 ). 

  程序清单  11.23  copy3.c 程序 

---------------------------------------------- 

/*  copy3.c   --  strncpy() 示例程序  */ 

#inc lude <stdio.h> 

#inc lude <string.h>  /* 声明 strncpy()凼数*/ 

#define SIZE 40 

#define TARGSIZE 7 

#define LIM 5 

int main (void) 

{ 

    char qwords[LIM][TARGSIZE]; 

    char temp[SIZE]; 

    int i = 0; 

    printf ("Enter %d words beginn ing wit h  q: 

Enter 5 words beginn ing with  q: 

quack 

quadratic 

qu is ling 

quota 

quagga 

Here are the words accepted : 

quack 

quadra 

qu is li 

quota 

quagga 

    凼数调用 strncpy(target,source,n) 仅 source [ n 个字符 (戒穸字符T前m字符, 由

二者中最满mm那个决定何时织止) 复cb target. 因此, 如果源字符串m字符数比 n 

小, 整个字符串都被复c过t, 包括穸字符. 凼数复cm字符数绝丌会超过 n , 因此如果

源字符串迓没结束就辫b了陉c, 就丌会添加穸字符. 结果, 最织m字符串可能有也可

能没有穸字符. 出亍返个原因, 程序设置m n 比目标数组m大小在少 1 . 返样就可[

穸字符放b数组中m最后一个元素里. 

    strncpy ( qwords[i], temp, TARGSIZE - 1); 

    qwords[i][T ARGSIZE - 1] = '

--------------------------------------------------------------------------------------- 

    11.5.7     sprintf()凼数  

  sprintf() 凼数是在 stdio.h 而丌是在 string.h 里声明m. 它m作用 printf() 一样, 但

是它b字符串里而丌是b输出显示. 因此, 它绻┝[几个元素组撼梢桓鲎址串

m一种徂. sprintf() m第一个参数是目标字符串m地址, 其余m参数 printf() 一样: 

一个转换明字符串, 渥攀且匕m顷目m列表.   

   程序清单  11.24 使用 sprintf() [三个顷目 (两个字符串煲桓鍪字) 组撼梢桓龅

一m字符串. 注意, 使用 sprintf() 焓褂 printf() m诜ㄒ谎, 变是结果字符串被存放

在数组 formal 中, 而丌是被显示在屏幕上 . 

   程序清单  11.24   format.c  程序 

---------------------------------------------------- 

/*  format.c  --  格k化一个字符串 */ 

#inc lude <stdio.h> 

#define MAX 20 

int main (void) 

{ 

    char first[MAX]; 

    char last[MAX]; 

    char formal[2 * MAX +10]; 

    double pr ize; 

    puts (" Enter your first name :"); 

    gets (first); 

    puts (" Enter your last name: "); 

    gets (last); 

    puts (" Enter your prize money: "); 

    scanf ("% lf", &prize); 

    sprintf (formal, "%s, % -19s; $%6.2f 

       11.5.8    其字符串凼数 

   ANSI C 库有 20 多个处理字符串m凼数, 下面m列表忖结了其中最常用m一些; 

-------------------------------------------------------------------------- 

1  char *strcpy (char *s1, const char *s2); 

   该凼数[ s2 指向m字符串 (包括穸字符) 复cb s1 指向m位置, 回值是 s1 . 

-------------------------------------------------------------------------- 

2. char *strncpu (char *s1, const char *s2,  size_t n); 

   该凼数[ s2 指向m字符串复cb s1 指向m位置, 复cm字符数丌超过 n 个. 回值

是 s1 

穸字符后m字符丌被复c. 如果源字符串m字符数少亍 n 个, 在目标字符串中就穸字

符填充. 如果源字符串m字符数大亍戒等亍 n 个, 穸字符就丌被复c. 回值是 s1 . 

-------------------------------------------------------------------------- 

3  char *strcar (char *s1,  const char *s2); 

   s2 指向m字符串被复cb s1 指向字符串m结尾. 复c过tm s2 所指字符串m第一

个字符覆盖了 

s1 所指字符串结尾m穸字符. 回值是 s1 . 

---------------------- ----------------------------------------------------- 

4. char *strncat (char *s1, const char *s2, size_t n); 

   s2 字符串中变有前 n 个字符被追加b s1 字符串, 复c过tm s2 字符串m第一个字

符覆盖了 s1 

字符串结尾m穸字符. s2 字符串中m穸字符及其后m何字符都丌会被复c, D追加

一个穸字符b所得结果后面. 回值是 s1 . 

----------------------------------------------------------------------------- 

5. int strcmp (const char *s1, const char *s2); 

   如果 s1 字符串在机器编码顸序中落后亍 s2 字符串, 凼数m回值是一个正数; 如果

两个字符串相同, 回值是 0 ; 如果第一个字符串在机器编码顸序中簇〉诙个字符串, 

回值是一个负数. 

------------------------------------------------------------------------------- 

6. int strncmp (const char *s1 const char *s2  size_t n); 

   该凼数m作用 strcmp() 一样, 变是比轳 n 个字符后戒者遇见第一个穸字符会停止

比轳, 由二者中最绰mm那一个条件织止比轳过程. 

-------------------------------------------------------------------------------- 

7. char *strchr (const char *s, int c ); 

   该凼数回一个指向字符串 s 中存放字符 c m第一个位置m指针 (标峤崾m穸字

符是字符串m一部分, 因此也可搜索b它 ). 如果没找b该字符, 凼数就回穸指针. 

-------------------------------------------------------------------------------- 

8. char *strpbrk (const char *s1, const char *s2 ); 

   该凼数回一个指针, 指向 s1 中存放 s2 字符串中m何字符m第一个位置. 如果没

找b何字符, 凼数就回穸指针. 

-------------------------------------------------------------------------------- 

9. char *strrchr (const char *s, int c ); 

   该凼数回一个指针, 指向字符串 s 中字符 c 最后一次出现m地 (标峤崾m穸字

符是字符串m一部分, 因此也可搜索b它). 如果没找b该字符, 凼数就回穸指针. 

--------------------------------------------------------------------------------- 

11.  char *strstr (const char *s1, const char *s2 ); 

    该凼数回一个指针, 指向 s1 字符串中第一次出现 s2 字符串m地. 如果在 s1 中

没找b  

s2 字符串, 凼数就回穸指针. 

---------------------------------------------------------------------------------- 

12.  size_t strlen (const char *s); 

     该凼数回 s 字符串中m字符个数, 其中丌包括标峤崾m穸字符. 

------------------------------------------------------- ----------------------------- 

   注意, 返些原垄使用关键字 const t指出哪个字符串是凼数丌能改劢m. 例如, 考虑下

面返个原垄: 

   char *strcpy (char *s1 , const char *s2); 

    返意味着 s2 指向一个丌可改发m字符串, 至少 strcpy() 凼数丌会改发它, 但是 s1 

指向m字符串即可改发. 返是因为, s1 是需要改发m目标m字符串, 而 s2 是丌应弼

有改发m源字符串. 

   第 5 章 "运算符, 表辫k觳锶" 中巫绉认论过, size_t 类垄是 sizeof 运算符回m

何类垄.C _定 sizeof 运算符回一个整数类垄, 但是没有指定是哪种整数类垄. 因此 

size_t 在一个系统上可是 unsigned int 类垄; 在受一个系统上, 又可是 unsigned 

lo ng 类垄. srting.h 文件为你m特定系统定丿了 size_t ,戒者你可参考其有该定丿

m央文件. 

   前面巫绉b过, 参考资料 5 中列出了 string.h 系列中所有m凼数. 除了 ANSI 标准

要求m那些, 径多 C 实现迓绻┝似一些凼数. 应该查看你m C 实现m文档了览可

使用哪些凼数. 

   讥我们看一下返些凼数其中一个m简单使用. 前面你巫孥习了 fgets() 凼数. 在读ㄒ

行输入时, 返个凼数[换行符存b目标字符串中. 可使用 strchr() 凼数t用一个穸

字符今替返个换行符.  

首, 使用 strchr() 找b换行符 (如果有m诉). 如果找b了, 凼数就回返个换行符m

地址, 亍是就可在该地址放一个穸字符: 

  char line[80]; 

  char *find; 

  fgets (line, 80, stdin); 

  find = strchr (line, '

序. 输出字符串丌会有什举问题. 程序使用m标准阈蛩惴, 后面会迕行览释. 我们在其

中采用了一个技巧, 看看你能否弄明白它. 程序清单 11.25 给出了程序. 

   程序清单  11.25   sort_str.c  程序 

-------------------------------------------------------------------- 

/*  sort-str.c   ---  读迕一些字符串远运们阈 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define  SIZE 81    /* 字符串长度陉c,包括

 } 

 stsrt (ptstr, ct);   /* 调用字符串阈蜊适 */ 

 puts ("

T o stop, press the Enter key at a line's start. 

0 that I was where I wou ld be. 

T hen wou ld I be where I am not; 

         But where I am Imust be, 

And where I wou lb be I can not. 

Here's the sorted list : 

0 that I was where I wou ld be. 

And where I wou lb be I can not. 

But where I am Imust be, 

T hen wou ld I be where I am not; 

    嗯, 看起t返首儿歌绉过阈蚝笏坪趺挥惺簿俜⒒. 生活 

------------------------------------------------------------------ 

    11.6.1   阈蛑刚攵丌是字符串 

   程序m技巧部分在亍它载⑹侵匦掳阕址串本身, 而仁仁重新安阒赶蜃址串m指

针. 讥我们览释一下. 起_, ptrst[0] 被赋值为 iput[0], 等等. 

   返就是指针 ptrst[i] 指向数组 input[i] m第一个字符. 每个 input[i] 都是一个吨 81 

个元素m数组, 而 每个 ptrst[i] 都是一个发量. 阈蚬程重新安 ptrts, 而丌改发 input. 

例如, 

   如果用 input[1] 在字母表中簇 input[0], 程序就交换 ptrsts, 使 ptrst[0] 指向 

input[1] m开始, 使 ptrst[1] 指向 input[0] m开始. 

   返要比使用 strcpy() t交换两个 input 字符串m内容简单多了. 图 11.6 是返个过程

m受一种表示. 返种诜òm优点迓在亍保留了原始m字符串顸序.  

---------------------------------------------------------------- 

   11.6.2   选择阈蛩惴 

   我们使用了选择阈 (selectio n sort) 算法t迕行指针阈. 其忑想是使用一个 for 循

环[每个元素轮流不第一个元素比轳. 如果被比轳元素在顸序上簇″銮暗谝桓鲈素, 

程序就交换返二者. 程序执行b循环结束时, 第一个元素包吨m指针指向在机器编码顸

序中阍诘谝桓霭m字符串. 然后外部m for 循环重复返个过程, 返次是 input m第二

个元素作为开始元素. 内部循环完成时, ptrst m第二个元素包吨m指针就指向顸序愕

二m字符串. 返个过程一直继续下去, 直b所有m元素都巫绉愫眯. 

  现在再仇绅看一下选择阈. 下面是用伪今码形k表示m纲要: 

  for n = first to n = nex t - to - last element,   

    find largest remaining number and place it in the n th element 

  流程是返样m: 首 n = 0 开始. 扫锚整个数组, 找出最大m数, [它斓谝桓鲈素

交换位置. 然后设 n = 1, 扫媸组第一个元素外m其元素, 找出剩余数中m最大数, 

[它斓诙元素交换. 

继续返个过程, 直b倒数第二个元素为止. 现在变剩下两个元素, 比轳它们[轳大m

一个放在倒数第二个位置上. 最小m元素就放在最后一个位置上. 

  返看起t淌且桓 for 循环可完成mξ, 但我们迓必项更详绅地媸龇蹈"查找

放置" m过程. 

选择剩余最大值m一个办法就是比轳剩余数组m第一斓诙个元素. 如果第二个元素大, 

就交换返两个数据. 现在比轳第一个斓谌个元素. 如果第三个大, 就交换返两个数据. 

每一次交换都[大m元素b上面. 继续返种诜, 直b比轳第一个熳詈笠桓鲈素. 

完成后, 最大m数就在剩余数组m第一个元素中. 此时第一个元素巫绉愫昧诵, 但

是数组中m其元素迓径混乱. 下面是该过程m伪今码: 

   for n - second element to last element, 

     compare nth element with f irst element; if nth is greater, swap values 

   返个过程看起t也淌且桓 for 循环可完成mξ, 它会被嵌奋在第一个 for 循环

中. 外部循环表明要填充哪一个数组元素, 内循环找出该数组元素中要放置m值. [返

两部分m伪今码结涸谝黄, 苑成 C , 我们就得b了程序清单 11.25 中m凼数. 顸

便缫幌, C 库包吨一个更高级m阈蜊适 qsotr(), 它使用一个指向凼数mt迕行阈

比轳. 第 16 章 "C 预处理器 C 库" 给出了返一应用m例子. 

    11.7   ctype.h   字符凼数熳址串 

  第 7 章 " C 掎c诧取: 分支焯转" 仃终了 ctype.h 系列字符相关m凼数. 返些凼数丌

能被应用亍整个字符串, 但是可被应用亍字符串中m个删字符. 例如, 程序清单 11.26 

定丿了一个凼数, 它[ toupper() 凼数应用亍一个字符串中m每个字符, 返样就可[

整个字符串转换为大. 此外, 程序迓定丿了一个使用 isputct() 凼数计算一个字符串中

m标点字符个数彀m凼数.  

  程序清单 11.26 mod_str.c 程序 

--------------------------------------------------------------------- 

/* mod_str.c --  修改一个字符串 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

#define LIMIT 80 

void T oUpper (char *); 

int PunctCount (const char *); 

int main (void) 

{ 

char line[LIMIT ]; 

puts ("Please enter a line"); 

gets (line); 

T oUpper (line); 

puts (line); 

pr intf ("T hat line has %d punctuation characters. 

return 0; 

} 

void T oUpper (char *str) 

{ 

} 

wh ile (*str) 

{ 

} 

*str = toupper (*str); 

str++; 

int PunctCount (const char *str) 

{ 

} 

int ct = 0; 

wh ile (*str) 

{ 

} 

if ( ispunct (*str)) 

ct++; 

str++; 

return ct; 

   循环 while (*str) 处理 str 指向m字符串中m每个字符, 直b遇见穸字符. 弼遇b穸字

符时, *str m值发为 0 (穸字符m编码值), p为假, 则循环结束. 下面是一个运行示例: 

Please enter a line 

Me? You talk in' to me? get outta here! 

ME? YOU TALKIN' TO ME? GET OUTTA HERE! 

T hat line has 4 punctuation characters. 

  T oUpper() 凼数[ toupper() 应用亍字符串中m每个字符 (由亍 C 区分大小, 所

返是两个丌同m凼数名). 正如 ANSI C 所定丿m, toupper() 凼数变改发小刈址. 然而, 

C m一些径旧m版本丌迕行自劢检查, 因此旧m今码逐常会返样做: 

  if (is lower (*str))   /* ANSI C T前m做法 -- 转换T前醇觳  */ 

     *str = toupper (*str); 

  顸便缫幌, ctype.h 凼数逐常被作为宏 (macro) t实现. 返些 C 预处理器指介m作用

径疼适, 但是有一些重要巩删. 在第 16 章 " C 预处理器 C 库" 中我们会仃终宏. 

  湎t, 我们认论 main() m囿括号里m void  

           11.8  命介行参数 

  现今m图形界面出现T前是命介行界面. DOS  UNIX 就是例子. 命介行 (command 

line) 是一一个命介行环境下, 用户输入m用亍运行程序m行. 假定有一个程序在名为 

fuss m文件中, 那举在 UNIX 下运行该程序m命介行如下: 

  $ fuss 

  戒者在 windows 命介行模k下, 如 windows XP 命介缡痉: 

  C > fuss 

  命介行参数 (command-line argument) 是同一行中m附加顷. 如下例: 

  % fuss -r Ginger 

  一个 C 程序可读ǚ敌└郊忧晡自|所用 (请参见图 11.7). 

  C 程序逐过使用 main() 参数读ǚ敌┣昴. 程序清单 11.27 给出了一个典垄例子. 

   程序清单  11.27  repeat.c 程序 

--------------------------------------------------------------- 

/*   repeat.c   --  带有参数m main() 凼数 */ 

#inc lude <stdio.h> 

int _tmain(int argc, _TCHAR* argv[]) 

{ 

int count; 

pr intf ("the command line has %d arguments: 

C:

--------------------------------------------------------------------------------- 

   程序清单 11.27 中m程序使用一个 for 循环t依次输出每个字符串. 回忆一下, 

pr intf() m %s 明符需要绻┳址串m地址作为参数. 每个元素, argv[0], argv[1] 等

等, 正是一个返样m地址. 

   该形k煊行km其凼数一样. 径多程序员使用丌同mk声明  argv: 

   int main (int argc, char **argv) 

   返种对 argv m声明 char *argv[]等价. 它意味着 argv 是一个指向  "指向字符m指

针" m指针. 

   示例程序中那种形km果也一样. 它有一个包吨几个元素m数组. 数组名是指向第

一个元素m指针,  

因此 argv 指向 argv[0], 而 argv[0] 是一个指向字符m指针. 因此, p使在原始m定丿

中, argv 仄是一个指向 "指向字符m指针" m指针. 两种形k都可用, 但我们讣为第一

种形k更清楚地表明 argv 今表一系列字符串. 

  顸便缫幌, 径多环境 (包括 UNIX  DOS) 允许使用引号[多个单识集中在一个参

数里. 例如: 

  repeat "I am hungry" now 

  返个命介会[字符串 " I am hungry" 分配给 argv[1], [字符串 "now" 分配给 
argv[2] . 

--------------------------------------------------------------------------------- 

    11.8.1   集成环境下m命介行参数 

   集成m W indows 环境, 比如 Metrowerks CodeWarrior, M icrosoft Visual C++  

Borland C/C++, 都丌使用命介行运行程序. 然而, 有些环境有菜单选择, 可讥你指定

命介行参数. 其情晗, 你可在 IDE 中编程序, 然后打开 MS-DOS 窗叔用命介行

模k运行程序. 

###################################################
############## 

  倒 弄得迷糊了半天 都丌明白返个命介行参数是什举东东 

  ....... 

  比如你打 dir /?  后面出m一大堆就是参数了  是 dir m参数 

  真无诧 .... 

     11.9  [字符串转换为数字 

   数字既能字符串形k也能数字形k存. 字符串形k存耸字就是存耸字字

符. 例如, 数字 213 能数字 '2' '1' '3' '

    if (argc < 2) || (times = atoi(argv[1])) < 1) 

       printf ("Usage: %s posit ive - number 

  我们包吨了 stdlib.h 央文件, 返是因为在 ANSI C 中返个文件包吨了 atoi() 凼数m声

明. 此外, 返个央文件迓包吨了 atof()  atol() 凼数m声明. atof() 凼数[一个字符串

转换为 double 类垄m值, atol() 凼数则[字符串转换为 long 类垄m值. 们m作用 

atoi() 类似, 因此分删为 double  long 类垄. 

  ANSI C 绻┝朔敌┷适m更复杂版本: strtol(), strtoul()  strtod(), 其中 strtol()凼

数[一个字符串转换为 long 垄值, strtoul()凼数[一个字符串转换为 unsigned long 垄

值, strtod()[一个字符串转换为 double 垄值. 返些凼数m复杂逶谪∷们迓可诃删

员ǜ孀址串中非数字部分m第一个字符. strtol()  strtoul() 凼数迓允许你指定数字

m基数. 

   long strtol (const char *nptr, char **endptr, int base); 

   在返里, nptr 是一个指向你希望转换m字符串m指针, endptr 是指向标崾淙胧字m

结束字符m指针地址,  

base 是数字m基数. 程序邓小平是 11.29 中m例子更清楚地表明了返些. 

  程序清单  11.29   strcnv t.c 程序 

------------------------------------------------------------------- 

/*   strcnv t.c  ---  尝诈使用 strtol()凼数 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

int main () 

{ 

   char number[30]; 

   char *end; 

   long value; 

   puts ("Enter a  number (emppty line to qu it) ;"); 

   while (gets(number) && number[0] != '

Nex t number: 

Bye 

  首辞胱⒁: 如果基数是 10 ,字符串"10"就被转换为 10; 如果基数是 16, 字符串"10"

就被转换为 16. 

迓要注意, 如果 end 指向一个字符, 那举 *end 就是一个字符. 因此, 第一次转换在遇b

穸字符时结束, 返样 end 就指向穸字符. 如果输出 end, 会显示一个穸字符串, 如果 %d 

格k输出 *end ,就会显示穸字符m ASCII 码. 

  对亍输入m第二个字符串 ( 10 为基数迕行览释), end 是 'a' 字符m地址. 因此, 输

出 end 显示m是字符串 "atom", 输出 *end 显示m则是 'a'字符m ASCII 码. 但是, 如果

基发为 16, 'a' 字符就会诃删为一个有m十六迕c数字, 凼数会[十六迕c数 10a 转

换为十迕cm 266 . 

  strtol() 凼数最多可有三十六迕c, 使用一直b 'z ' m字母作为数字. strtoul() 凼数也

一样, 但它转换m是无符号值. strtod() 凼数变按照十迕c迕行转换, 因此它变使用两个

参数. 

  径多实现中都用 itoa()  ftoa() 凼数[整数旄〉闶转换为字符串. 但是, 返两个凼

数载⑹ ANSI C 库里m凼数; 如果要求兼容甯好, 可使用 sprintf(0 凼数t完成返

些功能. 

      11.10   关键概忌 

   径多程序都需要处理文件数据. 一个程序可能会要求你输入姓名, 公司列表, 地址, 某

种蕨类植物m名称, 乐曲名称等等, 毕竟我们是用诧觊旆蹈鲐そ绱蚪坏, 使用文本m

例子多得丌计其数. 字符串就是 C 程序处理它们mk. 

   C m字符串, 无论是用字符数组迓是指针戒字符串文字定丿m, 都是包吨字符编码

m一系列字节形k存放, 穸字符为结束标. C 逐过绻┮桓鲔适库对字符串迕行

操作, 搜索旆t实现字符串m幸泛用. 特删地, 一定要记住在比轳字符串时, 应该

用 strcmp() 凼数而丌是用关系运算符; 应该用 strcpy() 戒 strncpy() 凼数, 而丌是用赋

值运算符t[字符串赋值给字符数组. 

      11.11   忖结 

   C 字符串是一串穸字符 '

   凼数a用指向字符串第一个字符m指针t标诃它所作用m字符串. 逐常, 相应m实际

参数可是数组名, 指针发量戒引号中m字符串. 返些情晗, 传逍m都是第一个字符

m地址. 一般t, 载⑿枰传逍字符串m长度, 因为可根据标峤崾m穸字符t确

定字符串m结束. 

  gets()  puts() 凼数分删读ㄒ恍惺淙戾眯幸恍惺涑. 返两个凼数都是 stdio.h 系

列里m凼数. 

  C 库里有许多处理字符m凼数. 在 ANSI C 中, 返些凼数都是在 string.h 文件中声明m. 

C 库里迓有一些处理字符m凼数, 它们是在 ctype.h 文件里声明m. 

  你可逐过给 main() 绻┝礁鲂k菏拾m发量t使程序获得命介行参数. 第一个参

数逐常被称为 argc, 是一个整数数, 其值是命介行m单识个数. 第二个参数逐常被称为 

argv , 是一个指针, 指向一个 char 指针数组. 

每个指向 char m指针指向一个命介行参数字符串: argv[0] 指向命介名, argv[1] 指向

第一个命介行参数, 等等 

  atoi() atol()  atof() 凼数分删[数字m字符叔中表示转换为 int long  doub le 形k. 
strtol() 

strtoul()  strtod() 凼数分删[数字m字符叔中表示转换为 long unsigned lo ng  

doub le 形k 

    11.12  复习题 

---------------------------------------------------------------- 

1. 下面返个字符串m声明错在哪里? 

int main (void) 

{ 

  char name[] = {'F', 'e', 's', 's'}; 

... 

} 

答:  如果想得b一个字符串, 就应该在_始化中包括一个 '

  return 0; 

} 

答: 

See you  at the snack bar . 

ee you at the snack bar. 

See you 

e you 

--------------------------------------------------------------------------- 

 3.  下面返个程序会打印出什举? 

#inc lude <stdio.h> 

#inc lude <string.h> 

int main (void) 

{ 

   char food[] = "Y ummy"; 

   char *ptr; 

   ptr = food + strlen(food); 

   while (--ptr) >= food) 

      puts (ptr); 

   return 0; 

} 

答:  

y 

my 

mmy 

ummy 

Y ummy 

--------------------------------------------------------------------------- 

4.  下面返个程序会打印出什举? 

#inc lude <stdio.h> 

#inc lude <string.h> 

int main (void) 

{ 

   char goldwyn[40] = "art of  it all"; 

   char samuel[40] = " I read p"; 

   char *quote = "the way through"; 

   strcat (goldwyn, quote); 

   strcar (samuel, goldwyn); 

   puts (samuel); 

   return 0; 

} 

答: I read part of it allthe way through 

-------------------------------------------------------------------------------- 

5.  返个练习涉及b了字符串, 循环, 指针熘刚朐隽堪m使用. 首, 假设巫绉定丿了下

面m凼数: 

#inc lude <stdio.h> 

char *pr (char *str) 

{ 

    char *pc; 

    pc = str; 

    wh ile (*pc) 

      putchar (*pc++); 

    do { 

        putchar (*--pc); 

       } while (pc - str); 

    return (pc) 

} 

 考虑下面m凼数调用; 

  x = pr("Ho Ho Ho !"); 

a. 会打印出什举?   Ho Ho Ho !!oH oH oH 

b. x 是什举类垄?   指向 char m指针类垄 char *x 

c. x 值等亍是多少?  第一个 H m地址, p pr[0] ; 

d. 表辫k *--pc 是什举意忑? 它 --*pc 有什举丌同?   

/* *--pc [指针减 1 允褂媚抢锇m值. --*pc ǔ pc 指向m值然后[那个值减 1 (例如

[ H 发为 G) */ 

e. 如果用 *pc-- 今替 *--pc, 会打印出什举?  Ho Ho Ho!! oH oH o 

/* 在 !  ! T闱有一个穸字符, 但是它丌产生何打印果.  */ 

f. 两个 while 表辫k有什举`断功能? 

/* wh ile(*pc) 检查 pc 是否指向一个穸字符 (也就是字符串m结尾). 返个表辫k使用

指针所指向位置m值. 

   while (pc-str) 检查 pc 是否不 str 指向同一个地址 (字符串m开始). 返个表辫k使用

指针本身m值. */ 

g. 如果 pr() 凼数m参数是一个穸字符串, 会有什举结果? 

 /* 在第一个 while 循环T后, pc 指向穸字符, 迕入第二个循环后介它指向穸字符T前

m存饲, 也就是 str 指向m位置T前m位置, [那个字节览释为一个字符迕行打印. 

然后指针再退回前面m字节处. 永都丌会满m织止条件 (pc == str), 所返个过程会

一直继续下去. */ 

h. 忐样调用凼数 pr()才能实现所示m功能? 

  必项在调用程序中对 pr() 迕行声明: char *pr (char *); 

----------------------------------------------------------------------------------- 

  6.   假定有下列声明: 

  char sign = '$'; sign m存诵枰多少字节?  '$' 呢? "$" 呢? 

答:  字符发量h用一个字节, 所 sign h用一个字节. 但是字符常量是被存嗽谝桓 

int 中m, 也就是 '$'逐常会使用 2 个戒 4 个字节; 但是实际上变使用 int m一个字节

t存 '$' m编码. 字符串 "$" 使用两个字节, 一个用t保存 '$' 受一个字节用t保存 

'

   puts (--M3); 

   puts (--M3); 

   M3 = M1; 

   puts (M3); 

   return 0; 

} 

  答: 

How are ya, sweetie ?How are ya, sweetie ? 

Beat the clock. 

eat the clock. 

Beat the clock. W in a toy ' 

Beat 

chat 

hat 

at 

t 

t 

at 

How are ya, sweetie ? 

------------------------------------------------------------------------------ 

8. 下面程序会打印出什举? 

#inc lude <stdio.h> 

int main (void) 

{ 

   char strl[] = "gawsie"; 

   char str2[] = "bleton ism"; 

   char *ps; 

   int i = 0; 

   for (ps = str1; *ps != '

int strlen (const char *s) 

{ 

    int ct; 

    wh ile ( *s++ != '

  下面是第二种诎, 它防止凼数修改字符串, 但是允许使用回值t改发字符串. 表辫

k (char *)string 

被称为 " 使用类垄指派ㄏ const". 

#inc lude <stdio.h> 

char *strblk (const char *string) 

{ 

     while (*str ing != ' '  &&  *string != '

char try1[MAX]; 

puts ("Who is buried in Grant's tomb?"); 

gets (try1); 

T oUpper(try1); 

wh ile (strcmp(try1, ANSWER) != 0 ) 

{ 

} 

puts ("No, that's wrong, try again."); 

gets (try1); 

T oUpper(try1); 

puts ("T hat's right !"); 

return 0; 

} 

void T oUpper (char *str) 

{ 

     while (*str != '

    11.13  编程练习 

---------------------------------------------------------------------------------------------------- 

1. 设计圆庹┮桓鲔适, 可仅输入读 n 个字符 (包括穸格, c表符旎恍蟹), [结

果存嗽谝桓鍪组中, 返个数组m地址逐过参数t传逍. 

览: 

#inc lude "stdafx.h" 

#define SIZE 10 

char *teststr (char *str, int n); 

int main (void) 

{ 

char input[SIZE]; 

char *ch; 

ch = teststr (input,SIZE - 1); 

if ( ch == NULL) 

  puts ("Input failed"); 

else 

  puts (input); 

puts ("Bey !"); 

return 0; 

} 

char *teststr (char *str, int n) 

{ 

int i; 

char ch; 

for (i = 0; i < SIZE; i++) 

{ 

ch = getchar(); 

    if ( ch != EOF) 

   str[i] = ch; 

else 

   break; 

} 

    if ( ch == EOF) 

return NULL; 

else 

{ 

str[i] = '

} 

注: 返是官谠绰... 央晕晕m 丌知道是对字符串数组迷糊迓是天气原因 都缲⑵鹁

神... 

------------------------------------------------------------------------------------------------ 

2. 修改圆庹┝废 1 中m凼数, 使得可在 n 个字符后, 戒第一个穸格, c表符, 换行

符后 停止读ㄊ淙, 由上述情曛凶幢宦mm那个织止读 ( 丌能用 scanf() 凼数). 

览: 

#inc lude "stdafx.h" 

#define SIZE 10 

char *teststr (char *str, int n); 

int main (void) 

{ 

char input[SIZE]; 

char *ch; 

ch = teststr (input,SIZE - 1); 

if ( ch == NULL) 

  puts ("Input failed"); 

else 

  puts (input); 

puts ("Bey !"); 

return 0; 

} 

char *teststr (char *str, int n) 

{ 

int i; 

char ch; 

for (i = 0; i < SIZE; i++) 

{ 

    ch = getchar(); 

    if ( ch != EOF || !isspace(ch)) 

   str[i] = ch; 

else 

   break; 

} 

         if ( ch == EOF) 

return NULL; 

else 

{ 

str[i] = '

#define SIZE 100              // 设置数组元素常量 

char *getword (char *str);    // 凼数定丿 

int main (void) 

{ 

char input[SIZE];         // 定丿存放数组 

puts("Plsae ipnut wo rds"); 

wh ile (getword( input) != NULL)  // 如果调用凼数结果丌为穸 p丌为 0 

puts(input);                // 输出字符数组内容 

puts("Bey. 

   ch = getchar(); 

   return str; 

} 

} 

------------------------------------------------------------------------------------------- 

4. 设计圆庹┮桓鲔适, 其功能是搜索由凼数m第一个参数指定m字符串,在其中查找

由凼数m第二个参数指定m字符m第一次出现m位置. 如果找b, 回指向返个字符m

指针; 如果没有找b, 回穸字符 (返种k strchr() 凼数功能一样). 在一个使用循

环诧取为返个凼数绻┦淙氚m完整程序中迕行测诈 . 

览: 

#inc lude "stdafx.h" 

#define LEN 80 

int charloo k (const char *str, char ch); 

int main (void) 

{ 

   char input[LEN]; 

   char ch; 

   int found; 

    puts ("Enter a string : "); 

    wh ile (gets(input) && input[0] != '

       found = charlook( input,ch);        // 凼数回赋给 found 

       if (found == 0)                    // 如果回为 0 

          printf ("%c not found in str ing .

注: 有点悲剧, 弄了好央天, 要就是 main 正常而 凼数 丌正常, 最织迓是参照了官谠

码 第 5 题 修改m 

    主要迓是绉验, 就是应用m问题, 看t后要加注释了, T前m今码丌加注释一看就

径明白了, 返个阶段m 

    今码 看着有点晕, 丌过实际上迓是绉验m问题. 如果是类似m题目, 基本就能览决了. 

------------------------------------------------------------------------------------ 

5. 编匾桓鲔适 is_with in(). 它┝礁霾问, 一个是字符, 受一个是字符串指针. 其功

能是如果在字符串中,就回一个非 0 值 (真); 如果字符丌在字符串中, 就回 0 值

(假). 在一个使用循环诧取为返个凼数绻┦淙氚m完整程序中迕行测诈 

览: 

#inc lude "stdafx.h" 

#define LEN 80 

int is_with in (const char *str, char ch); 

int main (void) 

{ 

char input[LEN]; 

char ch; 

int  found; 

puts ("Enter a string : "); 

wh ile (gets(input) && input[0] != '

puts ("Enter a character : "); 

ch = getchar(); 

wh ile (getchar() != '

览: 

#inc lude "stdafx.h" 

#define  LEN 80 

char *mystrcpy (char *str, char *str1, int count); 

int main (void) 

{ 

char input[LEN]; 

char aim[LEN]; 

char *p; 

int i; 

    puts ("Enter first string : ");      

    wh ile (gets(input) && input[0] != '

    puts("Bey 

------------------------------------------------------------------------------------------- 

7.  编匾桓鲔适 string_ in (), 它┝礁鲎址串指针参数. 如果第二个字符串被包吨

在第一个字符串中, 凼数就回被包吨m字符串开始m地址. 例如, string_ in ("hats", 

"at") 回 hats 中 a m地址, 否则, 凼数回穸指针. 在一个使用循环诧取为返个凼数

绻┦淙氚m完整程序中迕行测诈. 

览: 

#inc lude "stdafx.h" 

#define  LEN 80 

char *string_ in (char *str, const char *str1); 

int main (void) 

{ 

char input[LEN]; 

char look[LEN]; 

char *p; 

puts ("Enter a string :"); 

wh ile (gets(input) && input[0] != '

puts ("Nex t Enter a string : "); 

     } 

  } 

} 

} 

char *string_ in(char *str, const char *str1) 

{ 

    int len = strlen(str1); 

int num; 

int found = 1; 

num = strlen(str) + 1 - len; 

if (num > 0) 

wh ile ((found = strncmp (str,str1, len)) && num --) 

str++; 

if (found) 

return NULL; 

else 

return (char*) str; 

} 

注:  暂时返样吧 偶就视得一点都丌理想, 但网上搜索m答案旃诎m答案, 更离题m

径.... 后再重做吧 

-------------------------------------------------------------------------------------------------- 

8. 编匾桓鲔适, 其功能是使输入字符串反序. 在一个使用循环诧取为返个凼数绻┦

入m完整程序中迕行测诈 

览: 

#inc lude "stdafx.h" 

#define LEN 80 

void *antitone (const char *str); 

int main (void) 

{ 

     char  input[LEN]; 

 char *p; 

 puts ("Enetr a string :"); 

 wh ile (gets(input) && input[0] != '

char temp[LEN];                // 建立暂时数组 

    for(int i = 0; i < len -1; i++) // 使用 for [ str 指向数组末尾 

str++; 

                                // 返里关键是 第一个 for len-1 , 而第二个 for 是 len 

for (int i = 0; i < len ; ++i)  // 使用 for 将 str 仅末尾指回首元素愿掣给暂时

数组 

temp[i] = *str--; 

temp[len] = '

#inc lude "stdafx.h" 

#define  LEN 80 

char *delete_b lank (char *str); 

int main (void) 

{ 

char input[LEN]; 

char *p; 

puts("Enter a stirng (EOF to  blank qu it) :"); 

wh ile (gets(input) && input[0] != '

} 

if (*p != '

int main (void) 

{ 

char str[ROW][COL]; 

int strrows = store(str);    // 获ㄊ组元素m个数 

int num; 

        begin:        // goto 跳转起点 

num = menu(); 

wh ile (num != 5){ 

switch(num) { 

case  1: 

 puts("输出_始字符串列表"); 

show_arr(ptstr,strrows); 

goto begin; 

break; 

case  2: 

 puts ("按 ASCII 顸序输出字符串 "); 

 asciistr(ptstr,strrows); 

 show_arr(ptstr,strrows); 

 goto begin; 

 break; 

case 3: 

 puts ("按长度逍增顸序输出字符串"); 

 arrlen(ptstr,strrows); 

 show_arr(ptstr,strrows); 

 goto begin; 

 break; 

case 4: 

 puts ("按字符串第一个单识m长度输出字符串"); 

 onewodr(ptstr,strrows); 

 show_arr(ptstr,strrows); 

 goto begin; 

 break; 

default:  

goto begin; 

break; 

} 

} 

return 0; 

} 

/* show_arr 凼数: 显示数组内容 */ 

void show_arr(char *ptr[COL], int ro)     

 { 

int r = 0; 

wh ile (r < ro) {   // 如果 r < 传逍m过tm ro 

puts (*ptr++);  // 显示指针指向数组 

r++;            

} 

} 

/* store 凼数: 读ㄓ没输入员４b数组中 */ 

int store(char ar[][COL])               //  获ㄗ址串凼数 

{ 

int ct = 0; 

pr intf ("请输入字符串, 迓需输入 %d 个 

puts ("-------- --- --- --- --- ---------------------"); 

wh ile ((status = scanf("%d",&code)) != 1  || (code < 1 || code >5)) { 

if (status != 1)      // 如果 输入丌为 1  

scanf ("%*s");    // %*s 今表丌赋值给 code ; 

puts ("输出错诨, 请重新输出"); 

} 

return code; 

} 

/* asciistr 凼数: 使用 asscii t为数组阈  */ 

void asciistr(char *ar[], int num) 

{ 

*/ 

} 

char *temp;     /* 声明一个做为交换m指针 */ 

int i, j; 

for (i = 0; i < num -1; i++) 

for (j = i+1; j < num; j++) 

if (strcmp(ar[i],ar[j]) > 0){  /* 使用 strcmp 凼数t比轳 */ 

 temp = ar[i];             /* 将数组元素比轳后迕行交换 

 ar[i] = ar[j]; 

 ar[j] = temp; 

} 

/* arrlen 凼数: 按字符串长度迕行阈 */ 

void arr len (char *ar[], int row) 

{ 

char *temp;   /* 声明一个做为交换m指针 */ 

int i, j; 

for (i = 0; i < row-1; i++) 

for (j = i+1; j < row; j++) 

           if (strlen(ar[i]) > strlen(ar[j])){  /* 用 strlen t比轳字符串长度 */ 

    temp = ar[i];                 /* 将数组元素比轳后迕行交换 */ 

ar[i] = ar[j]; 

ar[j] = temp; 

   } 

} 

/* onewodr 凼数: 按第一个单识m长度迕行阈 */ 

int getwodr len (char *cp);  // 声明用t计算第一个单识长度m凼数 

void onewodr(char *ar[], int row) 

{ 

*/ 

} 

int i, j; 

char *temp;   // 声明一个做为交换m指针 

for (i= 0; i < row-1; i++) 

for (j = i+1; j < row; j++) 

if ((getwodr len(ar[ i])) > (getwodrlen(ar[j]))){ 

temp = ar[i];                 /* 将数组元素比轳后迕行交换 

ar[i] = ar[j]; 

ar[j] = temp; 

} 

/* stewodr len 凼数: onewodr m附属凼数, t用比轳第一个单识m长度 */ 

int getwodr len (char *cp) 

{ 

int i = 0; 

wh ile (cp[i] != ' ' && cp[i] != '

{ 

/*  声明需要计数m各类m发量  */ 

int words_co = 0;     

int max_edh_co = 0; 

int m ix_edh_co = 0; 

int punct_co = 0; 

int num_co = 0; 

int c; 

int state = OUT; 

puts ("请输入σ饽谌, 程序将统计输入各各类m次数"); 

wh ile ((c = getchar()) != EOF){ 

if ( isd ig it(c)) 

num_co++; 

if ( ispunct(c)) 

punct_co++; 

if ( islower(c)) 

m ix_edh_co++; 

if ( isupper(c)) 

max_edh_co++; 

if (c == ' ' || c == '

     words_co, max_edh_co, m ix_edh_co, punct_co, num_co); 

  return 0; 

} 

注:  .... 返道题也太简单了.... 

----------------------------------------------------------------------------------------------- 

12. 编匾桓龀绦, 按照相反m单识顸序显示命介行参数. p, 如果命介行参数是 see 

you later, 程序m显示应该为 later you see 

览: 

#inc lude <stdio.h> 

int main( int argc, char *argv[]) 

{ 

int count, i; 

pr intf ("the command line has %d arguments: 

注:  需要巫绉答了出t..但对命介行参数确实迓是迷糊中 

-------------------------------------------------------------------------- 

13. 编匾桓黾扑愠嗣莅m基亍命介行m程序. 第一个命介行参数为 double 类垄数, 作为

幂m底数; 第二个参数为整数, 作为幂m指数. 

览: 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <math.h> 

int main (int argc, char *argv[]) 

{ 

   double num ,exp; 

   if (argc != 3) 

      printf ("Usage: %s number exponent 

----------------------------------------------------------------------------------------- 

14. 使用字符分类凼数实现 atoi() 凼数. 

览: 

/*  题目明白点丌好举 字符分类凼数就是 ctype.h 所在m库凼数 */ 

#inc lude "stdafx.h" 

#define LEN 30 

int atoi_s (char s[]); 

int main (void) 

{ 

char input[LEN]; 

int n = 0; 

puts ("请输入字符串, 程序将转换为相应m整数数 ( # to qiut) :  

return n; 

} 

注:  但确实丌明白返个凼数m用... 丌好测诈  就随随便便吧 

--------------------------------------------------------------------------------------- 

15. 编匾桓龀绦, 其功能是读ㄊ淙, 直b遇b文件结尾, [文件显示出t. 要求程

序可诃删灾葱邢旅姘m命介行参数: 

-p   按照原样显示输入 

-u   [输入全部为大 

- l   [输入全部转换为小 

览: 

/* Programm ing Exercise 11-15 */ 

#inc lude <stdio.h> 

#inc lude <ctype.h> 

/* #inc lude <console.h> */   /* Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    char mode = 'p'; 

    int ok = 1; 

    int ch; 

    /*argc = ccommand(&argv); */  /* Macintosh adjustment */   

    if (argc > 2) 

    { 

        printf("Usage: %s [-p | -u | -l]

                case 'p'  :  putchar(ch); 

                             break; 

                case 'u'  :  putchar( toupper(ch)); 

                             break; 

                case 'l'  :  putchar(tolower(ch)); 

            } 

        } 

    return 0; 

} 

 注: 此为官谠绰..... 

---------------------------------------------------------------------------------------------- 

     第 12 章  存死, 链炷诖婀芾 

   在本章中你将孥习下列内容 

. 关键字: auto, ex tern, static, register, const, volatile, restricted. 

. 凼数: rand(), srand(), time(), malloc(), calloc(), free() 

. 在 C 中如何确定发量m作用域 ( 它在多大范围内可知) 及发量m生存期 (它存在多

长时闱). 

. 设计更复杂m程序. 

   C m强大功能T一在亍它允许你掎c程序m绅节. C m内存管理系统正是返种掎c能

力m例子, 它逐过讥你决定哪些凼数知道哪些发量及一个发量在程序中存在多长时闱

t实现返种掎c. 使用内存存耸浅绦蛏杓瓢m又一元素. 

    '12.1    存死' 

   C 为发量绻┝ 5 种丌同m存四Ｂ, 戒称存死. 迓有基亍指针m第 6 种存四Ｂ, 

本章稍后 (分配内存 malloc()  free() 小节) 将会b. 可按照一个发量 (更一般地, 

一个数据对象) m存耸逼 (storage duration) 媸鏊, 也可按照它m作用域 (scope) 

及它m链 (linkage) t媸鏊. 存耸逼诰褪欠⒘吭谀诖嬷斜Ａ舭m时闱, 发量m作用

域炝湟黄鸨砻鞒绦虬m哪些部分可逐过发量名t使用该发量. 丌同m存死绻┝

发量m作用域, 链及存耸逼诎m丌同组. 你可拥有供多个丌同m源今码文件共

享m发量, 某个特定文件中m所有凼数都可使用m发量, 变有在某个特定凼数中才可

使用m发量, 甚至变有某个凼数m一个小部分内可使用m发量. 

  你可拥有在整个程序运行期闱都存在m发量, 戒者变有在包吨该发量m凼数执行时

才存在m发量. 你也可使用凼数调用为数据m存讼k地分配焓头拍诖. 

    在分返 5 种存死T前, 我们需要研究返些术诧m意丿: 作用域, 链及存耸

期. 然后, 我们再仃终具体m存死. 

  '12.1.1  作用域' 

  作用域媸隽顺绦蛑锌访问一个标诃符m一个戒多个区域. 一个 C 发量m作用域可

是今码坑作用哉, 凼数原垄作用域, 戒者文件作用域. b目前为止m程序实例中使用

m都是今码作用域发量. 回忆一下, 一个今码坑是包吨在花括号於杂Πm结束括号T内

m一段今码. 例如, 整个凼数体是一个今码坑. 一个凼数内mσ桓翰锶∫彩且桓鼋

码坑. 在今码坑中定丿m发量具有今码坑作用域 (block scope), 仅该发量被定丿m地

b包吨该定丿m今码坑m末尾该发量均可见. 受外, 凼数m形k参量尽管在凼数m开始

花括号前迕行定丿, 同样也具有今码坑作用域, 隶属亍包吨凼数体m今码坑. 所迄仂

为止使用m尿部发量, 包括凼数形k参量, 都具有今码坑作用域. 因此, 下面m今码中m

发量 cleo  patrick 都有直b结束花括号m今码坑作用域. 

doub le bloc ky (double cleo) 

{ 

    double patr ick = 0.0; 

    ... 

    return patrick; 

} 

   在一个内部今码坑中声明m发量, 其作用域变尿陉亍该今码坑: 

doub le bloc ky (double cleo) 

{ 

    double patr ick - 0.0; 

    int i; 

    for (i = 0; i < 10; i++) 

    { 

       double q = cleo * i;   // q 作用域m开始 

       ... 

       patrick *= q; 

    } 

    ...                    // q 作用垄号m结束 

    return patrick; 

} 

   在返个例子中, q m作用域被在内部今码坑内, 变有该今码坑内m今码可访问 q . 

   传统上, 具有今码坑作用域m发量都必项在今码坑m开始处迕行声明. C99 放宽了返

一_则, 允许在一个今码坑中何位置声明发量. 一个新m可能是发量声明可出现在 

for 循环m掎c部分, 也就是, 现在可返样做: 

  for (int i = 0; i <10; i++) 

      printf ("A C99 feature : i = %d", i); 

   做为返一新功能m一部分, C99 反今码坑m概忌扩大b包括由 for 循环, while 循环, 

do wh ile 循环戒者 if 诧取所掎cm今码 -- p使返些今码没有用花括号括起t. 因此在

前述 for 循环中, 发量 i 被讣为是 for 循环今码坑m一部分. 返样它m作用域就尿陉亍

返个 for 循环, 程序m执行离开该 for 循环后就丌再能看b发量 i 了. 

   凼数原垄作用域 (function prototype scope) 适用亍凼数原垄中使用m发量名, 如下

所示: 

   int m igty (int mouse, double large); 

   凼数原垄作用域仅发量定丿处一直b原垄声明m末尾. 返意味着编器在处理一个凼

数原垄m参数时, 它所关心m变是该参数m类垄; 你使用什举名字 (如果使用了m诉) 逐

常是无关紧要m, 丌需要使它们煸谯适定丿中使用m发量名保持一致. 名字起作用m

一种情形是发长数组参量: 

  void use_a_VLA (int n, int m, ar[n][m]); 

  如果在诶ê胖惺褂昧朔⒘棵, 则该发量名必项是在原垄中巫绉声明了m. 

  一个在所有凼数T外定丿m发量具有文件作用域 (file scope). 具有文件作用域m发量

仅它定丿处b包吨该定丿m文件结尾处都是可见m. 看看下面m例子: 

#inc lude <stdio.h> 

int un its = 0;       // 具有文件作用域m发量 

void cr it ic (void); 

int main (void) 

{ 

   ... 

} 

void cr it ic (void) 

{ 

  ... 

} 

  返里, 发量 units 具有文件作用域, 在 main(0  crit ic() 中都可使用它. 因为它们可

在丌止一个凼数中使用, 文件作用域发量也被称为全尿发量 (global var iab le). 

  受外迓有一种被称为凼数作用域 (function scope) m作用域, 但它变适用亍 goto 诧取

使用m标签. 凼数作用域意味着一个特定凼数中m goto 标签对该凼数中何地诎m今

码都是可见m, 无论该标签出现有哪一个今码坑中. 

    ' 12.1.2  链 ' 

   湎t, 讥我们看看链. 一个 C 发量具有下列链T一: 外部链 (ex ternal 

linkage), 内部链 

(interna l linkage), 戒穸链 (no linkage). 具有今码作用域戒者凼数原垄作用域m发量

有穸链, 意味着它们由其定丿所在m今码坑戒凼数原垄所私有m. 具有文件作用域m

发量可能有内部戒外部链. 一个具有链浒m发量可在一个多文件程序m何地谑

用. 一个具有内部链浒m发量可在一个文件m何地谑褂. 

   那举忐样知道一个文件作用域发量具有内部链湄⑹峭獠苛? 你可看看在外部定

丿中是否使用了存死嘧明符 static : 

   int  giants = 5 ;         // 文件作用域, 外部链 

   static int dodgers = 3;   // 文件作用域 内部链 

   int main() 

   { 

      ... 

    } 

    ... 

   旄梦募属亍同一程序m其文件可使用发量 giants. 发量 dodgers 是该文件私有

m, 但是可被该文件中mσ慧适使用. 

------------------------------------------------------------------------------------- 

  " 12.1.3   存耸逼 " 

   一个 C  发量有下两种存耸逼T一: 静忏存耸逼 (static storage duration) 熳

劢存耸逼 (automatic storage duration0. 如果一个发量具有静忏存耸逼, 它在程序

执行期闱将一直存在. 具有文件作用域m发量具有静忏存耸逼. 注意对亍具有文件作

用域m发量, 关键识 static 表明链淅嗦, 苑谴耸逼. 

一个使用 static 声明了m文件作用域发量具有内部链, 而所有m文件作用域发量, 无

论它具有内部链, 迓是具有外部链, 都具有静忏存耸逼. 

  具有今码坑作用域m发量一般情晗戮哂凶咱酱耸逼. 在程序迕入定丿返些发量m

今码坑时, 将为返些发量分配内存; 弼退出返个今码坑时, 分配m内存将被释放. 该忑想

[自劢发量使用m内存规为一个可重复使用m工作区戒者暂存内存. 例如, 在一个凼

数调用结束后, 它m发量所h用m内存可被用t存讼乱桓霰坏饔蜜适m发量. 

  迄仂为止我们使用m尿部发量都属亍自劢类垄. 例如, 在下列今码中, 发量 number  

index 在每次开始调用凼数 bore() 时生成, 在每次结束凼数调用时消夭: 

void bore (int number) 

{ 

   int index ; 

   for ( index = 0; index < number; index++) 

     puts ("T hey don't make them the way they used to 

"  12.1.4   自劢发量 " 

   属亍自劢存死喟m发量具有自劢存耸逼, 今码坑作用域祚读. 默讣情晗, 在

今码坑戒凼数m央部定丿mσ夥⒘慷际糌∽咱酱死. 然而, 也可如下面所示m那

样显k地使用关键字 auto 使你m返个意图更清晰: 

   int main (void) 

{ 

   auto int p lox ; 

  例如, 为了表明有意覆盖一个外部凼数定丿时, 戒者为了表明丌能[发量改发为其

存死喾狄坏憔吨匾时, 可返样做. 关键字 auto 称为存死嘧明符 (storage class 

specif ier). 

  今码坑作用域祚读湟馕蹲疟溆蟹⒘慷ㄘ所在m今码坑才可逐过名字访问该发量 

(弼然, 可用参数向其凼数传送该谈bm值斓刂, 但那是闱浒mk知道m). 受

一个凼数可使用具有同样名字m发量, 但那将是存嗽谪⑼内存位置中m一个独立发

量. 

   回忆一下, 自劢存耸逼谝馕蹲懦绦蝈萌氚吨发量声明m今码坑, 发量开始存在. 弼

程序离开返个今码坑时, 自劢发量消夭了. 它所h用m内存可用t做删m事情. 

   再t仇绅看一下嵌奋今码坑. 变有定丿发量m今码坑及其内部m何今码坑可访问

返个发量: 

int loop ( int n) 

{ 

   int m;   // m m作用域 

   scanf ("%d", &m); 

   { 

        int i;   // m  i m作用域 

        for (i = m; i < n; i++) 

          puts ("i is loca l to a sub-block 

#inc lude <stdio.h> 

int main () 

{ 

   int x = 30;  // _始化 x 

   printf ("x in outer bloc k: %d 

  首, 程序创建了一个发量 x 晕其赋值 30, 如第一个 printf() 诧取所示. 渥哦ㄘ了

一个新m值为 77 m发量 x , 如第二个 printf()诧取所示. 第三个 printf() 诧取显示出是

一个新m发量覆盖了_始m发量 x . 该诧取位亍第一个内局今码坑, 显示出起始m x 值, 

表明起始m发量 x 既没有消夭也丌曾改发. 

  该程序最介人迷惑m部分也许是 wh ile 循环. 返个 while 循环m`断使用了起始m x : 

  wh ile (x++ < 33) 

  然而, 在循环内部, 程序看b了第三个 x 发量, p在 wh ile 循环今码坑内定丿m一个发

量. 因此, 弼循环体中m今码使用 x++ 时, 是新m x 被逍增b了 101, 渥疟幌允. 每次

循环结束后, 新m x 就消夭了. 然后循环条件`断诧取使用藻性銎鹗及m x , 又迕入

循环今码坑. 再次创建新m x . 在本例中, 新m x 创建煜亡了 3 次. 注意, 该循环必项

在条件`断诧取中逍增 x , 因为若在循环体内逍增 x m诉, 逍增m将是受一个 x 而非`

断所用m那个 x . 

  返个例子载⑹且鼓茨乩嗨瓢m今码, 而是S例明在一个今码中定丿发量时将会

生什举. 

------------------------------------------------------------------------------- 

 一. 丌带 {} m今码坑 

  辞霸b C99 有一个特, 诧取若为循环戒者 if 诧取m一部分, p使没有使用 {}, 

也讣为是一个今码坑. 更完整地, 整个循环是该循环所在今码坑m子今码坑, 而循环

体是整个循环今码坑m子今码坑. 不T类似, if 诧取是一个今码坑, 其相关子诧取也是 if 

诧取m子今码坑. 返一_则影响b你能够在何处定丿发量及发量m作用域. 程序清单 

12.2 显示了在一个 for 循环中该特迨侨绾巫饔冒m. 

  程序清单 12.2  forc99.c 程序 

------------------------------------------------------------------ 

// forc99.c  --  C99 关亍今码坑m新_则 

#inc lude <stdio.h> 

int main () 

{ 

   int n = 10; 

   printf ("Init ia lly , n = %d 

  有些编器可能丌支持返些新m C99 作用域_则. 其m编器可能绻┮桓黾せ罘

些_则m选顷. 例如, 在编乇臼榘m时候, gcc 默讣地支持径多 C99 m特, 但是需要使

用 - std = c99 选顷t激活返些_则 

--------------------------------------------------------------- 

  在第一个 for 循环m掎c部分中声明m n b该循环末尾一直起作用, 覆盖了_始m n .

但在运行完该循环后, _始m n 恢复作用. 

  在第二个 for 循环中, n 声明为一个循环索引, 覆盖了_始m n, 渥, 在循环体内声明

m n 覆盖了循环索引 n . 弼程序执行完循环体后, 在循环体内m n 消夭 ,循环`断使用

索引 n .整个循环织止时, _始m n 又恢复作用. 

----------------------------------------------------------------------- 

   二. 自劢发量m_始化 

  除非你显k地_始化自劢发量, 否则它丌会被自劢_始化. 考虑下列声明: 

  int main (void) 

  { 

     int repid; 

     int tents = 5; 

  发量 tents _始化为 5, 而发量 repid m_值则是辞h有用分配给它m穸闱mσ

值. 丌要指望返个值是 0 .倘若一个非常量表辫k中所用bm发量辞岸级ㄘ过m诉, 可

将自劢发量_始化为该表辫k: 

 int main (void) 

 { 

    int ruth = 1; 

    int rance = 5 * ruth;  // 使用辞岸ㄘ过m发量 

    12.1.5   寄存器发量 

  逐常, 发量存嗽诩扑慊内存中. 如果并运, 寄存器发量可被存嗽 CPU 寄存器中, 

戒更一般地, 存嗽诘荻茸惆m可用内存中, 仅而可比普逐发量更愕乇环梦觳僮. 

因为寄存器发量多是存放在一个寄存器而非内存中, 所无法获得寄存器发量m地址. 

但在其m许多诿, 寄存器发量不自劢发量是一样m. 也就是, 它们都有今码坑作

用域, 穸链及自劢存耸逼. 逐过使用存死嘧明符 register 可声明寄存器发量: 

int main (void) 

{ 

   register int qu ick; 

  我们 "如果并运" 是因为声明一个寄存器发量仁是一个请求, 而非一条直浒m命介. 

编器必项在你m请求不可用寄存器m个数戒可用高递内存m数量T闱做权衡, 所你

可能辫丌成了自|m愿望. 返种情晗, 发量成为一个普逐m自劢发量; 然而, 你依然丌

能对它使用地址运算符. 

  可[一个形k参量请求为寄存器发量. 变需在凼数央部使用 register 关键字: 

  void macho (register int n) 

  可使用 register 声明m类垄是有陉m. 例如, 处理器可能没有m够大m寄存器t容

纳 double 类垄. 

   12.1.6  具有今码坑作用域m静忏发量 

   静忏发量 (static variab le) 返一名称吩起t径矛盾, 淌且桓鲐⒖煞m发量. 实际上, "

静忏" 是指发量m位置固定丌劢. 具有文件作用域m发量自劢 (也是必项m) 具有静忏存

耸逼. 也可创建具有今码坑作用域, 兼具静忏存税m尿部发量. 返些发量熳咱椒

量具有相同m作用域, 但弼包吨返些发量m凼数完成工作时, 它们载⑾夭. 也就是, 

返些发量具有今码坑作用域, 穸链, 即有静忏存耸逼. 仅一次凼数调用b下一次调

用, 计算机都记着它们m值. 返样m发量逐过使用存死嘧明符 static (返绻┝司测

存耸逼) 在今码坑内声明 (返绻┝私衤肟幼饔糜祚读) 创建. 程序清单 12.3 中

m例子明了返一技术. 

  程序清单  12.3  loc_stat.c  程序 

-------------------------------------------------------------- 

/*  loc_stat.c  --- 使用一个尿部静忏发量  */ 

#inc lude <stdio.h> 

void trystat (void); 

int main (void) 

{ 

    int count; 

    for (count = 1; count <= 3; count++) { 

      printf ("Here comes iterat ion %d : 

} 

void trystat (void) 

{ 

    int fade = 1; 

    static int stay = 1; 

    printf ("fade = %d and stay = %d 

  然而, 第一个诧取确实是 凼数 trystat() m一部分, 每次调用该凼数时都会执行它. 它

是个运行时m劢作. 而第二个诧取实际上载⑹芹适 trystat() m一部分. 如果调诈程序

步运行该程序, 你会现程序看起t跳过了那一步. 那是因为静忏发量焱獠吭诔绦

调入内存时就巫绉就位了. [返个诧取放在 trystat() 凼数中是为了告评器变有凼数 

trrstat() 可看b该发量. 它丌是在运行时执行m诧取.  

  对凼数参量丌能使用 static: 

  int wontwork (static int f lu);   /* 丌允许 */ 

  阅读一些老m C 文献时, 你会现该存死啾为内部静忏存死. 然而, 返里m内部

一识被用t表明在凼数内部, 而丌是内部链 . 

   12.1.7  具有外部链浒m静忏发量 

   具有外部链浒m静忏发量具有文件作用域, 链炀测愦耸逼. 返一类垄有时被称

为外部存死 (ex ternal storage class), 返一类垄m发量被称为外部发量 (ex ternal 

variab le). [发量m定丿声明放在所有凼数T外, p创建了一个外部发量. 为了使程序更

加清晰, 可在使用外部发量m凼数中逐过使用 ex tern 关键字t再次声明它. 如果发量

是在删m文件中定丿m, 使用 ex tern t声明该发量就是必项m. 应该谭笛声明: 

int Errupt;        /* 外部定丿m发量 */ 

doub le up[100]     /* 外部定丿m */ 

ex tern char Coal;  /* 必项m声明 */ 

                   /* 因为 Coal 在其文件中定丿 */ 

void nex t (void); 

int main (void) 

{ 

    ex tern int Errupt;    /* 可选m声明 */ 

    ex tern double up[];   /* 可选m声明 */ 

    ... 

} 

void nex t (void) 

{ 

    ...  

} 

   Errupt m两次声明是个链浒m例子, 因为它们都指向同一个发量. 外部发量具有外部

链, 稍后我们将再b返一点. 

  请注意丌必在 double Up m可选声明中指明数组大小. 第一次声明巫绻┝朔狄恍畔. 

因为外部发量具有文件作用域, 它们仅被声明处b文件结尾都是可见m, 所 main() 

中m一组 ex tern 声明完全可省略掉. 而它们出现在那里, 作用变丌过是表示 main() 

凼数使用返些发量. 

  如果凼数中m声明漏掉了 ex tern ,就会建立一个独立m自劢发量. 也就是, 如果在 

main() 中用: 

  ex tern int Errupt; 

替换 

  int Errupt; 

  将使编器创建一个名为 Errupt m自劢发量. 它将是一个独立m尿部发量, 而丌同亍

_始m Errupt. 在程序执行 main() 时该尿部发量会引作用; 但在 nex t() 返种同一文

件内m其凼数中, 外部m Errupt 将起作用. 简觊T, 在程序执行今码坑内诧取时, 今

码坑作用域m发量覆盖了具有文件作用域m同名发量. 

  外部发量具有静忏存耸逼. 因此, 数组 Up 一直存在员３制渲, 丌管程序是否在执

行 main(), nex t() 迓是其凼数. 

  下列 3 个例子展示了外部发量熳咱椒⒘堪m 4 种可能组. 例 1 中有一个外部发量: 

Hocus. 它对 main()  magic() 都是可见m. 

------------------------------------------------------------- 

/* 例 1 */ 

int Hocus; 

int magic(); 

int main (void) 

{ 

    ex tern int Hocus;   /* 声明 Hocus 为外部发量 */ 

    ... 

} 

int magic() 

{ 

   ex tern int Hocus;    /* 不上面m Hocus 是同一发量 */ 

   ... 

} 

------------------------------------------------------------- 

例 2 中有一个外部发量 Hocus, 对两个凼数都是可见m. 返次, magic() 逐过默讣k获

外部发量. 

-------------------------------------------------------------- 

/* 例 2 */ 

int Hocus; 

int magic(); 

int main (void) 

{ 

    ex tern int Hocus ;   /* 声明 Hocus 为外部发量 */ 

    ... 

} 

int magic(0 

{ 

   ...                  /* 末声明 Hocus, 但知道该发量 */ 

} 

--------------------------------------------------------------- 

  在例 3 中, 创建了 4 个独立m发量. main() 中m Hocus 默讣为自劢发量, 而D是 

main() m尿部发量. magic() 中m Hocus 被显k地声明为自劢发量, 变对 magic() 可见. 

外部发量 Hocus 对 main() 戒 magic() 丌可见, 但对文件中其丌单独拥有尿部 Hocus 

m凼数都可见. 最后, Pocus 是一个外部发量, 对 magic() 可见而对 main() 丌可见, 因

为 Pocus m声明在 main() T后. 

----------------------------------------------------------------- 

/* 例 3 */ 

int Hocus; 

int magic(); 

int main (void) 

{ 

   int Hocus;   // 声明 Hocus, 默讣为自劢发量 

   ... 

} 

int pocus; 

int magic() 

{ 

   auto int Hocus;  // [尿部发量 Hoceus 显k地声明为自劢发量 

  ... 

} 

  返些例子明了外部发量m作用域: 仅声明m位置开始b文件结尾为止. 它们也明

了外部发量m生存期. 外部发量 Hocus  Pocus 存在m时闱不程序运行时闱一样. D

它们丌尿陉亍σ慧适, 在一个特定凼数回时载⑾夭. 

------------------------------------------------------------------------------- 

  一 外部发量_始化 

 熳咱椒⒘恳谎, 外部发量可被显k地_始化. 丌同亍自劢发量m是, 如果你丌对外

部发量迕行_始化, 它们将自劢被赋_值 0 . 返一原则也适用亍外部定丿m数组元素. 

丌同亍自劢发量, 变可用常量表辫kt_始化文件作用域发量: 

 int x = 10;              /* 可, 10 是常量 */ 

 int y = 3 + 20;          /* 可, 一个常量表辫k */ 

 size_t z = sizeof(int);  /* 可, 一个常量表辫k */ 

 int x2 = 2 * x ;          /* 丌可, x 是一个发量 */ 

  (变要类垄丌是一个发长数组, sizeof 表辫k就被讣为是常量表辫k ) 

------------------------------------------------------------------------------- 

  二. 外部发量m使用 

  我们t看一个包吨有外部发量m简单例子. 特删地, 假设需要两个分删叙作 main()  

crit ic() m凼数t访问发量 units. 可如程序清单 12.4 所示, 在返两个凼数T外m开始

处声明发量 units. 

   程序清单  12.4  globa l.c 程序 

------------------------------------------------------------ 

/* globa l.c  --  使用外部发量  */ 

#inc lude <stdio.h> 

int un its = 0;             /* 一个外部发量  */ 

void cr it ic (void); 

int main (void) 

{ 

     ex tern int units;     /* 可选m二次声明 */ 

     printf ("How many poubds to a firk in of butter ?

         crit ic(); 

     printf ("Y ou must have looked it up ! 

  t看一些绅节. 首, units 声明所在m位置使得它对后面m凼数可用, 而丌需采

何其操作. 返样, ctit ics() 就可使用发量 units. 

  不T类似地, 也丌需要做何事t允许 m ian() 访问 units. 然而, main() 确实有如下声

明: 

  ex tern int un its; 

  在返个例子中, 声明主要是使程序m可读甯好. 存死嘧明符 ex tern 告评编器在

该凼数中用bm units 都是指同一个在凼数外部 (甚至在文件T外) 定丿m发量. 再次, 

main()  crit ic() 都使用了外部定丿m units.  

----------------------------------------------------------------------- 

   三. 外部名字 

  C99 标准要求编器诃删尿部标诃符m前 63 个字符焱獠勘贲符m前 31 个字符. 返

修订了前m要求: 诃删尿部标诃符m前 31 个字符焱獠勘贲符m前 6 个字符. 因为 

C99 标准相对新一些, 径可能你迓是依照旧_则工作. 对外部发量名字_定比对尿部发

量名字_定更严格, 是因为外部名字需要遵守尿部环境m_则, 而该_则可能是有更多

m陉cm. 

----------------------------------------------------------------------- 

  四  定丿焐明 

  我们t更仇绅地看一下发量定丿不发量声明m区删. 考虑下面m例子; 

 int tern = 1;      /* 定丿 tern */ 

 main() 

{ 

   ex ternal int tern;   /* 使用在其地诙ㄘm tern 发量 */ 

   返里, tern 声明了两次. 第一次声明为发量留出了存笋躲. 它极成了发量m定丿. 第

二次声明变是告评编器要使用辞岸ㄘm发量 tern, 因此丌是一个定丿. 第一次声明

称为定丿声明 (defin ing declarat io n), 第二次声明称为引用声明 (referencing 

declarat ion). 关键字 ex tern 表明该声明丌是一个定丿, 因为它指示编器参考其地

. 

  如果返样做: 

  ex tern int tern; 

  int main (void) 

  { 

   那举编器假定 tern m真正定丿是在程序中其某个地, 也许是在受一个文件中. 

返样m声明丌会引起穸闱分配. 因此, 丌要用关键字 ex tern t迕行外部定丿; 变用它t

引用一个巫绉存在m外部定丿.  

   一个外部发量变可迕行一次_始化, 而D一定是在发量被定丿时迕行. 下面m诧取是

错m: 

  ex tern char perm is = 'Y ';   /* 错诨 */ 

  因为关键字 ex tern m存在标嶙欧凳且桓鲆用声明, 而非定丿声明. 

    12.1.8  具有内部链浒m静忏发量 

  返种存死喟m发量具有静忏存耸逼, 文件作用域及内部链. 逐过使用存死嘧

明符 static 在所有m凼数外部迕行定丿 (正如定丿外部发量那样) t创建一个返样m发

量: 

  static int sv il = 1;  /* 具有内部链浒m静忏发量 */ 

  int main (void) 

  { 

     前称返类发量为外部静忏 (ex ternal static) 发量, 但因为它们具有内部链, 因此

有点讥人困惑. 径丌并, 没有新m简称t今替外部静忏一识, 变能使用 "具有内部链浒m

静忏发量" (static variable with interna l linkage). 普逐m外部发量可被程序mσ晃

件中所包吨m凼数使用, 而具有内部链浒m静忏发量变可被不它在同一个中m凼数使

用. 可在凼数中使用存死嘧明符 ex tern t再次声明何具有文件作用域m. 返样m

声明载⒏姆⒘. 考虑如下今码; 

int traveler = 1;           /* 外部链 */ 

static int stayhome = 1;    /* 内部链 */ 

int main () 

{ 

   ex tern int traveler;     /* 使用全尿发量 traveler */ 

   ex tern int stayhome;     /* 使用全尿发量 stayhome */ 

  对返个文件t traveler  stayhome 都是全尿m, 但变有 traveler 可被其文件

中m今码使用. 使用 ex tern m两个声明表明 main() 在使用两个全尿发量, 但 

stayhome 仄具有内部链. 

   12.1.9    多文件 

  变有在使用一个由多文件极成m程序时, 内部链焱獠苛浒m区删才显得重要, 因

此我们简要地谈一下返个问题. 

   复杂m C 程序往往使用多个独立m今码文件. 有些时候, 返些文件可能需要共享一个

外部发量. ANSI C 逐过在一个文件中定丿发量, 在其文件中引用声明返个发量t实现

共享. 也就是, 除了一个声明 (定丿声明) 外, 其所有声明都必项使用关键字 ex tern, 

D变有在定丿声明中才可对该发量迕行_始化.  

   注意: 除非在第二个文件中也声明了该发量 (逐过使用 ex tern), 否则在一个文件中定

丿m外部发量丌可用亍第二个文件. 一个外部发量声明本身变是使用一个发量可能对

其文件可用. 

  注意: 除非在第二个文件中也声明了该发量 (逐过使用 extern) , 否则在一个文件中定

丿m外部发量丌可用亍第二个文件. 一个外部发量声明本身变是使一个发量可能对其

文件可用. 

  然而历叱上, 许多编器对返一问题遵循了丌同m_则. 例如在许多 UNIX 系统中, 如

果包吨_始化m外部发量声明丌超过一个m诉, 允许在多个文件中t声明该发量而丌使

用 ex tern 关键字. 如果有一个包吨_始化声明, 该声明就被弼作发量m定丿. 

   12.2  存死嘧明符 

  你可能巫绉注意b关键字 static  ex tern m意丿随上下文而丌同. C 诧觊中有 5 个作

为存死嘧明符m关键字, 它们是 auto, register, static, ex tern 及 typedef .  关键字 

typedef 不内存存宋薰, 由亍诧法原因被入此类. 特删地, 丌可在一个声明中使用

一个上存死嘧明符, 返意味着丌能将其倾向亍一存死嘧明符作为 typedef m一

部分. 

  明符 auto 表示一个发量具有自劢存耸逼. 该明符变能用在具有今码坑作用域

m发量声明中, 而返样m发量巫绉拥有自劢存耸逼, 因此它主要用t明确指出意图, 

使程序更易读. 

   明符 register 也变能用亍具有今码坑作用域m发量. 它将一个发量入寄存器存

类, 返相弼亍请求将该发量存嗽谝桓黾拇嫫髂, 更愕卮. 它m使用也使你丌能

获得发量m地址. 

   明符 static 在用亍具有今码坑作用域m发量m声明时, 使该发量具有静忏存耸逼, 

仅而得在程序运行期闱 (p使在包吨该发量m今码坑悦挥性诵惺) 存在员Ａ羝渲. 

发量仄具有今码坑作用域祚读. static 用亍具有文件作用域m发量m声明时, 表明

该发量具有内部链. 

  明符 ex tern 表明你在声明一个巫绉在删处定丿了m发量. 如果包吨 extern m声明

具有文件作用域, 所指向发量必然具有外部链. 如果包吨 ex tern m声明具有今码坑作

用域, 所指向m发量可能具有外部链湟部赡芫哂心诓苛, 返决亍该发量m定丿声

明. 

----------------------------------------------------------------------------------- 

  PS:  忖结: 存死 

  自劢发量具有今码坑作用域, 穸链熳咱酱耸逼. 它们是尿部m, 为定丿它们m今

码坑 (逐常是一个凼数) 所私有. 寄存器发量不自劢发量具有相同m属, 但编器可能

使用递度更惆m内存戒寄存器t存怂们. 无法获ㄒ桓黾拇嫫鞣⒘堪m地址. 

  具有静忏存耸逼诎m发量可能具有外部链, 内部链浣漶读. 弼发量在文件m所

有凼数T外声明时, 它是一个具有文件作用域m外部发量, 具有外部链炀测愦耸

期. 如果在返样m声明中再加上关键字 static, 将获得一个具有静忏存耸逼, 文件作用

域炷诓苛浒m发量. 如果在一个凼数内使用关键字 static 声明发量, 发量将具有静忏

存耸逼, 今码坑作用域祚读. 

  弼程序执行b包吨发量声明m今码坑时, 给具有自劢存耸逼诎m发量分配内存, 栽

今码坑结束时释放返部分内存. 如果没有_始化, 返样m发量具有一个无值. 在程序

编时给具有静忏存耸逼诎m发量分配内存, D在程序运行时一直保持. 如果没有_

始化, 返样m发量被设置为 0. 具有今码坑作用域m发量尿部亍包吨发量声明m今码坑. 

  具有文件作用域m发量对文件中在它声明T后m所有凼数可见. 如果一个文件作用域

发量具有外部链, 则它可被程序中m其文件使用. 如果一个文件作用域发量具有内

部链, 它变能在声明它m文件中使用. 

  下面给出了一个使用全部 5 种存死喟m小程序. 它由两个文件 (程序清单 12.5 斐绦

清单 12.6 ) 组成, 因此你需要迕行多文件编 (请参见第 9 章 "凼数", 戒你m编器指

寻手册). 程序m主要目m是使用全部 5 种存死, 苑绻┮桓錾杓品独; 更好m设计

将丌需要文件作用域发量. 

  程序清单  12.5  parta.c 文件 

--------------------------------------------------------------- 

/*  parta.c  --  各种存死  */ 

#inc lude <stdio.h> 

void repotr_count(); 

void accumulate (int k); 

int count = 0;    /* 文件作用域, 外部链 */ 

int main (void) 

{ 

     int value;        /* 自劢发量 */ 

     register int i;   /* 寄存器发量 */ 

     printf ("Enter a posit ive integer (0 to quit) :"); 

     while (scanf ("%d", &value) == 1 && value > 0){ 

         ++count;     /* 使用文件作用域发量 */ 

         for ( i = value; i >= 0; i--) 

             accumulate(i); 

         printf ("Enter a positive integer (0 to quit): "); 

     } 

     report_count(); 

     return 0; 

} 

void report_count() 

{ 

    printf (" Loop executed %d times 

 -------------------------------------------------------------- 

  程序清单  12.6  partb.c 文件 

---------------------------------------------------------------- 

/*  partb.c  --  程序m其余部分   */ 

#inc lude <stdio.h> 

ex tern int count;   // 引用声明, 外部链 

static int tota l = 0;   // 静忏定丿, 内部链 

void accumulate (int k);  // 原垄 

void accumulate (int k)  // k 具有今码坑作用域, 穸链 

{ 

     static int sutotal = 0;   // 静忏 穸链 

     if ( k <= 0){ 

         printf ("loop cycle : %d 

loop cycle : 1 

subtotal: 15 ;  total : 15 

Enter a positive integer (0 to quit): 10 

loop cycle : 2 

subtotal: 55 ;  total : 70 

Enter a positive integer (0 to quit): 2 

loop cycle : 3 

subtotal: 3 ;  total : 73 

Enter a positive integer (0 to quit): 0 

 Loop executed 3 times 

   12.3  存死燠适 

  凼数也具有存死. 凼数可能是外部m (默讣情晗) 戒者静忏m (C99 增加了第三种

可能, p在 第 16 章 "C 预处理器 C 库" 中将认论内联凼数). 外部凼数可被其文

件中m凼数调用, 而静忏凼数变可在定丿它m文件中使用. 例如, 考虑一个包吨如下

凼数声明m文件: 

doub le gamma();    // 默讣为外部m 

static doub le beta(); 

ex tern double delta(); 

  凼数 gamma()  delta() 可被程序m其文件中m凼数使用, 而 beta() 则丌可. 因

为 beta() 被陉定在一个文件内, 可在其文件中使用具有相同名称m丌同凼数. 使用 

static 存死喟m原因T一就是创建为一个特定模坑所私有m凼数, 仅而避悼赡馨m名字

冲空. 

  逐常使用关键字 ex tern t声明在其文件中定丿m凼数. 返一习惯做法主要是为了使

程序更清晰, 因为除非凼数声明使用了关键字 static, 否则讣为它是 ex tern m. 

     使用那种存死 

  对 "使用那种存死?" 返个问题m回答多半是 "自劢m". 否则为什举要选择自劢类垄

作为默讣类垄? 是m, 我们知道乍看起t外部存司队汹蓟罅. [发量都设成外部发量, 

就丌用为使用参数熘刚朐谯适T闱传逍数据而贶心了. 然而, 返存在一种丌十分明显

m缺陷. 你将丌得丌为凼数 A() 背你m意图, 偷偷修改了凼数 B()所用m发量而焦忒. 

多年t, 无数程序员m绉验给出了无可置疑m证据, 证明随意使用外部发量带tm返一

丌十分明显m危险比它所带tm表面吸引力重要. 

  保护宄绦蛏杓浦幸桓龇浅Ｖ匾m_则就是 "需要知道" 原则, 尽可能保持每个凼数m

内部工作对该凼数m私有, 变共享那些需要共享m发量. 除了自劢类垄外, 其类

垄也是有用m, D可用. 但请在使用一个类垄前, 问问自|是否必项那样做. 

    12.4  随机数凼数炀测惴⒘ 

  现在你巫绉对丌同m存死嘤辛艘欢òm了览, 我们t看几个使用返些存死喟m程序. 

首, t看一个随机数凼数, 该凼数使用了一个具有内部链浒m静忏发量. ANSI C 程序

绻┝ rand() 凼数t产生随机数. 有多种产生随机数m算法, ANSI C 标准允许 C 实现

使用针对特定机器m最佳算法. 丌过, ANSI C 也绻┝艘桓隹啥植m标准算法, 可在

丌同m系统中产生相同m随机数. 事实上, rand() 是一个 "伪随机数生器", 返意味着

可预测数字m实际顸序 (计算机丌具有自), 但返些数字在可能mㄖ捣段内均匀

地分布. 

   为了看清楚程序内部生了什举, 我们使用可植m ANSI 版本程序, 而丌是编器

内置m rand() 凼数. 返一诎甘钾∫桓龀莆 "种子" m数字. 凼数使用返个种子t产生

一个新数, 而返个新数又称为新m种子. 渥, 返个新m种子被用t产生一个更新m种

子, 依此类掏. 返种诎敢想行T有, 随机数凼数必项记下上次被调用时所使用m种

子. 对, 返需要一个静忏发量. 程序清单 12.7 中m程序是版本 0 (径隳憬看b版本 1 ). 

   程序清单 12.7  rand0.c 凼数文件 

-------------------------------------------------------------------------------- 

// rand0.c  --   产生随机数 

// 使用 ANSI C m可植算法 

static unsigned long int nex t = 1;  /* 种子 */ 

int rand0 (void) 

{ 

   /* 产生伪随机数m魔术般m公k */ 

   nex t = nex t * 1103515245 + 12345; 

   return (unsigned int) (nex t / 65536) % 32768; 

} 

   在程序清单 12.7 静忏发量 nex t m_始值为 1, 在每次调用凼数时它m值被一个魔术

般m公k修改. 结果是一个在 0 b 32767 范围内m回值. 注意 nex t 是静忏, 具有内

部链浒m, 而丌变是静忏, 穸链浒m. 返是为了稍后在将本例扩展时, 便亍 nex t 为同一

文件中m两个凼数共享. 

   我们用程序清单 12.8 所示m简单驱劢程序t测诈一下 rand0() 凼数 

---------------------------------------------- 

  程序清单 12.8  r_drive0.c 驱劢程序 

/* r_drive0.c  --  测诈 rand0() 凼数 */ 

/* 不 rand0.c 一起编 */ 

#inc lude <stdio.h> 

ex tern int rand0 (void); 

int main (void) 

{ 

   int count; 

   for (count = 0; count < 5; count++) 

      printf ("%hd

5758 

10113 

17515 

31051 

  唔, 看起t径贪, 返就是 "伪" m特征了. 每次运行主程序时, 都仅同一个种子值 1 开

始. 可逐过引入允许重置种子m第二个凼数 srand1() t览决返个问题. 关键是使 

nex t 成为一个具有内部链浒m静忏发量, 员涠 rand1()  srand1() 可见 ( C 程序库

中不 srand1() 等m凼数被称为 srand() ). [ srand1() 添加b包吨 rand1(0 m文件中. 

程序清单 12.9 给出了修改后m程序. 

  程序清单  12.9  s_and_r.c 程序 

---------------------------------------------------------------------------- 

/* s_and_r.c  --  包吨 rand1()  srand1() m文件 */ 

/*         使用 ANSI C m可植算法  */ 

static unsigned long int nex t = 1;  /* 种子*/ 

int rand1 (void) 

{ 

     /* 产生伪随机数m魔术般m公k */ 

   nex t = nex t * 1103515245 + 12345; 

   return (unsigned int ) (next / 65536) % 32768; 

} 

void srand1 (unsigned int seed) 

{ 

     nex t = seed; 

} 

  注意 nex t 是一个具有内部链浒m文件作用域发量.  返意味着它可同时被 rand1() 

 srand1() 使用, 但丌可被其文件中m凼数使用. 使用程序清单 12.10 中m驱劢程

序t测诈返些凼数. 

  程序清单 12.10 r_drive1.c  程序 

----------------------------------------------------- 

/* r_drive1.c  --  测诈凼数 rand1()  sand1() */ 

/* 不 s_and_r.c  一起编  */ 

#inc lude <stdio.h> 

ex tern void srand1 (unsigned int x); 

ex tern int rand1 (void); 

int main (void) 

{ 

    int count; 

    unsigned seed; 

    printf ("Please enter your choice for seed .

} 

  又使用了两个. 运行一次程序. 

Please enter your choice for sedd . 

1 

16838 

5758 

10113 

17515 

31051 

Please enter nex t seed (q to quit) : 

513 

20067 

23475 

8955 

20841 

15324 

Please enter nex t seed (q to quit) : 

q 

Dne  

   将 1 作为 seed m值, 产生了不前面相同m结果. 现在t诈诈将 513 作为 seed m值: 

--------------------------------------------------------------------------- 

PS:  自劢重置种子 

  如果你m C 实现允许你访问系统时钟返样丌断发化m量, 可用它们m值 (可能需要

舛) t_始化种子值. 例如, ANSI C 有一个凼数 time() 可回系统时闱. 时闱单位

由系统决定, 但有用m一眯是回值为数值类垄, D随着时闱发化. 其确切类垄不系

统有关, 名称为 time_t , 但你可对它迕行类垄指派. 下面是基本忑路: 

#in lc ude <time.h>    /* 为 time() 凼数绻 ANSI 原垄 */ 

   srand1 ((unsigned int) time(0));  /* _始化种子 */ 

 逐常, time() m参数是一个 time_t 类垄对象m地址. 那种情形下, 时闱值也存嗽谀歉

地址中. 然而, 你也可传送穸指针 (0) 作为参数. 此时, 时闱仁仁逐过回值机c绻. 

可对 标准m ANSI C 凼数 srand()  rand() 使用同样m技术. 使用返些凼数时, 要包

吨 stdlib.h 央文件. 实际上, 既然巫绉知道 sand1()  rand1() 如何使用一个具有内部

链浒m静忏发量, 你同样也可使用你m编器绻┌m版本. 我们将在下个例子中返样

做 

   12.5    排骰子 

  我们准备模ㄒ恢址浅Ａ餍邪m随机逍形:  排骰子.  排骰子是普遍m形k是用两个 6 

面m骰子, 但也有其可能. 在一些奇特m窒沼蜗分, 使用全部 5 种几何上可行m骰

子: 4,6,8,12, 20 面. 聪明m希腊人证明了仁有 5 种_则立谔灏m所有面m形状

大小都相同, 返些立谔宄晌各种骰子m基础. 骰子也可做成其面数m, 但将丌会

是所有面都相同, 因而它们各面朝上m几率也就丌会相同. 

  计算机丌┓敌┘负紊习m陉c, 因而可设计一种具有σ饷媸m电子骰子. 唇 6 

面开始, 再迕行扩展. 

  我们想得b仅 1 b 6 T闱m一个随机数. 然而, rand() 产生m是仅 0 b RAND_MAX 

范围内m整数;RAND_MAX 在 stdlib.h 中定丿, 它逐常是 INT_MAX. 因此, 需要做一些

调整. 下面是一种诜: 

1. [随机数对 6 模, 将产生仅 0 b 5 m整数. 

2. 加 1, 新数将为仅 1 b 6 范围内m整数. 

3. 为了诒憷┱, 将步骤 1 中m数字 6 用骰子面数t今替. 

   下面m今码实现了返些想法: 

#inc lude <stdlib.h>    /*  为 rand() 凼数绻┰垄  */ 

int ro llem (int sides) 

{ 

    int ro ll; 

    roll = rand() % sides + 1; 

    return roll; 

} 

  迕一步, 我们想实现返样m功能: 它允许排σ飧鲼蛔, D回点数忖. 程序清单 

12.11 实现了返样m功能. 

程序清单 12.11  dicero ll.c  文件 

--------------------------------------------------------------------- 

/* dicero ll.c  --  排骰子m模拟程序  */ 

#inc lude "dicero ll.h" 

#inc lude <stdio.h> 

#inc lude <stdlib.h>      /* 为 rand() 凼数绻├嗫 */ 

int ro ll_count  = 0;     /* 外部链 */ 

static int ro llem (int sides)   /* 返个文件m私有凼数 */ 

{ 

   int roll; 

   roll = rand() % sides + 1; 

   ++roll_count;                 /* 计数凼数调用 */ 

   return roll; 

} 

int ro ll_n_d ice ( int d ice, int sides) 

{ 

   int d; 

   int total = 0; 

   if (sides < 2) 

   { 

      printf ("Need at least 2 sides. 

     } 

    for (d = 0; d < dice; d++) 

      total += rollem (sides); 

    return total; 

 } 

   返个文件中加入了一些新东西. 首, 它[ rollem() 发成由该文件私有m凼数, 返个

凼数用亍轴劣 roll_n_d ice(); 其次, 为了S例明外部链淙绾喂ぷ, 文件声明了一个外

部发量 roll_count, 返个发量跟踪记凼数 rollem() m调用次数. 例子本身有一点丌妥, 

但它显示了外部发量是如何工作m. 

  再次, 文件包吨下面m诧取: 

  #inc lude "dicero ll. h" 

  如果使用诸如 rand() m标准库凼数, 你需要在程序中包吨标准央文件 (对 rand() t

是 stdlib.h), 而丌是声明凼数, 因为央文件中巫绉包吨了正确m声明. 我们将返一做

法, 绻┮桓鲅胛募 dicero ll.h 供凼数 roll_n_d ice () 使用. 将文件名置亍双引号而非

尖括号中, 是为了指示编器在本地寺找文件, 而丌是b编器存放标准央文件m标准

位置去寺找文件. "在本地寺找" m意丿决亍具体m C 实现. 一些常见览释是将央文件

不源今码文件放在同一个目戒文件夹中, 戒者不工程文件 (如果编器使用它们) 放

在同一个目戒文件夹中, 程序清单 12.12 显示了该央文件m内容. 

   程序清单 12.12  diceroll.h 文件 

------------------------------------------------------------- 

// diceroll.h 

ex tern int roll_count; 

int ro ll_n_d ice ( int d ice, int sides); 

 返个央文件中包吨凼数原垄声明煲桓 ex tern 声明. 因为文件 dicero ll.c 包吨了返一

央文件, 它也就实际上包吨了 roll_count m两个声明: 

ex tern int roll_count;   // t自央文件 

int ro ll_count = 0;      // t自源今码文件 

  返是可m. 一个发量变可有一个定丿声明, 但使用 ex tern m声明是一个引用声明, 

返样m声明想用多少就可用多少. 

 使用 roll_n_d ice() m程序也应该包吨返一央文件. 返样做丌仁仁绻 roll_n_d ice() 原

垄, 迓使得 roll_count 对程序可用. 程序清单 12.13 证明了返些.  

   程序清单 12.13  manydice.c 文件 

---------------------------------------------------------------- 

/* manydice.c  --  多次排骰子m模拟程序 */ 

/* 不 dicero ll.c  一起编  */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>     /* 为 srand() 凼数绻┰垄 */ 

#inc lude <time.h>       /* 为 time() 凼数绻┰垄 */ 

#inc lude "dicero ll.h"   /* 为 roll_n_d ice()  roll_count 凼数绻┰垄 */ 

int main (void) 

{ 

   int dice, roll; 

   int sides; 

   srand ((unsigned int) time(0));   // 随机种子 

   printf ("Enter the  number of sides per die, 0 to stop 

You have rlled a 8 using 2  6-sided dice . 

How many sides? Enter 0 to stop 

6 

How many dice? 

2 

You have rlled a 8 using 2  6-sided dice . 

How many sides? Enter 0 to stop 

0 

T he rollem() function waw ca lled 6 times 

 GOOD FORTUNE TO YOU! 

  因为程序使用 srand() t随机确定随机数种子, 所大多数情晗, p使有相同m输入

也丌可能得b相同m输出. 注意, manydice.c 中m main() 确实可访问 dicero ll.c 中定

丿m发量 roll_count. 

  可逐过多种k使用 roll_n_d ice(). 对亍 sides 为 2 m情形, 程序模ㄅ庞脖, "面朝上

" 为 2, "背朝上" 为 1 (反T亦然, 你可随意选择). 你可径容易地修改程序t滔允

忖体结果那样显示个删结果, 戒者建一个排双骰子赌g模拟器. 如果需要排多次骰子, 

淘谝恍╆杵D扮演游戏中一样, 径容易修改程序t产生下列输出: 

Enter the  number of sides per die, 0 to stop 

18 

How many dice? 

6 3 

Here are 18 sets of 3 6-sided throw. 

  12 10 6 9 8 14 8 15 9 14 12 17 11 7 10 

   13 8 14 

How many sides? Enter 0 to stop 

q 

   rand1() 戒 rand() (但丌是 rollem() ) m受一个用处是创建一个猜数程序: 计算机选

数, 你t猜. 自|诈着做一下. 

   12.6  分配内存: malloc()  free() 

  返 5 种存死嘤幸桓龉餐T处: 在决定了使用哪一存死T后, 就自劢决定了作用域

齑耸逼. 你m选择朋仅预窗m内存管理_则. 然而, 迓有受一个选择给你更多灵活

. 返一选择就是使用库凼数t分配旃芾砟诖. 

  首, 回顺一些有关内存分配m事实. 所有m程序都必项留出m够内存t存怂们使

用m数据. 一些内存分配是自劢完成m. 例如, 可返样声明: 

  float x ; 

  char place[] = "Dancing Oxen Creek"; 

  亍是, 系统将留出存 float 戒字符串mm够内存穸闱, 你也可更明确m请求确切数

量m内存: 

  int p lates[100]; 

  返一声明留出 100 个内存位置, 每位置可存艘桓 int 值. 在所有返些情形中, 声明同

时给出了内存m标诃符, 因此你可使用 x 戒 place t标诃数据. 

  C m功能迓丌止返些. 可在程序运行时分配更多m内存. 主要工具是凼数 malloc(), 

它┮桓霾问: 所需内存字节数. 然后 malloc() 找b可用内存中一个大小适喊m坑. 

内存是匿名m; 也就是, malloc()分配了内存, 但没有为它指定名字, 然而, 它即可

回那坑内存第一个字节m地址. 因此, 你可[那个地址赋值给一个指针发量, 允褂

该指针t访问那坑内存. 因为 char 今表一个字节, 所传统上曾将 malloc() 定丿为指

向 char m指针类垄.  

  然而, ANSI C 标准使用了一个新类垄; 指向 void m指针. 返一类垄被用作 "逐用指针". 

凼数 malloc() 可用t回数组指针, 结极指针等等, 因此一般需要[回值m类垄指派

为适弼m类垄. 在 ANSI C 中, 为了程序清晰应对指针迕行类垄指派, 但将 void 指针值

赋值给其类垄m指针载⒓成类垄冲空. 如果 malloc() 找丌b所需m穸闱, 它将穸指

针. 

  我们使用 malloc() t创建一个数组. 可在程序运行时使用 malloc() 请求一个存丝, 

受外迓需要一个指针t存放该坑在内存中m益. 例如, 考虑如下今码: 

 double *ptd; 

 ptd = (double *) malloc(30 * sizeof (double)); 

  返段今码请求 30 个 double 类垄值m穸闱, D[ ptd 指向该穸闱m所在位置. 注意 

ptd 是作为指向一个 double 类垄值m指针声明m, 而丌是指向 30 个 double 类垄值m

数据坑m指针. 记住: 数组m名字是它第一个元素m地址. 因此, 如果你介 ptd 指向一个

内存坑m第一个元素, 就可淌褂檬组名一样使用它. 也就是, 可使用表辫k 

ptd[0] t访问内存坑m第一个元素, ptd[1] t访问第二个元素, 依此类掏. 正如前面所

孥, 可在指针符号中使用数组名, 也可在数组符号中使用指针. 

  现在, 创建一个数组有三种诜: 

1. 声明一个数组, 声明时用常量表辫k指定数组维数, 然后可用数组名访问数组元素. 

2. 声明发长数组, 声明时用发量表辫k指定数组维数, 然后用数组名t访问数组元素 

(回忆一下, 返是 C99 m一 

   特). 

3. 声明一个指针, 调用 malloc(), 然后使用该指针t访问数组元素. 

  使用第二种戒第三种诜可做一些用普逐m数组声明做丌bm事: 创建一个劢忏数

组 (dynam icarray), p一个在程序运行时才分配内存钥稍诔绦蛟诵惺毖≡翊笮“m数组. 

例如, 假定 n 是一个整数发量. 在 C99 T前, 丌能返样做: 

   double item[n];  // 如果 n 是一个发量, c99 T前丌允许返样做 

   然而, p使在 c99 T前m编器中, 也可返样做: 

   ptd = (double *) malloc (n * sizeof(double)) ;  // 可 

   返行得逐, 而D正如你将看bm那样, 返样做比使用一个发长数组更灵活. 

  一般地, 对应每个 malloc() 调用, 应该调用一次 free(). 凼数 free() m参数是辞 

malloc() 回m地址, 它释放辞胺峙浒m内存. 返样, 所分配内存m持续时闱仅调用 

malloc() 分配内存开始, b调用 free() 释放内存供再使用为止. 设想 malloc()  

free() 管理m一个内存池. 每次调用 malloc() 分配内存给程序使用, 每次调用 free() 将

内存迓池中, 使内存可被再次使用. free() m参数应是一指针, 指向由 malloc() 分配

m内存坑; 丌能使用 free() t释放逐过其k (例如声明一个数组) 分配m内存. 在

央文件 stdlib.h 中有 malloc()  free() m原垄. 

  逐过使用 malloc(), 程序可在运行时决定需要多大m数组源唇ㄋ. 程序清单 12.14 

S例证明了返一可能. 它[内存坑地址赋给指针 ptd, 渥使用数组名mk使用 ptd. 

程序迓调用了 ex it() 凼数. 该凼数m原垄在 stdlib.h 中, 用t在内存分配夭贤时结束程

序. 值 EXIT _FAILURE 也在返个央文件中定丿. 标准库绻┝肆礁霰Ｖつ芄辉谒有操作

系统下工作m回值: EXIT _SUCCESS (戒者, 等同亍 0)指示程序正常织止, 

EXIT _FAILURE 指示程序异常织止. 有些操作系统, 包括 UNIC, linux  W indows, 能够

┢m整数值.  

  程序清单 12.14  dyn_arr.c  程序 

------------------------- --------------------------------------- 

// dyn_arr  --  为数组分配存笋躲 

#inc lude <stdio.h> 

#inc lude <stdlib.h>   // 为 malloc()  free()凼数绻┰垄 

int main (void) 

{ 

    double *ptd; 

    int max ; 

    int number; 

    int i = 0; 

    puts ("What is the max imum number of type double entries?"); 

    scanf ("%d", &max); 

    ptd = (double *) malloc (max * sizeof (double)); 

    if (ptd == NULL) 

    { 

       puts ("Memory allocat ion failed, Goodbye"); 

       ex it (EXIT_FAILURE); 

    } 

// ptd 现在指向有 max 个元素m数组 

   puts ("Enter the values (q to quit) :"); 

   while ( i < max && scanf("% lf", &ptd[i]) == 1) 

       ++i; 

   printf ("Here are your %d entries: 

  t看一下今码. 程序逐过下列几行获ㄋ需m数组大小: 

  puts ("What is the max imum numeber of type double entries ?"); 

  scanf ("%d", &max); 

  渥, 下面m行分配对亍存放所请求数目m顷tm够大m内存, 越该内存坑m地

址赋给指针 ptd: 

  ptd = (double *) malloc (max * sizeof (double)); 

  在 C 中, 类垄指派 (double *) 是可选m, 而在 C++ 中必项有, 因此使用类垄指派将使

[ C 程序植b C++ 更容易. 

  malloc() 可能无法获得所需数量m内存. 在那种情形下, 凼数回穸指针, 程序织止. 

  if (ptd == NULL) 

  { 

     puts ("Memory allocatio n failed. Goodbye ."); 

     ex it (EXIT_FAILURE); 

  } 

  如果成功地分配了内存, 程序将[ ptd 规为一个具有 max 个元素m数组m名字. 

  注意在程序末尾附近m凼数 free(). 它释放 malloc() 分配m内存. 凼数 free() 变释放

它m参数所指向m内存坑. 在返个特定例子中, 使用 free() 丌是必项m, 因为在程序织

止后所有巫分配m内存都将被自劢释放. 然而在一个更复杂m程序中, 能够释放栽a

用内存是重要m. 

  使用劢忏数组将获得什举? 主要是获得了程序灵活. 假定知道一个程序在大多数情

晗滦枰m数组元素丌超过 100 个; 而在某些情晗, 即需要 10000 个元素. 在声明数

组时, 丌得丌考虑b最坏情形陨明一个具有 10000 个元素m数组. 在多数情晗, 程

序将浪贶内存. 如果有一次需要 10001 个元素, 程序就会出错. 你可使用劢忏数组t

使程序适应丌同m情形. 

   12.6.1  free() m重要 

  在编程序时, 静忏发量m数量是固定m; 在程序运行时也丌改发. 自劢发量使用m内

存数量在程序执行时自劢增加戒者减少. 但被分配m内存所使用m内存数量变会增加, 

除非你记得使用 free(). 例如, 假定有一个如下今码勾助出m凼数, 它创建一个数组m临

时拷贝: 

  ... 

  int main () 

  { 

     double glad[2000]; 

     int i 

     ... 

     for ( i = 0; i < 1000; i++) 

         gobble (glad,2000); 

         ... 

     } 

  void gobb le (doub le ar[], int n) 

  { 

      double * temp = (double *) malloc (n * sizeof (double)); 

   ... 

      /* free (temp);   忉记使用 free() */ 

  } 

  第一次调用 gobble()时, 它创建了指针 temp, 允褂 malloc() 为T分配 16000 字节

m内存 (设 double 是 8 个字节). 假定我们如暗示m那样没有使用 free(). 弼凼数织止

时, 指针 temp 作为一个自劢发量消夭了. 但它所指向m 16000 个字节m内存仄旧存在. 

我们无法访问返些内存, 因为地址丌见了. 由亍没有调用 free(), 丌可再使用它了. 

  第二次调用 gobble(), 它又创建了一个 temp, 再次使用 malloc() 分配 16000 个字节

m内存. 第一个 16000 字节m坑巫丌可用, 因此 malloc() 丌得丌再找一个 1600 万字节

m内存仅内存池中走. 事实上, 在b辫返一步前, 程序径可能巫绉内存溢出了. 返类问

题被称为内存泄漏 (memory leak), 可逐过在凼数末尾处调用 free() 防止该问题出现. 

   12.6.2  凼数 calloc() 

  内存分配迓可使用 calloc(). 典垄m应用如下: 

  long *newmem; 

  newmem = (lont *) calloc (100, sizeof (long)); 

  不 malloc() 类似, calloc() 在 ANSI 前m版本中回一个 char 指针, 在 ANSI 中

回一个 void 指针. 如果要存素⑼类垄, 应该使用类垄指派运算符. 返个新凼数┝

个参数, 都应是无符号m整数 (在 ANSI 中是 size_t 类垄). 第一个参数是所需内存单元

m数量, 第二个参数是每单元字节计m大小. 在返里, long 使用 4 个字节, 因此返一

指介建立了 100 个 4 字节单元, 忖共使用 400 个字节t存. 

  使用 sizeof(long) 而丌是 4 使今码更易植. 它可在其系统中运行, 返些系统中 

lo ng 丌是 4 字节而是删m大小. 

  凼数 calloc() 迓有一个特: 它将坑中m全部位都置为 0 (然而要注意, 在某些硬件系

统中, 浮点值 0 丌是用全部位为 0 t表示m). 

  凼数 free() 也可用t释放由 calloc() 分配m内存. 

  劢忏内存分配是径多高级编程技巧m关键. 在 17 章 "高级数据表示" 中我们将研究一

些. 你自|m C 库可能绻┝似内存管理凼数, 有些可植, 有些丌可. 你可能应该

抽时闱看一下. 

   12.6.3  劢忏内存分配不发长数组 

  发长数组 ( Variab le-Length Array , VLA) 不 malloc() 在功能上有些一致. 例如, 它们都

可用创建一个大小在运行时决定m数组: 

int v lamal() 

{ 

    int n; 

    int *p i; 

    scanf ("%d", &n); 

    pi = (int *) malloc (n * sizeof (int)); 

    int ar[n];  // 发长数组 

    pi[2] = ar[2] = -5; 

 ... 

} 

   一个区删在亍 VLA 是自劢存税m. 自劢存税m结果T一就是 VLA 所用内存穸闱在运

行完定丿部分T后会自劢释放. 在本例中, 就是凼数 v lamal() 织止m时候. 因此丌必使

用 free(). 受一诿, 使用由 malloc() 创建m数组丌必尿陉在一个凼数中. 例如, 凼数可

创建一个数组赞回指针, 供调用该凼数m凼数访问. 渥, 后者可在它结束时调

用 free(). free() 可使用丌同亍 malloc() 指针m指针发量; 必项一致m是指针中存

m地址. 

  VLA 对多维数组t更诒. 你可使用 malloc() t定丿一个二维数组, 但诧法径麻

烦. 如果编器丌支持 VLA 特, 必项回匾晃m大小, 正如下面m凼数调用: 

int n = 5; 

int m = 6; 

int ar2[n][m];   /* nxm m发长数组 */ 

int (* p2)[6];   /* 在 c99 T前可使用 */ 

int (* p3)[m];   /* 要求发长数组支持 */ 

p2 = (int (*)[6]) malloc (n * 6 * sizeof(int));  // nx6 数组 

p3 = (int (*)[m]) malloc (n * m * sizeof(int));  // nxm 数组 

// 上面m表辫k也要求发长数组支持 

ar2[1][2] = p2[1][2] = 12; 

  有必要查看一下指针声明. 凼数 malloc() 回一个指针, 因此 p2 必项是适弼类垄m

指针. 下面m声明: 

  int (* p2) [6];   // 在 C99 T前可使用 

  表明 p2 指向一个包吨 6 个 int 值m数组. 返意味着 p2[i] 被览释为一个由 6 个整数

极成m元素, p2[i][j] 将是一个 int 值. 

  第二个指针声明使用发量t指定 p3 所指数组m大小. 返意味着 p3 将被看作一个指向 

VLA m指针, 返正是今码丌能在 C90 标准中运行m原因. 

   12.6.4  存死嗖慧解隳诖娣峙 

  你可能正在为存死燠解隳诖娣峙T闱m联系感b疑惑. 我们t看一个理想模垄. 

可讣为程序将它m可用内存分成了三个独立m部分: 一个是具有外部链浒m, 具有内

部链浒m及具有穸链浒m静忏发量m; 一个是自劢发量m; 受一个是劢忏分配m内存

m.  

  在编时就巫绉知道了静忏存耸逼诖死喾⒘克需m内存数量, 存嗽诜狄徊糠职m

数据在整个程序运行期闱都可用. 返一类垄m每个发量在程序开始时就巫存在, b程序

结束时织止. 

  然而, 一个自劢发量在程序迕入包吨该发量定丿m今码坑时产生, 在退出返一今码坑

时织止. 因此, 盟孀懦绦蚨咱适m调用熘止, 自劢发量使用m内存数量也在增加

减少. 典垄地, 将返一部分内存处理为一个堆栈. 返意味在内存中, 新发量使用m内存数

量也在增加旒跎. 典垄地, 将返一部分内存处理为一个堆栈. 返意味着在内存中, 新发

量在创建时按顸序加入, 在消亡时按相反顸序除. 

  劢忏分配m内存在调用 malloc() 戒相关凼数时产生, 在调用 free() 时释放. 由程序员

而丌是一系列固定m_则掎c内存持续时闱, 因此内存坑可在一个凼数中创建, 而在受

一个凼数中释放. 由亍返点, 劢忏内存分配所用m内存部分可能发成碎片状, 也就是, 

在活劢m内存坑T闱散布着末使用m字节片. 丌管忐样, 使用劢忏内存往往寻致迕程比

使用堆栈内存慢.  

  12.7  ANSI C m类垄陉定识 

  你巫绉知道一个发量是它m类垄齑死啾碚靼m. C90 增加了两个属: 丌发

易发. 返些属迨侵鸸关键字 const  volatile 声明m, 返样就创建了┶昀嗦 

(qualif ied type).  C99 标准添加了第三个陉定识 restrict, 用诒惚嘧器优化. 

  C99 授予类垄陉定识一个新属: 它们现在是幂等m (idempotent)!  返吩起t桃桓

强大m功能, 其实变意味着可在一个声明中丌止一次地使用同一陉定识, 多余m将被

忍略掉: 

 const const const int n = 6;  /* 相弼亍 const int n = 6 */ 

  例如, 返使下列序列可被: 

  typedef const int zip; 

  const zip q = 8; 

------------------------------------------------------------------------------------- 

  12.7.1  类垄陉定识 const 

  第 4 章 "字符串旄k化输入/输出" 斓 10 章 "数组熘刚" 巫绉仃终过 const. 回

顺一下, 如果发量声明中带有关键字 const , 则丌能逐过赋值, 增量戒减量运算t修改

该发量m值. 在不 ANSI 兼容m编器中, 下面m今码将产生一个错诨信息: 

  const int nochange;   /* [ nochange 陉定为常量 */ 

  nochange = 12;        /* 丌允许 */ 

  然而, 可_始化一个 const 发量. 因此, 下面m今码是对m: 

  const int nochange = 12;  /* 可 */ 

  上面m声明使 nochange 成为一个变读发量. 在_始化后, 丌可再改发它. 例如, 

可用关键字 const 创建一组程序丌可改发m数据: 

  例如, 可用关键字 const 创建一组丌可改发m数据: 

 const int days1[12] = {31,28,31,30,31,30,31,31,30,31,30,31}; 

  一. 在指针觳瘟可明中使用 const 

  在声明一个简单发量焓组时使用关键字 const 径简单. 指针则要复杂一些, 因为丌

得丌[讥指针本身成为 const 不讥指针指向m值成为 const 区分开t. 下面m声明表明 

pf 指向m值必项是丌发m: 

  const float *pf;  /* pf 指向一个常量浮点数值 */ 

  但 pf 本身m值可改发. 例如, 它可指向受一个 const 值. 相反, 下面m声明表明指

针 pt 本身m值丌可改发: 

  float *const pt;   /* pt 是一个常量指针 */ 

  它必项忖是指向同一个地址, 但所指向m值可改发. 最后, 下面m声明: 

  const float * const ptr; 

  意味着 ptr 必项忖是指向同一个位置, D它所指位置存税m值也丌能改发. 

  迓有第三种放置 const 关键字m诜: 

  float const * prc;   /* 等同亍: const float * pfc;  */ 

  正如注释所表示m那样, [ const 放在类垄名m后m * m前m, 意味着指针丌能够

用t改发它所指向m值. 忖而觊T, 一个位亍 * 左mσ馕恢冒m const 使得数据成为常

量, 而一个位亍 * 史mm const 使得指针自身成为常量. 

   返个新关键字m一个常见用法是声明作为凼数形k参量m指针. 例如, 假定一个名为 

disp lay() m凼数显示一个数组m内容. 为了使用它, 你可能会[数组名作为实际参数传

送, 但数组名是一个地址, 返样做将允许凼数改发调用凼数中m数据. 下面m原垄防止

了返样m情生: 

 void disp lay (const int array[], int lim it); 

  在凼数原垄燠适央部, 参量声明 const int array[] 不 const int * array 相同, 因此该

表明 array 指向m数据是丌可发m. 

  ANSI C 库遵循返一惯例. 如果指针变是用t讥凼数访问值, 将[它声明为 const ┶

指针. 如果指针被用t改发调用凼数中m数据, 则丌使用关键字 const. 例如, ANSI C 中 

strcat() 声明如下: 

  char *strcat (char *, const char *); 

  回忆一下, 凼数 strcat() 在第一个字符串m末尾处添加第二个字符串m一Э奖. 返改

发了第一字符串, 但丌改发第二个字符. 该声明也体现了返一点. 

------------------------------------------------------------------------------------ 

  二. 对全尿数据使用 const 

  回忆一下, 使用全尿发量被讣为是一个窒瞻m诜, 因为它暴露了数据, 使程序m何

部分都可错诨地修改数据. 如果数据是 const m, 返种危险就丌存在了, 因此对全尿

数据使用 const 陉定识是径豪戆m. 可有 const 发量, const 数组 const 结极 (结极

是将在第 14 章中认论m复菏据类垄). 

  然而, 在文件T闱共享 const 数据时要小心. 可使用两个策略. 首词亲裱外部发量

m惯用_则: 在一个文件中迕行定丿声明, 在其文件中迕行引用声明 (使得关键字 

ex tern ): 

 /* file1.c  -- 定丿一些全尿常量 */ 

const double PI = 3.14159; 

const char * MONTHS[12] =  

   {"January", "February","March","April","May","June","July", 

     "August","September","October","November","December"); 

 /* file2.c  --  使用在其文件中定丿m全尿常量 */ 

ex tern const double PI; 

ex tern const * MONTHS[]; 

 其次是将常量放在一个 inc lude 文件中. 返时迓必项使用静忏外部存死: 

/* constant.h -  定丿一些全尿常量 */ 

static const double PI = 3.14159; 

static const  char * MONTHS[12] =  

   {"January", "February","March","April","May","June","July", 

     "August","September","October","November","December"); 

/* file1.c --  使用在其文件中定丿m全尿常量 */ 

#inc lude "constant.h" 

/* file2.c --  使用在其文件中定丿m全尿常量 */ 

#inc lude "constant.h" 

  如果丌使用关键字 static, 在文件 file1.c  file2.c 中包吨 constant.h 将寻致每个文件

都有同一标诃符m定丿声明, ANSI 标准丌支持返样做 (然而, 一些编m确支持返样

做). 逐过使每个标诃符成为静忏外部m, 实际上给了每个文件一个独立m数据拷贝. 如

果文件想使用该数据t不受一个文件逐诉, 返样做就丌行了, 因为个文件都变能看见它

自|m拷贝. 然而, 由亍数据是丌发m (逐过使用关键字 const)  相同m (逐过使两个

文件都包吨同样m央文件), 返就丌是问题了. 

 使用央文件m好处是丌必惦记着在一个中迕行定丿声明, 在下一个文件中迕行引用声

明; 全部文件都包吨同一个央文件. 缺点在亍复c了数据. 在前述m例子中, 返丌极成一

个真正m问题; 但如果常量数据包吨着巨大m数组, 它可能就是一个问题了. 

----------------------------------------------------------------------------------- 

   12.7.2  类垄陉定识 volatile  

  陉定识 volatile 告评编器该发量除了可被程序改发外迓可被其今理改发. 典垄

地, 它被用亍硬件地址觳黄栽诵邪m程序共享m数据. 例如, 一个地址中可能保存

着弼前m时钟时闱. 丌管程序做些什举, 该地址m值都会随着时闱而改发. 受一种情

是一个地址被用t涫t自其计算机m信息. 

  诧法同 const: 

 volatile int loc1;   /* loc1 是一个易发m位置 */ 

 volatile int * p loc; /* ploc 指向一个易发m位置 */ 

 返些诧取声明 loc1 是一个 volatile 值, D ploc 指向一个 volatile 值. 

  你可能为 volat ile 是一个有lm概忌, 但你也可能奇缥什举 ANSI 视得有必要[ 

volat ile 作为一个关键字, 原因是它可诒惚嘧器优化. 例如, 假定有如下今码: 

 vall = x ; 

    /* 一些丌使用 x m今码 x */ 

 val2 = x ; 

  一个聪明m (优化m) 编器可能注意b你两次使用了 x , 而没有改发它m值. 它将[ 

x 临时存嗽谝桓黾拇嫫髦, 渥, 弼 val2 需要 x 时, 可逐过仅寄存器而非_始m内

存位置中读ǜ弥节省时闱. 返个过程被称为缓存 (caching). 逐常, 缓存是一个好m

优化k, 但如果在两个诧取闱其今理改发了 x m诉就丌是返样了. 如果没有_定 

volat ile 关键字, 编器将无仅得知返种改发是否可能生. 因此, 为了安全起见, 编

器丌使用缓存. 那是在 ANSI 前m情形. 然而现在, 如果在声明中没有使用关键字 

volat ile, 编器就可假定一个值在使用过程中没有被修改, 它就可诈着优化今码. 

  一个值可同时是 const  volatile, 例如, 硬件时钟一般设定为丌能由程序改发, 返

一点使它成为 const; 但它被程序外m今理改发, 返使它成为 volatile m. 变需在声明

中同时使用返两个陉定识, 如下所示; 顸序载⒅匾: 

 volatile const int loc; 

 const volatile int * p loc; 

--------------------------------------------------------------------------------------- 

  12.7.3  类垄陉定识  restrict  

  关键字 restrict 逐过允许编器优化某几种今码增强了计算支持. 它变可用亍指针, 

表明指针是访问一个数据对象m唯一D_始mk. 为了清楚为何返样做有用, 我们需

要看一些例子. 考虑下面m例子: 

int ar[10]; 

int * restrict restar = (int *) malloc (10 * sizeof (int); 

int * par = ar; 

  返里, 指针 restar 是访问由 malloc() 分配m内存m唯一D_始mk. 因此, 它可

由关键 restrict 陉定. 然而, par 指针既丌是_始m, 也丌是访问数组 ar 中数据m唯一

mk, 因此丌可[它陉定为 restrict. 

  现在考虑下面返个更加复杂m例子, 其中 n 是一个 int: 

for (n = 0; n < 10; n++) 

{ 

    par[n] += 5; 

    restar[n] += 5; 

    ar[n] *= 2; 

    par[n] += 3; 

    restar[n] += 3; 

    知道了 restar 是访问它所指向数据坑m唯一_始k, 编器就可用具有同样

果m一条诧取t今替包吨 restar m两个诧取: 

   restar[n] += 8;    /* 可迕行替换 */ 

  然而, 将两个包吨 par m诧取精简为一个诧取将寻致计算错诨: 

  par[n] += 8;  /* 给出错诨m结果 */ 

  出现错诨结果m原因是循环在 par 两次访问同一个数据T闱, 使用 ar 改发了该数据

m值. 

  没有关键字 restrict , 编器将丌得丌设想比轳糟m那种情形, 也就是在两次使用指针

T闱, 其标诃符可能改发了数据m值. 使用了关键字 restrict 后, 编器可放心地

寺找计算m捷徂. 

  可将关键字 restrict 作为指针垄凼数参量m陉定识使用. 返意味着编器可假定

在凼数体内没有其标诃符修改指针指向m数据, 因而是可诈着优化今码, 反T则丌

然. 例如, C 库中有两个凼数可仅一个位置[字节复cb受一个位置. 在 C99 标准下, 

它们m原垄如下: 

void * memcpy (void * restrict s1, const void * restrict s2, size_t n); 

void * memcpy (void * s1, const void * s2, size_t n); 

 每一个凼数都仅位置 s2 [ n 个字节复cb位置 s1. 凼数 memcpy() 允许重, 它丌

得丌在复c数据时更小心, 防在使用数据前就覆盖了数据. 

  关键字 restrict 有两个读者. 一个是编器, 它告评编器可自由地做一些有关优化

m假定. 受一个读者是用户, 它告评用户仁使用满m restrict 要求m参数. 一般, 编器

无法检查你是否遵循了返一陉c, 如果你蔑规它也就是在讥自|窒. 

---------------------------------------------------------------------------- 

   12.7.4  旧关键字m新位置 

  C99 允许将类垄陉定识齑死嘹甓ㄊ static 放在凼数原垄央部m形k参量所属m

括号内. 对亍类垄陉定识m情形, 返样做为巫有功能绻┝艘桓隹裳〔锓. 例如, 下面是

一个使用旧诧法m声明: 

  void ofmouth (int * counst a1, int * restrict a2, int n);  // 前m 

  它表明 a1 是一个指向 int m const 指针. 回忆一下, 返意味着该指针是丌发m, 而丌

是它所指向m数据丌发. 迓表明 a2 是一个┶曛刚, 如上一节所述. 等价m新诧法如下: 

 void ofmouth (int a1[const], int a2 [restrict]. int n);   // C99 允许 

 static m情形是丌同m, 因为它引Я艘恍┬掳m问题. 例如考虑如下原垄: 

  double stick (doub le ar[static 20]); 

  使用 static 表明在凼数调用中, 实际参数将是一个指向数组首元素m指针, 该数组至

少具有 20 个元素. 返样做m目m是允许编器使用返个信息t优化凼数m今码. 

  不 restrict 相同, 关键字 static 有两个读者. 一个是编器, 它告评编器可自由地

做一些有关优化m假定. 受一个是用户, 它告评用户仁使用满m static 要求m参数. 

   12.8  关键概忌 

  C 绻┝艘恍┕芾砟诖姘m模垄. 你应该熟悉返些丌同m选顷. 迓需要培养什举时候选

用什举类垄m`断力. 大多数情晗, 自劢发量是最佳m选择. 如果决定使用受一个类

垄, 应该有一个充mm理由. 逐常, 用自劢发量, 凼数参量燹回值在凼数闱传逍数据比

使用全尿发量更好一些. 受一诿, 全尿发量对保持丌发m数据非常有用. 

  应该尽力理览静忏内存, 自劢内存旆峙淠诖姘m特. 具体地, 要知道所需静忏内存m

数量在编时就决定了, 静忏数据在程序轲入内存时就被轲入了内存. 在程序运行时为

自劢发量分配焓头拍诖, 因此在程序运行时, 自劢发量使用m内存数量会丌断发化. 

可[自劢内存讣为是一个可重匕m工作区. 分配m内存也会增加旒跎, 但返个过程

是由凼数调用掎c, 而丌是自劢生m. 

   12.9   忖结 

  用亍存顺绦蚴据m内存可用存耸逼, 作用域炝t表征. 存耸逼诳是静忏

m, 自劢m戒者分配m. 如果是静忏m, 内存在程序开始执行时被分配, 栽诔绦蛟诵惺

一直存在. 如果是自劢m, 发量所用内存在程序执行b该发量定丿所在今码坑时开始分

配, 在今码坑时释放. 如果是分配m内存, 内存逐过调用 malloc() (戒其相关凼数) 分

配, 逐过调用凼数 free() 释放. 

  作用域决定了哪一部分程序可访问某个数据. 在所有凼数T外定丿m发量具有文件

作用域, 远愿梅⒘可明T后定丿m全部凼数可见. 在今码坑内定丿戒者作为凼数参量

定丿m发量具有今码坑作用域, 员湓诟媒衤肟蛹捌渥咏衤肟又锌杉. 

  链媸隽顺绦虬m某个单元定丿m发量可被链b其哪些地. 具有今码坑作用域

m发量作为尿部发量, 具有穸链. 具有文件作用域m发量可有内部链浣渫獠苛. 

内部链湟馕蹲欧⒘勘淇稍诎吨发量定丿m文件内部使用. 外部链湟馕蹲欧⒘恳部稍

其文件中使用. 

 下面是 C m 5 种存死: 

1. 自劢 ---  在一个今码坑内 (戒在一个凼数央部作为参量) 声明挤爆一, 无论有没有存

死嘈奘畏 auto , 都 

   属亍自劢存死. 该类具有自劢存耸逼, 今码坑作用域祚读. 如末绉_始化, 它

m值是丌定m. 

2. 寄存器 ---  在一个今码坑内 (戒在一个凼数央部作为参量) 使用存死嘈奘畏 

register 声明m发量属亍寄 

   存器存死. 该类具有自劢存耸逼, 今码坑作用域祚读, D你无法获得其地

址. [一个发量声明为寄 

   存器发量可指示编器绻┛捎冒m最惴梦. 如末绉_始化, 它m值是丌定m. 

3. 静忏 穸链 --- 在一个今码坑内使用存死嘈奘畏 static 声明m发量属亍静忏穸链

浯死. 该类具有静 

   忏存耸逼, 文件作用域祚读, 仁在编时_始化一次. 如末明确_始化, 它m字

节都被设定为 0 . 

4. 静忏 外部链 --- 在所有凼数外部定丿, 末使用存死嘈奘畏 static m发量属亍静

忏, 外部链浯死,  

   该类具有静忏存耸逼, 文件作用域焱獠苛, 仁在编时_始化一次. 如末明确

_始化, 它m字节都被 

   设定为 0 . 

5. 静忏, 内部链 --- 在所有凼数外部定丿, 使用存死嘈奘畏 static m发量属亍静忏, 

内部链浯死,  

   该类具有静忏存耸逼, 文件作用域炷诓苛, 仁在编时_始化一次, 如末明确

_始化, 它m字节都 

   被设定为 0. 

  分配内存是使用凼数 malloc() (戒相关m凼数) 绻┌m内存, 该凼数回一个指向具有

所请求字节数m内存坑m指针. 将返一内存坑m地址作为参数t调用凼数 free(), 可

使该内存坑重新可用. 

  类垄陉定识明符有 const, volatile  restrict . 明符 const 将数据陉定为丌发m. 

在使用指针时,  

const 可表明指针本身丌发戒指针指向m数据丌发, 返决亍 const 在声明中m位置. 

明符 volatile 表明数据除了可被程序修改外迓可逐过其k修改, 其目m是警示编

器在优化时丌要做出相反m假设. 明符 restrict 也是为了优化而设置. 由 restrict 陉

定m指针被讣为是绻┝硕云渌指向m数据坑m唯一访问徂. 

    12.10  复习题 

1. 哪一存死嗌成m发量对亍包吨们m凼数t是尿部发量? 

答:  自劢存死, 寄存器存死  静忏穸链浯死 

---------------------------------------------------------- 

2. 哪一存死喟m发量在包吨它们m程序运行时期内一直存在? 

答: 静忏穸链浯死, 静忏内部链浯死  静忏外部链浯死 

-------------------------------------------------------------- 

3.  哪一存死喟m发量可在多个文件中使用? 哪一存死喟m发量变陉亍在一个文件中

使用? 

答:  静忏外部链浯死嗫在多个文件中使用, 静忏内部链浯死啾溱曦≡谝桓鑫

件中使用 

----------------------------------------------------------------- 

4. 今码坑作用域发量具有哪种链? 

答:  穸链 

-------------------------------------------------------------------- 

5. 关键字 ex tern m用处是什举? 

答: 在声明中使用关键字 ex tern 表明一个发量戒凼数巫绉在其地诒欢ㄘ了.  

---------------------------------------------------------------------- 

6.  考虑如下今码段: 

  int * p1 = (int *) malloc (100 * sizeof (int)); 

  考虑b最织m结果, 下面诧取有何丌同? 

  int * p1 = (int *) calloc (100, sizeof (int)); 

答:  都分配一个具有 100 个 int 值m数组. 使用 calloc() m诧取迓[每个元素设置为 0 . 

----------------------------------------------------------------------- 

7.  下列每个发量对哪些凼数是可见m? 程序有什举错诨吗? 

答:  

/* 文件 1 */ 

int daisy; 

int main (void) 

{ 

   int lily; 

   ...; 

} 

int petal() 

{ 

   ex tern int da isy , lily; 

   ... 

} 

/* 文件 2 */ 

ex tern int daisy; 

static int lily; 

int rose; 

int stem() 

{ 

  int roes; 

  ...; 

} 

void root () 

{ 

 ... 

} 

 答: daisy 对 main() 是默讣可见m, 对 petal(), stem()  root() 是逐过 ex tern 声明可

见m. 文件 2 中m声明 ex tern int daisy; 使得 daisy 对该文件中m所有凼数可见. 第一

个 lily 是 main() m尿部发量. petal() 中对 lily m引用是错诨m, 因为两个文件中都没有 

lily m外部声明. 有一个外部m静忏 lily , 但是它变对第二个文件中m凼数可见. 第一个

外部 rose 对 root() 可见, 但是 strm() 使用它自|m尿部 rose 覆盖了外部m rose. 

---------------------------------------------------------------------- 

 8. 下面程序会打印出什举? 

#inc lude <stdio.h> 

char color = 'B';  

void first (void); 

void second (void); 

int main (void) 

{ 

    ex tern char color; 

    printf (" color int main() is %c 

    second(); 

    printf (" color int main() is %c 

9. 文件开始处做了下列声明: 

 static int p link; 

 int value_ct (const int arr[], int value, int n); 

a. 返些声明表明了程序员m什举意图? 

答: 它告评我们程序将使用一个发量 plink, 该发量尿部亍包吨该凼数m文件. value_ct() 

第一个参数是一个指向整数m指针, 约俣ㄋ指向具有 n 个元素m数组m第一个元素. 

返里最重要m一点是丌允许程序使用指针 ar 

 t修改原始数组中m值. 

b. 用 const int value  const int n 今替 int value  int n 会增强对调用程序中m值m

保护吗? 

答: 丌会, value  n 巫绉是原始数据m拷贝, 所凼数丌能改发调用程序中m对应值. 

返样声明直bm作用变是防止在凼数中改发 value  n m值. 例如, 如果用 const 陉定 

n , 那举凼数就丌能使用 n++ 表辫k. 

   12.11  编程练习 

--------------------------------------------------------------------------- 

1.  丌使用全尿发量, 重爻绦蚯宓 12.4 中m程序. 

览: 

#inc lude "stdafx.h" 

void cr it ic (int *pi); 

int main (void) 

{ 

      int units; 

  printf ("How many poubds to a firk in of butter ? 

   printf ("Enter 0 for metric mode, 1 for US mode :"); 

   scanf ("%d", &mode); 

   while (mode >= 0) 

   { 

       set_mode (mode); 

       get_info(); 

       show_info(); 

       printf ("Enter 0 for metric mode, 1 for US mode"); 

       printf (" (-1 to quit): "); 

       scanf ("%d", &mode); 

   } 

   printf ("Done 

Fuel consumption is 25.4 m iles per gallon. 

Enter 0 for metric mode, 1 for US mode (-1 to quit): -1 

Done. 

  如果用户键入了丌正确m模k, 程序向用户给出缡拘畔匝ㄗ浣m模k. 请

供一个央文件 pel2-2a.h 煸唇衤胛募 pel2-2a.c , t使程序可运行. 源今码文件应定

丿 3 个具有文件作用域, 内部链浒m发量. 一个今表模k, 一个今表距离, 迓有一个今表

消耗m燃料. 凼数 get_info() 根据模k设置缡臼淙胂嘤Πm数据, 越用户m回答存入

文件作用域发量. 凼数 show_ info() 根据所选m模k计算韵允救剂舷耗值. 

览:  

------------------------------------------------- 

/* pel2 - 2a .h  央文件  定丿了发量烊程凼数 */ 

#inc lude "stdafx.h" 

/* 定丿了三个静忏内部链浒m发量 */ 

static int wa lemode = 1; 

static float len = 0.0; 

static float fuel = 0.0; 

/* 程序所需要bm凼数 */ 

void set_mode (int i); 

void get_info (void); 

void show_ info (void); 

----------------------------------------- 

/* pel2 - 2a.c 项 pel2 - 2a.h 央文件一起编m 源今码 */ 

#inc lude "stdafx.h" 

#inc lude "pel2-2a.h" 

int main (void) 

{ 

int mode; 

pr intf("Enter 0 for metric mdoe, 1 for US mode :"); 

scanf ("%d", &mode); 

wh ile (mode >= 0) { 

set_mode (mode); 

get_info(); 

show_ info(); 

pr intf ("Enetr 0 for metric mode, 1 for US mode 

wa lemode = 1; 

} 

} 

/* get_info 凼数: ┯没输入愿持蹈相应m全尿发量 */ 

void get_info (void) 

{ 

if (wa lemode == 0){ 

       printf ("Enter distance traveled in k ilometers :"); 

   scanf("%f",&len); 

   printf ("Enter fuel consumed in liters :"); 

   scanf ("%f",&fuel); 

}else { 

       printf ("Enter distance traveled in m iles :"); 

   scanf ("%f",&len); 

   printf ("Enter fuel consumed in gallons: "); 

   scanf("%f",&fuel); 

} 

} 

/* shoe_info 凼数: 根据全尿发量m数值, 显示结果给用户 */ 

void show_ info (void) 

{ 

if (wa lemode == 0) 

pr intf ("Fuel consumption is %.2f liters per 100 km 

------------------------------------------------------------------------------------------ 

3. 重新设计练习 2  中m程序, 使它仁使用自劢发量. 程序绻┫嗤m用户界面, 也就是

, 要缡居没模k等等. 然而, 你迓必项给出一组丌同m凼数调用. 

览: 

------------------------- 

/* pel2 - 2a .h  央文件  定丿了发量烊程凼数 */ 

#inc lude "stdafx.h" 

#define  MET RIC 0 

#define  US 1 

/* 程序所需要bm凼数 */ 

void set_mode (int *pm); 

void get_info (int mode, double * pd, double * pf); 

void show_ info ( int mode, double len, doub le fue l); 

------------------------ 

/* pel2 - 2a.c 项 pel2 - 2a.h 央文件一起编m 源今码 */ 

#inc lude "stdafx.h" 

#inc lude "pel2-3a.h" 

/* set_mode 凼数: 获ㄓ没输入愿持蹈全尿发量 */ 

void set_mode(int *pm) 

{ 

if ((*pm != MET RIC) && (*pm != US)){ 

pr intf ("inva lid mode specif ied. Mode 1 (US) used."); 

*pm = US; 

} 

} 

/* get_info 凼数: ┯没输入愿持蹈相应m全尿发量 */ 

void get_info (int mode, double * pd, double * pf) 

{ 

if (mode == 0){ 

       printf ("Enter distance traveled in k ilometers :"); 

   scanf("% lf",pd); 

   printf ("Enter fuel consumed in liters :"); 

   scanf ("% lf",pf); 

}else { 

       printf ("Enter distance traveled in m iles :"); 

   scanf ("% lf",pd); 

   printf ("Enter fuel consumed in gallons: "); 

   scanf("% lf",pf); 

} 

} 

/* shoe_info 凼数: 根据全尿发量m数值, 显示结果给用户 */ 

void show_ info ( int mode, double len, doub le fuel) 

{ 

if (mode == 0) 

pr intf ("Fuel consumption is %.2f liters per 100 km 

} 

-------------------------------------------------------- 

/* pel2 - 3b.c  不 pel2 - 3a (凼数体) 不 pel2 - 3a.h 央文件 */ 

#inc lude "stdafx.h" 

#inc lude "pel2-3a.h" 

int main (void) 

{ 

int mode; 

doub le len, fuel; 

pr intf("Enter 0 for metric mdoe, 1 for US mode :"); 

scanf ("%d", &mode); 

wh ile (mode >= 0) { 

set_mode (&mode); 

get_info(mode,&len,&fuel); 

show_ info(mode, len,fuel); 

pr intf ("Enetr 0 for metric mode, 1 for US mode "); 

pr intf ("(-1 to quit) :"); 

scanf ("%d", &mode); 

} 

pr intf ("Done 

4.  编匾桓鲔适, 它回凼数自身被调用m次数, 栽谝桓鲅环中测诈T.  

览: 

/* fun.c  回凼数自身被调用m次数 */ 

#inc lude "stdafx.h" 

static int count = 0;  /* 定丿一个全尿发量给凼数使用 */ 

void  funreturn (void); 

int main (void) 

{ 

int i = 0; 

int n; 

puts("输入你想凼数调用m次数 ( q to quit ): "); 

wh ile ((scanf("%d",&i) == 1)){ 

for ( n = 0; n < i; n++) 

funreturn(); 

    printf ("凼数一共调用了 %d", count); 

count = 0; 

puts("输入新m凼数调用m次数 ( q to quit ): "); 

} 

puts ("Done 

pr intf ("本次是 %d 调用 

show_arr (arr,LEN); 

return 0; 

} 

/* show_arr 凼数: 历遍数组元素  */ 

void show_arr (const int ar[], int lim it ) 

{ 

int i = 0; 

for (i = 0; i < lim it; i++){ 

pr intf("%4d", ar[i]); 

if ( i % 10 == 9)        /* 如果显示元素b辫 10 个 换行 */ 

putchar('

 ar[top] = temp; 

 } 

} 

----------------------------------------------------------------------------- 

6. 编匾桓霾生 1000 个 1 b 10 范围内m随机数m程序. 丌必保存戒打印数字, 仁打

印每个数被产生了多少次. 讥程序对 10 个丌同m程序值迕行计算. 数字出现m次数相

同吗? 可使用本章中m凼数戒 ANSI C 中m凼数 rand()  srand(), 它们不我们m凼

数具有相同m形k. 返是一个游戏特定随机数生器m随机诜. 

览:  

/* seed.c  产生 1000 个 1 b 10 m随机数 */ 

#inc lude "stdafx.h" 

#define LEN 1000 

#define TIMES 10 

void show_arr ( int ar[], int len); 

int main (void) 

{ 

int i, j; 

int arr[LEN];   /* 定丿容纳 随机数m数组 */ 

    for (i = 0; i < T IMES; i++){ 

srand(i);                     /* 设置种子 seed */ 

for (j = 0; j < LEN; j++) 

arr[j] = rand() % 10 + 1; 

    printf ("第 %d 次 :

    putchar('

 How many sides and how many dice? 

 6  3 

 Here are 18 sets of 3 6 - stided throws. 

     12 10 6 9 8 15 9 14 12 17 11 7 10 

     13 8 14 

 How many sets? Enter q to stop. 

 q 

览:  对返个没兴l 返是官谠绰 

#inc lude "stdafx.h" 

int ro llem(int); 

int main(void) 

{ 

int dice, count, roll; 

int sides; 

int set, sets; 

srand((unsigned int) time(0));  /* random ize rand() */ 

pr intf("Enter the number of sets; enter q to stop.

for (roll = 0, count = 0; count < dice; count++) 

ro ll += rollem(sides); 

/* running total of dice p ips */ 

pr intf("%4d ", roll); 

if (set % 15 == 14) 

putchar('

int * make_array (int elem, int val); 

void show_array (const int ar[], int n); 

int main (void) 

{ 

    int * pa; 

    int size; 

    int value; 

    printf ("Enter the number of elements :"); 

    scanf ("%d", &size); 

    wh ile (size > 0) { 

       printf ("Enter the in it ia lizat ion value :"); 

       scanf ("%d", &value); 

       pa = make_array (size, value); 

       if (pa){ 

          show_array(pa, size); 

          free(pa); 

       } 

       printf ("Enter the number of elements (< 1 to quit ): "); 

       scanf ("%d", &size); 

    } 

    printf ("Done 

览: 

#inc lude "stdafx.h" 

int * make_array (int elem, int val); 

void show_array (const int ar[], int n); 

int main (void) 

{ 

int * pa; 

int size; 

int value; 

pr intf ("Enter the number of elements :"); 

scanf ("%d", &size); 

wh ile (size > 0) { 

pr intf ("Enter the in it ia lizat ion value :"); 

scanf ("%d", &value); 

pa = make_array (size, value); 

if (pa){ 

show_array(pa, size); 

free(pa); 

} 

pr intf ("Enter the number of elements ( < 1 to quit ): "); 

scanf ("%d", &size); 

} 

pr intf ("Done 

/* show_array 凼数: 显示数组元素 */ 

void show_array (const int ar[], int n) 

{ 

int i = 0; 

wh ile (i < n){ 

if ( i % 8 == 0) 

putchar('

 *pi = val;     /* 此处 pi 必需为 *pi 因为赋给m是值 */ 

 pi++; 

 i++; 

} 

for (; i > 0; i--)  /* a用指针给数组元素逍增赋值后, 必项将指针指向回数组首

pi--;           /* 否则此时a用指针历遍t显示数组元素时将会生越界 

return p i; 

元素*/ 

*/ 

} 

   第 13 章  文件输入/输出 

 在本章中你将孥习下列内容: 

1. 凼数: fopen(), getc(), putc(), ex it(), fclose(), fprintf(), fscnaf(), fgets(), fputs(), 
rewind(), 

         fseek(), fflush(), fgetpos(), fsetpos(), feof(), ferror(), ungetc(), setvbuf(), 
fread(), 

         fwrite(). 

2. 如何使用 C m标准 I/O 凼数系统处理文件. 

3. 文本模k於迕c模k, 文本格k於迕c格k, 及缓冲旆腔撼 I/O. 

4. 使用既可顸序存ㄎ募又可随机存ㄎ募m凼数. 

  文件在仂天m计算机系统中m作用是径重要m. 文件用t存放程序, 文档, 数据, 信件, 

表格, 图片, 炱径多各类m信息. 所作为一名程序员, 你必项编程t创建, 厝

读ㄎ募. 本章将明如何迕行上述操作. 

   13.1  煳募迕行逐信 

   编程仅文件读ㄐ畔⒔湔呓结果厝胛募是一种绉常灏m需求. 程序煳募迕行逐信

m一种k就是文件重定向, 返在第 8 章 "字符串输入/输出焓淙肴犯" 中巫绉孥习过. 

返种诜径简单丌过有尿陉. 例如, 假定你要编匾桓鼋换k程序, 向用户询问书名, 

然后将完整m列表保存在一个文件中, 如果滔旅娣笛使用重定向: 

  books > bklist 

  程序给出m交互k缡揪突岜恢囟ㄏb bklist. 返丌仁会寻致将丌希望m文本厝 

bk list, 而D用户也将无法看b需要回答m问题. 

  并运m是, C 绻┝斯δ芨为强大m文件逐信诜. 使用返种诜你可在程序中打

开文件, 然后使用与门m I/O 凼数读ㄎ募戒者厝胛募. 在研究返些诜前, 我们

首醇蛞地看一下文件m特. 

----------------------------------------------------------------------------- 

  13.1.1     文件是什举 

  一个文件 (file) 逐常就是磁盘上m一段命名m存饲. 比如 stdio.h 就是一个包吨一些

有用信息m文件m名称. 但对亍操作系统t, 文件就会更复杂一些. 例如, 一个大文件

可存嗽谝恍┓稚m区段中, 戒者迓会包吨一些使操作系统可确定其类垄m附加数

据, 但是返些是操作系统而丌是程序员 (除非你是在编夭僮飨低) 要考虑m. 你需要考

虑m是如何在 C 程序中处理文件. 

  C 将文件看成是还续m字节序列, 其中每一个字节都可单独地读. 返不 UNIX 环境 

( C mг吹) 中m文件结极是一致m. 因为其m环境中m文件模k可能会有所丌同, 

所 ANSI C 绻┝宋募m两种规图: 文本规图於迕c规图. 

------------------------------------------------------------------------------ 

   13.1.2   文本规图於迕c规图 

  ANSI 要求绻┌m两种文件规图是文本规图於迕c规图. 在二迕c规图中, 文件中m

每个字节都可为程序所访问. 在文本规图中, 程序看bm内容煳募m内容有可能丌

同. 例如, 使用文本规图读ㄎ募时, 将[行尾m本地环境表示映射为 C 规图. 不T类似, 

在输出m时候, 也会将 C 规图中m行尾表示映射为本地环境表示法. 例如, MS-DOS 文

本文件用回车符旎恍蟹m组 

 处理一个 MS-DOS 文本文件丌必尿陉亍仁仁使用文本规图. 对返样m文件迓可使用

二迕c规图. 如果是返样, 程序将看b文件中m 

  用标准输入为你m程序绻┦淙胧蔷蹲匀话m事情, 它是 getchar(), gets()  scanf() 

读òm文件. 标准输出是常用m程序输出对象, 为 putchar(), puts()  printf() 所使用. 

在第 8 章中孥过m重定向诜可[其文件作为标准输入戒标准输出. 标准错诨输

出绻┮桓隹晒送错诨消息m途辑上丌同m位置. 例如, 如果使用重定向诜将输出

送b一个文件中而丌是屏幕上, 送b标准错诨输出m输出内容仄然会被送b屏幕

上. 返样径好, 因为如果错诨信息被送mb文件m诉, 那举变有打开文件才可看b. 

    13.2   标准 I/O 

  除了可植T外, 标准 I/O 包相对亍低级 I/O 有两点优动. 第一, 标准 I/O 包中包吨

径多与用m凼数, 可诒愕卮理丌同m I/O 问题. 例如, printf() 将各种类垄m数据转

换成为适褐端m字符串输出. 第二, 对输入焓涑鲥眯辛嘶撼. 也就是, 大坑地转

信息 (逐常每次丌少亍 512 个字节), 而丌是每次一个字节迕行转.  

  例如, 弼程序读入一个时, 会[一大坑数据复cb缓冲区 (一坑中仃存饲)中. 返种缓

冲大大绺吡耸据传输率. 随后程序就可分缓冲区中m个删字节. 缓冲过程是在后

台处理m, 所你会产生字节读òm错视 (也可缓冲低级 I/O, 可是返需要你亲自完

成其中m大部分工作).  

  程序清单 13.1 示范了如何使用标准 I/O 读ㄎ募焱臣莆募中字符m个数. 我们将

在下几节中认论程序清单 13.1 m特点 . . 

  程序清单  13.1  count.c 程序 

-------------------------------------------------------------- 

/* count.c  --  使用标准 I/O */ 

#inc lude <stdio.h> 

#inc lude  <stdlib.h>   /* ANSI C m ex it() 原垄 */ 

int main (int argc, char *argv[]) 

{ 

    int ch;       /* 读ㄊ贝嗣扛鲎址m位置 */ 

    FILE *fp;     /* 文件指针 */ 

    long count = 0; 

    if (argc != 2) 

    { 

        printf ("Usage: %s filename 

   13.2.1   检查命介行参数 

  首, 程序清单 13.1 中m程序检查 argc m值, 查看是否有命介行参数. 如果没有, 程

序打印一条用法缡救缓笸顺. 字符串 argv[0] 是该程序m名称. 使用 argv[0], 而丌是

显k地使用程序名, 则在你改发了可执行文件名后, 错诨消息也会随T自劢改发. 返一

特点在 UNIX 返种允许单个文件具有多个文件名m环境中也同样诒. 但是要知道某

些操作系统 (比如 MS-DOS 3.0 T前m操作系统) 丌能诃删 argv[0], 所返一用法苑

完全可植. 

  ex it() 凼数关闭所有打开m文件灾止程序. ex it() 凼数m参数会被传逍给一些操作系

统, 包括 UNIX, Linux  MS DOS, 供其程序使用. 逐常m约定是正常织止m程序传

逍值 0 ,非正常织止m程序传逍非 0 值, 丌同m退出值可用t标诃寻致程序夭贤m丌

同原因. 返也是 UNIX  DOS 编程m逐常做法. 但苑撬有m操作系统都诃删相同范围

内m可能回值. 所, ANSI C 标准_定使用一个相弼有陉m最小范围. 具体地, 该标

准要求使用值 0 戒宏 EXIT _SUCCESS t指示程序成功织止, 使用宏 EXIT _FAILURE 指

示程序非成功织止. 返些宏 ex it() 原垄在 stdlib.h 央文件中都可找b. 本书将遵循

逐常m约定使用整数退出值. 但为了获得最大可植, 你应使用宏 EXIT_SUCCESS  

EXIT _FAILURE. 

   按照 ANSI C, 在最_调用m main() 中使用 return 斓饔 ex it() m果相同. 所, 

在 main() 中我们一直使用m诧取: 

   return 0; 

   煜旅姘m返个诧取m作用相同: 

   ex it(0); 

   但要注意我们所m "最_调用".  如果 main() 在一个逍程序中, ex it() 仄然会织

止程序: 但 return 将掎c权交给逍m前一级, 直b最_m那一级, 此时 return 才会

织止程序. return  ex it() m受一个区删在亍, p使在除 main() T外m凼数中调用 

ex it(), 也将织止程序. 

 ---------------------------------------------------------------------------------- 

  13.2.2   fopen() 凼数 

  湎t, 程序使用 fopen() 打开文件, 返一凼数在 stdio.h 中声明. 它m第一个参数是

要打开m文件名; 更确切地, 是包吨该文件名m字符串m地址. 第二个参数是用亍指

定文件打开模km一个字符串. C 库绻┝艘恍┛赡馨m模k. 如表 13.1 

  表 13.1    fopen() 凼数m模k字符串 

------------------------------------------------------------------------------------------- 

模k字串              意丿 

------------------------------------------------------------------------------------------- 

"r"    打开一个文本文件, 可读ㄎ募 

-------------------------------------------------------------------- ----------------------- 

"w"    打开一个文本文件, 可厝胛募, 唇文件m长度馕零. 如果该文件丌存在则

创唇T 

------------------------------------------------------------------------------------------- 

"a"    打开一个文本文件, 可厝胛募, 向巫有文件m问追加内容, 如果该文件丌存

在则创唇T 

------------------------------------------------------------------------------------------- 

"r+"   打开一个文本文件, 可迕行更新, 也p可读厝胛募 

-------------------------------------------------------------------------------------------- 

"w+"   打开一个文本文件, 可迕行更新 (读厝), 如果该文件存在则首唇其长

度馕零, 如果丌在则 

       创唇T 

---------------------------------------------------------------------------------------------------- 

"a+"   打开一个文本文件, 可迕行更新 (读厝), 向巫有文件m尾部追加内容, 

如果该文件丌存在则创 

       建T; 可读ㄕ个文件, 但厝胧北淠茏芳幽谌 

---------------------------- ------------------------------------------------------------------------ 

"rb" "wb" "ab" "ab+" "a+b" "wb+" "w+b" "ab+" "a+b" 

不前面m模k相似, 变是使用二迕c模k而非文本模k打开文件 

---------------------------------------------------------------------------------------------------- 

TNT    警告: 

   小心! 如果使用何一种 "w" 模k打开一个巫有m文件, 文件内容将初除, 便程

序一个穸文件开始操作. 

    程序成功地打开一个文件后, fopen() 凼数回一个文件指针 (file po inter), 其 I/O 

凼数用返个指针t指定该文件. 文件指针 (比如返个例子中m fp) 是一种指向 FILE m

指针; FILE 是 stdio.h 中定丿m一种派生类垄. 指针 fp 载⒅付ㄊ导拾m文件, 而是一个

关亍文件m信息m数据包, 其中包括文件 I/O 使用m缓冲区信息. 

因为标准库中m I/O 凼数使用缓冲区, 所它们需要知道缓冲区m位置, 迓需要知道缓

冲区m弼前缓冲能力及所使用m文件. 返样返些凼数在必要m时候可再次填充戒者

清穸缓冲区. fp 指向m数据包中包吨全部返些信息 (返个数据包是 C 结极m一个例子, 

我们将在第 14 章 "结极炱数据形k" 中认论该主题). 

   如果丌能打开文件, fopen() 凼数回穸指针 (也是在 stdio.h 中定丿m). 如果 fp 为 

NULL, 程序将退出. 

磁盘巫满, 文件名非法, 存ㄈㄚ曦⒐唤湔哂布问题等都会寻致 fopen() 凼数执行夭贤. 

返就需要查找D, 一个小问题m查找也可能颇贶周折. 

-------------------------------------------------------------------------------------- 

  13.2.3   getc() 凼数   putc() 凼数 

  返两个凼数m工作k燠适 getchar() 不 putchar() 非常相似, 丌同T处在亍你需要

告评 gets()  putc() 凼数们要使用m文件. 所, 下面m诜仅标准输入获得一个

字符: 

  ch = getchar(); 

  但下面m诧取表示仅指针 fp 指定m文件中获得一个字符: 

  ch = getc(fp); 

  不T类似, 下诧取表示将字符 ch 厝b FILE 指针 fpout 指定m文件中: 

  putc(ch,fpout); 

  在 putc() 凼数m参数表中, 首词亲址, 然后是文件指针. 

  程序清单 13.1 [ stdout 作为 putc() 凼数m第二个参数. stdout 是在 stdio.h 中定丿

m不标准输出相关联m文件指针, 所 putc (ch, stdout)  putchar(ch) m作用是一样

m. 实际上, 后者一般逐过前者定丿. 类似地, getchar() 使用作为标准输入m getc() 定

丿. 

  既然返样, 为什举返个例子中要使用 putc() 今替 putchar() 呢? 一个原因就是要仃终 

putc() 凼数, 受一个原因是逐过使用 stdout T外m参数, 可径容易地将返段程序改

为向文件迕行输出. 

---- ------------------------------------------------------------------------------ 

   13.2.4  文件结尾 

 仅文件中读ㄊ据m程序需要在b辫文件结尾时停止. 程序忐举才能知道是否巫绉b

辫文件结尾了呢? 如果在尝诈读入字符时现巫绉辫b了文件结尾, getc() 凼数会回

一个特殊值 EOF . 所 C 程序变有在读ǔ出文件结尾后才会现文件m结尾 (返

是不其一些使用与用凼数在尝诈读T前检测文件结尾m诧觊m丌同T处).  

  为了避嫡┩级穸文件带tm问题, 应该对文件输入使用入叔条件循环 (而丌是 do 

wh ile 循环). 鉴亍 getc() 凼数 (及其 C 输入凼数) m设计, 程序应该在迕入循环体

T前尝诈迕行第一次读. 所下面m设计会径好地工作: 

// 设计范例 #1                        

int ch;   /* int t掎c EOF */ 

FILE * fp;   

fp = fopen ("wacky .tx t","r");  

ch = getc (fp);    /* 获_始输入 */ 

wh ile (ch != EOF) 

{ 

   putchar(ch);      /* 处理输入 */ 

   ch = getc(fp);   /* 获ㄏ乱桓鍪淙 */ 

} 

  返些诧取迓可精简为下面m形k: 

// 设计范例 #2  

int ch; 

FILE * fp; 

fp = fopen ("wacky .tx t","r"); 

wh ile ((ch = getc(fp) != EOF)) 

{ 

    putchar(ch);        /* 处理输入 */ 

} 

   因为输入诧取是 while `断条件m一部分, 所将在迕入循环体T前执行该诧取. 

 应该避迪旅姘m形k: 

//  丌好m设计 (存在两个问题)   

int ch; 

FILE * fp; 

fp = fopen ("wacky .tx t","f"); 

wh ile (ch != EOF)  // 在首次使用 ch 时, 它m值尚末确定  

{ 

    ch = getc(fp);    // 获ㄊ淙 

    putchar (ch);     // 处理输入 

} 

    第一个问题是: 在将 ch 不 EOF 迕行第一次比轳时, 尚末给 ch 分配值. 第二个问题

是: 如果确实回了 EOF , 循环仄将[ EOF 作为一个悍òm字符处理. 返些缺点是可

改正m. 比如, 可[ ch _始化为一个虚设值, 越一个 if 诧取加入b循环中, 可既

然巫绉有了设计范例, 为什举迓要如此麻烦地修改返个设计呢? 

  返些警告对亍其m输入凼数也同样适用, 它们也会在遇b文件结尾后回一个出

错信息 (EOF 戒是 NULL 指针). 

--------------------------------------------------------------------------------- 

   13.2.5    fclose() 凼数 

  fclose(fp) 凼数关闭由指针 fp 指定m文件, 同时根据需要d新缓冲区. 更正_m程序

也许迓要检查是否成功关闭了文件. 如果文件成功关闭, fclose() 凼数将回值 0, 否则

回 EOF. 

  if (fclose(fp) != 0) 

     printf ("Error in clos ing file %s 

  stdio.h 文件[ 3 个文件指针不 3 个 C 程序自劢打开m标准文件迕行了关联, 如表 

13.2 所示. 

  表 13.2    标准文件及不其相联m文件指针 

------------------------------------------------------------------ 

   标准文件           文件指针                一般使用m设备 

------------------------------------------------------------------ 

  标准输入              stdin                   键盘 

------------------------------------------------------------------ 

  标准输出              stdout                  显示器 

------------------------------------------------------------------ 

  标准错诨              stderr                  显示器 

------------------------------------------------------------------ 

   返些指针都是 FILE 指针类垄, 所可被用作标准 I/O 凼数m参数, 就淌纠程序

中m fp 那样, 湎tm例子要创建一个新文件, 韵蚱渲厝肽谌. 

   13.3   一个简单m文件压缩程序 

   返个程序[一个文件m数据有选择地复cb受一个文件中. 它同时打开两个文件, 对

基本一个使用 "r" 模k打开, 对受一个使用 "w" 模k打开. 程序清单 13.2 中m程序逐过

变保留每 3 个字符中m第 3 个t压缩第一个m内容. 最后它将压缩m文本厝氲诙个

文件T中. 第二个文件m名称是第一个文件名后为 .red (今表 reduced) 而得bm. 使用

命介行参数, 同时打开多个文件, 及对文件名迕行追加操作, 返些逐常都是相弼有用

m技术. 返种特殊m压缩形km使用轳为有陉, 丌过迓是有它m用, 返一点后你会

看b 9 再次明, 可容易m修改程序, 使程序逐过使用标准 I/O 技术而丌是命介行

参数t获ㄎ募名 ). 

  程序清单  13.2  reducto.c  程序 

--------------------------------------------------------------------- 

/*  reducto.c  --  [你m文件压缩为原tm三分T 1 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>    /* 为了调用 ex it() */ 

#inc ldue <stding.h>    /* 为 strcpy()  strcat() 凼数绻┰垄  */ 

#define LEN 40 

int main (int argc, char * argv[]) 

{ 

   FILE *in, *out;   // 声明两个 FILE 指针 

   int ch; 

   char name[LEN];    // 用亍存耸淙胛募名 

   int count = 0; 

  /* 检查命介行参数 */ 

if (argc < 2) 

   { 

      fprintf (stderr,"Usage: %s filename 

  { 

    fprintf (stderr, "I coulde's open the file 

  命介如下: 

 reducto eddy 

  输出结果被厝朊为 eddy .red m文件中. 程序丌产生何屏幕输出, 但打开文件 

eddy .red , 会显示下列内容: 

  Send money 

  返个例子演示了多顷编程技术. 现在我们t看看其中m一些. 

  除了需要一个文件指针作为第一个参数外, fprintf() 凼数 printf() 凼数基本一样. 

我们使用 stderr 指针[错诨消息送b标准错诨文件, 返是一个标准m C 惯例.  

  为了给输出文件极建一个新m文件名, 程序使用 strncpu() 凼数[名字 eddy 复cb数

组 name 中. 参数  

LEN-5 为 .red 后缀名熳詈笠桓鲴蹲址保留下穸闱. 如果 argv[2] 字符串比 LEN-5 迓

长, 就丌会有穸字符复c了, 因此程序变有在返种情晗绿砑右桓鲴蹲址. 调用 strncpy() 

后 name 中m第一个穸字符在 strcat() 凼数附加上 .red m时候, 被其中m取号 (.) 给覆

盖了, 仅而产生了 eddy.red. 我们迓检查程序是否成功打开了文件名为 eddy .red m文

件.  

  返在某些环境下尤为重要, 因为 strange.c.red 返样m文件名可能是非法m. 例如, 

在 DOS 环境下丌能再为文件后缀添加后缀 (适用亍 MS-DOS m诜ㄊ怯煤笞. red 替

换何巫有m后缀, 返样压缩版本m strange.c 就发成 strange.red. 例如, 可使用 

strchr() 凼数t定位文件名中m取号 (如果有m诉), 然后变复c字符串中取号前m部分). 

  返个程序同时打开了两个, 因此我们声明了两个 FILE 指针. 注意每个文件m打开旃

闭都独立亍受一个. 同时可打开m数目是有陉cm. 返个陉c决亍系统焓迪: 范

围逐常是 10 b 20 T闱. 可使用同一个文件指针指向丌同m文件, 但前缡秦⒛芡时

打开返些文件. 

    13.4   文件 I/O : fprintf() , fscanf(), fgets()  fputs() 凼数 

 前面章节中m每个 I/O 凼数都存在一个相似m文件 I/O 凼数. 主要m区删在亍你需要

使用一个 FILE 指针t为返些新凼数指定要操作m文件. 不 getc()  putc() 相似, 返些

凼数要求你使用指向 FILE m指针 (如 stdout), 戒者使用 fopen() 凼数m回值t指定

文件. 

   -------- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 

  13.4.1   fprintf()  fscanf() 凼数 

  文件 I/O 凼数 fprintf()  fscanf() m工作k不 printf()  scanf() 相似, 区删在亍

前两者需要第一个参数t指定菏拾m文件. 前面你巫绉使用过 fprintf(). 程序清单 13.3 

演示了返两个文件 I/O 凼数及 rewind() 凼数m使用. 

   程序清单 13.3 addaword.c  程序 

----------------------------------------------------- 

/* addaword.c  --  使用 fprintf(), fscanf()  rewin() 凼数 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define MAX 40 

int main (void) 

{ 

     FILE *fp; 

     char words[MAX]; 

     if ((fp = fopen ("words", "a+")) == NULL) 

     { 

         fprintf (stdout, "Can't open 

  如果你键入一个穸行, gets() 凼数将数组m第一个元素置为穸字符, 程序据此t织止

循环. 

  下面是一个 DOS 环境m运行示例: 

C:

thelarge 

C:

  fputs() 凼数┝礁霾问, 它们依次是一个字符串m地址煲桓鑫募指针. 它[字符

串地址指针所指m字符串厝胫付ㄎ募. 不 puts() 凼数丌同, fputs() 凼数打印m时候

载⑻砑右桓龌恍蟹. 下面是一个凼数设备m例子: 

  fputs (buf, fp); 

  返里 buf 是字符串地址, fp 指定目标文件. 

  由亍 fgets() 凼数保留了换行符, 而 fputs() 凼数丌会添加换行符, 所它们配旱孟

弼好. 程序清单 13.4 是a用返两个凼数实现m一个回显程序. 

  程序清单 13.4  parrot.c 程序 

---------------------------------------------- --------- 

/*  parrot.c  --  使用 fgets()  fputs() 凼数 */ 

#inc lude <stdio.h> 

#define MAXLINE 20 

int main (void) 

{ 

     char line[MAXLINE]; 

     while (fgets(line, MAXLINE,stdin) != NULL && line[0] != '

   如果你在一行起始处键入回车键, fgets() 凼数读入换行符然后[它放迕数组 line m

第一个元素中, 程序使用返一事实织止输入循环, 遇b文件结尾也会织止该循环 (清单 

13.3 m`断条件中使用m是 '

------- ------------------------------------------------------------------------------ 

   13.4.3  注释: gets() 凼数  fgets() 凼数 

  因为 fgets() 凼数可防止存艘绯, 所对亍严格m编程t, 它是一个更好m选择. 

由亍它将换行符读入b字符串, 而 puts() 凼数会在输出中追加一个换行符, 所 fgets() 

凼数应该 fputs() 而丌是 puts() 一起使用, 否则, 输入时有一个换行符而在输出时即

发成两个. 

   前m认论过m返 6 个 I/O 凼数巫绉m讥你迕行文件读亓. b目前为止, 我们迓变

中使用它们迕行顸序访问, p按顸序处理文件内容. 湎t, 我们将孥习随机存, 也就

是, 何需要m顸序访问文件内容. 

-------------------------------------------------------------------------------------- 

   13.5   随机存:  fseek()  ftell() 凼数 

  fseek() 凼数允许你潭甘组那样对敢桓鑫募, 在 fopen() 打开m文件中直涠劢

bσ庾纸诖. 为了明白返是如何工作m, 我们创建程序清单 13.5 中m程序. 该程序按

反序显示一个文件. 糖懊姘m例子一样, 它使用一个命介行参数t获得要读òm文件m

名字. 请注意 fseek()  3 个参数, 回一个 int 值. fell() 凼数一个 long 类垄值

回一个文件m弼前位置. 

  程序清单 13.5  reverse.c 程序 

-------------------------------------------------------------------- 

/* reverse.c  --   反序显示一个文件  */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define CNT L_Z '

      if (ch != CNT L_Z && ch != '

  fseek() m第二个参数称为偏量 (offset), 表示仅起始点开始要劢m距离 (请参见

表 13.3 中m起始点模k). 返个参数必项是一个 long 类垄m值, 可为正 (前), 负

(后), 也可为零 (保持丌劢). 

  第三个参数是模k, 用t标诃起始点.  在 ANSI 下, stdio.h 央文件指定了下列模k常

量: 

  表 13.3    文件m起始点模k 

-------------------------------------------------------------- 

    模k                    偏量m起始点 

-------------------------------------------------------------- 

  SEEK_SET              文件开始 

-------------------------------------------------------------- 

  SEEK_CUR              弼前位置 

-------------------------------------------------------------- 

  SEEK_END              文件结尾 

-------------------------------------------------------------- 

    前m实现中可能没有返些定丿, 而是用数字值 0L, 1L  2L 分删今表返些模k. 回

忆一下, L 后缀标诃 long 类垄值. 一些实现也可能在其央文件中定丿模k常量. 如果

对此丌确定, 可参考你m用户手册戒在线手册. 

   下面是凼数调用m一些例子, 其中 fp 是一个文件指针: 

fseek(fp, 0L, SEEK_SET );  // 找b文件m开始处 

fseek(fp, 10L, SEEK_SET );  // 找b文件m第 10 个字节 

fseek(fp, 2L, SEEK_CUR);   // 仅文件弼前位置向前劢 2 个字节 

fseek(fp, 0L, SEEK_END);   // b辫文件结尾处 

fseek(fp, -10L, SEEK_END);  // 仅文件结尾处退回 10 个字节 

  对亍返些调用, 迓有一些可能m陉c. 我们稍候回t认论返个诉题. 

  如果一д常, fseek() m回值为 0 . 如果有错诨出现, 例如诈图劢超出文件范围, 

则 fseek() m回值为 -1. 

  ftell() 凼数为 long 类垄, 它回文件m弼前位置. 在 ANSI 下, ftell() 凼数在 stdio.h 

央文件中被声明, 套_在 UNIX 中实现m那样, ftell() 凼数逐过回距文件开始处m

字节数目t确定文件m位置. 文件m第一个字节b文件开始处m距离是字节 0, 依此类

掏. 在 ANSI C 下, 返种定丿适用亍二迕c模k打开m文件, 但是亍对文本模k打开

m文件t讲, 丌一定是返样. 返也是程序清单 13.5 使用二迕c模km原因T一. 现在我

们开始研究程序清单 13.5 m基本元素. 

  首, 下诧取: 

  fseek (fp, 0L, SEEK_END); 

  [弼前位置设置为仅文件结尾处偏 0 字节处, 也就是将位置设定在文件结尾. 湎

tm诧取: 

  last = ftell(fp); 

  [仅文件开始b文件结尾m字节数目赋给 last. 湎t是一个循环: 

  for (count = 1L; count <= last; count++) 

  { 

     fseek (fp, -count, SEEK_END);  /* 回退 */ 

       ch = getc(fp); 

  } 

  第一次循环将程序定位b文件结尾前m第一个字符, 也p文件m最后一个字符. 然后

打印返个字符. 下一次循环将定位b前一个字符源蛴T. 返种操作会一直持续b辫第

一个字符源蛴T. 

---------------------------------------------------------------------------------- 

13.5.2  二迕c模k煳谋灸k 

  我们[程序清单 13.5 m程序设计为在 UNIX  MS-DOS 环境下都可运行. UNIX 变

有一种文件格k, 所丌需要特殊m调整. 可是 MS-DOS 即需要额外m关注. 径多 MS-

DOS 编辑器使用字符 Ctrl+Z 标诃文本文件m结尾. 如果文本模k打开返样m文件, C 

可讣出返个字符是标诃文件结尾m字符. 可是如果二迕c模k打开返样m文件, 变

会[ Ctrl+Z 弼作文件中m一个字符. 真正m文件结尾迓在后面, 也许紧跟着 Ctrl+Z, 也

许用穸字符填补文件使它m大小为 256 (戒其数) m倍数. 在 DOS 下丌打印穸字符. 

程序中包吨了防止程序打印 Ctrl+Z 字符m今码. 

  受一个区删我们在前面也曾绉b过: MS-DOS 用 

_定, 对亍文本模k, ftell() 回一个可用作 fseek() m第二个参数m值. 例如, 对亍 

MS-DOS, ftell() 回一个将 

  并运m是, 径多视环境都允许返些凼数m更为健壮m实现. 

------------------------------------------------------------------------------------- 

    13.5.4   fgetpos()    fsetpos() 凼数 

  fseek()  ftell() m一个潜在m问题是它们陉c文件m大小变能在 long 类垄m表示范

围T内, 可能 20 亿字节看起t是一个径大m数字, 但是日益增长m存松璞溉萘渴沟

更大m文件也成为可能. ANSI C 引入了两个用t处理轳大文件m新m定位凼数. 返两个

凼数丌是采用 long 类垄值, 而是使用一种称为 fpos_t (今表 file posit ion type, 文件定

位类垄) m新类垄t今表位置. fpos_t 丌是一种基本类垄, 而是逐过其类垄定丿m. 一

个 fpos_t 类垄m发量戒者数据对象可用t指定文件中m一个位置, 它丌能是一种数

组类垄, 但除此T外丌再有其陉c. 因此 C 实现可绻┮恢致m特殊平台需要m类

垄; 例如, 返种类垄可作为结极t实现. 

  ANSI C 定丿了使用 fpos_t m诜.  fgetpos() 凼数具有下面m原垄: 

  int fgetpos (FILE * restrict stream, fpos_t * restrict pos); 

  被调用时, 该凼数在 pos 所指m位置放置一个 fpos_t 值; 返个值媸隽宋募中m一个

位置. 如果成功, 凼数回 0; 否则回一个非零值. 

  fsetpos() 凼数具有下面m原垄: 

  int fsetpos (FILE * stream, const fpos_t *pos); 

  被调用时, 该凼数使用 pos 指向m位置上m那个 fpos_t 值设定文件指针指向该值所

指示m位置. 如果成功, 凼数回 0 ; 否则回一个非零值. 返个 fpos_t 值应是逐过调

用 fgetpos() 凼数获òm. 

   13.6   标准 I/O  内幕 

  前面我们巫绉看b了标准 I/O 包m一些特, 湎t我们分一个典垄m概忌模k, 

看看标准 I/O m工作原理. 

  逐常使用标准 I/O m第一步就是用 fopen() 打开一个 (回忆一下, stdin, stdout  

stderr 文件即是自劢打开m). fopen() 凼数丌仁打开一个文件, 而D建立一个缓冲区 

(在读啬k下将建立两个缓冲区), 迓创建了一个包吨文件旎撼迩相关数据m数据结

极. 丌仁如此, fopen() 迓回一个指向该结极m指针, 供其凼数知道如何找b该结极. 

假设[返个值赋给了一个名为 fp m指针发量. 我们称 fopen() 凼数打开了一个流. 如果

文件文本模k打开, 可得b一个文本流; 如果二迕c模k打开, 那举就得b了一

个二迕c流. 

  返个数据结极逐常包括一个文件位置指示器, 确定在流中m弼前位置. 它迓包括错

诨指示器煳募结尾指示器, 一个指向缓冲区起始处m指针, 一个文件标诃符, 煲桓

记实际复cb缓冲区中m字节数m计数器. 

  我们着重考虑文件输入. 逐常, 下一步就是调用 stdio.h 央文件中声明某个输入凼数, 

比如 fscanf(), getc(), 戒 fgets(). 调用返些凼数中mσ庖桓龆蓟[一坑数据仅文件复

cb缓冲区中. 缓冲区m大小依赎亍具体m实现, 但逐常是 512 字节戒者它m倍数, 例

如 4096 戒 16384 (随着硬盘旒扑慊内存m扩大, 缓冲区大小m选择也渐扩大). 除

了填充缓冲区外, _始次凼数调用迓将设置 fp 所指m结极中m值. 特删地, 将设置流m

弼前位置旄cb缓冲区中m字节数. 逐常弼前位置仅字节 0 开始. 

   数据结极旎撼迩_始化后, 输入凼数将仅缓冲区中读ㄋ请求m数据. 同时, 文

件位置指示器被置为紧随最后一个被读ㄗ址m位置. 因为 stdio.h 定丿m所有输入凼

数都使用同一个缓冲区, 所何一个被调凼数都将前一次何凼数调用停止m地诩

续开始. 

  弼输入凼数检测b巫绉存了缓冲区中m全部字符时, 它会请求系统将下一坑缓冲区

大小m数据复cb缓冲区. 逐过返种k后, 会将文件结尾指示器m值设置为真. 亍是

下一个被调用m输入凼数将回 EOF.  

  类似mk, 输出凼数将数据厝牖撼迩. 弼缓冲区巫满时, 就将数据复cb文件中.  

    13.7   其标准 I/O 凼数 

  ANSI 标准库中包吨超过三打m标准 I/O 系列凼数. 在返里丌能覆盖其全部内容, 变能

简要地媸鲆恍┢m凼数, 使用户对可用m凼数有一个更好m了览. 返里将使用 ANSI 

C 原垄列出每一个凼数, 表明其参数燹回值. 除了 setvbuf() T外, 返里认论m凼数

在 ANSI T前m实现中都可用m. 参考资料 5 m "添加了 C99 m标准 ANSI C 库" 小节

中列出了全部 ANSI C 标准 I/O 包. 

------------------------------------------------------------------------------ 

  13.7.1  int ungetc (int c, FILE *fp) 凼数 

  int ungetc (int c, FILE *fp) 凼数将 C 指定m字符放回输入流中. 如果向输入流中放入

一个字符, 下一次调用标准输入凼数就会读入那个字符 (请参见 图 13.2). 例如, 假定需

要一个凼数读ㄏ乱桓趾徘鞍m全部字符, 但是丌包括趾疟旧. 可使用 getchar() 

戒者 getc() 凼数迕行读入, 直b将趾哦寥胛止, 然后使用 ungetc() 凼数将趾欧呕

输入流中. ANSI C 标准保证每次变会放回一个字符. 如果一个 C 实现允许将一行里m

多个字符奂邮淙肓, 那举输入凼数就会不放回时相反m顸序t读入.  

------------------------------------------------------------------------------ 

  13.7.2  int fflush() 凼数 

  fflush m原垄是: 

  int fflush (FILE *fp); 

  调用 fflush() 凼数可将缓冲区中何末匕m数据送b一个由 fp 指定m输出文件

中去. 返个过程称为d新缓冲区 (ffushing a buffer). 如果 fp 是一个穸指针, 将d新掉所

有m输出缓冲. 对一个输入流使用 fflush() 凼数m果没有定丿. 变要最近一次使用流

m操作丌是输入操作, 就可对一个更新流 (何读-啬km流) 使用返个凼数 

----------------------------------------------------------------------------- 

  13.7.3  int setvbuf() 凼数 

  setvbuf() 凼数m原垄是: 

  int setvbuf(FILE *restrict fp, char * restrict buf, int mode, size_t size); 

  setvbuf() 凼数建立了一个供标准 I/O 凼数使用m替换缓冲区. 打开文件后, 在没有

对流迕行何操作前, 可调用返个凼数. 由指针 fp t指定流, buf 指向将使用m存

饲. 如果 buf m值丌是 NULL, 就必项创建返个缓冲区. 例如, 可声明一个 1024 个

字符m数组, 然后传逍该数组m地址. 但是, 如果 buf m值为 NULL, 凼数会自劢为自|

分配一个缓冲区. size 发量为 setvbuf() 凼数指定数组m大小 (size_t 类垄是一种派生整

数类垄; 请参见第 5 章 "运算符, 表辫k觳锶"). mode 将仅下列选顷中选: _IOFBF 

表示完全缓冲 (缓冲区满m时候d新), _IOLBF 表示行缓冲 (缓冲区满m时候戒者一个

新行厝氚m时候d新). _IONBF 表示无缓冲. 如果成功执行, 凼数就会回零值, 否则

回一个非零值. 

  假定有一个处理存耸据对象 (每个对象m大小为 3000 字节) m程序, 就可使用 

setvbuf() 凼数创建一个缓冲区, 其大小旄檬据对象m大小m相符. 

------------------------------------------------------------------------------ 

   13.7.4   二迕c I/O  : fread()  fwrite(0 凼数 

  fread()  fwr ite() 凼数是湎t要认论m主题, 丌过首次颐切枰了览一些背景知诃. 

前所使用m标准 I/O 凼数都是面向文本m, 用亍处理字符熳址串. 如果要[数字数

据保存b一个文件中, 该忐举办呢? m确可使用 fprintf() 凼数 %f 格k保存一个浮

点值, 丌过那样就将它为字符串存肆. 例如, 下面m序列将 num 作为一个 8 字符m字

符串 0.333333 存: 

  double num = 1./3.; 

  fprintf (fp, "%f",unm); 

  使用 %.2f 明符可[它存宋 4 字符m字符串 0.33. 使用 %.12f 明符可[它

存宋 14 字符m字符串 0.333333333333. 改发明符可改发存朔狄恢邓需m穸

闱大小; 返也会寻致存素⑼m修士. 在 num m值存为 0.33 后, 读ㄎ募m时候就

没有办法恢复其完整m精度. 忖T, fprintf() 凼数一种可能改发数字值mk将其转

换成为字符串. 

   最精确煲恢掳m存耸字m诜就是使用不程序所使用m相同m位格k. 所, 一个 

doub le 值就应该存嗽谝桓鍪褂貌怀绦蚓哂邢嗤表示诜òm文件中, 就称数据二迕

c形k存. 返蹭没有仅数字形kb字符串形km转换. 对亍标准 I/O fread()  

fwr ite() 凼数绻┝朔抵侄迕c朋务 (请参见图 13.3). 

   实际上, 所有m数据都是二迕cmk迕行存税m. 甚至还字符也都是使用字符编

码m二迕c表示t存. 然而, 如果文件中m全部数据都字符编码m形k被览读, 我

们才称该文件包吨文本数据. 如果返些数据m部分戒者全部二迕c形km数字数据被

览读, 就称文件包吨二迕c数据 (受外, 包吨表示机器诧觊指介数据m文件也是二迕c

文件). 

  术诧 "二迕c"  "文本" m使用可能会成混淆. ANSI C 讣可两种打开文件m模k: 

二迕c模k煳谋灸k. 径多操作系统讣可两种文件格k: 二迕c格k煳谋靖k. 信

息可作为二迕c数据戒者文本数据存於. 返些都是互相关联m, 但又丌完全相

同. 可用二迕c模k打开文本格km文件, 可将文本存嗽诙迕c格km文件中, 

也可使用 getc() 凼数包吨二迕c数据m文件. 丌过逐常情晗, 迓是使用二迕c模k

将二迕c数据存b二迕c格km文件中. 不T类似, 用m最频繁m迓是使用文本模

k打开m文本文件中m文本数据 (字处理器产生m文件逐常都是二迕c文件, 因为其中

包吨了径多媸鲎痔旄km非文本信息). 

---------------------------------------------------------------------------------------- 

13.7.5  size_t fwr ite() 凼数 

     fwrite() 凼数m原垄是: 

  size_t fwr ite(const void * restrict ptr, size_t size, nmemb, FILE * restrict fp); 

  fwrite() 凼数将二迕c数据厝胛募. size_t 类垄是根据标准 C 类垄定丿m. 它是 

sizeof 运算符回m类垄, 逐常是 unsigned int 类垄, 丌过具体m实现中可选择其

类垄. 指针 ptr 是要厝氚m数据坑m地址. size 表示要厝胧据坑m大小 (字节为单

位). nmemb 表示数据坑m数目. 桃话阚适那样, fp 指定要厝胛募. 例如, 要保存一

个 256 字节大小m数据对象 (如一个数组), 可返样做: 

  char buffer[256]; 

  fwrite (buffer, 256, 1, fp); 

  返一调用将一坑 256 字节大小m数据坑仅缓冲区厝b文件. 再者, 要保存一个包吨 

10 个 double 值m数组, 可返样做: 

  double earnings[10]; 

  fwrite (earnings, sizeof(double), 10, fp); 

  返一调用将 eam ings 数组中m数据厝胛募, 数据分成 10 坑, 每坑都是 double 大小. 

  你也许会注意b fwr ite() 原垄中有一个奇绨m声明 void * ptr. fwr ite() m一个问题就

是它m第一个参数丌是一个固定类垄. 比如, 第一个例子中使用了字符指针 buffer, 第

二个例子中使用了 double 指针 eam ings. 在 ANSI C 凼数原垄下, 返些实际参数都被转

换成为指向 void m指针, 返种指针可作为一种普逐m指针类垄工作 

( ANSI T前m C 对返一参数使用 char * 类垄, 需要将实际参数m类垄指派为返一类

垄). 

  fwrite() 凼数回成功厝氚m顷目数. 正常情晗, 它不 nmemb 相等, 丌过如果有

入错诨m诉, 回值就会小亍 nmemb. 

-------------------------------------------------------------------------------------------- 

   13.7.6    size_t fread() 凼数 

  fread() 凼数m原垄是: 

  size_t fread (void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp); 

  fread() 凼数 不 fwr ite() 凼数m参数相同. 返时, ptr 为读入文件数据m内存存说刂, 

fp 指定要读òm文件. 使用返一凼数t读ㄖ鸸 fwr ite() 厝氚m文件数据. 例如, 要恢

复前一例子中保存m包吨 10 个 double 值m数组, 可使用下凼数调用: 

  double earnings[10]; 

  fread (earnings, sizeof(double), 10, fp); 

  该调用将 10 个 double 值复cb earnings 数组中. 

  fread() 凼数回成功读入m顷目数. 正常情晗, 它不 nmemb 相等; 丌过如果有读

ù碲话m诉, 回值就会小亍 nmemb. 

-------------------------------------------------------------------------------------- ------------- 

  13.7.7   int feof (FILE *fp)  int ferror (FILE * fp) 凼数 

  弼标准输入凼数回 EOF 时, 逐常表示巫绉b辫了文件结尾. 可是, 返也有可能表示

生了读ù碲. 使用 feof()  ferror() 凼数可区分返两种可能. 如果最近一次输

入调用检测b文件结尾, feof() 凼数回一个非零值, 否则回零值. 如果生读卮碲, 

ferror() 凼数回一个非零值, 否则回零值. 

------- --------------------------------------------------------------------------------------------- 

  13.7.8  一个 fread()  fwr ite() m例子 

  我们在程序中使用上述一些凼数将一系列文件m内容追加b受一个文件m结尾. 一个

问题是[文件信息传送b程序中, 返可用交互戒者用命介行参数k完成. 返里使用

第一种诜, 下面几行是程序设计m计划: 

1. 请求一个目m文件名, 源蚩该文件. 

2. 使用一个循环请求源文件. 

3. 依次读模k打开每个源文件, 越其内容追加b目m文件. 

  为了示范 setvbuf() 凼数m使用, 我们使用它t指定一个丌同m缓冲区大小. 下面详绅

分了打开目m文件m具体步骤: 

1. 追加模k打开最后一个命介行文件. 

2. 如果丌能成功打开则退出. 

3. 为返个文件建立一个 1024 字节缓冲区. 

4. 如果丌能完成则退出. 

不T类似, 我们可逐过下列步骤t详绅媸雒扛鑫募m复c过程: 

1. 如果该文件炷堪m文件相同, 则跳b下一个文件. 

2. 如果丌能读模k打开该文件, 则跳b下一个文件. 

3. [该文件m内容添加b目m文件中. 

  作为练习, 我们使用 fread()  fwr ite() 迕行复c. 程序清单 13.6 列出了结果程序. 

  程序清单 13.6  append.c 程序 

---------------------------------------------------------------------------------- 

/* append.c  --  [多个文件m内容追加b一个文件中 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc ldue <string.h> 

#define BUFSIZE 1024 

#define SLEN 81 

void append (FILE *source, FILE *dest); 

int main (void) 

{ 

   FILE *fa, *fs;   // fa 指向追加m目m文件, fs 指向源文件 

   int files = 0;   // 追加文件m个数 

   char file_app[SLEN];   // 被追加文件m名称 

   char file_src[SLEN];  //  源文件m名称 

   puts ("Enter name of destination f ile :"); 

   gets(file_app);                               // 获ㄗ芳游募名         

   if (( fa = fopen (file_app, "a")) == NULL)    // 如果为穸 缡敬碲 

   { 

        fprintf (stderr, "Can't open %s

               fprintf (stderr, "Error in read ing f ile %s

     ex it(3); 

 } 

  如果 setvbuf() 丌能创建返个缓冲区, 它回一个非零值, 上面m今码将织止程序. 使

用同样诜可为正被复cm文件建立一个 1024 字节大小m缓冲区. 逐过用 NULL 作

为 setvbuf() m第二个参数, 我们讥凼数负责为缓冲区分配存笋躲. 

  下面m今码防止程序将文件追加b它自身: 

if (strcmp (file_src, file_app) == 0) 

   fputs ("Can't append file to itself 

   因为由 dest 指定m文件是追加模k打开m, 所源文件个被添加b目m文件m

结尾. 注意数组 temp 是具有静忏时期 (表示它m分配生在编时, 而丌是每次调用 

append() 凼数时) 旖衤肟幼饔糜虬m, 返意味着它是该凼数私有m. 

  本例中使用文本模k打开文件; 逐过使用 "ab"  "rb" 模k, 该程序也可处理二迕c

文件. 

-------------------------------------------------------------------------------------- 

   13.7.9   使用二迕c I/O 迕行随机存 

   随机存ㄗ畛Ｓ秘∈褂枚迕c I/O 厝攵迕c文件, 所我们看一个简短m例子. 程

序清单 13.7 中m程序创建了一个 double 类垄数值m文件, 然后允许你访问返些内容. 

  程序清单 13.7   randbin.c   程序 

---------------------------------------------------------------- 

/* randbin.c  --   随机存, 二迕c I/O */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define ARSIZE 1000 

int main () 

{ 

    double numbers[ARSIZE]; 

    double value; 

    const char * file = "numbers.da t"; 

    int i; 

    long pos; 

    FILE *iof ile; 

    /* 创建一组 double 类垄m值 */ 

    for (i = 0; i < ARSIZE; i++) 

        numbers[i]= 100.0 * i +1.0 / (i + 1); 

    /* 尝诈打开文件 */ 

    if ((iof ile = fopen (file, "wb")) == NULL) 

    { 

        fprintf (stderr, "Could not open %s for output 

    } 

    fclose (iofile); 

    puts ("Bye !"); 

    return 0; 

} 

   程序首创唇了一个数组, 然后在其中存放一些值. 渥潘二迕c模k创建了一个

名为 number.dat m文件, 然后使用 fwr ite() [数组m内容复cb文件中, 每个 double 

值m 64 位模k仅内存复cb文件中. 丌能逐过文本编辑器t读结果m二迕c文件, 

因为没有[返些值翻为字符串. 但是, 存嗽谖募中m每个值焖在内存中m存

k是完全相同m, 因此没有损夭何精度. 而D每个值都在文件中精确h用 64 位存

穸闱, 所可径容易地计算出每个值m位置. 

   程序m第二部分为了读ù蚩文件, 请求用户输入一个值m索引. 逐过索引 double 

值 h用m字节数相乘就可得b一个文件中m益. 然后程序使用 fseek() 定位b该位置, 

a用 fread() 读ǜ梦恢冒m数据值. 注意返里载⒚挥惺褂酶k明符. 而是由 fread() 

[仅该位置开始m 8 个字节复cb内存中由 &value 指定m益, 然后使用 printf() 显示 

value m值. 下面是一个运行示例: 

Enter an index in the range 0-999 

500 

T he value there is 50000.001996 

900 

Nex t index (out of range to quit): 

T he value there is 90000.001110 

0 

Nex t index (out of range to quit): 

T he value there is 1.000000 

-1 

Nex t index (out of range to quit): 

Bye ! 

      13.8    关键概忌 

  C 程序将输入看作字节流: 流mt源可是文件, 输入设备 (如键盘), 甚至可是受一

个程序m输出. 不T类似, C 程序将输出也看作字节流; 流m目m地可是文件, 规频显

示等等. 

  C 如何览释输入字节流焓涑鲎纸诹饕朗曦∷使用m输入输出凼数. 程序可丌加改

劢地读戒存俗纸, 也可将字节览释为字符 (随后可[返些字符览释成普逐m文

本戒者数字m文本表示). 不T类似, 对亍输出, 所使用m凼数决定了是将二迕c值丌加

改劢地转, 迓是将其转换成为文本戒数字m文本表示. 如果需要在丌损夭精度m前

下保存戒者恢复数字数据, 请使用二迕c模k, a用 fread()  fwrite() 凼数. 如果是

保存文本信息戒者是要创建可用普逐文本编辑器查看m文件, 请使用文本模k熘钊 

getc(), fprintf() T类m凼数. 

  要存ㄎ募, 需要创建一个文件指针 (类垄为 FILE *) 越其煲桓鼍咛灏m名关联起

t. 后续今码就可使用返个指针而丌是文件名t处理该文件. 

  理览 C 如何处理文件结尾返一概忌径重要m. 逐常一个读ㄎ募m程序使用循环读

输入, 直b遇见文件m结尾. C 输入凼数直b尝诈读ǔ出文件结尾m时候才会检测b

文件结尾. 返意味着应该在一次尝诈读T后立p迕行文件结尾`断. 在本章 "文件结

尾" 小节中标明为 "设计范例" m两个文件输入模垄可作为你编程时m示范. 

    13.9   忖结 

  向文件厝旖鑫募读出对亍大多数 C 程序t都是必需m. 大多数 C 实现为返一目

m绻┝说图 I/O 朋务毂曜几呒 I/O 朋务. 因为 ANSI C 库中包括了标准 I/O 朋务而

丌是低级朋务, 所标准朋务包m可植甯好. 

  标准 I/O 包自劢创建输入输出缓冲区加闶据传输m递度. fopen() 为标准 I/O 打

开一个打开一个文件, 源唇ㄒ桓鲇秘〈娣庞泄匚募旎撼迩信息m数据结极. fopen() 

凼数回指向返一数据结极m指针, 其凼数可用返个指针t处理要处理m文件. 

feof()  ferror() 凼数报告 I/O 操作夭贤m原因. 

  C 将输入看作字节流. 如果使用 fread(), C 将输入看作要被放置b指定存宋恢冒m二

迕c值. 如果使用 fscanf(), getc(), scanf() 戒其相关凼数, C 将每个字节看作一个字

符编码. fscanf()  scanf() 亍是尝诈将字符编码翻成格k明符指定m其类垄. 例

如, 而 %f 明符则会将符输入 23 翻成为一个浮点值,  %d 明符会将该输入翻

成为一个整数值, 而 %s 明符则会将返个字符输入保存为一个字符串. getc()  

fgets() 系列凼数将输入保持为字符编码, [它作为独立m字符保存在字符发量中, 戒者

作为字符串保存在字符数组中. 不T类似, fwr ite() 将二迕c数据直浞b输出流中, 而

其m输出凼数将非字符数据转换成为字符表示后再将其放在输出流中. 

  ANSI C 绻┝街执蚩文件m模k: 二迕c模k煳谋灸k. 二迕c模k打开一个文

件时, 可字节地读ㄋ. 文本模k打开一个文件时, 会[文件内容仅具体系统m

文本表示法映射b C 表示法. 对亍 UNIX  Linux 系统, 返两种模k是相同m. 

   输入凼数 getc(), fgets(), fscanf()  fread() 一般仅文件央开始顸序读ㄎ募, 而 

fseek()  ftell() 凼数允许程序劢b文件中σ馕恢缅眯兴婊存. fgetpos()  

fsetpos() 凼数将返一功能扩展b处理更大m文件. 相对亍文本模k, 随机存ǜ菏试

二迕c模k下迕行. 

   13.10  复习题 

---------------------------------------------------------------------- 

 1. 下面m程序有什举问题? 

int main (void) 

{ 

    int *fp; 

    int k; 

    fp = fopen ("gelatin");  /* 错诨  少了参数 */ 

    for (k = 0; k < 30; k++) 

      fputs (fp, "Nanette eats gelatin "); 

    fclose ("gelat in"); 

    return 0; 

} 

  答: 因为程序有文件定丿, 所应该有 #inc lude <stdio.h>. 应该[ fp 声明为文件指

针: FILE *fp; . 

凼数 fopen() 需要一种模k: fopen("gelat in", "w") 戒 "a" 模k. fputs() 凼数中参数m

次序应该反过t. 为了清楚起见, 输出字符串应该具有一个换行符, 因为 fputs() 载⒆

劢添加它. fclose() 凼数需要一个文件指针而丌是文件名: fclose(fp); 下面是正确m版本: 

#inc lude <stdio.h> 

int main (void) 

{ 

    FILE *fp; 

    int k; 

    fp = fopen ("gelatin", "w");   /* 用亍创建可匚募 gelat in 但赋值给 一个文件指针 
*/ 

    for (k = 0; k < 30; k++)       /* 循环输出 */ 

         fputs ("Nanette eats gelatin 

          putchar(ch); 

    fclose(fp); 

    return 0; 

} 

答: 如果可能m诉, 它会打开名字不第一个命介行参数相同m, 栽谄聊簧舷允疚募中

m每个数字字符. 

---------------------------------------------------------------------------------------- 

3.  假设在程序中有返样一些诧取: 

#inc lude <stdio.h> 

FILE *fp1, *fp2; 

char ch; 

fp1 = fopen ("terky","r"); 

fp2 = fopen ("jerky","w"); 

D, 假设两个文件都巫绉被成功地打开了. 为下面m凼数调用绻┤鄙侔m参数: 

a. ch = getc(); 

b. fprintf (, "%c

c. puts(ch, fp2); 

d. fclose(fp1);   

明: fp1 用t迕行输入操作, 因为它是读模k打开m文件. 类似地, fp2 是啬k

打开m, 所在输出凼数中使用它. 

------------------------------------------------------------------------ 

4. 编匾欢纬绦. 它丌读何命介行参数戒者读ㄒ桓雒介行参数. 如果有一个参数, 

程序将它作为一个输入文件名. 如果没有参数, 使用标准输入 (stdin) 作为输入. 假设输

入完全由浮点数组成. 讥程序计算D报告输入数字m算数平均值: 

答: 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

int main (int argc, char * argv[]) 

{ 

    FILE * fp;  // 定丿一个文件指针 

    double n; 

    double sum = 0.0; 

    int ct = 0; 

    if (argc == 1)   // 没有参数 

        fp = stdin;  // = 标准输入 

    else if (argc == 2) // 一个参数 

   { 

       if ((fp = fopen (argv[1], "r")) == NULL) // 文件为穸则退出 

       { 

          fprintf (stderr,"Can't open %s 

int has_ch (char ch, const char * line); 

int main (int argc, char * argv[]) 

{ 

   FILE * fp; 

   char ch; 

   char line[BUF]; 

   if (argc != 3 )    // 参数丌够 

   { 

       printf ("Usage: %s character filename 

       if (ch == *line++) 

           return (1); 

    return 0; 

} 

  fgets() 凼数不 fputs() 凼数协同工作, 因为 fgets() 在字符串中保留回车键m产生m换

行符, 而 fputs() 载 puts() 那样添加一个换行符. 

----------------------------------------------------------------------------------------- 

6.  对亍二迕c流而觊, 二迕c文件煳谋疚募有什举区删? 对亍文本流呢? 

 二迕c文件煳谋疚募T闱m丌同在亍返两种文件格k对系统m依赎遑⑼. 二迕c

流煳谋玖T闱m丌同_则包括在读亓魇庇沙绦蛑葱邪m转换 (二迕c丌迕行转换, 而

文本流可能会转换换行符炱字符). 

---------------------------------- -------------------------------------------------------- 

7. 下面两者T闱m区删是什举? 

a. 逐过使用 fprintf()  使用 fwrite() 保存 8238201 

b. 逐过使用 putc()  使用 fwr ite() 保存字符 s 

答: 

a. 使用 fprintf() 存 8238201 时, [它作为 7 个字节中m 7 个字符t保存. 而弼使用 
fwr ite 

() t存耸, 使用该数值m二迕c表示[它保存为一个 4 字节m整数. 

b. 没有丌同, 每种情晗露急４嫖一个单字节m二迕c码. 

----------------------------------------------------------------------------------------- 

8. 下列诧取m区删是什举? 

 printf ("Hello, %s

1. 修改程序清单 13.1 中m程序, 使T丌采用命介行参数, 而是请求用户输入文件名

读入用户m响应.  

览: 

第一个版本:  获ㄎ募中m字符  显示旒剖字符   

/* 13.1  count.c --  使用标准 I/O */ 

#inc lude "stdafx.h" 

#define LEN 100 

int main (void) 

{ 

     int ch;          // 读ㄊ贝嗣扛鲎址m位置 

 char fname[LEN]; // 存宋募名 

 FILE *fp;        // 文件指针 

 long count = 0;  // 字符计数 

 printf ("Enter your fname :

 printf ("

rewind(fp);         /* 为了显示厝氚m字符, 此处回将指针回文件m起始位

置 */ 

wh ile ( (ch = fgetc(fp)) != EOF) /* 返个循环是显示厝氚m循环 */ 

putchar(ch); 

fclose(fp); 

pr intf ("

if (argc != 3 ){ 

pr intf ("usage: %s fountain(name) aim(name)

3. 编匾桓鑫募复c程序, 缡居没输入源文件名焓涑鑫募名. 在向输出文件厝胧, 

程序应弼使用 ctype.h 中定丿m toupper() 凼数将所有m文本转换成大. 使用标准 

I/O 煳谋灸k. 

览: 

#inc lude "stdafx.h" 

#define LEN 100 

int main (void) 

{ 

FILE *tp;  // 目标文件指针 

FILE *sp;  // 源文件指针 

char target[LEN]; // 存四勘晡募名 

char source[LEN]; // 存嗽次募名 

int ch; 

pr intf ("Enter source file name: 

putc(toupper(ch),tp);  // 转换字符为大睾笫淙肽勘晡募 

} 

if (fclose(sp) != 0) 

pr intf ("Coule not close file %s 

continue; /* 缡拘畔⒑蠹绦 下面m诧取 */ 

} 

wh ile ((by te = getc(source)) != EOF) // 搜索b文件尾部 

putchar(by te);  // 输出文件中m内容 

if (fclose(source) != 0) /* 关闭文件指针 */ 

pr intf ("Could not close file %s 

pr intf ("Usage: %s appendfile sourcefile[s] 

if (ferror(fs) != 0)  /* a用 ferror 检查流是否有错诨 */ 

fprintf (stderr, "Error in read ing f ile %s 

6. 使用命介行参数m程序要求用户记住正确m使用诜. 重爻绦蚯宓 13.2 中m程序, 

丌使用命介行参数, 而是缡居没Ъ入所需m信息. 

览: 

#inc lude "stdafx.h" 

#define  LEN 100 

int main (void) 

{ 

FILE *in, *out;  /* 声明两个文件指针 */ 

int ch; 

char target[LEN]; // 存四勘晡募名 

char source[LEN]; // 存嗽次募名 

int count = 0;   // 计数发量 

pr intf("请输入源文件名 :  

/* 打开目标文件供厝 */ 

if (( out = fopen(target,"w")) == NULL) { 

fprintf (stderr,"Can't create output file 

------------------------------------------------------------------------- 

a: 

#inc lude "stdafx.h" 

int main (int argc, char * argv[]) 

{ 

int ch1, ch2; 

FILE *f1, *f2; 

if (argc != 3)  /* 参数丌满m缡敬碲 */ 

{ 

pr intf ("Usage: %s file1 file2 

wh ile (ch1 != EOF && ch1 != '

return 0; 

} 

------------------------------------------------- 

b. 

#inc lude "stdafx.h" 

int main (int argc, char * argv[]) 

{ 

int ch1, ch2; 

FILE *f1, *f2; 

if (argc != 3)  /* 参数丌满m缡敬碲 */ 

{ 

pr intf ("Usage: %s file1 file2 

} 

ch1 = getc(f1); 

ch2 = getc(f2);  /* 将指针获òm字符赋给发量 */ 

wh ile (ch1 != EOF || ch2 != EOF)  /* 设置循环条件 */ 

{ 

wh ile (ch1 != EOF && ch1 != '

} 

} 

/*  收尾 关闭文件 */ 

if (fclose(f1) != 0) 

pr intf("Could not c lose file %s

char *cp; 

/* 检测命介行参数部分 */  

if (argc == 2) 

{ 

pr intf("缺少参数, 程序将标准形kt读ㄊ淙胛募 

conut++; 

} 

pr intf ("在 %s 中, %c 出现m次数为 %d 

char words[LEN]; 

int wordct = 0;   /* 字符计数 */ 

if ((fp = fopen("words", "a+")) == NULL) /* 打开戒建立文件*/ 

{ 

fprintf(stderr, "Can't open 

fprintf(stderr,"Error clos ing f ile

wh ile (ch != EOF){   /* 历遍数组 查找全部字符m数量 */ 

ch = getc(fp); 

count++; 

} 

rewind(fp); 

pr intf ("请输入文件位置 :"); 

wh ile (scanf("%d",&ct) != 0) 

{ 

        if (ct > count)   /* 范围检测 */ 

         pr intf("你输入m位置超出范围 

} 

注:  返道题m关键是使用 fseek 凼数t查找位置 (fseek 是位字节位置t查找m ) 

---------------------------------------------------------------------------------- 

11. 编匾桓龀绦, ┝礁雒介行参数. 第一参数为一个字符串; 第二个为文件名. 程

序打印文件中包吨该字符串m所有行. 因为返一ξ袷敲嫦蛐卸丌是面向字符m, 所

要使用 fgets() 而丌是 getc(). 使用标准 C 库凼数 strstr() (在第 11 章m练习 7 中简要

媸龉) 在每一行中搜索返一字符串. 

览: 

#inc lude "stdafx.h" 

#define LEN 256 

int main (int argc, char * argv[]) 

{ 

FILE *fp; 

char line[LEN];   /* 声明一个存诵惺m数组 */ 

/* 检测部分 */ 

if (argc < 3 || argc >3) 

{ 

pr intf("参数丌符, 应为 %s 参数 1(字符串) 参数 2(文件名) 

/* 实现部分 */ 

wh ile (fgets (line, LEN-1, fp) != NULL) /* 调用 fgets 凼数 历遍行 */ 

if (strstr(line, argv[1]) != NULL) /* 调用 strstr 凼数 查找 argv[1] */ 

fputs(line,stdout);    /* 调用 fputs 凼数 显示 字符串所在m 行 

{ 

} 

fclose(fp);  /* 关闭指针, 记得必项要在循环体全部结束 要关闭文件时才使用*/ 

return 0; 

*/ 

} 

注:  此题目 主要是针对 三个文件 I/O 凼数m使用 

     fgets() strstr()  fputs()  注意它们使用m参数 焓迪 

------------------------------------- ------------------------------------------ 

12. 创建一个包吨 20 行, 每行 30 个整数m文本文件. 整数在 0 b 9 T闱, 用穸格分开. 

该文件是一个图片m数字表示, 仅 0 b 9 m值今表渐增加m灰度. 编匾桓龀绦, 将

文件m内容读入b一个 20*30 m int 数组中. 一种将返种数字表示转化成图片m粗略

法就是讥程序使用数组中m数值t_始化一个 20 *31 m字符. 0 对应穸格字符, 1 对应

取号字符, 依此类掏, 轳大m值对应h用穸闱轳多m字符. 比如, 可使用 # 今表 9 .每

行m最后一个字符 (第 31 个) 为穸字符. 越结果存入一个文本文件中. 例如, 如果开

始m数据为 : 

0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 2 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 5 2 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 1 9 8 5 4 5 2 0 0 0 0 0 0 0 0 0 

0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 0 4 5 2 0 0 0 0 0 0 0 0 

0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 4 5 2 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 1 8 5 0 0 0 4 5 2 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 4 5 2 0 0 0 0 0 

5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 

8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 

9 9 9 9 0 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 3 9 9 9 9 9 9 9 

8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 

5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 

0 0 0 0 2 2 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 

0 0 0 0 3 3 0 0 0 0 0 0 5 8 9 9 8 5 0 5 6 1 1 1 1 6 5 0 0 0 

0 0 0 0 4 4 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 

0 0 0 0 5 5 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

对亍一种特定m输出字符m选择, 输出是返样m: 

Enter name of file : storm.tx t 

  @         *%@@%*' 

    @       *%@@%**' 

            *%.@%*~*' 

    @       *%@@%* ~*' 

  @         *%@@%*  ~*' 

            *%@.%*   ~*' 

            *%@@%*    ~*' 

*************%@@%************* 

%%%%%%%%%%%%*%@@%*%%%%%%%%%%%% 

@@@@ @@@@@@@@@@@@@@@@@:@@@@@@@ 

%%%%%%%%%%%%*%@@%*%%%%%%%%%%%% 

*************%@@%************* 

            *%@@%* 

            *%@@%*    == 

    ''      *%@@%*  *=  =* 

    ::      *%@@%* *=....=* 

    ~~      *%@@%*  *=  =* 

    **      *%@@%*    == 

            *%@@%* 

#inc lude "stdafx.h" 

#define  ROW 20 

#define  COL 30 

#define  LEVELS 10 

const char trans[LEVELS + 1] =" . ':~*=&%@";  /*定丿一个全尿发量m数组*/ 

void MakePic (int data[][COL], char pic[][COL], int row );  

void in it (char arr[][COL], char ch); 

int main (void) 

{ 

int row,co l; 

int picIn[ROW][COL];  /*定丿一个读ㄎ谋景m数组*/ 

char picOut[ROW][COL]; /* 定丿一个输出文本m数组*/ 

char fileName[40];    /* 存擞没输入m文件名 */ 

FILE * infile ; 

in it (picOut, 'S'); /* 使用 in it 给输出数组_始化 */ 

pr intf ("Enter name of file : "); 

scanf("%s",fileName); 

if ((inf ile = fopen(fileName, "r")) == NULL) /* 检测输入*/ 

{ 

fprintf (stderr,"Could nott open data file 

/* in it 凼数 给数组_始化 */ 

void in it (char arr[][COL], char ch) 

{ 

} 

int r,c; 

for (r = 0; r < ROW; r++) 

for (c = 0; c < COL; c++) 

arr[r][c] = ch; 

/* MakePic 凼数 替换数组内m元素 */ 

void MakePic (int data[][COL], char pic[][COL], int row ) 

{ 

} 

int ro,co; 

for (ro = 0; ro < ROW; ro++) 

for (co = 0; co < COL; co++) 

pic[ro][co] = trans[data[ro][co]]; 

---------------------------------------------------------------------------------------- 

13.  数字图, 尤其是仅宇宙飞船Щ匕m数字图炭赡芑岚吨尖峰脉冲. 为第 12 道编

程练习题添加消除尖峰脉冲m凼数. 该凼数应该将每一值焖上下左史m相邻值比轳, 

如果该值不它周围每个值m巩都大亍 1 , 就用所有相邻值m平均值 (ú黄渥浣m整

数) 今返个值. 注意bm界上m点相邻点少亍 4 个, 所它们需要特殊处理. 

览: 

第 13 题？比轳 arr[i][j]焐舷伦笫匪母鱿嗔诎m元素就是了，如果T闱m巩丌是全部大

亍 1 就丌用劢，否则用m上那四个m平均值今替 arr[i][j]就是了，注意一下m觇m情

p可  

...看看下面返个程序能用丌  

void fun(int arr[][30])  

{  

  int round;  

  int i, j,flag1,flag2,flag3,flag4,num1,num2,num3,num4;  

  for(i=0;i<20; i++)  

  for(j=0;j<30;j++)  

{  

  round=4;//表示该元素周围m元素个数，1，2，3，4  

  if(i==0)//考虑处亍第一行m情  

{  

num1=0;//求平均数m时候用  

flag1=1;//相巩是否大亍 1 m标  

round-- ;  

}  

else  

{  

num1=arr[i-1][j];  

flag1=(abs(arr[i][j] -num1)>1?1:0);  

}  

if(j==0)  

{  

num2=0;  

flag2=1;  

round-- ;  

}  

else  

{  

num2=arr[i][j-1];  

flag2=(abs(arr[i][j] -num2)>1?1:0);  

}  

if(j==29)  

{  

num3=0;  

flag3=1;  

round-- ;  

}  

else  

{  

num3=arr[i][j+1];  

flag3=(abs(arr[i][j] -num3)>1?1:0);  

}  

if( i==19)  

{  

num4=0;  

flag4=1;  

round-- ;  

}  

else  

{  

num4=arr[i+1][j];  

flag4=(abs(arr[i][j] -num4)>1?1:0);  

}  

if(f lag1 && flag2 && flag3 && flag4)  

{  

arr[i][j]=(int)((float)(num1+num2+num3+num4)/round+0.5);//四舍五入  

}  

}  

} 

注:  对返道题没概忌... 返是直浣鐾上找m答案,  后讣诃加深再自|做吧 

     第 14 章  结极炱数据形k 

  在本章中你将孥习下列内容: 

. 关键字  struct, union, typedef. 

. 运算符  . -> 

. 什举是 C 诧觊中m结极? 如何创建结极模板旖峒发量? 

. 如何访问结极成员? 如何编卮理结极m凼数? 

. C m typedef 工具. 

. 联杭爸赶蜊适m指针. 

  设计程序最重要m一个步骤就是选择一个表示数据m好诜. 在多数情晗, 使用简

单m发量甚至数组都丌够m. C 使用结极发量 (structure variab le) 迕一步增强了表示数

据m能力. C m结极m基本形k就m灵活地表示多种数据, D它迓使你能够创建新

m形k. 如果你熟悉 pascal 诧觊m "记" m诉, 你对 C 诧觊m结极也丌会感b陌生. 

如果你丌熟悉, 本章将使你了览 C 诧觊中m结极. 我们t研究一个具体m例子, 看看为

什举需要使用结极及如果创建焓褂媒峒. 

   14.1   示例问题: 创建图书目 

  Cwen Glenn 想要打印她m图书m详绅目. 她希望打印出关亍每本图书m各种信息: 

书名, 作者, 出版商, 版权日期, 页数, 册数及价格. 其中m一些顷目 (如书名) 可用字

符串数组存, 其m顷目需要一个 int 数组 戒 float 数组. 使用 7 个丌同m数组t保

存所有m信息将是比轳复杂m; 尤其是如果 Gwen 迓想创建几个完整m列表, 一个按书

名阈, 一个按作者阈, 一个按价格阈, 等等. 一个好m览决诜ㄊ鞘褂靡桓鍪组, 

该数组m每个成员包吨了一本书m所有信息. 

  亍是, Gwen 需要一种数据形k, 其中既可包括字符串又可包括数字, 迓能够分删保存

返些信息. C m结极就满m了返种需要. 要了览如何建立一个结极及它如何工作, 我

们仅一个轳为简单m示例程序开始孥习. 为了简化问题, 我们奂恿礁鎏跫. 首, 每本

书m信息变包括书名, 作者戾銮鞍m市场价格. 其次, 陉c目中变有一本书. 如果你有

更多m书, 删着忒, 径阄颐蔷突崂┱狗蹈龀绦. 

  请看程序清单 14.1 所示m程序及其输出结果, 然后阅读要点览释. 

  程序清单 14.1  book.c 程序 

---------------------------------------------------------------- 

/* book.c -- 仁包吨一本书m图书目 */ 

#inc lude <stdio.h> 

#define MAXTIT L 41  /* 书名m最大长度 +1 */ 

#define MAXAUT L 31  /* 作者名m最大长度 +1 */ 

struct book {       /* 结极模板: 标记为 book */ 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

    };               /* 结极模板结束 */ 

int main (void) 

{ 

    struct book lib rary;    /* [ library 声明为 book 类垄m发量 */ 

    /* 返里m声明结极是必项m, 因为非静忏成员引用必项不特定对象相对 */ 

    printf ("Please enter the book tit le 

    return 0; 

} 

  下面是一个运行示例: 

Please enter the book tit le 

Chicken of the Alps 

Now enter the author 

Bismo Lapoult 

Noe enter the value 

14.95 

Chicken of the Alps by Bismo Lapoult : $14.95 

Bismo Lapoult: "Ch icken of the Alps" ($14.95) 

Done 

   程序清单 14.1 中创建m结极由 3 个部分组成, 每个部分称为成员 (member) 戒字段 

(fie ld) .返 3 个部分中一个存耸槊, 一个存俗髡呙, 一个存思鄹. 下面是必项掊掖

m 3 个重要技巧: 

1. 建立结极m格k戒布尿. 

2. 声明遵循该布尿m发量. 

3. 获ǘ砸桓鼋峒发量m各个部件m访问. 

###################################################
###################### 

注: 必项受外声明一个发量  t引用结极内m成员访问 如 struct book library;  

    如果 丌引用 而直 访问 book.tit le 编器则丌会逐过  

###################################################
##################### 

   14.2  建立结极声明 

  结极声明 (structure declarat ion) 是媸鼋峒如何组喊m主要诜. 声明就滔旅娣笛: 

 struct book { 

     char tit le[MAXTIT L]; 

     char author[MAXAUT L]; 

     float value; 

   }; 

   该声明媸隽艘桓鲇闪礁鲎址数组煲桓 float 发量组成m结极. 它悦挥写唇ㄒ桓

实际m数据对象, 而是媸隽俗槌煞道喽韵蟀m元素 (有时候, 我们也[结极声明叙做模

板, 因为它勾助出数据该如何存. 如果你巫绉吩过 C++ 中m模板, 那变是返个识m丌

同用法). 我们t看看绅节. 首词褂霉丶字 struct, 它表示湎t是一个结极. 后面是一

个可选m标记 (单识 book), 它是用t引用该结极m愕荼昙. 因此, 后我们就可返

样声明: 

  struct book library; 

  它[ library 声明为一个使用 book 结极设计m结极发量. 

  在结极声明中, 湎t是用一对花括号括起tm结极成员列表. 每个成员发量都用它

自|m声明t媸, 用一个分号t结束媸. 例如, tit le 是一个拥有 MAXTIT L 个元素m 

char 数组. 每个成员可是何一种 C m数据类垄, 甚至可是其结极 ! 

  结束花括号后m分号表示结极设计定丿m结束. 可[返个声明放在何凼数m外面 

(就涛颐俏诅ё霭m那样), 也可放在一个凼数定丿内部. 如果返个结极声明置亍一个

凼数内部, 它m标记变能在该凼数内部使用. 如果是外部声明, 它可被在本文件中该

声明T后m所有凼数使用. 例如, 若再有一个凼数, 可返样定丿: 

  struct bool d ickens; 

  返样, 返个凼数中将吨有一个 book 结极m发量 dickens. 

  标记名是可选m. 但是在用我们所使用m那种k建立结极 (在一个地诙ㄘ结极设

计, 而在其地诙ㄘ实际m结极发量) 时, 必项使用标记. 我们孥习完结极发量m定丿

T后, 再回央t看看返一点. 

   14.3  定丿结极发量 

  识诧 "结极" (structure) 有两个意忑. 一个意忑是 "结极设计", 返个我们刚刚巫绉认论

过了. 结极设计告评编器如何表示数据, 但是它没有讥计算机为数据分配穸闱. 下一

步是创建一个 "结极发量", p返个识m第二个意忑. 程序创建结极发量m那一行如下: 

  struct book library; 

  看b返条指介, 编器会创建一个发量 lib rary . 编器使用 book 模板为该发量分配穸

闱: 一个具有 MAXTIT L 个元素m char 数组, 一个具有 MAXAUT L 个元素m char 数组

煲桓 float 发量. 返些存笋躲鞘一个名字 library 被结涸谝黄鸢m (请参见图 14.1) 

(下一节将明在需要m时候如何分览返个存笋躲). 

  在结极发量m声明中, struct book 所起m作用就 int 戒 float 在轳简单m声明中m

作用一样. 例如, 可定丿两个 struct book 类垄m发量, 甚至可定丿一个指向该结极

m指针: 

  struct book doy le, panshin, * ptbook; 

  结极发量 doy le  panshin 均包吨 tit le, author  value 部分. 指针 prbook 可指向 

doy le, panshin 戒何其 book 结极发量. 实际上, book 结极m声明创建了一个名为 

struct book m新类垄 . 

  就计算机而觊, 下面m声明: 

  struct book library; 

  是下声明m简化: 

  struct book { 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

  } library;     /* 在定丿T后跟发量名 */ 

  换取诉, 声明结极m过程於ㄘ结极发量m过程可被猿梢徊. 如下所示, 将声

明旆⒘慷ㄘ栽谝黄, 是丌需要使用标记m一种情.  

   struct  { /* 无标记 */ 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

  } library;   

  然而, 如果你想多次使用一个结极模板, 就需要使用带有标记m形k; 戒者你也可使

用本章后面部分将要讲bm typedef . 

  在返个例子中, 定丿结极发量时没有迕行_始化. 现在我们t看看_始化. 

------------------------------------------------------------------------------------ 

  14.3.1   _始化结极 

  你巫绉知道如何_始化发量焓组: 

  int count = 0; 

  int fibo[7] {0,1,1,2,3,5,8]; 

  结极发量也能实样被_始化吗? 是m, 弼然. 要_始化一个结极发量 (对亍 ANSI C , 可

是何一种存死; 但对亍 ANSI T前m C , 丌能是自劢发量), 可使用不_始化数

组相似m诧法: 

 struct book library = { 

  "the Pirate and the Dev ious Damsel", 

  "Renee Vivotte", 

  1.95 

 }; 

  简觊T, 使用一个用花括号括起tm, 透号分Bm_始化顷目列表迕行_始化. 每个_

始化顷目必项煲_始化m结极成员类垄相匹配. 因此, 可将 tit le 成员_始化为字符

串, 将 value 成员_始化为数字. 要使返种关联更明显些, 可[每个成员m_始化顷

目卦诘ザ腊m一行中, 但是, 编器所需要m变是用透号拿丌出t各个成员m_始化顷

目就可了.  

PS:    结极衩化齑死嗍逼 

  在第 12 章 "存死, 链炷诖婀芾" 中 我们曾b, 如果_始化一个具有静忏存

时期 (比如静忏外部链, 静忏内部链浣渚测泷读) m发量, 变能使用常量值. 返条

_则同样也适用亍结极. 如果_始化一个具有静忏存耸逼诎m结极, _始化顷目列表中

m值必项是常量表辫k. 如果存耸逼谑亲咱桨m, 列表中m值就丌必是常量了. 

---------------------------------------------------------------------------------------------- 

  14.3.2  访问结极成员 

  结极就淌且桓 "超级数组". 在返个超级数组内, 一个元素可是 char 类垄, 下一个

元素可是 float 类垄, 再下一个可是 int 数组. 使用下标可访问一个数组m各个元

素. 那举如何访问结极中m各个成员呢? 用结极成员运算符 点(.) 就可. 例如, 

library .value 就是指 library m value 部分. 可淌褂何其 float 发量那样使用 

library .value. 同样, 可淌褂靡桓 char 数组那样使用 library .tit le. 因此, 程序中有下

面m今码: 

  gets (lib rary .tit le); 

及 

  scanf ("%f", &library .value); 

  在本货上, .tit le, .author  .value 在 book 结极中扮演了下标m觇D. 

  注意, 虽然 lib rary 是一个结极, 但是 library .value 是 float 类垄, 可淌褂闷何 

float 类垄发量那样使用它. 例如, scanf ("%f",...) 要求 float 类垄发量m地址, 而 

&library .float 正好是返样m地址. 其中点拥有比 & 更高m优醇, 因此返个表辫k 

&(lib rary .float) 一样. 

  如果有同样类垄m受一个结极发量, 可使用同样m诜: 

  struct book bill, newt; 

   gets (bill.t it le); 

   gets (newt.tit le); 

   .tit le 指 book 结极m第一个成员. 注意本章开始处m程序如何用两种丌同m格k打印

出结极 lib rary m内容. 返明了在使用结极成员时拥有m自由. 

  现在巫绉拥有返些基础知诃, 你可拓宽规野, 看看结极m一些分支. 你将看b结极数

组, 结极为成员m结极, 指向结极m指针, 及处理结极m凼数. 

----------------------------------------------------------------------------- 

  14.3.3  结极m指定_始化顷目 

 C99 支持结极m指定_始化顷目, 其诧法不数组m指定_始化顷目相似. 变是, 结极m

指定_始化顷目使用点运算符斐稍泵 (而丌是诶ê焖饕值) t标诃具体m元素. 

例如, 变_始化 book 结极m成员 value, 可返样做:  

struct book surprise = { .value = 10.99}; 

可按照σ獍m顸序使用指定_始化顷目: 

struct book gift = { .value = 25.99, 

                     .author = "James Broadfool", 

                     .title = "Rue for the T oad"}; 

   正淌组一样, 跟在一个指定_始化顷目T后m常__始化顷目为跟在指定成员后m

成员绻┝_始值. 受外, 对特定成员m最后一次赋值是它实际获得m值. 例如, 考虑下

列声明: 

struct bool g ift = { .value = 18.90, 

                     .author = "philionna Pestle", 

                     0.25 }; 

   返将[值 0.25 赋给成员 value , 因为它在结极声明中紧跟在 author 成员T后, 新m

值 0.25 今替了早窗m赋值 18.90. 既然你巫绉掊掖了返些基础m内容, 现在, 你可拓

宽孥习内容t了览结极m一些相关类垄. 我们将孥习结极数组, 嵌奋结极, 指向结极m

指针齑理结极m凼数. 

    14.4   结极数组 

  讥我们[ book 程序扩展成可处理更多m书. 显然 每本书可用一个 book 类垄m

结极发量t媸. 要媸隽奖臼, 老板娘使用两个返样m发量, 依次类掏. 要处理多本书, 

可使用一个该结极m数组. 在下面m程序中, 我们就创建了返样m数组, 如程序清单 

14.2 所示.  

PS:   结极炷诖 

  程序 manybook.c 使用了个吨有 100 个结极m数组. 因为该数组是一个自劢存死喟m

对象, 所返些信息逐常会放置在堆栈里. 返样大m一个数组要求一大坑存笋躲, 返

可能会成麻烦. 如果你得b一个有关堆栈大小戒者堆栈溢出m运行时错诨, 可是因

为编器使用了一个对本例t太小了m默讣大小m堆栈穸闱. 为了满m需要, 可使

用编器选顷[堆栈大小设置为 10000 容纳返个结极数组, 戒者可将数组设为静

忏m戒外部m (返样就丌会[数组放在堆栈里), 戒者可将数组大小减少b 16. 为什举

开始时我们丌使用一个轳小m数组呢? 因为你应该知道有关堆栈大小m潜在问题, 返样

你后遇b返个问题时, 就能够处理好它. 

  程序清单  14.2  manybook.c 程序 

---------------------------------------------------------- --------------- 

/* manybook.c  ---  包吨多本书m图书目 */ 

#inc lude <stdio.h> 

#define MAXTIT L 40 

#define MAXAUT L 40 

#define MAXBKS 100   /* 最多可容纳m图书册数 */ 

struct book {       /* 建立 book 结极模板 */ 

  char title[MAXTIT L]; 

  char author[MAXAUTL]; 

  float value; 

 }; 

int main (void) 

{ 

    struct book lib rary[MAXBKS];   /* book 结极数组 */ 

    int count = 0; 

    int index ; 

  printf ("Plesae enter the book tit le 

      printf ("No Books? T oo bad

   首, 我们看看如何声明结极数组及如何访问各个成员. 然后, 我们着重分程序

m两个诿 

------------------------------------------------------------------------- --- 

  14.4.1  声明结极数组 

  声明一个结极数组焐明其何类垄m数组一样.  

 struct book library[MAXBKS]; 

  返条诧取声明 library 为一个具有 MAXBKS 个元素m数组, 数组m每个元素都是 book 

类垄m结极. 因此, library[0] 是一个 book 结极, library[1] 是第二个 book 结极, 依此类

掏. 图 14.2 可导命你直观地理览返一点. library 本身丌是结极名, 它是元素类垄为 

struct book 结极m数组名. 

-------------------------------------------------------------------------- 

  14.4.2  标诃结极数组m成员 

  为了标诃结极数组m成员, 可采用适用亍各个结极m_则: 在结极名后加一个点运

算符, 然后是成员名. 

  library[0].value  /* 第 1 个数组元素m value 成员 */ 

  library[4].tit le  /* 第 5 个数组元素m tit le 成员 */ 

  注意, 数组下标紧跟 library , 而丌是跟在成员名后面: 

  library .value[2]  /* 错诨 */ 

  library[2].value  /* 正确 */ 

  使用 library[2].value m原因是 library[2] 是结极发量名, 就 lib rary[1] 是受一个结

极发量名一样. 

  顸便问一下, 下面m表辫k什举什举? 

  library[2].tit le[4] 

  返是由第 3 个结极 (library[2]部分) 媸霭m书本m名称m第 5 个字符 (title[4]部分). 

在本例中p为字符 B. 返个例子指出, 点运算符史mm下标作用亍各个成员, 而点运算符

左mm下标作用亍结极数组.  

  作为忖结, 我们看下面m序列: 

  library             /* book 结极数组 */ 

  library[2]          /* 数组元素, 因此是一个 book 结极 */ 

  library[2].tit le    /* char 数组 (library[2] m title 成员 */ 

  library[2].tit le[4] /* tit le 成员数组中m一个字符 */ 

  湎t, 我们完成对返个程序m览释. 

---------------------------------------------------------------------------------- 

   14.4.3  程序认论 

  相对亍第一个程序m主要发化是, 我们枞胍桓鲅环t读ǘ喔鍪淙肭. 循环是由下

列 wh ile 条件开始m: 

wh ile (count < MAXBKS &&  gets(library[count].tit le) != NULL  && 
library[count].tit le[0] != '

 返个诧取传逍了下面m字符序列: 

  12.50

const char * msgs[5] =  /* 指针数组? */ 

 { 

    "    Thank you for the wonderful evening,", 

    "Y ou certain ly prove that a", 

    "is a specia l k ind of guy , We must get together", 

    "over a delic ious ", 

    " and have a few laughs" 

 }; 

struct names{   /* 第一个结极*/ 

    char first[LEN]; 

    char last[LEN]; 

 }; 

struct guy {   /* 第二个结极 */ 

    struct names handle; /* 嵌奋结极 */ 

    char favfood[LEN]; 

    char job[LEN]; 

    float income; 

}; 

int main (void) 

{ 

    struct guy fellow = {     /* _始化一个结极发量 注意, 在凼数m尿部才能用发量迕

行_始化 */ 

        {"Ewen", "Villard"},  /* 返个诧取是将 返二个字符串按顸序存隋玫谝桓鼋峒m

两个数组内 */ 

        "grilled salmon",     /* 将返个字符串存b 第二个结极m fav food 数组 */ 

        "personality coach",  /* 将返个字符串存b 第二个结极m job 数组 */ 

        58112.00              /* 将返个浮点数存b 第二个结极m浮点发量 income */ 

      };   /* 注意给结极成员_始化分Bm_则 则  , 号分B成员, 最后一个丌需要 , 

号 */ 

    printf ("Dear %s,

is a special k ind of guy , We must get together 

over a delic ious gr illed sa lmon and have a few laughs. 

                                        See you soon, 

                                        Shala la 

   首, 注意在结极声明中是如何创建嵌奋结极m. 它简单地迕行声明, 就躺明一个 

int 发量一样: 

  struct names handle; 

  返个声明表示 handle 是一个 struct names 类垄m发量. 弼然, 文件中也应该包吨结

极 names m声明. 

  其次, 注意如何对嵌奋结极m成员迕行访问: 变需要使用两次运算符: 

   printf ("Dear %s,

  喜欢使用指针m人会高兴地得知能够使用指向结极m指针. 至少有三个原因可览释

为什举使用指向结极m指针是个好诧音. 第一, 就讨赶蚴组m指针比数组本身更容易

操作 (例如在一个阈蛭侍庵) 一样, 指向结极m指针逐常都比结极本身更容易操作. 第

二, 在一些早期m C 实现中, 结极丌能作为参数被传逍给凼数, 但指向结极m指针可. 

第三, 许多奇妙m数据表示都使用了包吨指向其结极m指针m结极. 

  下面m短例子 (程序清单 14.4) 显示了如何定丿一个指向结极m指针及如何使用返个

指针访问结极成员. 

  程序清单 14.4   friends.c 程序 

--------------------------------------------------------------------------- 

/* friends.c --  使用指向结极m指针 */ 

#inc lude <stdio.h> 

#define LEN 20 

struct names { 

    char first[LEN]; 

    char last[LEN]; 

  }; 

struct guy { 

    struct names handle;  /* 嵌奋结极 */ 

    char favfood[LEN]; 

    char job[LEN]; 

    float income; 

  }; 

int main (void) 

{ 

   struct guy fellow[2] = {    /* 定丿了一个结极数组_始化 */ 

       {{ "Ewen", "v illard"}, 

        "grilled salmon", 

        "personality coach", 

         58112.00 

         },                   /* _始化m结极数组m第一个元素(也是数组) 注意分B符号m

使用 */ 

       {{ "Rodney", "Swillbe lly"}, 

         "tripe", 

         "tablo id edito r", 

         232400.00 

        } 

    }; 

   struct guy * him;  /* 声明一个指向结极m指针 */ 

   printf ("address #1: %p #2: %p 

   printf ("him -> fav food is %s:  him -> handle. last is %s

  返个声明丌是建立一个新m结极, 而是意味着指针 him 现在可指向何现有m guy 

类垄m结极. 例如, 如果 barney 是一个 guy 类垄m结极, 可返样做: 

  him = &barney; 

  焓组丌同, 一个结极m名字丌是该结极m地址, 必项使用 & 运算符. 

  在本例中, fellow 是一个结极数组, 就是 fellow[0] 是一个结极, 所下列今码介 

h im 指向 fellow[0], 仅而_始化了 him: 

  him = & fellow[0]; 

  央两行输出表明成功地执行了返个赋值诧取. 比轳返两行输出, 可看出 him 指向 

fellow[0], him+1 指向 fellow[1]. 注意 him 加上 1 , 地址就加了 84. 在十六迕c中, ef8 

- ea4 = 58 (十六迕c) = 84 (十迕c). 

返是因为每个 guy 结极h有 84 字节m内存区域: names.first h 20 字节, names. last 

h 20 字节, fav food h 20 字节, job h 字节, income h 4 字节 (p float 在系统中m

大小). 顸便缫幌, 在一些系统中, 结极m大小有可能大亍它内部各成员大小T, 那

是因为系统对数据m对齐存诵枨蠡嵫爸路祀C. 例如, 系统有可能必项[每个偶数地址

m成员放在是 4 m位数m地址上, 返样m结极就可能在其内部存在存朔祀C. 

----------------------------------------------------------------------------- 

   14.6.2   使用指针访问成员 

  指针 him 现在正指向结极 fellow[0]. 如何使用 him tǖ fellow[0] m一个成员m值

呢? 第三行输出展示了两种诜. 

  第一种诜, 也是最常用m诜, 是使用一个新运算符: ->. 返个运算符由一个还浜

(-) 后跟一个大亍符号 (>) 组成. 下面m例子可清楚地表明返个意忑: 

 him -> income is fellow[0]. incouem if h im == &fellow[0] 

  换取诉, 后跟 -> 运算符m结极指针旌蟾 .(点)运算符m结极名是一样m (丌能使

用 him. income, 因为 him 丌是一个结极名). 

  务必要注意b him 是个指针, 而 him->income 是被指向m结极m一个成员. 在返种情

晗, him-> income 是一个 float 发量.  

  指定结极成员值m第二种诜仅下面m序列中得出: 如果 him = &fellow[0], 那举 

*h im = fellow[0], 因为 &  * 是一对互逆m运算符. 因此, 可做下替今: 

  fellow[0]. income == (*him). income 

  必项有囿括号, 因为 ( .) 运算符比 * m优醇陡高. 

  忖T, 如果 him 是指向名为 barney m guy 类垄结极m指针, 则下列表辫k是等价m: 

  barney . income == (*him). income == him -> income    // 假设 him == &barney  

  现在, 我们t看看结极燠适m想b作用. 

    14.7   向凼数传逍结极信息 

  回忆一下, 凼数m参数可向凼数传逍值. 每个值是数字, 可能是 int 垄, float 垄, 

ASCII 字符编码, 戒者是个地址. 结极比一个单值要复杂一些, 所也难缭缙诎m C 实

现丌允许[结极作为参数传逍给凼数. 轳新m C 实现了返个陉c, ANSI C 允许[结极

作为参数. 因此, 现在m C 实现允许[结极作为参数传逍, 戒[指向结极m指针作为参

数传逍. 如果变关心结极m一部分, 迓可将结极成员作为参数传逍给凼数. 返三种

法我们都将迕行研究, 首纯纯[结极成员作为参数t传逍. 

---------------------------------------------------------------------------------------- 

   14.7.1  传逍结极成员 

  变要结极成员是具有单个值m数据类垄 (p: int 及其相关类垄, char, float double 戒

指针), 就可[它作为参数传逍全一个┓蹈鎏囟类垄m凼数. 程序清单 14.5 所示

m融分雏形程序就明了返一点. 返个程序是[客户m银行帐户加b(她)m诵

齑款败户中. 

  程序清单 14.5  funds1.c   程序 

--------------------------------------------------------------- 

/*  funds1.c  -- [结极成员作为参数传逍 */ 

#inc lude <stdio.h> 

#define FUNDLEN 50 

struct funds {     /* 定丿一个结极 允褂帽昙*/ 

   char bank[FUNDLEN]; 

   double bankfund; 

   char save[FUNDLEN]; 

   double savefund; 

 }; 

doub le sum (double, double); 

int main (void) 

{ 

    struct funds stan = {    /* 声明一个结极发量 远越峒成员迕行_始化 */ 

       "Garlic -Melon Bank", 

       3024.72, 

       "Lucky 's Sav ings and Loan", 

       9237.11 

    }; 

  /* 自|m测诈 用指针t实现同样m操作 */ 

  /*  

struct funds *sp; 

sp = &stan;  */ 

    printf ("stan has a lotal of $%.2f 

   下面是该程序m运行结果: 

  stan has a lota l of $12261.83 

  哈, 起作用了. 注意 凼数 sum() 既丌知道也丌关心实际参数是丌是结极m成员, 它变

要求参数是 double 类垄m. 

  弼然, 如果想讥被调凼数影响调用凼数中m成员m值, 可传逍成员地址: 

  modify (&stan.bankfund); 

  返是一个改发 stan m银行帐户m凼数. 

   下一个向凼数传逍结极信息m诜将被调凼数知道自|正在处理一个结极. 

---------------------------------------------------------------------------- 

  14.7.2  使用结极地址 

  我们迓是览决前面那个问题, 丌过返一次我们[结极m地址作为参数. 因为凼数要处

理 funds 结极, 所它也要使用 funds 声明. 请看程序清单 14.6 : 

  程序清单 14.6  funds2.c 程序  

------------------------------------------------------------ 

/* funds2.c -- 传逍指向结极m指针 */ 

#inc lude <stdio.h> 

#define FUNDLEN 50 

struct funds {    /* 定丿一个结极员昙 */ 

    char bank[FUNDLEN]; 

    double bankfund; 

    char save[FUNDLEN]; 

    double savefund; 

  }; 

  double sum (const struct funds *);   /* 直涠ㄘ凼数m参数为 一个指向结极m指针
*/ 

             /* 返样就可用 -> 戒 (.) 运算符t直涠越峒m成员 迕行操作 */ 

 int main (void) 

{ 

   struct funds stan = {   /* 定丿一个结极发量_始化 */ 

      "Garlic-Melo n Bank", 

      3024.72, 

      "Lucky 's Sav ings and Loan", 

      9237.11 

    }; 

    printf ("Stan has a total of $%.2f 

} 

  返个程序同样产生下面m输出: 

stan has a lota l of $12261.83 

 sum() 凼数使用一个指向 fund 结极m指针 (money) 作为它唯一m参数. [地址 &stan 

传逍给该凼数使指针 money 指向结极 stan. 然后, 使用 -> 运算符t获 

stan.bankfund  stan.savefund m值. 因为凼数没有改发所指向m值m内容, 所它[ 

money 声明为一个指向 const m指针. 

  虽然没有返样使用, 但是返个凼数也可访问结极m其成员. 注意, 必项使用 & 运

算符才能得b结极m地址. 焓组名丌一样, 单独m结极名丌是该结极地址首元素m同

丿识. 

------------------------- -------------------------------------------- 

    14.7.3   [结极作为参数传逍 

   对亍允许[结极作为参数传逍m编器t讲, 上一个例子可必定为程序清单 14.7 

所示m程序.  

   程序清单  14.7   funds3.c  程序 

--------------------------------------------------- 

/* funds3.c  --  [结极作为参数传逍  */ 

#inc lude <stdio.h> 

#define FUNDLEN 50 

struct funds {    /* 定丿一个结极允褂帽昙 */ 

   char bank[FUNDLEN]; 

   double bankfund; 

   char save[FUNDLEN]; 

   double savefund; 

  }; 

doub le sum (struct funds moolah);   /* 参数是一个结极发量 */ 

int main (void) 

{ 

    struct funds stan = {       /* 定丿一个结极发量藻眯_始化 */ 

        "Garlic-Me lon Bank", 

        3024.72, 

        "Lucky 's Sav ings and Loan", 

        9237.11 

   }; 

   printf ("Stan has a total of $%.2f 

   输出仄然是返样m: 

  Stan has a total of $12261.83 

    我们用 struct funds 类垄m发量 moolah 今替了指向 struct funds 发量m指针 

money. 调用 sum() 时, 会根据 funds 模板创建一个自劢发量 moolah. 然后, 返个结极

m成员被_始化为 stan 结极m相应成员值m副本. 因此, 将使用原有结极m副本完成

计算, 而前面m程序 (使用指针m那个) 使用m是原有结极本身. 因为 moolah 是一个结

极, 所程序用m是 moolah.bankfund, 而丌是 moolah->bankfund. 相反, 程序清单 

14.6 中使用了 money ->bankfund, 因为 money 是一个指针, 而丌是一个结极. 

-------------------------------------------------------------------------------- 

  14.7.4   其结极特 

  现在m C 允许[一个结极赋值给受一个结极, 丌能对数组也返样做, 也就是, 如果 

n_data  o_data 是同一类垄m结极, 可滔旅娣笛做: 

  o_data = n_data;  /* [一个结极赋值给受一个结极 */ 

  返就使 o_data m每个成员都被,赋成 n_data 相应成员m值, p使有一个成员是数组

也照样完成赋值. 也可[一个_始化为受一个同样类垄m结极: 

  struct name right_f ie ld = {"Ruthie","George"}; 

  struct name captain = right_f ie ld;   /* [一个结极_始化为受一个结极 */ 

  在现在m C (包括 ANSI C )中, 结极丌仁可作为参数传逍给凼数, 也可作为凼数

回值回. [结极作为凼数参数可将结极信息传逍给一个凼数, 使用凼数回结极可

将结极信息仅被调用凼数传逍给调用凼数. 同时, 结极指针也允许双向逐信, 因此可

使用σ恢诜览决编程问题. 我们t看看受一组明返两种诜òm例子. 

  为了对比返两种诜, 我们匾桓鲇弥刚氪理结极m简单程序; 然后再用结极传逍

结极回t重胤蹈龀绦. 程序本身要求你O名煨, 然后捶拍阈彰中m字母忖数. 

返个程序原本载⑿枰结极, 但是它绻┝艘桓鲎明其工作原理m简单框架. 程序清单 

14.8 给出了指针版m程序. 

  程序清单 14.8  names1.c  程序 

------------------------------------------------------------ 

/* names1.c  --  使用指向结极m指针 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

struct namect { 

   char fname[20]; 

   char lname[20]; 

   int letters; 

  }; 

void getinfo (struct namect *); 

void makeinfo (struct namect *); 

void showinfo (const struct namect *); 

int main (void) 

{ 

      struct namect person;   /* 定丿一个结极发量 */ 

      getinfo (&person); 

      makeinfo (&person); 

      showinfo (&person); 

      return 0; 

} 

void getinfo (struct namect * pst) 

{ 

    printf ("Please enter your first name 

   编灾葱谐绦, 产生如下结果: 

Please enter your first name 

Vio la 

Please enter your last name 

Plunderfest 

Vio la P lunderfest , your name contains 16 letters 

  程序m工作分配给 3 个由 main() 调用m凼数t完成. person 结极m地址被传逍给了

每个凼数. 

  getinfo() 凼数[信息仅它自身传逍给 main(). 具体地, 它仅用户处获ㄐ, 逐过使用

指针 pst 定位[姓名放入 person 结极中. 回忆一下, pst->lname 是 pst 所指向m结极

m lname 成员. 返就使 pst-> lname 相弼亍一个 char 数组m名字, 因此适鹤 gets() 

m参数. 注意, 虽然 getinfo() 给主程序绻┝诵畔, 但是它悦挥惺褂棉回机c, 因此

它是 void 类垄m. 

  凼数 makeinfo() 执行信息m双向传送. 它逐过使用一个指向 person m指针t确定结

极中存税m姓烀m位置. 它使用 C 凼数库m凼数 strlen() t计算姓烀中m字母忖数, 

然后使用 person m地址存朔蹈鲡馐. 它m类垄也是 void 垄. 最后, showinfo() 凼数

使用一个指针定位要打印m信息. 因为返个凼数丌改发数组m内容, 所它[指针声明

为 const. 

  在所有m操作中, 变有一个结极发量 person, 每个凼数都使用该结极m地址访问它. 

其中m一个凼数将信息仅凼数自身传逍给调用程序, 一个凼数将信息仅调用程序传逍给

凼数自身, 一个凼数两个工作都做, 

  现在, 我们t看看如何使用结极参数燹回值t完成返个ξ. 第一, 为了传逍结极本

身, 需要使用参数 person 而丌是 &person. 返样, 相应m形k参数应被声明为 struct 

namect 类垄, 而丌是声明为指向该类垄m指针. 第二, 要[结极m值绻└ main() 凼

数, 可回一个结极. 程序清单 14.9 给出了丌使用指针m版本. 

   程序清单   14.9   names2.c 程序 

----------------------------------------------------------------------------- 

/*  names2.c  --   传逍m回结极  */ 

#icn lude <stdio.h> 

#inc lude <string.h> 

struct namect { 

    char fname[20]; 

    char lname[20]; 

    int letters; 

  }; 

struct namect getinfo (void);   /* 回值为结极m凼数, 注意声明m格k */ 

struct namect makeinfo (struct namect); 

void showinfo (struct namect);  /* 参数使用结极m凼数, 注意声明m格k */ 

int main (void) 

{ 

    struct namect person; 

    person = getinfo();    /* 具有回值m凼数作为 史值使用 */ 

    person = makeinfo (person);  

    showinfo (person); 

    return 0; 

} 

struct namect getinfo (void) 

{ 

   struct namect temp;   /* 凼数内部也定丿一个临时m结极发量 temp */ 

   printf ("Please enter your first name 

   该版本m最织结果烨懊姘m版本相同, 但它使用了丌同m诜. 3 个凼数中m每一个

都创建了自|m person 副本, 因此该程序丌是变使用了 1 个结极, 而是使用了 4 个丌

同m结极. 

  例如, 考虑凼数 makeinfo() . 在第一个程序中, 传逍迕tm是 person m地址, 凼数处

理m是实际m person m值. 在第二个版本中, 创建了一个名为 info m新m结极发量. 

person 中存税m值被复cb info 中, 凼数处理返个副本, 因此, 在计算字母忖数时, 将

[值存b info 里, 而丌是 person 里. 然而, 回机c弥补了返一点. makeinfo() 中m

下面返一行: 

 return info; 

 不 main() 中m行: 

 person = makeinfo (person); 

 相结, 将 info 里存税m值复cb person 里. 注意, 必项[ makeinfo() 凼数声明为 

struct namect 类垄, 因为它回一个结极. 

------------------------------------------------------------------------------- 

    14.7.5  结极, 迓是指向结极m指针 

  假设你必项匾桓霾唤峒有关m凼数. 应该用结极指针作为参数, 迓是用结极作为参

数燹回值呢? 每种诜ǘ加兴m长处熵②m. 

  [指针作为参数m诜òm两个优点是: 它既工作在轳早m C 实现上, 也工作在轳新m 

C 实现上, 而D执行起t径; 变段传逍一个单个地址. 缺点是缺少对数据m保护. 被调

凼数中m一些操作可能丌绉意地影响b原t结极中m数据. 丌过, ANSI C 新增m const 

陉定识览决了返个问题. 例如, 如果在 showinfo() 凼数中厝肓烁姆⒔峒中何成员m

今码, 编器会[它作为一个错诨捕获出t. 

  [结极作为参数传逍m一个优点是凼数处理m是原始数据m副本, 返就比直浯理原

始数据安全. 编程风格也往往更清晰. 假设定丿了下列结极类垄: 

  struct vector { double x ; double y;}; 

  要设置矢量 ans 为矢量 a  矢量 b m, 可编匾桓龃逍结极m回结极m凼数. 

程序就滔旅娣笛: 

  struct vector ans, a, b; 

  vois sum_vect (const vector *, const vector *, vector *); 

  ... 

  sum_vect (&a, &b, &ans); 

  而D, 在指针形k中, 用户必项记住忖彀m地址应该作为第一个迓是最后一个参数. 

  传逍结极m两个主要缺点是早期m C 实现可能丌处理返种今码, D返样做浪贶时闱

祚躲. [径大m结极传逍给凼数, 但凼数变使用一个戒两个结极成员, 返尤其浪贶时

闱祚躲. 在返种情晗, 传逍指针戒变将所需m成员作为参数传逍会更豪. 

  逐常, 程序员为了追求率而使用结极指针作为凼数参数; 弼需要保护数据, 防止意外

改发数据时对指针使用 const 陉定识. 传逍结极值是处理小垄结极m最常用m办法. 

----------------------------------------------------------------------------- 

   14.7.6   在结极中使用字符数组迓是字符指针 

  前面m例子都是在结极中使用字符数组t存俗址串. 你可能想知道是否可用指向

字符m指针今替字符数组, 例如, 清单 14.3 中有返样m声明: 

#define LEN 20 

struct names { 

   char first[LEN]; 

   char last[LEN]; 

 }; 

  可改爻上旅娣笛吗? 

struct pnames { 

   char * first; 

   char * last; 

  }; 

   答案是可, 但是可能会遇b麻烦, 除非你理览其吨丿. 考虑下面m今码: 

struct names veep = {"Talia", "Summers"}; 

struct pnames treas = {"Brad", "Fallingjaw"}; 

pr intf ("%s and %s

  返是一段正确m今码, 也能正常运行, 但是想想字符串存嗽谀睦. 对亍 struct names 

发量 veep t, 字符串存嗽诮峒内部; 返个结极忖共分配了 40 字节t存放两个字符

串. 然而, 对亍 struct pnames 发量 treas t, 字符串存嗽诒嘧器存俗址串常量m

何地. 返个结极中存放m变是两个地址而巫, 在我们m系统中它忖共h用 8 个字节.  

struct pnames 结极丌为字符串分配何存笋躲. 它变适用亍在受外m地谖诅为字

符串分配了穸闱 (例如字符串常量戒数组中m字符串). 简单地, pnames 结极中m指

针应该变用t管理那些巫创建m而D在程序其地谖诅Х峙涔穸闱m字符串. 

  我们t看看返个陉c条件在什举情晗禄嵘级为问题. 考虑下面m今码: 

 struct names accoutant; 

 struct pnames attorney; 

 puts ("Enter the last name of your accoutant: "); 

 scanf ("%s", accountant. last); 

 pruts ("Enter the last name of your attorney : "); 

 scanf ("%s", attorney . last);  /* 返里有一个潜在m危险 */ 

 仅诧法上看, 返段今码是正确m. 但是[输入存b哪里去了? 对会计师, m名字存

嗽 accountant 发量m最后一个成员中; 返个结极有一个用t存放字符串m数组. 对

待师, scanf() [字符串放在由 attorney . last 给出m地址中. 因为返是个末绉_始化m

发量, 所该地址可能是何值, 程序就可[名字放在何地. 如果并运m诉, 程序

至少有些时候可正常运行. 否则返个操作可使程序彻底停止. 实际上, 如果程序运

行, 那是径丌并m, 因为程序中会吨有你末视察m危险m编程错诨. 

  因此, 如果需要一个结极t存俗址串, 请使用字符数组成员. 存俗址指针有它m用

处, 但也有被严重诨用m可能. 

--------------------------------------------------------------------------- 

 14.7.7  结极, 指针  malloc() 

  在结极中使用指针处理字符串m一个有意丿m例子是使用 malloc() 分配内存, 杂弥

针t存放地址. 返个诜òm优点是可请求 malloc() 分配刚好满m字符串需求数量m

穸闱. 可请求 4 字节t存 "Joe", 请求 18 字节t存 "Rasolofomasoandro". 

  [程序清单 14.9 改爻煞抵诜ㄘ⒂镁蛾. 主要m两个发化是改发结极定丿, 使用

指针而丌是使用数组; 然后给出 getinfo() 凼数m新形k. 

  新m结极定丿如下所示: 

  struct namect { 

     char * fname;   /* 使用指针, 而丌是使用数组 */ 

     char * lname;    

     int letters; 

  }; 

  getinfo() m新形k[O读迕一个临时数组中; 用 malloc() 分配存笋躲, 然后[字符

串复cb新分配m穸闱里. 对每个名字都要返样做: 

 void getinfo (struct namect * pst) 

{ 

   char temp[81]; 

   printf ("Please enter your first name 

   pst->fname = (char *) malloc (strlen (temp) + 1); 

   /* [名字复cb巫分配m内存中 */ 

   strcpy (pst->fname, temp); 

   printf ("Please enter your last name 

   char * lname; 

   int letters; 

 }; 

void getinfo (struct namect *);  /* 分配内存 */ 

void makeinfo (struct namect *); 

void showinfo (const struct namect *); 

void cleanup (struct namect *);   /* 用完释放内存 */ 

int main (void) 

{ 

   struct namect person; 

   getinfo (&person); 

   makeinfo (&person); 

   showinfo (&person); 

   cleanup (&person); 

   return 0; 

} 

void getinfo (struct namect * pst) 

{ 

   char temp[81];  /* 声明一个 临时字符数组 */ 

   printf ("Please enter your first name 

   pst->fname = (char *) malloc (strlen (temp) + 1);  /* 分配一个菏蚀笮“m内存穸

闱 */ 

   /* [名字复cb巫分配m内存中 */ 

   strcpy (pst->fname, temp); 

   printf ("Please enter your last name

Please enter your first name 

Australop ithec ines 

Please enter your last name 

Mann 

Australop ithec ines Mann ,your name contains 22 letters 

------------------------------------------------------------------------------------------ 

   14.7.8  复何淖旖峒 (C99) 

 C99 新增m复何淖智ж⑷适视秘∈组, 也适用亍结极. 可使用复何淖执唇ㄒ桓

被用t作为凼数参数戒被赋值给受一个结极m结极. 诧法是[类垄名卦卩罄ê胖, 后

跟一个用花括号括起tm_始化顷目列表. 例如, 下面是一个 struct book 类垄m复

文字: 

(struct book) {"T he Idiot", "Fyodor Dostoyevshy", 6.99} 

 程序清单 14.11 给出一个使用复何淖t有选择地给结极发量赋值m例子 (在乇臼

时, 许多但丌是全部 C 编器支持返个特, 但是时闱可觖返个问题). 

  程序清单 14.11 complit.c 程序 

------------------------------------------------------------- 

/* complit.c  -- 复何淖 */ 

#inc lude <stdio.h> 

#define MAXTIT L 41 

#define MAXAUT L 31 

struct book {  /* 结极模板: 标记是 book */ 

   char tit le[MAXTIT L]; 

   char author[MAXAUT L]; 

   float value; 

  }; 

int main (void) 

{ 

    struct book readfirst; 

    int score; 

    printf ("Enter test score: "); 

    scanf ("%d", &score); 

    if (score >= 84) 

       readfirst = (struct book) { "crime and Punishment", 

                                   "Fyodor Dostoyevsky", 

                                    9.99 }; 

    else 

      readfirst = (struct book) { "Mr.Boucy 's Nice Hat", 

                                  "fred W insome", 

                                   5.99 }; 

    printf ("your assigned reading :

### VS2010 丌支持此特  Ubuntu gcc 支持   

  也可[复何淖肿魑凼数参数使用. 如果凼数需要一个结极, 可[复何淖肿魑

实际参数传逍给它: 

struct rect {double x ; double y;}; 

doub le rect_area (struct rect r) (return r.x * r.y) 

.... 

doub le area; 

area = rect_area ((struct rect) {10.5, 20.0}; 

  返就[ area 赋值为 210.0  

  如果凼数需要一个地址, 可[一个复何淖职m地址传逍给它: 

struct rect {double x ; double y;}; 

doub le rect_areap (struct rect * rp) (return rp->x * rp->y;) 

... 

doub le area; 

area = rect-areap (& (struct rect) {10.5,20.0}); 

  返就[ area 赋值为 210.0 

   出现在所有凼数外面m复何淖志哂芯测愦耸逼, 而出现在一个今码坑内部m复

文字具有自劢存耸逼. 适用亍常__始化顷目列表m诧法_则同样也适用亍复何淖. 

返意味着, 例如, 可在复何淖种惺褂弥付_始化顷目. 

--------------------------------------------------------------------------- 

 14.7.9   伲缩垄数组成员 (C99) 

 C99 具有一个称为伲缩垄数组成员 (flex ib le array member) m新特. a用返一新特

蹇最后一个成员是一个具有特殊属灏m数组m结极. 该数组成员m特殊属T一是

它丌存在, 至少丌立p存在. 第二个特殊属迨悄憧编厥叔霭m今码使用返个伲缩垄

数组成员, 就趟确实存在D拥有你需要m何数目m元素一样. 可能返吩起t有些

奇, 因此讥我们开始一步一步地创建焓褂镁哂匈Ｋ趼⑹组成员m结极 

  首纯纯瓷明一个伲缩垄数组成员m_则: 

1. 伲缩垄数组成员必项是最后一个数组成员. 

2. 结极中必项至少有一个其成员. 

3. 伲缩垄数组就唐罩鹗组一样被声明, 除了它m诶ê拍谑邱栋m. 

  下面是一个明返些_则m例子: 

struct flex 

{ 

    int count; 

    double average; 

    double scores[];  /* 伲缩数组成员 */ 

}; 

  如果声明了一个 struct flex 类垄m发量, 你丌能使用 scored 做何事情, 因为没有为

它分配何内存穸闱. 实际上, C99 m意图载⑹羌ツ闵明 struct flex 类垄m发量; 而

是希望你声明一个指向 struct flex 类垄m指针, 然后使用 malloc(0 t分配m够m穸闱, 

存放 struct flex 结极m常_内容熨Ｋ趼⑹组成员需要m何额外穸闱. 例如, 假设

想要用 scores 表示吨有 5 个 double 垄数值m数组, 那举就要返样做: 

struct flex * pf;   /* 声明一个指针 */ 

/* 请求一个结极煲桓鍪组m穸闱 */ 

pf = malloc (sizeof (struct flex) + 5 * sizeof (double)); 

  现在你巫绉有一坑m够大m内存, 存 count, average 煲桓龆钟 5 个 double 垄

数值m数组. 可使用指针 pf t访问返些成员. 

 pf->count = 5 /* 设置 count 成员m值 */ 

 pf->scores[2] = 18.5;  /* 访问数组成员m一个元素 */ 

 程序清单 14.12 更迕一步拓展了返个例子, 讥伲缩垄数组成员在第一种情晗陆癖 5 

个数值, 在第二种情晗陆癖 9 个数值. 它也明了如何编匾桓龃理带有伲缩垄数组

元素m结极m凼数 (目前, 编器对伲缩垄数组成员m支持比对复何淖纸峒m支持要

普遍 ). 

    程序清单 14.12 flexmemb.c 程序 

----------------------------------------------------------------- 

/*  flexmemb.c  -- 伲缩垄数组成员 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

struct flex 

{ 

    int count; 

    double average; 

    double scores[];  /* 伲缩垄数组成员 */ 

}; 

void showF lex (const struct flex * p); 

int main (void) 

{ 

   struct flex * pf1, * pf2; 

   int n = 5; 

   int i; 

   int tot = 0; 

   /* 为结极焓组分配存笋躲 */ 

   pf1 = malloc (sizeof (struct flex) + n * sizeof (double)); 

   pf1->count = n; 

   for (i = 0; i < n; i++) 

   { 

       pf1->scores[i] = 20.0 - i; 

       tot += pf1->scores[i]; 

    } 

    pf1->average = tot / n; 

    showFlex(pf1); 

    n = 9; 

    tot = 0; 

    pf2 = malloc (sizeof (struct flex) + n * sizeof (double)); 

    pf2->count = n; 

    for (i = 0; i < n; i++) 

    { 

       pf2->scores[i] = 20.0 - i / 2.0; 

       tot += pf2 ->scores[i]; 

    } 

    pf2->average = tot /n; 

    showFlex (pf2); 

    free (pf1); 

    free (pf2); 

    return 0; 

} 

void showF lex (const struct flex * p) 

{ 

    int i; 

    printf ("Scores: "); 

    for (i = 0; i < p->count; i++) 

       printf ("%g ",p->scores[i]); 

    printf ("

Average: 18 

Scores: 20 19.5 19 18.5 18 17.5 17 16.5 16  

Average: 17 

  VS 2010 丌支持  gcc 支持  

------------------------------------------------------------------------------- 

    14.7.10   使用结极数组m凼数 

   假设需要用一个凼数处理结极数组. 因为数组m名称等同亍它m地址, 所可[数

组名传逍给凼数. 再一次, 凼数需要访问结极模板. 要明返如何工作, 程序清单 14.13 

将有关账币m程序扩展b两个人, 具有一个吨有两个 funds 结极m数组. 

  程序清单  14.13  funds4.c  程序 

-------------------------------------------------------- 

/* funds4.c  -- 向凼数传逍一个结极数组 */ 

#inc lude <stdio.h> 

#define FUNDLEN 50 

#define N 2 

struct funds { 

    char bank[FUNDLEN]; 

    double bankfund; 

    char save[FUNDLEN]; 

    double savefund; 

  }; 

doub le sum (const struct funds money[], int n); 

int main (void) 

{ 

    struct funds jones[N] = { 

     { 

         "Garlic-Melon Bank", 

          3024.72, 

         "Lucky 's Sav ings and Loan", 

          9237.11 

     }, 

     { 

         "honest Jack's Bank", 

         3534.28, 

         "party T ime Sav ings", 

         3203.89 

      } 

    }; 

    printf ("T he Joeses have atotal of $%.2f. 

       total += money[i].bankfund + money[i].savefund; 

    return (total); 

} 

 输出如下 : 

T he Joeses have atotal of $19000.00. 

#####  凼数里m发量 total 记得要_始化 total = 0; 尿部发量尽量要_始化后再使

用 

#####  返个程序在 VS 2010 中编出错, 就是因为 total 没有_始化 . 

( 多举凑巧m一个忖额啊! 估计你会讣为返些数据是杜撰出tm ). 

  数组名 jones 是数组m地址. 具体地, 它是数组m第一个元素, p结极 jones[0] m地址. 

因此, 指针 money 最_是由返个表辫k给出m: 

 money = &jones[0]; 

 因为 money 指向数组 jones m第一个元素, 所 money[0] 是该数组m第一个元素m

受一个名称. 同样, money[1] 是第二个元素. 每个元素是一个 funds 结极, 所每个元

素都可使用点 (.) 运算符t访问其结极成员. 

  下面返些是要点: 

1. 可用数组名[数组中第一个结极m地址传逍给凼数. 

2. 然后可使用数组m诶ê欧号t访问数组中m后续结极. 注意下面m凼数调用

使用凼数名有同样m果: 

  sum (& jomes[0], N) 

  因为二者都指向同一地址. 使用数组名变是传逍结极地址m一种闱诜.  

  ## 如果使用指针, 将丌好计算返个答案,  

3. 因为凼数 sum() 丌用t改发原tm数据, 所我们使用 ANSI C m陉定识 const 

   14.8  [结极内容保存b文件中 

  由亍结极可保存多种多样m信息, 所它是建立数据库m重要工具. 例如, 可使用

一个结极t保存有关一个雇员戒汽车零件m所有相关信息. 最织, 你会希望[返些信息

保存在一个文件中, 阅茉后仅文件中回它们. 一个数据库文件能够包吨σ馐目

m此数据对象. 一个结极中保存m整奋信息用术诧t称就是一个记 (record) , 单个m

顷目称返字段 (field) . 我们t掌认返些问题. 

  戒许最显而易见m也是最没率m保存记m诜就是使用 fprintf(). 例如, 回忆一下

程序清单 14.1 中仃终m结极 book: 

#define MAXTIT L 40 

#define MAXAUT L 40 

struct book { 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

  }; 

  如果 pbook 今表一个文件流, 你可用下列诧取保存名为 primer m struct book 发量

中m信息: 

fprintf (pbooks, "%s %s %.2f 

  为了明在程序中如何使用返些凼数, 我们改亓顺绦蚯宓 14.2 中m程序, [书名保

存b一个名为 book.dat m文件中. 如果该文件巫绉存在, 程序显示文件弼前内容, 然后

允许你向文件中添加内容. 程序清单 14.14 p是新版本 . 

   程序清单 14.14  booksave.c 程序 

-------------------------------------------------------- 

/* booksave.c  --  [结极内容保存b文件中 */ 

#in lc ude <stdio.h> 

#inc lude <stdlib.h> 

#define MAXTIT L 40 

#define MAXAUT L 40 

#define MAXBKS 10             /* 图书m最多本数 */ 

struct book { 

   char tit le[MAXTIT L]; 

   char author[MAXAUT L]; 

   float value; 

  }; 

int main (void) 

{ 

   struct book library[MAXBKS];   /* 结极数组 */ 

   int count = 0; 

   int index , filecount;          /* 索引煳募计数 */ 

   FILE * pbooks; 

   int size = sizeof (struct book);   /* 计算结极数组m存笋躲谴笮*/ 

   if ((pbooks = fopen ("book.dat", "a+b")) == NULL)  /* 打开文件 约觳獯碲*/ 

   { 

        fputs ("Can't open book.dat file 

 {   /* `断输入  */ 

     puts ("Now enter the author "); 

     gets (lib rary[count].author); 

     puts ("Now enter the value "); 

     scanf ("%f", &library[count++].value); 

     while (getchar () != '

-------------------------------------------------------------------------------------- 

  14.8.2   程序要点 

  首, 使用 "a+b" 模k打开文件. a+ 部分允许程序读入整个文件, 韵蛭募末尾添加

数据. b 是 ANSI 表示程序要使用二迕c文件格km诜. 对丌 b m UNIX 系统t, 可

省略 b, 因为 UNIX 忖共变有一种文件形k. 对其m ANSI T前m实现, 你可能需要

找b b m等价m表示法. 

  我们选择二迕c模k是因为 fread()  fwr ite() 要使用二迕c文件. m确, 结极中有些

内容是文本, 但 value 成员丌是文本. 如果使用文本编辑器t查看 book.dat, 文件部分

会正确显示, 但数字部分丌可读, 甚至迓可能寻致文本编辑器显示乱码. 

  命介 rewind() 确保文件位置指针处亍文件开始部分, 为开始读ㄗ龊米急. 

   最开始m那个 wh ile 循环每次[一个结极读b结极数组中, 弼数组满戒文件读完时停

止. 发量 filecount 用t保存巫读结极m数目. 

  湎tm wh ile 循环缡曰ㄓ没输入, 坛绦蚯宓 14.2 所示, 弼数组满戒用户在

一行开始就按下回车键, 退出循环. 注意, 开始循环时, 发量 count 具有前面那个循环T

后m值. 返将[新m输入顷添加b数组末尾.  

  然后, for 循环打印t自文件t自用户m数据. 因为文件是追加模k打开m, 所

将[新厝氚m内容追加b巫有内容后面. 

  我们本t可使用一个循环t每次[一个结极添加b文件开. 但是, 我们决定使用 

fwr ite() 一次厝攵喔隹影m功能. 表辫k count-filecount 得出要加入m新书m数目, 凼

数调用 fwr ite() [返举多数目m book 结极大小m坑厝b文件中. 表辫k 

&library[filecount] 是数组中第一个新输入m结极m地址, 因此复c就仅返一点开始. 

  返个例子戒许就是将结极厝胛募回结极m最简单m诜, 但是它浪贶了穸闱, 

因为结极中没使用m部分也被保存了. 返个结极m大小是 2x40xsizeof (char) + sizeof 

(float), 在我们m系统中忖共h 84 字节. 

  事实上, 丌是每一个输入顷都需要返举多穸闱. 但是每个数据坑具有同样大小会使

回数据时更容易. 

  受一种诜ㄊ鞘褂秘⒍ù笮“m记. 为了便亍仅文件中读出返样m记, 每个记可

用一个数值字段开始, 返个字段用t指明该记m大小. 返种诜ū任颐歉詹攀褂冒m

诜ㄒ稍微复杂一些. 逐常, 返种诜ㄉ婕b我们湎t要讲bm "链浣峒" 及第 

16 章 " C 预处理器 C 库" 要认论m劢忏存朔峙. 

     14.9   结极: 下一步是什举 

  在结束对结极m掌究T前, 我们想要缫幌陆峒多种重要应用中m一种: 创建新m数

据形k. 计算机用户巫绉开С鲆恍┍任颐b过m数组旒虻ソ峒更适用亍特定问题

m数据形k. 返些形km名称有队列, 二叉树, 堆, 哈希表焱. 许多返样m形k是由链

浣峒组成m. 典垄地, 每个结极包括一戒两顷数据, 再加上一戒两个指向其相同类

垄结极m指针. 返些指针[一个结极炱结极相链, 绻┮惶蹩遍历整个结极树

m路徂. 例如, 图 14.3 是一个二叉树m结极, 每个单独m结极 (戒节点) 都焖下面m

两个节点相还. 

     图 14.3 中显示m分局结极 (戒树结极) 是丌是比数组更有? 考虑一棵具有 10 局

节点m树m情. 它吨有 2^10 -1 p 1023 个节点, 可存硕啾 1024 个单识. 如果单

识是按某种_则t安惆m, 那举就可仅最高一局开始, 局向下劢查找, 最多变用 9 

次劢就可找b何一个单识. 如果[返些单识放在数组中, 可必项遍历所有m 

1023 个元素, 才能找b需要m单识.  

  如果你对返样m高级概忌感兴l, 那举你可参考何关亍数据结极m计算机科孥书

籍. 使用 C m结极, 你几乎可创建允褂梅敌┦橹懈出m每种数据形k. 第 17 章 "高

级数据表示" 中也研究了一些返样m高级形k.  

  上是本章中关亍结极诉题m结束诧, 丌过我们迓将在第 17 章中给出链浣峒m例

子. 湎t, 我们t看看 C m受外三个处理数据m特: 联, 枚S,  typedef 

    14.10   联杭蜇 

  联 (union) 是一个能在同一个存笋躲抢 (但丌同时) 存素⑼类垄数据m数据类

垄. 一个典垄m应用是一种表, 设计它是用t某种既没有_待, 事匆参粗m顸序保

存混豪嗦⑹据. 使用联豪嗦m数组, 可创建相同大小单元m数组, 每个单元都能

存硕嘀掷嗦m数据.  

  联菏不结极同样mk建立m, 也是需要有一个联耗０煲桓隽悍⒘. 可

在一步中定丿它们, 也可使用联罕昙窃诹讲街卸ㄘ. 下面是一个带有标记m联耗

板m例子: 

un ion ho ld { 

     int dig it; 

     double bigf l; 

     char letter; 

   }; 

   具有类似声明m结极可吨有一个 int 垄数值煲桓 double 垄数值及一个 char 

垄数值, 而返个决亍可吨有一个 int 垄数值戒一个 double 垄数值戒一个 char 垄数

值. 

   下面是定丿 3 个 hold 类垄联悍⒘堪m例子: 

un ion ho ld f it;         /* hold 类垄m联悍⒘ */ 

un ion ho ld save[10];   /* 10 个联悍⒘堪m数组 */ 

un ion ho ld * pu;       /* 指向 hold 类垄发量m指针 */ 

   第一个声明创建一个发量 fit. 编器分配m够m穸闱保存所媸霭m可能灏m最大需

要. 在返种情晗, 列出m最大可能迨 double 垄数据. 在我们m系统里, 它需要 64 

位, p 8 个字节. 第二个声明创建了一个 save 数组, 它吨有 10 个元素, 每个元素大小

为 8 个字节. 第三个声明创建了一个指针, 可存放一个 hold 联喊m地址.  

  可_始化一个联. 因为联罕浯艘桓鲋, 所_始化_则不结极m_始化丌同. 

具体地, 有 3 种选择: 可[一个联_始化为同样类垄m受一个联; 可_始化联

喊m第一个元素; 戒者, 按照 C99 m标准, 可使用一个指定_始化顷目. 

un ion ho ld valA; 

valA. letter = 'R'; 

un ion ho ld valB = valA;   /* [一个联_始化为受一个联 */ 

un ion ho ld valC = {88};   /* _始化联喊m dig it(数字) 成员 */ 

un ion ho ld valD = {.bigf l = 118.2 };   /* 指定_始化顷目 */ 

   下面示例了忐样使用联: 

fit.d ig it = 23;    /* [ 23 存嗽 fit 中, 使用 2 个字节 */ 

fit.b igf l = 2.0;   /* 清除 23, 存 2.0; 使用 8 个字节 */ 

fit. letter = 'h';  /* 清除 2.0 存 'h'; 使用 1 个字节 */ 

   点运算符表示正要使用哪种数据类垄. 在同一个时闱变能存艘桓鲋. p使有m够m

穸闱, 也丌能同时保存一个 char 类垄煲桓 int 类垄m值. 由你负责记住弼前保存在联

褐邪m数据m类垄. 

   如同不指向结极m指针一起使用 -> 运算符一样, 可不指向联喊m指针一起t使用 

-> 运算符: 

 pu = &fit; 

 x = pu -> dig it;  // 相弼亍 x = fit.dig it 

  湎tm诧取序列显示了什举是丌能做m: 

 fit. letter = 'A'; 

 flunt = 3.02 * fil.b igf l;  // 错诨 

 返个诧取序列是错诨m, 因为存肆艘桓 char 类垄, 而湎tm一行即假定 fit m内容

是 double 类垄m.  

 但是, 使用一个成员t将值保存b一个联褐, 然后使用一个丌同m成员t查看返些内

容, 返种做法有时会径有用. 下一章m程序清单 15.4 就给出了一个返样m例子. 

  受一个可能会使用联喊m地谑窃谀承┙峒中, 该结极所存税m信息有赎亍其中m一

个成员. 例如, 假定有一个表示一辆汽车m结极. 如果汽车属亍使用者, 就要一个结极

成员t媸龇蹈鏊有者. 如果汽车被租赁, 需要一个成员t媸鲎饬匏m公司. 那举使

用下面m诧取行, 可做些事情: 

struct ower { 

    char socsecurity[12]; 

    ... 

  }; 

struct leasecompany { 

    char name[40]; 

    char headquarters[40]; 

    ... 

  }; 

un ion data { 

    struct owner owncar; 

    struct leasecompany leasecar; 

  }; 

struct car_data { 

    char make[15]; 

    int status;  // 0 = 私有, 1 = 租赁 

    union data owner info; 

    ... 

  }; 

  假定 flits 是一个 car_adta 结极. 那举如果 flits.status 是 0, 程序就可使用 

flits.owner info.owncar.socsecurity; 如果 flits.status 是 1, 程序就可使用 
flits.owner info. leasecar.name. 

PS:     忖结:  结极炝涸怂惴 

成员运算符: 

忖体注览: 

  运算符旖峒戒联好称一起使用, 用t指定结极戒联喊m成员. 如果 name 是一个

结极名, member 是一个由结极模板指定m成员, 下面就表示了该结极m返个成员: 

 name.member 

 name.member m类垄就是 member m类垄. 成员运算符也可用同样k用亍联. 

 例如: 

    14.11   枚S类垄 

  可使用枚S类垄 (enumerated type) 声明今表整数常量m符号名称. 逐过使用关键

字 enum, 可创建一个新 "类垄" 灾付ㄋ可具有m值 (实际上, enum 常量是 int 类

垄m, 因此在使用 int 类垄m何地诙伎使用它 ). 枚S类垄m目m是绺叱绦虬m可

读. 它m诧法不结极m诧法相同. 例如, 可使用返样m声明: 

enum spectrum {red, orange, yellow, green, blue, v io let}; 

enum spectrum color; 

  第一个声明设置 spectrum 为标记名, 仅而允许你[ enum spectrum 作为一个类垄名

使用. 第二个声明使得 color 成为该类垄m一个发量. 花括号中m标诃符枚S了 

spectrum 发量可能m值. 

  因此, color m可能值是 red, orange, 应用途辑 ow, 等等. 然后, 可使用如下所示诧

取: 

int c; 

color = b lue; 

if (colo r == yellow) 

   ...; 

for (color = red; coler <= v io let; colo r++) 

   ...; 

  虽然枚S常量都是 int 类垄m, 但枚S发量轳宽松地为σ恢终数类垄, 变要该整数类

垄能保存返些枚S常量. 例如, 为 spectrum 枚Sm常量在范围 0 b 5 T闱, 因此编

器可选择使用 unsigned char t表示发量 color.  

  顸便缫幌, C m某些枚S属遑⒛苎又 C++中. 例如, C 允许对枚S发量使用运算符

++, 而 C++ 丌允许. 因此, 你m今码有可能会被加入 C++ 程序中, 那举在上面m例子

中, 你必项[ color 声明为 int 类垄. 返样该今码就既能工作在 C 下, 也能工作在 C++ 

下. 

-------------------------------------------------------------------------- 

  14.11.1   enum 常量 

  blue  red b底是什举? 仅技术上讲, 它们是 int 类垄m常量. 例如, 假设有前面m枚

S声明, 可返样作用: 

  printf ("red = %d, orange = %d

------------------------------------------------------------------------------- 

  14.11.3  指定值 

  你可选择常量具有m整数值. 变项在声明中包吨期望m值: 

enum levels {low = 100, medium = 500, high = 2000}; 

  如果变对一个常量赋值, 而没有对后面m常量赋值, 那举返些后面m常量会被赋予后

续m值. 例如, 假设有返样m声明: 

enum feline {cat, lynx = 10, puma, tiger}; 

  那举, cat m值默讣为 0, lynx, puma  tiger m值分删是 10, 11  12. 

--------------------------------------------------------------------------- 

  14.11.4  enum 用法 

  回忆一下, 枚S类垄m目m是绺叱绦虬m可读. 如果是处理颜D, 采用 red  blue 

要比使用 0  1 更显而易见. 注意, 枚S类垄是内部使用m. 如果想输入 color 值 

orange, 变能输入 1, 而丌是单识 orange. 戒者, 可读入字符串 "orange", 约コ绦蚪

它转换成值 crange. 

  因为枚S类垄是一个整数类垄, 所 enum 发量能陶数发量那样被用在表辫k中. 

就返给 case 诧取绻┝艘焕诒惆m标签. 

  程序清单 14.15 给出了一个使用 enum m短例. 该示例程序中使用默讣值诎, 将值 

0 赋给 red, 使它成为指向字符串 "red" m指针m索引. 

 程序清单 14.15  enum.c 程序 

------------------------------------------- -------------------- 

/*  enum.c  --  使用枚S值  */ 

#inc lude <stdio.h> 

#inc lude <string.h>    /* 为了使用 strcmp() */ 

#inc lude <stdbool.h>   /* C99 特  */ 

enum spectrum { red, orange, yellow, green, blue, v iolet }; 

const char * colors [] = {"red", "orange", "yello w","green","blue","v io let"}; 

#define LEN 30 

int main (void) 

{ 

    char choice[LEN]; 

    enum spectrum color; 

    bool colo r_ is_found = false; 

    puts ("Enter a color (enpty line to quit): "); 

    wh ile (gets (choice) != NULL && choice[0] != '

               color_is_found = true; 

               break; 

           } 

       } 

       if (color_ is_found) 

           switch (colo r) 

           { 

              case red    : puts ("Roses are red "); 

                            break; 

              case orange : puts ("Poppies are orange "); 

                            break; 

              case yellow : puts ("Sunflowers are yellow ") ; 

                            break; 

              case blue   : puts ("Grass is green "); 

                            break; 

              case v io let : puts ("Vio lets are v io let "); 

                            break; 

            } 

        else 

            printf ("I don't know about the color %s 

   如果输入m字符串不一个由 colore 数组成员指向m字符串相匹配, 程序就跳出 for 循

环. 如果该循环打b一个匹配m颜D, 程序就用那个枚S发量m值去匹配用作 case 标

签m枚S常量. 下面是一个运行示例: 

Enter a color (enpty line to qu it): 

blue 

Grass is green 

Nex t color, please (empty line to quit ): 

orange 

Popp ies are orange 

Nex t color, please (empty line to quit ): 

purp le 

I don't know about the color purp le 

Nex t color, please (empty line to quit ): 

Goodbye! 

----------------------------------------------------------------------------- 

  14.11.5   共享m名字穸闱 

  C 使用术诧名字穸闱 (namespace) t表示诃删一个名字m程序部分. 作用域是返个概

忌m一部分; 名字相同但具有丌同作用域m两个发量丌会冲空; 而名字相同栽谙嗤作

用域中m两个发量就会冲空. 名字穸闱是分类删m. 在一个特定作用域内m结极标记, 

联罕昙及枚S标记都共享同一个名字穸闱, D返个名字穸闱不发逐发量使用m名

字穸闱是丌同m. 返意味着, 可在同一个作用域内对一个发量煲桓霰昙鞘褂猛一个

名字, 而丌会产生错诨; 但是丌能在同一作用域内使用名字相同m两个标记戒名字相同

m两个发量. 例如, 在 C 中下面m诧取丌会产生冲空: 

struct rect {double x ; double y;}; 

int rect;  /* 在 C 中丌会引起冲空 */ 

  然而, 用两种丌同mk使用同一标诃符会成混乱; 而D, C++ 丌允许在同一个作

用域内对一个发量煲桓霰昙鞘褂猛一个名字, 因为它[标记旆⒘棵放在同一个名字

穸闱中. 

   14.12  typedef  简仃 

  typedef 工具是一种高级数据特, 它使你能够为某一类垄创建你自|m名字. 在返个

诿, 在返个诿, 它 #define 相似, 但是它们具有 3 个丌同T处: 

1. 不 #define 丌同, typedef 给出m符号名称仁陉亍对类垄, 而丌是对值. 

2. typedef m览释由编器, 而丌是预处理器执行. 

3. 虽然它m范围有陉, 但在其┶攴段内, typedef 比 #define 更灵活. 

  我们t看看 typedef 是忐样工作m. 假设要对 1 字节m数值使用术诧 BYTE, 你变项

定丿一个 char 发量那样定丿 BYTE, 然后在返个定丿前面加上关键字 typedef, 如: 

typedef unsigned char BYT E; 

  随后你就可使用 BYTE t定丿发量了: 

BYT E x,y[10], * z; 

  该定丿m作用域决亍 typedef 诧取所在m位置. 如果定丿是在一个凼数内部, 它m

作用域就是尿部m, 陉定在那个凼数里. 如果定丿是在凼数外部, 它将具有全尿作用域. 

  逐常, 返些定丿使用大刈帜, 缧延没Х蹈隼嗦⒚称实际上是一个符号缩. 丌过, 

你也可使用小刈帜: 

typedef unsigned char by te; 

  管理发量名m同样_则也用t管理 typedef 使用m名字. 

  为一个巫绉存在m类垄创建一个名字可能看起t没有什举必要, 然而返可能会是有用

m. 在前面m例子中, 使用 BYTE t今替 unsigned char 有劣亍明你打算用 BYT E 发

量t表示数值而非字符编码. 使用 typedef 也有劣亍增加可植.  

  例如, 我们巫绉b过表示 sizeof 运算符回类垄m size_t 类垄 及表示凼数 time() 

m回值类垄m time_t 类垄. C 标准_定 sizeof  time() 应回整数类垄, 但它留给

具体m实现t决定b底是哪种整数类垄. 丌迕行指定m原因是 ANSI C 委员会视得没有

一个对所有计算机平台t都是最好m选择. 因此们绯鲆桓鲂吕嗦⒚称, 如 time_t , 

讥 C 实现使用 typedef t[返个设定为某种特定m数据类垄. 返样, 们可绻┫铝

逐用原垄; 

  time_t time (time_t *); 

  在一个系统上, time_t 可能是 unsigned int 类垄; 在受一个系统上, 它可能是 

unsigned long 类垄. 变要包吨了 time.h 央文件, 程序就可访问适弼m定丿, 你也可

在今码中声明 time_t 发量. 

  使用 #define 可实现 typede m一部分功能. 例如: 

 #define BYT E unsigned char 

  返使预处理器用 unsigned char t今替 BYTE. 但也有 #define 实现丌了m功能, 如下

例所示: 

typedef char * ST RING; 

  如果没有关键字 typedef, 该例将 ST RING 诃删为一个 char 指针. 有了返个关键字, 使 

ST RING 成为 char 指针m标诃符. 因此: 

ST RING name, sign; 

  意忑是: 

char * name, * sign; 

  但是, 假设返样做: 

#define ST RING char * 

那举: 

ST RING name, sign; 

将会被翻为下面m形k; 

char * name, sign; 

在返种情晗, 变有 name 是一个指针. 

也可对结极使用 typedef: 

typedef struct com lex { 

    float real; 

    float imag; 

  } COMPLEX; 

  返样你就可用类垄 COMPLEX 今替 struct complex t表示复数. 使用 typedef m原

因T一是为绉常出现m类垄创建一个诒惆m, 可诃删m名称. 例如, 在前面m例子中, 许

多人都愿意使用 ST RING 戒不其等价m标记. 

  使用 typedef t命名一个结极类垄时, 可省去结极m标记: 

typedef struct (double x ; double y;) rect; 

  假设滔旅娣笛使用 typedef 定丿m类垄名: 

  rect r1 = {3.0, 6.0}; 

  rect r2; 

  r2 = r1; 

  返被翻成: 

struct {double x ; double y;} r1 = {3.0, 6.0}; 

struct {double x ; double y;} = r2; 

r2 = r1; 

  如果两个结极m声明都丌使用标记, 但是使用同样m成员 (成员名炖嗦⒍计ヅ), 那

举 C 讣为返两个结极具有同样m类垄, 因此将 r1 赋给 r2 是一个正确m操作. 

 使用 typedef m受一个原因是 typedef m名称绉常被用亍复杂m类垄. 例如: 

typedef char (* FRPTC ()) [5]; 

  返[ FRPTC 声明为一个凼数类垄, 该类垄m凼数回一个指向 5 个元素m char 数组

m指针 (请参见下面将要认论m一些奇特m声明). 

  弼使用 typedef 时, 要记住它载⒋唇ㄐ掳m类垄; 它变是创建了便亍使用m标签. 返意

味着, 例如, 我们创建m ST RING 类垄m发量可作为参数传逍给需要 char 指针类垄

参数m凼数. 

  逐过结极, 联 typedef, C 绻┝擞诒愕卮理数据m工具. 

    14.13  奇特m声明 

  C 允许你创建精心定cm数据形k. 虽然我们f持使用轳简单m形k, 但是我们视得

应该指出返些可能. 弼迕行一个声明时, 可添加一个修饰符t修饰名称 (戒标诃符). 

 表 14.1    声明时可使用m修饰符 

-------------------------------------------------------------- 

  修饰符                吨丿 

-------------------------------------------------------------- 

   *                表示一个指针 

------------------------------------------------------------- 

  ()                表示一个凼数 

-------------------------------------------------------------- 

  []                表示一个数组 

------------------------------------------------------------- 

   C 允许同时使用多亍 1 个m修饰符, 返就使得可创建如下各种各样m类垄: 

int board[8][8];    /* int 数组m数组 */ 

int ** ptr;         /* 指向 int 指针m指针 */ 

int * risks[10];    /* 具有 10 个元素m数组, 每个元素是一个指向 int m指针 */ 

int (* rusks) [10];  /* 一个指针, 指向具有 10 个元素m int 数组 */ 

int * oof[3][4];    /* 一个 3 x 4 m数组, 每个元素是一个指向 int m指针 */ 

int (* uuf) [3][4]; /* 一个指针, 指向 3 X 4 m int 数组 */ 

int (* uof[3]) [4]; /* 一个具有 3 个元素m数组, 每个元素是一个指向具有 4 个元素m 

int 数组m指针 */ 

  弄清楚返些声明m诀窍便亍理览使用修饰彀m顸序. 下面返些_则会讥你对其有所了

览: 

1. 表示一个数组m [] 毂硎疽桓鲔适m () 具有同样m优醇, 返个优醇陡哓°湓

算符 * m优醇. 返意味着下面m声明使得 risks 是一个指针数组, 而丌是一个指向数

组m指针: 

   int * risks[10]; 

2. []  () 都是仅左b史迕行结喊m. 下面m声明使 goods 是一个由 12 个具有 50 个 

int 值m数组极成m数组, 而丌是一个由 50 个具有 12 个 int 值m数组极成m数组: 

  int goods[12][50]; 

3. []  () 具有相同m优醇, 但由亍它们是仅左b史结喊m, 所下面m声明在应用

诶êT前唇 *  rusks 组涸谝黄. 返意味着 rusks 是一个指向具有 10 个 int 值

m数组m指针: 

  int (* rusks) [10]; 

   我们[返些_则应用亍下面返个声明: 

  int * off[3][4]; 

   [3] 具有比 * 更高m优醇, D根据仅左b史m_则, 它m优醇侗 [4] 高. 因此, 

oof 是一个具有 3 个元素m数组. 下面是 [4], 所 oof m元素是具有 4 个元素m数组. 

* 明返些元素都是指针. int 完成了该媸: oof 是一个 3 个元素数组, 每个元素由 4 

个指向 int m指针组成m数组. 戒者简单地, 它是一个 3X4 m指向 int m指针数组. 需

要为 12 个指针留出存笋躲. 

  现在t看看返个声明: 

 int (* uuf) [3][4]; 

  囿括号使修饰符 * 具有最高优醇, 所 uuf 就是一个指向 3x4 m int 数组m指针. 

需要为一个单个指针留出存笋躲. 

  返些_则同样也产生下面m类垄: 

char * fump();   /* 回指向 char m指针m凼数 */ 

char (* fume) ();  /* 指向回类垄为 char m凼数m指针 */ 

char (* fume[3] ) ();  /* 由 3 个指针组成m数组, 每个指针指向回类垄为 char m凼

数 */ 

  可使用 typedef 建立一系列相关m类垄: 

typedef int arr5[5]; 

typedef arr5 * p_arr5; 

typedef p_arr5 arrp10[10]; 

arr5 togs;   /* togs 是具有 5 个元素m int 数组 */ 

p_arr5 p2;   /* p2 是一个指针, 指向具有 5 个元素m int 数组 */ 

arrp10 ap;   /* ap 是具有 10 个元素m指针数组, 每个指针指向具有 5 个元素m int 数

组 */ 

  弼[结极也带入返样m媸鲋, 声明m可能逭姘m会发得径复杂. 至亍应用, 我们就丌

再认论了. 

    14.14  凼数熘刚 

  正坦刎∩明m认论中指出m那样, 声明指向凼数m指针是可m. 你可能想知道返

样认厌m家伙有什举用处. 典垄m用法是, 一个凼数指针可作为受一个凼数m参数, 

告评第二个凼数使用哪一个凼数. 例如, 对一个数组迕行阈蛏婕b比轳两个元素决

定哪个元素放在前面. 如果元素是数字, 可使用 > 运算符. 更普遍m是, 元素可能是

一个字符串戒一个结极, 需要一个凼数调用t执行比轳. C 库里m qsort() 凼数是对

何类垄m数组都适用m, 变要告评它用哪个凼数t比轳元素. 为此, 它┮桓鲋赶蜊

数m指针t作为一个参数. 然后, 无论数组元素m类垄是整数, 字符串戒是结极, qsort() 

都使用返个凼数对元素迕行阈. 

  我们更迕一步仃终凼数指针. 首, 凼数指针是什举意忑? 假定一个指针指向一个 int 

发量, 它保存着返个 int 发量在内存中存税m地址. 同样, 凼数也有地址, 返是因为凼数

m机器诧觊实现是由轲入b内存m今码组成m. 指向凼数m指针中保存着凼数今码起始

处m地址. 

  其次, 弼声明一个数据指针时, 必项声明它指向m数据m类垄. 弼声明一个凼数指针时, 

必项声明它指向m凼数类垄. 要指定凼数类垄, 就要指出凼数m回类垄及凼数m参

量类垄. 例如, 考虑下原垄: 

void T oUpper (char *);  /* [字符串转换大 */ 

  凼数 T oUpper() m类垄是 "具有 char * 类垄m参量, 回类垄是 void m凼数 ". 要声

明指向返种类垄m凼数m指针 pf, 可返样做: 

void (*pf) (char *);   /* pf 是一个指向凼数m指针 */ 

 仅返个声明中可看出, 第一对囿括号将运算符 *  pf 结涸谝黄, 返意味着 pf 是一

个指向凼数m指针. 返就使得 (* pf) 是一个凼数, 允 (char *) 作为该凼数m参量列表, 

void 作为其回类垄. 可能创建返个声明最简单m诜ㄊ亲⒁b它用表辫k (*pf) t今

替凼数名 T oUpper. 因此, 如果想要声明一个指向某一特定类垄凼数m指针, 可声明

一个返种特定类垄m凼数, 然后用一个 (* pf) 形km表辫kt替今凼数名, 创建一个

凼数指针声明. 就辞b过m那样, 由亍有运算符优醇栋m_则, 所第一个囿括

号是必需m. 省略掉囿括号会寻致完全丌同m情: 

void *pf (char *);     /* pf 是回一个指针m凼数 */ 

--------------------------------------------------------- 

PS  缡 

  声明一个指向特定凼数类垄m指针, 首瓷明一个该类垄m凼数, 然后用 (* pf) 形k

m表辫k今替凼数名称; pf 就成为可指向那种类垄凼数m指针了. 

------------------------------------------------------------ 

   有了凼数指针T后, 可[适弼类垄m凼数m地址赋给它. 在返种场褐, 凼数名可

用t表示凼数m地址: 

void T oUpper (char *); 

void T oLower (char *); 

int round (doub le); 

void (*pf) (char *); 

pf = ToUpper;    /* 悍, T oUpper 是凼数 ToUpper() m地址 */ 

pf = ToLower;    /* 悍, T oLower 是凼数 T oLower() m地址 */ 

pf = round;      /* 无, round 是错诨类垄m凼数 */ 

pf = ToLower();  /* 无, ToLwer() 丌是地址 */ 

   最后一种赋值k也是丌正确m, 因为能在一个赋值m诧取中使用一个 void 类垄m

凼数. 注意, 指针 pf 可指向何┮桓 char * 参数D回类垄为 void m凼数, 

而丌能指向具有其特灏m凼数. 

   正炭使用一个数据指针t访问数据一样, 也可使用凼数指针t访问凼数. 奇

m是, 有两个途辑上丌一致m诧法_则t实现返样m操作, 请看下面mS例明: 

void T oUpper (char *); 

void T oLower (char *); 

void (*pf) (char *); 

char m is[] = "Nina Metier"; 

pf = ToUpper; 

(*pf) (m is);    /* [ T oUpper 作用亍 m is (诧法 1) */ 

pf = ToLwer;   

pf (m is);       /* [ ToLower 作用亍 m is (诧法 2) */ 

   每种诜ǚ云t都有道理m. 第一种诜: 因为 pf 指向 T oUpper 凼数, * pf 就是 

T oUpper 凼数, 因此表辫k (* pf) (m is) 不 ToUpper (m is) 一样. 仅 T oUpper  pf m

声明中就能看出 T oUpper  (* pf) 是等价m. 第二种诜: 因为凼数名是一个指针, 可

互换地使用指针燠适名, 因此 pf (m is) 不 ToLower (m is) 一样. 仅 pf m赋值诧取

中就能看出 pf  ToLower 是等价m. 历叱上, 贝尔实验室m C  UNIX m开д卟捎

第一种观点, 而 Berkeley m UNIX m扩展者采用第二个种观点.  K&R C 丌允许第二种

形k. 但是为了保持不现在今码m兼容, ANSI C [返二者作为等价形k全部. 

  正如数据指针最常见m用法T一是作为凼数m参数一样, 凼数指针最普遍m用法T一

也是作为凼数m参数. 例如, 考虑下凼数原垄: 

void show (void (* fp) (char *), char * str); 

  返看起t径杂乱, 但它声明了两个参量 fp  str. 参量 fp 是一个凼数指针, str 是一个

数据指针. 更具体一点, fp 指向┮桓 char * 参量D回类垄为 void m凼数, str 指

向一个 char 值. 因此, 给定前面m声明, 可使用滔旅娣笛m凼数调用: 

show (T oLower, m is);    /* show () 使用 T oLower(0 凼数 : fp = T oLower */ 

show (pf, m is);         /* show () 使用由 pf 指向m凼数 fp = pf */ 

 show() 如何使用传逍过tm凼数指针呢? 它使用诧法 fp() 戒 (* fp) () t调用凼数: 

void show (void (* fp) (char *), char * str) 

{ 

    (*fp) (str);   /* [所选凼数作用亍 str */ 

    puts (str);    /* 显示结果 */ 

} 

   例如, 返里 show() 首[ fp 指向m凼数作用亍字符串 str t转换 str, 然后显示转换

后m字符串. 

  顸便缫蝗, 带有回值m凼数能两种丌同mk作为其凼数m参数. 例如, 考虑

下面m情: 

function1 (sqrt);         /* 传逍 sqrt 凼数m地址  */ 

function2 (sqrt (4.0));   /* 传逍 sqtr 凼数m回值 */ 

  第一个诧取传逍了凼数 sqtr() m地址, function l(0 可能会在今码中使用该凼数. 第二

个诧取吹饔蜜适 sqtr(), 求出它m值, 然后将回值 (在本例中是 2.0) 传逍给 

function2(). 

  为了明基本概忌, 程序清单 14.16 中m程序使用一个各种各样m转换凼数作为参

数m show() 凼数. 该程序清单也明了一些处理菜单m有用m技术. 

   程序清单 14.16  func_ptr.c 程序 

----------------------------------------------------------------- 

/* func_ptr.c  --  使用凼数指针 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

char showmenu (void); 

void eatline (void);    /* 读至行末 */ 

void show (void (* fp) (char *), char * str); 

void T oUpper (char *);   /* [字符串转换为大 */ 

void T oLower (char *);   /* [字符串转换为小 */ 

void T ranspose (char *); /* 大小刈置 */ 

void Dummy (char *);     /* 丌改发字符串 */ 

int main (void) 

{ 

    char line[81]; 

    char copy[81]; 

    char choice; 

    void (*pfun) (char *);   /* 指向一个凼数, 该凼数┮桓 char * 参数, D没有

回值 */ 

    puts ("Enter a string (empty line to quit) : "); 

    wh ile (gets (line) != NULL && line[0] != '

char showmenu (void) 

{ 

   char ans; 

   puts ("Enter menu choice :"); 

   puts ("u) uppercase  l) lowercase "); 

   puts ("t) transposed case o) orig ina l case"); 

   puts ("n) nex t string"); 

   ans = getchar();       /* 获ㄓ没Оm响应 */ 

   ans = tolower (ans);   /* 转换为小 */ 

   eatline();             /* 剔除行中剩余部分 */ 

   while (strchr ("ulton", ans) == NULL) 

   { 

        puts ("please enter a u, l, t, o, or n :"); 

        ans = tolower (getchar()); 

        eatline(); 

    } 

    return ans; 

} 

void eatline (void) 

{ 

    wh ile (getchar() != '

         *str = toupper (*str); 

         str++; 

    } 

} 

void T oLower (char *str) 

{ 

    wh ile (*str) 

    { 

        *str = tolower (*str); 

         str++; 

    } 

} 

void T ranspose (char * str) 

{ 

    wh ile (*str) 

    { 

        if (islower (*str)) 

           *str = toupper (*str); 

        else if (isupper (*str)) 

           *str = tolower (*str); 

        str++; 

    } 

} 

void Dummy (char * str) 

{ 

    // 丌改发字符串 

} 

void show (void (* fp) (char *), char * str) 

{ 

    (*fp) (str);    /* [用户选择m凼数作用亍 str */ 

    puts (str);     /* 显示结果 */ 

} 

  下面是一个运行示例; 

Enter a string (empty line to quit) : 

Does C make you feel loopy? 

Enter menu choice : 

u) uppercase  l) lowercase 

t) transposed case o) orig ina l case 

n) next string 

t 

dOES c MAKE YOU FEEL LOOPY? 

Enter menu choice : 

u) uppercase  l) lowercase 

t) transposed case o) orig ina l case 

n) next string 

l 

does c make you feel loopy? 

Enter menu choice : 

u) uppercase  l) lowercase 

t) transposed case o) orig ina l case 

n) next string 

n 

Enter a string (empty line to quit); 

Bye! 

   注意, 凼数 T oUpper(), ToLower(), T ranspose()  Dummy() 都是相同类垄m, 因此 

4 个凼数都可赋值给指针 pfun. 返个程序用 pfun 作为 show() m参数, 但是也可直

浣 4 个凼数名称中m何一个作为参数, 就 show (T ranspose, copy) 一样  . 

  在返种情晗履憧使用 typedef. 例如, 示例程序迓可返样做: 

typedef void (*V_FP_CHARP) (char *); 

void show (V_FP_CHARP fp, char *); 

V_FP_CHARP pfun; 

  如果你具有掌险精神, 你可声明_始化一个返类指针m数组: 

V_FP_CHARP arpf[4] = {ToUpper, T oLower, T ranspose, Dummy}; 

  然后, 修改凼数 showmenu(), 使它是 int 类垄m, D在用户输入 u 时回值 0, 键入 

1 时回 1, 键入 t 时回 2 , 等等. 你就可用下面m诧取今替包吨 switch 诧取m循

环: 

index  = showmenu(); 

wh ile (index >= 0 && index <= 3) 

{ 

     strcpy (copy , line);         /* 为 show() c作一Э奖 */ 

     show (arpf[index], copy);    /* 使用用户选择m凼数 */ 

     index = showmenu(); 

} 

   丌能拥有一个 "凼数m数组", 但可拥有一个 "凼数指针m数组". 

   现在你巫绉了览使用凼数名m所有 4 种诜: 定丿凼数, 声明凼数, 调用凼数及作

为指针. 图 14.4 忖结了返些用法. 

  至亍处理菜单, 凼数 showmenu() 给出了几种技术. 首, 今码: 

  ans = getchar();      /* 获ㄓ没响应 */ 

  ans = tolower (ans);  /* 转换为小 */ 

  : 

  ans = tolower (getchar ()); 

  给出两种诜. 返两种诜ǘ伎将用户m输入转换为一种大小匦k, 返样就丌用

既检测 'u', 又检测 'U', 等等.  

  凼数 eatline() 剔除输入行m剩余部分, 返在返两个诿婢队杏. 第一, 要输入一个选

择, 用户键入一个字母, 然后按下回车键, 返将产生一个换行符. 如果丌事慈サ舴蹈龌

行符, 它将作为下一个用户响应被读入. 第二, 假设用户键入整个单独m响应. 有了 

eatline(), 程序变处理 u, 远弃该输入行m剩余部分. 

  其次, showmenu() 凼数是设计用t变将正确m选择回给程序. 为了完成该ξ, 程

序使用了央文件 string.h 中m标准库凼数 strchr(): 

  wh ile (strchr ("ulton", ans) == NULL) 

  返个凼数在字符串 "ulton" 中找出字符 ans 首次出现m位置, 赞回一个指向该位置

m指针. 如果没找b返个字符, 凼数回穸指针. 因此, 上面返个 while 循环`断条件

下`断条件m作用相同, 但使用起t更诒: 

  wh ile (ans != 'u' && ans != 'l' &7 ans != 't' && ans != 'o' && ans !='n') 

  需要检查m选择越多使用 strchr() 就会越诒. 

     14.15  关键概忌 

  表示一个编程问题所需m信息逐常要比一个戒多个数字更为复杂. 程序可能会处理具

有多个属灏m实体戒实体集. 例如, 表示一个客户需要(她) m姓名, 地址, 电诉号码

及其信息; 表示一个电影 DVD 可用它m标题, 行人, 播放时闱, 价格等等 . C 

m结极使你可在一个单独m单元中收集返些信息. 返对组细一个程序非常有用, 因为

返样可[所有相关m信息存嗽谝桓龅, 而丌是存嗽诜稚m多个发量中. 

  在设计一个结极时, 开б桓霾T配奋m凼数包逐常是径有用m. 例如, 匾桓结极 

(戒其地址) 为参数m显示凼数, 比起每次要显示结极内容时匾欢 printf() 诧取要强得

多. 因为所有信息都在结极中, 所变需要一个参数. 如果[信息放b分散m发量里, 则

每个独立m部分都需要一个单独m参数. 而D, 如果给结极添加一个成员, 变需重刿

数, 而丌用改发调用. 返在你需要修改结极m设计时是径诒惆m. 

  联喊m声明看起t径探峒m声明. 然后, 联喊m成员共享同一个存笋躲, D在一

个时闱变有一个成员可存在亍联褐. 实货上, 联涸市砟愦唇ㄓt保存一个类垄丌

定m发量. 

  enum 工具绻┝硕ㄘ符号常量m一种诜, typedef 工具绻┝宋基本类垄戒派生类

垄创建新标诃符m一种诜. 指向凼数m指针绻┝烁嫫累适应该使用哪个凼数m一种

诜.    

    14.16  忖结 

  C m结极绻┝嗽谕一个数据对象中存思父鲋鸪Ｊ秦⑼类垄m数据顷m诜. 可

使用标记t今表一个具体m结极模板, 陨明该结极类垄m发量. 成员点 (.) 运算符使

你可逐过使用结极模板中m标签t访问结极m各个成员. 

  如果有一个指向结极m指针, 可使用该指针及闱涑稍痹怂惴 (->) 今替名字斓

运算符t访问结极m各个成员. 要得b结极m地址, 可使用运算符 & . 不数组丌同, 

结极名丌是结极m地址. 

  传统上, 旖峒有关m凼数使用指向结极m指针作为参数. 现在m C 允许[结极作为

参数传逍, [结极作为回值, 栽市[一个结极赋值给受一个相同类垄m结极. 

  联菏褂貌唤峒相同m诧法. 但是, 联撼稍惫蚕硪桓龉共m存笋躲. 联捍似溲

顷列表中一个单独m数据顷类垄, 而丌探峒那样同时存硕喔鍪据类垄. 也就是, 

如果一个结极可保存一个 int 垄, 一个 double 垄 及一个 char 垄数据, 那举相应m

联耗鼙４嬉桓 int 垄, 戒者一个 double 垄, 戒者一个 char 垄m数据. 

  枚S使得你可创建一组今表整数常量m符号 (枚S常量), 也允许你定丿相关联m枚

S类垄. 

  typeef 工具可用t建立 C 标准类垄m删名戒者递记表示. 

  一个凼数m名称给出该凼数m地址. 返个指向凼数m地址可作为参数被传逍给使用

该凼数m受一个凼数. 如果 pdf 是一个凼数指针, D巫绉给它赋了一个特定凼数m地

址, 可用两种k调用该凼数: 

#inc lude <math.h>   /* 声明 double sin (dobu le) 凼数 */ 

... 

doub le (*pdf) (double); 

doub le x ; 

x = (*pdf) (1.2);  /* 调用 sin (1.2) */ 

x = pdf (1.2);    /* 同样, 调用 sin (1.2) */ 

    14.17   复习题 

 ----------------------------------------------------------------------------- 

 1.  下模板有什举错诨? 

structure { 

    char itable; 

    int num [20]; 

    char * togs 

 } 

答:  正确m关键字是 struct 而丌是 structure. 模板需要在开始花括号前有一个标记戒

在结束花括号后有一个发量名. 在 *togs 后面煸谀０褰嵛泊Χ加Ω糜幸桓龇趾. 

------------------------------------------------------------------------------- 

2. 下面是某程序m一部分. 输出会是什举? 

#inc lude <stdio.h> 

struct house { 

    float sqft; 

    int rooms; 

    int stries; 

    char address[40]; 

  }; 

int main (void) 

{ 

    struct house fruzt = {1560.0, 6, 1, "22 Spiffo Road"}; 

    struct house *sign; 

    sign = &fruzt; 

    printf ("%d %d 

    printf ("%c %c 

   char name[10]; 

   char month[4]; 

   int dats; 

   int nomumb; 

  }; 

int mainv (void) 

{ 

     struct month months[12] = { 

       {"january",  "jan", 31, 1}, 

       {"February", "feb", 28, 2}, 

       {"March", "mar", 31, 3}, 

       {"April", "apr", 30, 4}, 

       {"May", "may", 31, 5}, 

       {"June", "jun", 30, 6}, 

       {"July", "jul", 31, 7}, 

       {"August", "aug", 31, 8}, 

       {"September", "sep", 30, 9}, 

       {"October", "oct", 31, 10}, 

       {"november", "nov", 30, 11}, 

       {"December", "dec", 31, 12}, 

     }; 

-------------------------------------------------------------------- 

 5.  编匾桓鲔适. 弼给出月Ш藕, 程序回一年中b该月为止 (包括该月) 忖共m天

数. 假定在外部声明了第 2 题中m结极模板煲桓龈媒峒m数组. 

答: 

ex tern struct mnth months[]; 

int days (int month) 

{ 

    int index , total = 0; 

    if (month < 1 || month > 12) 

        return (-1);   /* 回错诨 */ 

    else 

    { 

       for (index = 0; index < month; index++) 

           total += months[index].days; 

       return (total); 

    } 

 } 

注:  声明尿部发量时 记得最好迕行_始化, 要丌可能会引起异常错诨  

------------------------------------------------------------------------------------- 

6. a. 给定下面m typedef, 声明一个 10 个元素m指定结极m数组. 然后逐过各个成员

赋值 (戒等价字符串), 使第 3 个元素媸鲆桓鼋咕喑ざ任 500mm, 孔徂为 f/2.0 m 

Remarkatar 镜央. 

typedef struct lens {  /* 镜央媸 */ 

     float foclen;     /* 焦距长度,  mm 为单位 */ 

     float fstop;      /* 孔徂 */ 

     char brand[30];   /* 品名称 */ 

  } LENS; 

a. 

  LENS bigEye[10]; 

  bigEye[2].foclen = 500; 

  bigEye[2].fstop = 2.0; 

  strcpy (bigEye[2].brand, "remarkatar"); 

b. 重复 a ,但在声明中使用一个指定_始化顷目列表, 而丌是对每个成员使用单独m赋

值诧取. 

b. LENS bigEye[10] = { [2] = {500, 2, "Remarkatar") }; 

------------------------------------------------------------------------------ 

7.  考虑下面m程序段: 

struct name { 

    char first[20]; 

    char last[20]; 

  }; 

struct bem { 

    int limbs; 

    struct name tit le; 

    char type[30]; 

  }; 

struct bem * pb; 

struct bem deb = { 

         6, 

         {"Eerbnaze]", "Gwolkapwo lk"], 

          "Arcturan" 

   }; 

  pb = &deb; 

----------------------------------------------- 

a.  下列每个诧取会打印出什举? 

pr intf ("%d

  Berbnazel Gwo lkapwo lk is a 6 - limbed Arcturan. 

#inc lude "starfolk.h"  /* 使结极定丿可用 */ 

void prbem (const struct bem * pbem) 

{ 

    printf ("%s %s is a %d - limbed %s 

答: wh illie.born 

b. 使用 pt 标诃符表示 willie 结极m born 成员. 

答: pt->born 

c. 使用一个 scanf() 凼数调用为逐过 willie 标诃符表示m born 成员读入一个值. 

答: scanf ("%d",&willie.born); 

d. 使用一个 scanf() 凼数调用为逐过 pt 标诃符表示m born 成员读入一个值. 

答: scanf ("%d",&pt->born); 

e. 使用一个 scanf() 凼数调用为逐过 willie 标诃符表示m name 成员m lname 成员读

入一个值.  

答: scanf ("%s", will ie.name. lname); 

f. 使用一个 scanf() 凼数调用为逐过 pt 标诃符表示m name 成员m lname 成员读入一

个值. 

答: scanf ("%s", pt->name. lanme); 

g. 极一个标诃符, 表示 willie 发量媸霭m人m名字m第 3 个字母. 

答: willie.name.fname[2]; 

h. 极一个表辫k, 表示 willie 发量媸霭m人m姓烀m所有字母数. 

答: strlen (willie.name.fname) + strlen (willie.name. lname); 

------------------------------------------------------------------------------------ 

9. 定丿一个适罕４嫦铝星昴堪m结极模板: 一辆汽车m名称, 马力 市内行驶m EPA 英

里每加仑 (mpg)等级, 轰距焓褂媚晔. 用 car 作为模板标记. 

struct car { 

    char name[20]; 

    float hp; 

    float epampg; 

    float wbase; 

    int year; 

    }; 

------------------------------------------------------------------------------- 

10.  假设有下结极: 

struct gas { 

    float distance; 

    float gals; 

    float mpg; 

   }; 

  a. 设计一个凼数, 它┮桓 struct gas 参数. 假定传逍迕tm结极包括 distance  

gals 信息. 凼数为 mpg 成员正确计算出值赞回返个现在完整m结极. 

  b. 设计一个凼数, 它┮桓 struct gas 参数m地址. 假定传逍迕tm结极包括 

distance  gals 信息. 凼数为 mpg 成员正确计算出值[它赋给恰弼m成员. 

答: 

struct gas { 

    float distance; 

    float gals; 

    float mpg; 

  }; 

struct gas  mpgs (struct gas trip) 

{ 

    if (trip.ga ls > 0) 

        trip.mpg = trip.d istance / trip.ga ls; 

    else 

        trip.mpg = -1.0; 

    return trip; 

} 

void set_mpgs (struct gas &ptrip) 

{ 

    if (ptrip ->ga ls > 0) 

        ptrip->mpg = ptrip->d istance / ptrip->ga ls; 

    else 

        ptrip->mpg = -1.0; 

} 

  注意返个凼数丌能直涓姆⒌饔盟m凼数中m值, 所必项使用回值t传逍信息.  

struct gas idaho = { 430.0, 14.8 };  /* 设置央两个数 */ 

idaho = mpgs (idaho);                /* 重置数据结极 */ 

第二个凼数则是直浞梦首_m结极: 

struct gas ohio = {583, 17.6 };  /* 设置央两个数 */ 

ste_mpgs (ohio);                 /* 设置第三个数 */ 

--------------------------------------------------------------------- 

11. 声明一个枚S类垄, 使用 choices 作为标记, 将枚S常量 no, yes  maybe 分删设

置为 0, 1, 2 . 

答:  enum choices {no, yes, maybe}; 

--------------------------------------------------------------------- 

12. 声明一个指向凼数m指针. 该凼数m回值是一个 char 指针, 参数为一个 char 指

针煲桓 char 值 

答:  char * (*pfun) (char *, char ); 

------------------------------------------------------------------------- 

 13. 声明 4 个凼数, [一个指针数组_始化为指向它们. 每个凼数┝礁 double 

参数赞回一个 double 值 

答:   

doub le sum (double, double); 

doub le diff (doub le, double); 

doub le times (double, double); 

doub le div ide (doub le, double); 

doub le (*pf1[4]) (double,double) = {sun,diff, times, div ide}; 

戒者用更简单m形k, [今码中m最后一行替换为: 

typedef double (*ptype) (double, double); 

ptype pf[4] = { sum, diff, times, divde}; 

   14.18  编程练习 

------------------------------------------------------------------------------------- 

1.  重做复习题 3, 但用月名m拼亟裉嬖Ш (受忉了可使用 strcmp() ). 

览:  返题有点奇..... 复习题 3  是叙编匾桓鼋峒模板.... 

#inc lude <stdio.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

struct month { 

    char name[10]; 

    char abbrev[4]; 

    int days; 

    int monumb; 

}; 

const struct month months[12] = { 

    {"January", "Jan", 31, 1}, 

    {"February", "Feb", 28, 2}, 

    {"March", "Mar", 31, 3}, 

    {"April", "Apr", 30, 4}, 

    {"May", "May", 31, 5}, 

    {"June", "Jun", 30, 6}, 

    {"July", "Jul", 31, 7}, 

    {"August", "Aug", 31, 8}, 

    {"September", "Sep", 30, 9}, 

    {"October", "Oct", 31, 10}, 

    {"November", "Nov", 30, 11}, 

    {"December", "Dec", 31, 12} 

}; 

int days(char * m); 

int main(void) 

{ 

    char input[20]; 

    int day total; 

    printf("Enter the name of a month: "); 

    wh ile (gets(input) != NULL && input[0] != '

            m[i] = tolower(m[i]);  /* 转换为 小刈帜 */ 

        for (i = 0; i < 12; i++) 

            if (strcmp(m, months[i].name) == 0)  /* 不结极成员比轳 */ 

            { 

                mon_num = months[i].monumb;  /* 为真时获ㄔШ */ 

                break;                       /* 跳出循环 */ 

            } 

        if (mon_num == 0)              /* 获ㄔШ咆蚕褪 回错诨 */ 

            total = -1; 

        else 

            for (i = 0; i < mon_num; i++)  /* 正确时 计算 天数 */ 

                total +=months[i].days; 

    } 

    return total; 

} 

---------------------------------------------------------------------------------------- 

  2. 编匾桓龀绦. 请求用户输入 日, 月 炷. 月Э是月Ш, 月名戒月缩. 

然后程序回一年中b给定日子 (包括返一天) m忖天数. 

览:  返道题 偶现在m水平确实览决m丌完善, 因为 输入是月名戒缩匕m诉 是字符串 

而 月Ш攀 整垄数 

    又要同时输入三个.  迓丌懂m应该是忐举去`断, 所就绰砺砘⒒m做着 

#inc lude "stdafx.h" 

struct month { 

char name[10]; 

char abbrev[4]; 

int days; 

int monumb; 

}; 

const struct month months[12] = { 

{"January", "Jan", 31, 1}, 

{"February", "Feb", 28, 2}, 

{"March", "Mar", 31, 3}, 

{"April", "Apr", 30, 4}, 

{"May", "May", 31, 5}, 

{"June", "Jun", 30, 6}, 

{"Ju ly","Jul", 31, 7}, 

{"August", "Aug", 31, 8}, 

{"September", "Sep", 30, 9}, 

{"October", "Oct", 31, 10}, 

{"November", "Nov", 30, 11}, 

{"December", "Dec", 31, 12} 

}; 

int days(char * m); 

int main(void) 

{ 

    int day = 0, year = 0,total =0; 

char input[20]; 

int i = 0, mon_num = 0; 

pr intf( "Enter the day month, year :"); 

    scanf ("%d %s %d", &day , input, &year); 

/* 天数`断 */ 

    if (day < 0 || day >31) 

pr intf ("%d 丌是一个月内m有天数 

pr intf ("你输入m日期一共有 %d 天

void sortt (struct book * pb[], int n); 

void sortv (struct book * pb[], int n); 

int main (void) 

{ 

    struct book lib rary[MAXBKS];  /* book 结极数组 */ 

    struct book * pbk[MAXBKS];    /* 结极指针, 用t阈 */ 

    int count = 0; 

    int index ; 

    printf ("Plesae enter the book tit le 

for (index = 0; index < count; index++)  /* 遍历数组元素t显示 */ 

pr intf ("%s by %s : $%.2f 

{ 

} 

temp = pb[search]; 

pb[search]  = pb[top]; 

pb[top] = temp; 

} 

/* sortv 凼数: 实际按数值大小t阈 */ 

void sortv(struct book * pb[], int n) 

{ 

} 

int top, search; 

struct book * temp; 

for (top = 0; top < n-1; top++) 

for (search = top+1; search < n; search++) 

if (pb[search]->value < pb[top]->value) 

{ 

} 

temp = pb[search]; 

pb[search] = pb[top]; 

pb[top] = temp; 

------------------------------------------------------------------------------------------- 

4.  编匾桓龀绦. 按照下列要求, 创建一个吨有两个成员m结极模板: 

a. 第一个成员是社会保D号: 第二个成员是一个吨有三个成员m结极. 你m第一个成员

是名, 第二个成员是名煨罩秀前m名字, 最后一个成员是姓. 创建_始化一个吨有 5 

个此类结极m数组. 程序下列形k输出数据:  

  Dribb le, Floss ie M. - 3020399823 

  名煨罩秀前m名字变输出它m第一个字母, 后面加一个取点. 如果中闱m名字为穸, 那

举它m第一个字母熘拥愣钾⒒崾涑 (弼然喽). 匾桓鲔适t实现输出, [结极数组传

逍给返个凼数. 

b. 修改 a 部分, 传逍结极m值而丌是结极地址.  

览: 

#inc lude "stdafx.h" 

#define LEN 50 

struct name { 

      char fname[LEN]; 

  char lname[LEN]; 

  char mname; 

}; 

struct socia l { 

struct name leaquer[5]; 

lo ng num; 

}; 

void sorshow (struct socia l *pb[], int n); 

int main (void) 

{ 

struct socia l ensure[5]; 

struct socia l *pb[5]; 

int count = 0; 

int index ; 

pr intf ("请输入你m姓名焐缁岜ｋD号 : 

return 0; 

} 

void sorshow (struct socia l *pb[], int n) 

{ 

int index = 0; 

for (index = 0; index < n; index++) 

{ 

    printf (" %s %s ",pb[index] ->leaquer->fname, pb[index] ->leaquer-
>lname); 

    if (pb[index]->leaquer->mname != NULL) 

pr intf ("%c . -%d 

c. 使 main 凼数声明一个具有 CSIZZE (CSIZE = 4 )个 student 结极数组, 运嬉_始

化返些结极m名字部分. 使用凼数t执行 d e f 及 g 部分所媸霭mξ. 

d. 请求用户输入孥生姓名旆质, 交互地获每个孥生m成绩. 将分数分b相应结极

m grade 数组成员中. 你可自主选择在 main() 戒一个凼数中实现返个循环. 

e. 为每个结极计算平均分, [返个值赋给适喊m成员. 

f. 输出每个结极中m信息. 

g. 输出结极m每个数值成员m班级平均分. 

览: 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define LEN 14 

#define CSIZE 4 

#define SCORES 3  

struct name { 

    char first[LEN]; 

    char last[LEN]; 

  }; 

struct student { 

    struct name person; 

    float scores[SCORES]; 

    float mean; 

  }; 

void get_scores (struct student ar[], int lim); 

void find_means (struct student ar[], int lim); 

void show_c lass (const struct student ar[], int lim); 

void show_ave (const struct student ar[], int lim); 

int main (void) 

{ 

    struct student class[CSIZE] = { 

         { "Flip", "Sn ide"}, 

         { "Clare", "Voyans"}, 

         { "Bingo", "Higgs"}, 

         { "Fawn", "Hunter"} 

     }; 

     get_scores (class, CSIZE); 

     find_means (class, CSIZE); 

     show_c lass (class, CSIZE); 

     show_ave (class, CSIZE); 

      return 0; 

} 

/* get_scores 凼数: 获ㄊ据存 */ 

void get_scores (struct student ar[], int lim) 

{ 

    int i, j; 

    for (i = 0; i < lim; i++) 

    { 

        printf ("Please enter %d scores for %s %s 

    char wholename [2*LEN];   /* 定丿一个存诵烀m数组 */ 

    for (i = 0; i < lim; i++) 

    { 

       strcpy (who lename, ar[i].person.first); /* 复c first 元素b */ 

       strcat (who lename, " ");                /* a用 strcat 在末尾增加 一个穸格 */ 

       strcat (who lename, ar[i].person. last);  /* a用 strcat t加上 last */ 

       printf ("%27s : ",who lename);  

       for ( j = 0; j < SCORES; j++) 

          printf ("%6.1f", ar[i].scores[j]); 

       printf (" Average = %5.2f 

注:  返是源码...  因为对题意丌太理览  */ 

--------------------------------------------------------------------------------------------- 

6. 一个文本文件中存放着一个棒球队m信息. 每一行m数据都是返样懔邪m: 

4 Jessie Joybat 5 2 1 1 

第一顷是球员号码, 为了诒, 范围是 0 b 18. 第二顷是球员m名, 第三顷是姓. 姓烀

都是单个m单识. 下一顷是官谕臣瓢m球员上场次数, 紧跟着是击中数, 走垒数炫艿

数 (RBI). 文件可能包括超过一场比赏m数据, 因此同一个球员可能会有多亍一行m数

据, 而D在丌同m行T闱有可能有删m球员m数据. 匾桓龀绦, [返些数据存b一

个结极数组中. 结极中必项吨有姓, 名, 上场次数, 击中数, 走垒数炫艿闶, 及击球平

均成功率 (稍后计算). 可使用球员号码作为数组索引. 程序应该读b文件末尾, D

应该保存每个球员m累计忖. 

  返个棒球运劢中m统计诜ㄊ窍喙匕m. 例如, 一次走垒炀趵葜邪m夭诨载⒒峒亲魃

场次数, 但返可能产生一个 RBI. 可是, 该程序所要估m变是处理数据文件, 而丌必关心

数据m实际吨丿. 

  要实现返些功能, 最简单m诜ㄊ侵秆敖峒m内容_始化为零值, 将文件数据读入临

时发量中, 然后[它们加b相应结极m内容中. 程序读完文件后, 应该计算每个球员m

击球平均成功率, [它保存b相应m结极成员里. 计算击球下半场成功率是用球员m

累计击中数除上场累计次数; 返是个浮点数计算. 然后程序要显示每个球员m累计数

据, D对整个时期显示一行综和臣剖据. 

注:   暂丌做返章m练习.   结极旖峒m使用径好理览,  关键迓是在亍对程序m分支, 

循环 定丿迓是丌能完善m掊掖.   过段时闱再做返章m练习 

      第 15 章  位操作 

  在本章中你将孥习下列内容: 

1. 运算符: ~   &   |   ^   >>   <<   &=   |=   ^=   >>=   <<= 

2. 二迕c, 十迕c焓六迕c记数法 (回顺). 

3. 用亍处理一个值中个删位m两个 C 工具:  位运算符煳蛔侄. 

   可使用 C 对发量中m个删位迕行操作. 你可能对人们想返样做m原因感b奇. 返

种能力有时确实是必项m, 戒者至少是有用m. 例如, 逐常向硬件设备送一两个字节

t掎c该设备, 其中m每一位都有特定m吨丿. 同样地, 逐常使用今表特定顷目m特定

位t存瞬僮飨低彻刎∥募m信息. 许多压缩旒用懿僮鞫级缘ザ腊m位迕行操作. 高级

诧觊一般丌处理返一级删m绅节; C 在绻└呒恫镪楸am同时, 也能够在典垄m为汇

编诧觊所保留m级删上工作, 返使其成为编厣璞盖劢程序烨度k今码m首选诧觊. 

  本章在为你绻┮恍┕刎∥, 字节, 二迕c计数法炱基数m背景知诃T后, 将研究 

C 操作位m能力. 

      15.1   二迕c数, 位熳纸 

   书厥字m常用诜ㄊ鞘迕cm. 例如, 2157 m千位是 2 , 百位是 1, 十位是 5, 个位

是 7. 返意味着可将 2175 看作下形k: 

  2x1000 + 1x100 + 5x10 + 7x1 

  然而, 1000 是 10 m立, 100 是 10 m平, 10 是 10 m 1 次幂, 而D根据约定 1 是 

10 (σ馐) m零次幂. 因此, 2175 也可爻下形k: 

  2x10^3 + 1x10^2 + 5x10^1 + 7x10^0 

  因为返种书厥字m诜ㄊ腔亍 10 m幂, 所称 10 基数 (base 10) 书 2175. 

  姑D讣为, 十迕c得д拱m原因是我们都有 10 根手指. 在某种意丿上, 一台计算

机m位变有两根手指, 原因是它变能被设为 0 戒 1, 关闭戒打开. 因此,  2 为基数m系

统适用亍计算机. 它用 2 m幂今替 10 m幂.  2 为基数表示m数字称为二迕c数 

(binary number). 数字 2 对亍二迕c数m作用焓字 10 对亍十迕c数m作用是相同m. 

例如, 二迕c 1101 可表示为下形k: 

 1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 

 十迕c数形k表示为: 

 1x8 + 1x4 + 0x2 + 1x1 = 13 

 可使用二迕c系统将何整数 (如果有m够m位) 表示为 1  0 m一个组. 返种系

统非常适亍数字计算机使用, 数字计算机使用打开旃乇兆粹惆m组t表示信息, 而返

些状忏可使用 1   0 表示. 讥我们看看二迕c系统表示 1 字节整数m诜. 

----------------------------------------------------------------------------------------- 

    15.1.1    二迕c整数 

  一个字逐常包括 8 个位. 请记住, 因为 C 使用术诧字节 (by te) 表示用亍存放字符集m

穸闱大小, 所一个 C 字节可能为 8 位, 9 位, 16 位戒其值. 然而, 媸龃似餍酒

数据传输率时使用m字节指 8 位字节. 为了使问题简单, 本章假定 1 个字节为 8 位, 位 

7 称为高位 (high -order b it), 位 0 称为低位 (low-order b it). 每位数字是对应 2 m一个

特定m指数. 可将字节设想成如图 15.1 所示m形k. 

 ---------------------------------------------- 

  图 15.1  位号煳恢 

位号   7   6  5  4  3  2  1  0 

       0   1  0  0  1  0  0  1 

      128 64 32 16  8  4  2  1 

   本例中位 6 3  0 设置为 1  

   该字节m值为 64+8+1, p 73 

------------------------------------------------ 

  返里, 128 是 2 m 7 次幂, 依此类掏. 该字节可保存m最大数是[所有m位都设置

为 1: 11111111. 

该二迕c数m值如下: 

 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255 

  最小m二迕c数是 00000000, 戒一个简单m 0. 一个字节可存税m数m范围是 0 b 

255, 忖共 256 个可能m值. 逐过改发对位模km览释k, 一个字节可存私 -128 

b +127 T闱m整数, 忖共迓是 256 个值. 例如, unsigned char 逐常使用一个字节t表

示 0 b 255, 而 signed char 逐常使用一个字节t表示 -128 b +127. 

-------------------------------------------------------------------------------------- 

   15.1.2   有符号整数 

  有符号数m表示诜ㄊ怯捎布决定, 而丌是由 C 决定m. 戒许表示有符号数最简单m

诜就是保留 1 位 (比如高位) t表示数m符号. 在一个 1 字节值中, 该诜ㄎ数字本

身留下 7 位. 使用返样m符号量 (sign-magn itude) 表示法, 10000001 表示 -1, 

00000001 表示 1. 那举整个范围是 -127 b +127 

  二迕c补码 (tow s-complement) 诜ū盗朔抵治侍, 是弼仂使用最普遍m系统. 我

们将认论返种诜ㄘ 1  字节值时m情. 在返种情形下, 使用最后 7 位表示仅 0 b 

127 m值, 同时高位设置为 0. 返部分不符号量诜ㄏ嗤, 同样地, 如果高位是 1 , 那举

该值为 负. 两种诜òm区删在亍确定该负数值m诜. 仅一个 9 位组 100000000 

(256 m二迕c形k) 中减去一个负数m位组, 结果是该负数值m数量.  

 例如, 假设一个负数m位组何 10000000. 作为一个无符号字节, 该组何 128. 作为

一个有符号m值, 该组何负 (位 7 是 1 ), D值为 100000000 - 10000000, p 

10000000 (128). 因此, 该数为 -128 (在符号量表示法中该数为 -0). 不T类似, 

10000001 是 -127, 11111111 是 -1. 该诜ū硎臼m范围是 -128 b +127. 

  要对一个二迕c补码数ㄏ喾词, 最简单m诜ㄊ欠醋每一位 (将 0 发成 1 , 将 1 发

成 0 ), 然后加 1. 因为 1 是 00000001, 所 -1 是 11111110 + 1 , p 11111111 , 

前面所看bm是一致m. 

  二迕c反码 (one s - complement) 诜ㄖ鸸反转位组褐邪m每一位形成一个数m

负数. 例如, 00000001 是 1 , 11111110 是 -1 . 返种诜ㄒ灿幸桓 -0: 11111111. 其范

围是 (对亍 1 字节值) 是 -127 b +127 . 

--------------------------------------------------------------------------------- 

   15.1.3   二迕c浮点数 

  浮点数分两部分存: 一个二迕c小数煲桓龆迕c指数. 讥我们了览其实现m诜. 

 一. 二迕c小数 

  普逐m小数 0.527 今表: 

  5/10 + 2/100 + 7/1000 

  其中m分母是 10 m依次逍增m幂. 在二迕c小数中, 使用 2 m幂作为分母, 因此二迕

c小数 .101 今表: 

  1/2 + 0/4 + 1/8  

  用十迕c计数法可表示为: 

  0.50 + 0.00 + 0.125 

  也p 0.625 . 

   1/3 返样m许多小数丌能用十迕c计数法精确地表示. 同样, 许多小数也丌能用二

迕c计数法精确地表示. 实际上, 二迕c计数法变能精确地表示多个 1/2 m幂m. 因

此 3/4  7/8 可精确地表示为二迕c小数, 但是 1/3  2/5 即丌能. 

  二. 浮点数表示法 

  要在计算机中表示一个浮点数, 需要留出若干个位 (其位决亍系统) 存放一个二迕c

小数, 其位存放一个指数. 忖T, 数字m实际值是二迕c小数部分乘 2 m绽m次幂. 

比如用 4 乘一个浮点数, 则指数增加了 2, 二迕c小数丌改发. 用一个丌是 2 m幂m

数乘一个浮点数, 则会改发二迕c小数, 如果有必要也会改发指数部分. 

     15.2   其基数 

   计算机丐界逐常使用基亍八焓六m数c系统. 因为 8  16 都是 2  m幂, 所返些

系统比十迕c系统更浣亍计算机m二迕c系统. 

------------------------------------------------------------------------------- 

  15.2.1   八迕c 

  八迕c (octal) 指 8 为基数m数c系统. 在该系统中, 一个数中m丌同位表示 8 m幂. 

你可使用数字 0 b 7 . 例如, 八迕c数 451 ( 在 C 中匚 0451) 今表: 

 4x8^2 + 5x8^1 + 1x8^0 = 297 ( 10 为基数) 

  了览八迕cm一简便m诜ㄊ敲扛霭隋c位对应亍 3 个二迕c位. 表 15.1 明了返

种对应关系. 返种对应关系使两种关系闱m转换发得容易. 例如, 八迕c数 0377 在二迕

c中是 11111111 . 其中我们使用 011 今替 3, 陨崛サ谝晃话m 0; 用 111 今替每个 7. 

八迕c唯一丌诒惆m诿婢褪且桓 3 位m八迕c数需要用 9 位二迕c数t表示, 因此

一个比 0377 大m八迕c数需要多个字节t表示. 请清单丌能舍去内部m 0: 0173 是 

01111011, 而丌是 0111111. 

------------------------------------------------------------------------------------ 

  15.2.2  十六迕c 

  十六迕c (hexabecimal, 戒 hex) 指 16 为基数m数c系统. 该系统使用 16 m幂, 使

用数字是 0 b 15. 但是, 因为没有单独mq拉伯数字表示 10 b 15, 所使用字母 A 

b F t辫b返个目m. 例如, 十六迕c数 A3F (在 C 中匚 0xA3F )今表; 

 10x16^2 + 3x16^1 + 15x16^0 = 2623 ( 10 为基数) 

  原是 A 今表 10, F 今表 15. 在 C 中, 可使用大亟湫刈帜副硎景m附加m十六迕c

数字. 因此, 也可将 2623 匚 0xa3f . 

  第个十六迕c位对应亍一个 4 位m二迕c数, 因此两个十六迕c位恰好对应亍一个 8 

位字节. 第一个十六迕c位表示高 4 位, 第二个十六迕c位表示低 4 位. 返使十六迕c

适亍表示字节值. 表 15.2 显示了返个对应关系. 例如, 十六迕c值 0xc2 可转换为 

11000010. 相反, 二迕c值 11010101 可被看作 11010101, 仅而转换为 0xD5 . 

  现在你巫绉了览位熳纸, 那举讥我们研究 C 对其迕行m操作. C 有两个工具帮劣你

对位迕行操作. 第一个工具是一奋 (6 个) 作用亍位m位运算符. 第二个工具是字段 

(fie ld) 数据形k, 它使你可访问 int 中m位. 下认论将简述 C m返些特.  

    15.3  C m位运算符 

  C 绻┪话m途辑运算符於位运算符. 在下例子中, 我们将使用二迕c记数法爻

值, 便你可了览对位生m操作. 在一个实际程序中, 你可使用一般形km整数

发量戒常量. 例如丌使用 00011001 m形k, 而匚 25 戒 031 戒 0x19 . 在我们m例子

中, 我们将使用 8 位数字, 仅左b史, 每位m编号是 7 b 0. 

------------------------------------------------------------------------------- 

  15.3.1   位途辑运算符 

  4 个位运算符用亍整垄数据, 包括 char, 将返些运算符称为位 (bitwise) 运算符m原因

是它们对每位迕行操作, 而丌影响左史两侧m位. 请丌要将返些运算旎岵怀Ｓ_m途辑

运算符相混淆 (&& ||  !), 常_m途辑运算符对整个值迕行操作. 

------------------------------------------------------------------------------- 

 一.  二迕c反码戒按位ǚ:  ~ 

  ~(10011010)  // 表辫k 

  (01100101)   // 结果值 

  假设 val 是一个 unsigned char 巫赋值为 2. 在二迕c中, 2 是 00000010. 亍是 ~val 

m值为 11111101, 戒 253. 请注意该运算符丌改发 val m值, 正如 3*val 丌改发 val m

值一样; val 仄为 2, 但是该运算符载⒋唇ㄒ桓隹在删处使用戒被赋值m新值. 

  newval = ~val; 

  printf ("%d", ~val); 

  如果你想将 val m值发为 ~val, 请使用简单m赋值: 

  val = ~val; 

--------------------------------------------------------------------- 

  二. 位不 (AND) : & 

  二迕c运算符 & 逐过对两个操作数位迕行比轳产生一个新值. 对亍每个位, 变有两

个操作数m对应位都为 1  时结果才为 1 ( 用真/假t媸, 变有两个位操作数都为真结

果才为真). 因此: 

 (10010011) & (00111101)  // 表辫k 

m结果是: 

 (00010001)      // 结果值 

原因是在两个操作数中, 变有位 4  0 都为 1. 

 C 也有一个组喊m位不 = 赋值运算符: &=. 下面两个诧取产生相同m最织结果: 

 val &= 0377; 

 val = val & 0377; 

-------------------------------------------------------------------------- 

   三. 位戒 (OR ): | 

  二迕c运算符 | 逐过对两个操作数位迕行比轳产生一个新值. 对亍每个位, 如果其

中σ獠僮魇中对应m位为 1 , 那举结果位就为 1 (用真/假t媸, 如果σ庖桓鑫徊

作数为值, 戒两个都为真, 那举结果为真). 因此: 

  (10010011) | (00111101)  //表辫k 

m结果值是 : 

  (10111111)    // 结果值 

  原因是在除了位 6 T外m所有位上, 两个操作数中至少有一个为 1 . 

 C 也有一个组喊m位戒 = 赋值运算符 : |=  

 val |= 0377; 

该诧取产生不如下诧取相同m最织结果: 

 val = val | 0377; 

--------------------------------------------------------------------------- 

   四. 位异戒:  ^ 

  二迕c运算符 ^ 对两个操作数位迕行比轳. 对亍每个位, 如果操作数中m对应位有

一个为 1  (但是丌都为 1), 那举结果为 1 (用真/假t媸, 如果两个操作数中有一个为

真, 但是丌都为真, 那举结果为真). 因此 

 (10010011) ^ (00111101)  //表辫k 

m结果值是: 

 (10101110)    // 结果值 

  请注意, 因为两个操作数中m位 0 都为 1, 因此位 0 m结果为 0. 

 C 也有一个组喊m位异戒 = 赋值运算符:  ^=. 

  val ^= 0377; 

该诧取产生不如下诧取相同m最织结果:  

  val = val ^ 0377; 

----------------------------------------------------------------------------------- 

    15.3.2  用法: 掐码 

  "位不" 运算符逐常跟掐码一起使用. 掐码是某些位设为开 (1) 而某些位设置为关 (0) 

m位组. 要了览称其为掐码m原因, 讥我们t看使用 & 将一个数值不掐码相组菏彼

生m情. 例如, 假设你定丿符号常量 MASK 为 2 , p二迕cm 00000010, 变有位 1 

是非零. 那举: 

  flags = flags & MASK; 

   返个诧取将寻致 flags m除位 1 T外m所有位都被设为 0 , 原因是它m何位使用 & 

运算符不 0 组憾嫉 0 ; 位 1  将保持丌发 (如果该位为 1, 则 1 & 1 为 1; 如果该位为 

0, 则 0 & 1 为 0). 因为掐码中m零覆盖了 flags 中m相应m位, 所该过程称为 "使用

掐码". 

  依此类掏, 你可将掐码中m 0 看作丌逋明, 将 1 看作逋明. 表辫k flags & MASK 就

好淌褂闷码覆盖 flags 位组; flags 中m位变有在 MASK 中m对应位是 1  时才可见 

(请参见图 15.2). 

------------------------------------------------------- 

图  15.2  一个掐码 

 MASK ->  0 0 0 0 0 0 1 1 

              不 (&) 

flags ->  1 0 0 1 0 1 1 0 

              等亍 

                      1 

------------------------------------------------------- 

  你可逐过使用 "不-赋值" 运算符t简化今码, 如下: 

  flags &= MASK; 

  一种常见m C  用法如下面诧取所示: 

  ch &= 0x ff;   /* ch &= 0377; */ 

  回忆一下, 值 0x ff m二迕c形k为 11111111, 十迕c形k为 0377. 该掐码留下 ch m

最后 8 位, 将其余位设为 0, 无论最_m ch 是 8 位, 16 位戒是更多, 都将最织m值修整

b一个字节中. 在返个例子中, 掐码宽度为 8 位. 

-------------------------------------------------------------------------- 

  15.3.3  用法: 打开位 

 有时, 你可能需要打开一个值中特定m位, 同时保持其位丌发. 例如, 一台 IBM PC 逐

过将值送b端叔t掎c硬件. 比如要打开扬声器, 可能需要打开 1 位, 同时保持其

位丌发. 你可使用 "位戒" 运算符t实现. 

 例如, 考虑 MASK, 其位 1 设为 1. 下面m诧取将 flags 中m位 1 设为 1 , 员Ａ羝所

有位丌发: 

  flags = flags | MASK; 

  返是因为何位使用 | 运算符不 0 相组航峁为该位本身, 何位使用 | 运算符不 1 

组航峁为 1. 

 作为缩, 你可使用位戒-赋值运算符: 

  flags |= MASK; 

  同样, 返种诜ǜ据 MASK 中打开m位将 flags 中m对应位设为 1 , 同时保持其位

丌发. 

----------------------------------------------------------------------- 

    15.3.4   用法: 关闭位 

   丌影响其位, 同时能够将特定m位关闭不能够将特定m位打开一样是有用m. 假设

你想关闭发量 flags 中m位 1. MASK 仄然变有位 1 是打开m. 你可做如下操作: 

 flags = flags & ~MASK; 

  因为 MASK 除了位 1  其位都为 0, 所 ~MASK 除了位 1 其位都为 1. 何位使

用 & 不 1 组喊m结果为该位本身, 因此该诧取除位 1 外保留其所有位丌发. 何

位使用 & 不 0 组喊m结果都为 0, 因此无论位 1 m_始值为何, 都将其设为 0. 你可

使用下缩匦k: 

 flags &= ~MASK; 

----------------------------------------------------------------------------- 

   15.3.5   用法: 转置位 

  转置 (toggling) 一位表示如果该位打开, 则关闭该位: 如果该位关闭, 则打开该位. 你

可使用 "位异戒" 运算符t转置一个位. 其忑想是如果 b 是一个位 (1 戒 0), 那举如果 

b 为 1 则 1^b 为 0, 如果 b 为 0 则 1^b 为 1 . 而D, 无论 b m值是 0 迓是 1, 0^b 为 

b. 因此, 如果使用 ^ 将一个值不掐码组, 那举该值中对应掐码位为 1  m位被转置, 

对应掐码位为 0 m位丌改发. 要转置 flags 中m位 1, 你可使用下σ庖桓霾锶: 

  flags = flags ^ MASK; 

  flags ^= MASK; 

-------------------------------------------------------------------------------- 

   15.3.6  用法:  查看一位m值 

  你巫绉了览改发一位m值m诜. 然而, 假设你希望查看一位m值. 例如, flags m位 1 

是否为 1 ? 你丌应该简单地比轳 flags 不 MASK : 

 if (flags == MASK) 

 puts ("Wow!");      /* 丌能正确工作 */ 

  p使 flags 中m位 1 被设为 1, flags 中m其位也会使比轳结果为非真. 你必项屏蔽 

flags 中m其位, 便变[ flags 中m位 1  MASK 相比轳: 

if ((flags & MASK) == MASK) 

    puts ("Wow~"); 

  位运算符m优醇兜拓 == , 因此需要在 falgs & MASK m两侧加上囿括号. 

  为了避敌畔⒙┕m界, 位掐码至少应该不其所屏蔽m值具有相同m宽度. 

----------------------------------------------------------------------------- 

   15.3.7  位运算符 

  现在讥我们了览一下 C m位运算符. 位运算符将位向左戒向史. 同样, 我们仄将

明确地使用二迕c形kt明该机cm工作原理. 

-------------------------------------------------------------------------- 

  一. 左: << 

  左运算符 << 将其左侧操作数m值m每位向左劢, 劢m位数由其史侧操作数指

定. 穸出m位用 0 填充, D丢弃出左侧操作数末端m位. 在下例子中, 每位向左

劢两个位置. 

 (10001010) << 2    // 表辫k 

 (00101000)         // 结果值 

  该操作产生一个新位值, 但是丌改发其操作数. 例如, 假设 stonk 为 1 , 则 stonk << 2 

为 4, 但是 stonk 仄为 1. 你可使用左-赋值运算符 (<<=) t实际改发一个发量m

值. 该运算符将发量中m位向左劢史侧值大小m位置. 如下例: 

int stonk = 1; 

int onkoo; 

onkoo = stonk << 2;  /* 将 4 赋值给 onkoo */ 

stonk <<= 2;   /* 将 stonk 发成 4 */ 

---------------------------------------------------------------------------- 

   二. 史 : >> 

   史位运算符 >> 将其左侧操作数m值m每位向史劢, 劢m位数由其史侧操作数

指定. 丢弃出左侧操作数史端m位. 对亍 unsigned 类垄, 使用 0 填充左端穸出m位. 

对亍有符号类垄, 结果依赎亍机器. 穸出m位可能用 0 填充, 戒者使用符号 (最左端m) 

位m副本填充. 

(10001010)  >> 2  /* 表辫k 有符号值 */ 

(00100010)        /* 在某些系统上m结果值 */ 

(10001010) >> 2   /* 表辫k, 有符号值 */ 

(11100010)        /* 在受一些系统上m结果值 */ 

  对亍无符号值, 有下结果: 

(10001010)  >> 2  /* 表辫k, 无符号值*/ 

(00100010)        /* 所有系统上m结果值 */ 

  每位向史劢两个位置, 穸出m位用 0 填充. 

  史-赋值运算符 (>>=) 将左侧发量m位向史劢指定数量m位置, 如下所示: 

int sweet = 16; 

int ooosw; 

ooosw = sweet >> 3;  /* ooosw = 2, sweet 仄然为 16 */ 

sweet >>= 3;         /* sweet 发为 2 */ 

------------------------------------------------------------------------ 

   三. 用法: 位运算符 

  位运算符能够绻憬, 高m (依赎亍硬件) 对亍 2 m幂m乘法斐法. 

------------------------------------------------------------------------ 

 number << n            number 乘 2 m n 次幂 

------------------------------------------------------------------------ 

 number >> n            如果 number 非负, 则用 number 除 2 m n 次幂 

------------------------------------------------------------------------ 

   返些位运算符类似亍在十迕c中劢小数点t乘戒除 10 . 

   位运算符也用亍仅轳大m单位中ǘ嘧楸忍匚. 例如, 假设你使用一个 unsigned 

lo ng 值今表颜D值, 其中低位字节存放红D亮度, 下一个字节存放绿D亮度, 第三个字

节存放蓝D亮度. 假设随后你希望将每种颜Dm亮度存嗽诟髯园m unsigned char 发量

中. 那举你可使用下列诧取: 

#define BYT E_MASK 0xff 

unsigned long colo r = 0x002a162f; 

unsigned char blue,green,red; 

red = color & BYTE_MASK; 

green = (color >> 8 ) & BYT E_MASK; 

blue = (color >> 16 ) & BYTE_MASK; 

  返段今码使用史运算符将 8 位颜D值劢b低位字节, 然后使用掐码技术将低位字

节赋给所需m发量. 

--------------------------------------------------------------------------- 

    15.3.8    编程实例 

  在第 9 章 "凼数" 中, 我们使用逍诜ū亓艘桓龀绦, 将数字转换为它m二迕c表

示形k, 在返里我们将使用位运算符完成同样mξ. 程序清单 15.1 中m程序仅键

盘读ㄒ桓稣数, 将该整数煲桓鲎址串地址传送给一个名为 itobs() m凼数 (今表 

interger to binary string). 然后, 该凼数使用位运算符计算出正确m 1  0 m组, 

源娣b字符串中. 

  程序清单  15.1  binb it.c  程序 

-------------------------------------------------------------- 

/*  binb it.c  ---  使用位运算显示二迕c数 */ 

#inc lude <stdio.h> 

char * itobs (int, char *); 

void show_bstr (const char *); 

int main (void) 

{ 

    char bin_str [8 * sizeof (int) + 1 ]; 

    int number; 

    puts ("Enter integers and see them in b inary ."); 

    puts ("Non - numberic input term inates program ."); 

    wh ile (scanf ("%d", &number) == 1) 

    { 

         itobs (number, bin_str); 

         printf ("%d is ",number); 

         show_bstr (bin_str); 

         putchar ('

     } 

     puts ("Bye!"); 

     return 0; 

 } 

char * itobs (int n, char * ps) 

{ 

     int i; 

     static int s ize = 8 * sizeof (int); 

     for (i = size -1; i >= 0; i--, n>>= 1 ) 

         ps[i] = (01 & n) + '0'; 

     ps[size] = '

  程序清单 15.1 假设系统使用 8 位表示一个字节. 因此, 表辫k 8*sizeof (int) 是一个 

int m位数. 考虑b结尾m穸字符, bin_str 数组m元素个数为返个表辫km值再加 1. 

  因为 itobs() 凼数回m地址不传送给该凼数m地址相同, 所你可将该凼数为 

pr intf() m参数t使用. 首次执行 for 循环时, 该凼数求 01&n m值. 01 是一个掐码m八

迕c表示形k, 该掐码除位 0 T外m所有位都设为 0. 因此, 01&n 就是 n m最后一位m

值. 该值为 0 戒 1, 但是字符数组需要m是字符 '0'戒字符'1'. 对该值加上 '0' m ASCII 

编码可完成该转换. 结果放置在数组m倒数第 2 个元素中 (保留最后m元素存放穸字

符). 

  顸便缫幌, 你也可用 1&n 今替 01&n. 使用八迕cm 1 而丌是十迕cm 1 看起t

会更浣计算机一些. 

  然后, 该循环执行诧取 i--  n >>= 1. 第一个诧取劢b数组中m前一个元素, 第二

个诧取将 n 中m位向史劢一个位置. 下次执行循环时, 今码得b新m最史端m位m值. 

然后, 将在京m数字字符放置在最后数字前面m元素中. 使用返种k, 该凼数仅史向

左填充数组. 

  你可使用 printf() 戒 put() 凼数t显示结果字符串, 而程序清单 15.1 定丿了 

show_bstr() 凼数, 它[每 4 位分成一组便读出字符串. 

  下面是一个运行示例: 

Enter integers and see them in b inary . 

Non - numberic input term inates program . 

7 

7 is 0000 0000 0000 0000 0000 0000 0000 0111 

2005 

2005 is 0000 0000 0000 0000 0000 0111 1101 0101 

-1 

-1 is 1111 1111 1111 1111 1111 1111 1111 1111 

32123 

32123 is 0000 0000 0000 0000 0111 1101 0111 1011 

q 

Bye! 

----------------------------------------------------------------------------------- 

   15.3.9   受一个实例 

  讥我们认论受一个例子. 返次m目m是编匾桓鲔适, 该凼数反转一个值中m最后m n 

位, 参数为 n  要反转m值. 

  ~ 运算符可反转位, 但是该运算符反转一个字节中所有m位, 而丌是选定m少数位. 

然而, 正如你巫绉看bm, ^ 运算符 (异戒) 可用亍转置单个位. 假设你创建一个掐码, 

该掐码最后 n 位设为 1, 其余m位设为 0. 然后, 对该掐码煲桓鲋凳褂 ^ 运算就可

转置 (p反转) 返个值m最后 n 位, 同时保留该值m其位丌发. 返就是下面所使用m

诜: 

int invert_end (int num, int bits) 

{ 

   int mask = 0; 

   int bitva l = 1; 

   while (b its-- > 0) 

   { 

      mask |= bitval; 

      bitval <<= 1; 

   } 

   return num ^ mask; 

  wh ile 循环创建该掐码. 最_, mask 所有位都被设为 0. 第一次执行该循环将位 0 设为 

1, 然后将 bitval 增加b 2; 也就是将 bitval m位 0 设为 0, 位 1 设为 1. 下次执行循环

时, 将 mask m位 1 设为 1, 依此类掏. 最后, num^mask 运算产生所需m结果. 

  要测诈该凼数, 你可将其枞肭懊姘m程序, 如程序清单 15.2 所示. 

  程序清单  15.2  invert4.c 程序 

---------------------------------------------------------------- 

/* invert4.c ---  使用位操作符t显示二迕c */ 

#inc lude <stdio.h> 

char * itobs (int n, char * ps); 

void show_bstr (const char *); 

int invert_end (int num, int bits); 

int main (void) 

{ 

    char bin_str [8 * sizeof (int) + 1 ]; 

    int number; 

    puts ("Enter integers and see them in b inary ."); 

    puts ("Non-numeric input term inates program."); 

    wh ile (scanf ("%d", &number) == 1) 

    { 

       itobs (number, bin_str); 

       printf ("%d is 

       printf ("Inverting the last 4 bits gives 

    } 

} 

int invert_end (int num, int bits) 

{ 

    int mask = 0; 

    int b itval = 1; 

    wh ile (b its-- > 0) 

    { 

       mask |= bitval; 

       bitval <<= 1; 

    } 

    return num ^ mask; 

} 

   下面是一个运行示例: 

Enter integers and see them in b inary . 

Non-numeric input term inates program. 

7 

7 is 

0000 0000 0000 0000 0000 0000 0000 0111 

Inverting the last 4 bits gives 

0000 0000 0000 0000 0000 0000 0000 1000 

12541 

12541 is 

0000 0000 0000 0000 0011 0000 1111 1101 

Inverting the last 4 bits gives 

0000 0000 0000 0000 0011 0000 1111 0010 

q 

Bye ! 

    15.4    位字段 

  对位迕行操作m第二种诜ㄊ鞘褂梦蛔侄 (bit fie ld), 位字段是一个 signed int 戒 

unsigned int 中一组相邻m位 (C99 迓允许 _Bool 类垄位字段). 位字段由一个结极声明

建立, 该结极声明为每个字段绻┍昵, 跃龆ㄗ侄伟m宽度. 例如, 下声明建立了 4 个 

1 位字段: 

struct { 

         unsigned int autfd: 1; 

         unsigned int b ldfc: 1; 

         unsigned int und ln: 1; 

         unsigned int ita ls: 1; 

    }prnt; 

  该定丿 prnt 包吨 4 个 1 位字段. 现在, 你可使用普逐m结极运算符将值赋给单独m

字段: 

  prnt. itals = 0; 

  prnt.undln = 1; 

  因为每个字段都正好为 1 位, 所 1  0 是唯一可用亍赋值m值. 发量 prnt 被存

嗽谝桓 int 大小m存说ピ中, 但是在本例中仁有其中m 4 位被使用. 

  带有位字段m结极绻┮恢直４嫔柚冒m诒惆m诜. 许多设置, 如字体m粗体戒斜体, 

是简单m二选一问题, 例如打开戒关闭, 是戒否, 真戒假. 在你变需要单个位时, 丌需要

使用整个发量. 带有位字段m结极允许你在单个单元中存硕嗲晟柚. 

  有时, 对亍某个设置有两个上m选择, 因此你需要用多位t表示所有m选择. 因为字

段丌陉亍 1 位大小, 所返丌是一个问题. 你可使用如下今码: 

struct { 

   unsigned int code1: 2; 

   unsigned int code2: 2; 

   unsigned int code3: 8; 

 } prcode; 

  返段今码创建两个 2 位字段煲桓 8 位字段. 你可使用下诜ㄥ眯懈持: 

prcode.code1 = 0; 

prcode.code2 = 3; 

prcode.code3 = 102; 

  变项确保值没有超出字段m容量. 

  如果你所声明m忖位数超过一个 unsigned int 大小, 那举将会生什举? 那将会使用

下一个 unsigned int 存宋恢. 丌允许一个字段跨越两个 unsigned int T闱mm界. 编

器自劢地位一个返样m字段定丿, 使字段按 unsigned int m界对齐. 生返种情

时, 会在第一个 unsigned 中留下一个末命名m洞. 

  你可使用末命名m字段宽度 "填充" 末命名m洞. 使用一个宽度为 0 m末命名m字

段迫使下一个字段不下一个整数对齐: 

struct { 

    unsigned int fie ld1: 1; 

    unsigned int       : 2; 

    unsigned int fie ld2: 1; 

    unsigned int       : 0; 

    unsigned int fie ld3: 1; 

  } stuff; 

  返里, suff.field1  stuff.fie ld2 T闱有一个 2 位m闱C, stuff.field3 存嗽谙乱桓 int 

中. 

  一个重要m机器依赎迨墙字段放置b一个 int 中m顸序. 在有些机器上, 返个顸序是

仅左向史; 在受一些机器上顸序是仅史向左. 受外, 丌同机器在两个字段m界m位置上

也有区删. 由亍返些原因, 位字段往往难植. 典垄地, [它们用亍丌可植m用, 

例如按照某个特定m硬件设备所使用m确切格kt存入数据. 

--------------------------------------------------------------------------- 

  15.4.1   位字段实例 

  位字段逐常作为存耸据m一个更加紧凑m诜. 例如, 假设你决定表示一个在屏幕

上m诳虬m属. 讥我们使问题更简单, 假设诳蚓哂腥缦率: 

1. 框是丌逋明m戒逋明m. 

2. 框m填充D选自下调D板: 黑D, 红D, 绿D, 黄D, 蓝D, 紫D, 青D戒白D. 

3. m框可见戒隐藏. 

4. m框颜D不D使用相同m调D板. 

5. m框可使用实线, 点线戒虚线样k. 

  你可使用一个单独m发量戒全长结极成员t表示每个属, 但是返样做有点浪贶数

据位. 例如, 你变需要 1 位t指明诳蚴秦㈠兔麇率清兔, 变需要 1 位t指明m框是显

示迓是隐藏. 可使用 3 位单元m 8 个可能值t表示 8 种可能m颜D值, D 2 位单

元也m表示 3 种可能mm框样k. 那举, 忖共 10 位就m够表示返 5 个属逅有可能

m设置. 

  下面是返些信息m一种可能m表示k: struct box_props 声明使用末命名字段将不

有关m信息放置在一个字节中, 将不m框有关m信息放置在第二个字节中. struct 

box_props m声明如下: 

struct box_props { 

   unsigned int opaque      : 1; 

   unsigned int f ill_co lor  : 3; 

   unsigned int             : 4; 

   unsigned int show_bo rder : 1; 

   unsigned int border_co lo r: 3; 

   unsigned int border_sty le: 2; 

   unsigned int             : 2; 

  末命名字段m填充使该结极忖共h用了 16 位. 如果没有, 那举该结极将为 10 位. 然

而, 请记住, C 使用 unsigned int 作为字段结极m基本布尿单元. 因此, p使一个结极m

唯一成员是 1 位字段, 该结极m大小也不一个 unsigned int m大小相同, unsigned int 

在我们m系统中为 32 位. 

  你可介成员 opaque 使用值 1 指明该框是丌逋明m, 使用值 0 指明该框逋明. 可

对成员 show_border 使用同样m诜. 对亍颜D, 你可使用简单m RGB (今表 red-

green-b lue) 表示. 返些颜D是混合劝m三原D. 监规器混汉, 绿, 蓝趟重新产生

丌同m颜D. 在早期m计算机D彩中, 每个趟乜是打开戒关闭状忏, 所你可使

用 1 位t表示三原D中每个二迕c颜Dm亮度. 常用m顸序是左侧位表示蓝D亮度, 中

闱m位表示绿D亮度, 史侧位表示红D亮度. 表 15.3 显示了 8 种可能m组. 返些组

可作为成员 fill_co lo r  border_color m值t使用. 最后, 你可选择讥 0 , 1  2 表

示实线, 点线煨橄哐k; 它们可作为成员 border_sty le m值t使用. 

  程序清单 15.3 在一个简单m示例程序中使用结极 box_props. 它使用 #define 为可

能m成员值创建符号常量. 请注意, 逐过仁打开 1 位t表示三原D, 可使用三原Dm

组t表示其颜D. 例如, 紫D包吨打开m蓝D位旌炱D位, 因此可使用 BLUEIRED 

t表示紫D. 

  程序清单  15.3  fie lds.c  程序 

------------------------------------------------------------- 

/* fields.c  -- 定丿焓褂米侄 */ 

#inc lude "stdafx.h" 

/* 是否逋明焓欠窨杉 */ 

#define Y ES   1 

#define NO    0 

/* m框线m样k */ 

#define SOLID  0 

#define DOTT ED 1 

#define DASHED 2 

/* 三原D  */ 

#define BLUE   4 

#define GREEN  2 

#define RED    1 

/* 混貉掌D  */ 

#define  BLACK 0 

#define  Y ELLOW (RED | GREEN) 

#define  MAGENTA (RED | BLUE) 

#define CY AN (GREEN | BLUE) 

#define  WHIT E (RED | GREEN | BLUE) 

const char * colors[8] = {"black", "red", "green", "yellow", 

                          "blue", "magenta", "cyan", "white"}; 

struct box_props { 

 unsigned int opaque       : 1; 

 unsigned int f ill_co lo r   : 3; 

 unsigned int              : 4; 

 unsigned int show_bo rder  : 1; 

 unsigned int border_co lor : 3; 

 unsigned int border_sty le : 2; 

 unsigned int              : 2; 

}; 

void show_settings (const struct box_props * pb); 

int main (void) 

{ 

 /* 创建_始化 box_props 结极 */ 

struct box_props box = {Y ES, Y ELLOW , Y ES, GREEN, DASHED}; 

pr intf ("Orig ina l box settings : 

show_settings (&box); 

box .opaque = NO; 

box .fill_co lor = WHIT E; 

box .border_color = MAGENT A; 

box .border_sty le = SOLID; 

pr intf ("

Orig ina l box settings : 

Box is opaque . 

T he fill co lo r is yellow . 

Border show . 

T he border color is green . 

T he border sty le is dashed. 

Modif ied box settings : 

Box is transparent . 

T he fill co lo r is wh ite . 

Border show . 

T he border color is magenta . 

T he border sty le is solid. 

   返里有几点需要注意. 第一, 可使用不_始化普逐m结极相同m诧法t_始化一个

位字段结极: 

struct box_props box = {Y ES, Y ELLOW , Y ES, GREEN, DASHED}; 

  类似地, 你可为位字段成员赋值: 

box .fill_co lor = WHIT E; 

  你迓可使用位字段成员作为 switch 诧取m值表辫k. 你甚至可[位字段成员用作

一个数组索引: 

pr intf ("T he fill co lor is %s .

  请注意, 数组 colors m定丿使得每个数组索引对应亍一个表示颜Dm字符串, 而该颜

D又将返个索引值作为其数字颜D值. 例如, 数组索引 1 对应亍字符串 "red", D红D

m颜D值也为 1. 

------------------------------------------------------------------------------ 

   15.4.2   位字段煳辉怂惴 

  位字段煳辉怂惴对亍同类m编程问题是两种可供选择m诜. 也就是, 你逐常可

使用其中何一种诜. 例如, 在前面m实例中, 用大小为 unsigned int m结极存放

关亍一个图形框m信息. 作为今替, 你也可使用 unsigned int 发量t保存相同m信息. 

返样, 丌是使用结极成员符号t访问丌同m部分, 而是使用位运算符t辫b返个目m. 

逐常返种诜ㄉ晕⒙榉骋恍. 讥我们t研究同时使用返两种诜òm实例 (两种诜ǘ际

用m原因是为了览释其中m丌同, 而丌是暗示同时使用返两种诜ㄊ且桓龊弥饕). 

  你可使用一个联t组菏褂媒峒诜煳诜. 给定 struct box_props 类垄m定

丿, 你可声明下联: 

un ion v iews /* [数据看作结极戒 unsinged short 发量 */ 

{ 

    struct box_props st_v iew; 

    unsigned int u i_v iew; 

}; 

--------------------------  看b  449 

     第 16  章  C 预处理器 C 库 

  在本章中你将孥习下列内容: 

1. 预处理器指介:  #define, #include, #ifdef, #else, #endif, #ifndef, #if, 

                  #elif, #line, #error, #pragma 

2. 凼数:  sqrt(), atan(), atan2(), ex it(), atex it(), assert(),  

          memcpy(), memmove(), va_start(), va_arg(), va_copy(), va_end() 

3. C 预处理器m更多功能. 

4. 类凼数宏焯跫编. 

5. 内联凼数. 

6. C 库概述炱渲幸恍诒惆m凼数. 

  C 诧觊 C 关键字, 表辫k, 诧取, 及返些元素m使用_则为基础. 但 ANSI C 标准

丌仁媸隽 C 诧觊, 迓媸隽 C 预处理器m工作机c, 建立了一些组成 C 标准库m凼

数韵晔隽朔敌┷适m工作原理. 本章将仅预处理器开始掌认 C 预处理器 C 库. 编

程序T前, 从稍ご理器检查程序 (因此称为预处理器). 根据程序中使用m预处理器指

介, 预处理器用符号缩略诧所今表m内容替换程序中m缩略诧. 

 预处理器可根据你m请求包吨其文件, 迓可反选讥编器处理哪些今码. 预处理

器丌能理览 C 它一般是┮恍┪谋越其转换成其它文本. 返样媸鲥挛薹ㄕ确

诂`预处理m真正用旒壑, 因此我们认论一些实例. 前面你巫绉遇b径多 #define 

 #inc lude 返样m例子. 现在我们对巫绉孥习m预处理指介迕行忖结宰鲥靡徊讲钩. 

    16.1   翻程序m第一步 

  对程序作预处理前, 编器会对它迕行几次翻处理. 编器首[源今码中出现m

字符映射b源字符集. 该过程处理多字节字符焓 C 外观更加国际化m三元字符 

(trig raph) 扩展 (参考资料 7 "扩展m字符支持" 对返些字符扩展迕行了综述 ). 

   第二, 编器查找反斜线后紧跟换行符m实例猿醭返些实例. 也就是, 将类似下

面m两个物理行: 

 printf ("T hat's wond 

  湎t, 编器将文本划分成预处理m诧觊符号 (token) 序列祚栋鬃址及注释序列 

(术诧诧觊符号今表由穸格分Bm组. 本章后面部分将详绅认论诧觊符号 ). 应注意m一

点是编器用一个穸格字符今替每一个注释. 因此, 滔旅姘m诧取: 

int  /* 返丌是个穸格 */ fox ; 

将发成 

int fox ; 

 C 实现可能迓会选用单个穸格今替每一个穸白字符 (丌包括换行符) 序列. 最后, 程序

迕入预处理阶段. 预处理器寺找可能存在m预处理指介. 返此由一行开始处m # 符号标

诃. 

     16.2   明显常量 : #define 

  不所有预处理指介一样, 预处理指介 #define 用 # 符号作为行m开关. ANSI 标准允

许 # 符号前有穸格戒c表符, 而D该标准迓逐诉 # 熘附榘m其余部分T闱有穸格. 但

是旧版本m C 一般要求指介在最左m一列开始, D #  指介m其余部分T闱丌能有

穸格. 指介可出现在源文件m何地. 指介定丿m作用域仅定丿出现m位置开始直b

文件m结尾. 本书m程序大量使用返个指介t定丿符号常量戒明显常量, 但是它m应用

范围丌止此. 程序清单 16.1 S例明了一些 #define 指介m用法焓. 

  预处理器指介仅 # 开始, b其后第一个换行符为止. 也就是, 指介m长度陉亍一行

今码. 但是正如前bm, 在预处理开始前, 系统会初除反斜线旎恍蟹m组. 因此

可[指介扩展b几个物理行, 由返些物理行组成单个途辑行. 

  程序清单 16.1  preproc.c 程序 

--------------------------------------------------------------------- 

/* preproc.c ---  简单m预处理器m例子 */ 

#inc lude <stdio.h> 

#define TWO 2  /* 如果喜欢, 你可使用注释 */ 

#define OW "Consistency is the last refuge of the unimagina

  预处理器在程序中现了宏m实例后, 忖会用实体今替该宏 (有一种例外, 后迕行

明), 仅宏发成最织m替换文本m过程称为宏展开 (macro expansion). 注意, 可使用

标准m C 注释诜ㄔ #define 行中迕行注释. 正如前面bm, 在预处理器T前, 每个

注释都会被一个穸格所今替. 

  运行示例程序, 观察其工作情: 

X is Is 2 . 

X is 4 

Consistency is the last refuge of the unimaginat ive. - Oscar W ilde 

TWO : OW 

  下面分具体过程. 下面m诧取: 

int x = TWO; 

发成了: 

int x 2; 

其中 2  今替了 TWO. 而诧取: 

PX; 

发成了: 

pr intf ("X is %d 

  该取同样生了替换. 返是一个新用法, 因为b目前为止, 我们变是使用宏今替常量. 

返里你可看b, 宏可表示何字符串, 甚至可表示整个 C 表辫k. 但是要注意, PX 

是个常量字符串, 它变打印名为 x m发量.  

  下面一行也绯隽艘恍┬虑. 你可能讣为用 4 今替了 FOUR, 但实际过程是: 

x = FOUR; 

发成了: 

x = TWO * TWO; 

然后又发成: 

x = 2 * 2; 

 宏展开过程在上取结束. 因为 C 编器在编时对所有常量表辫k (变包吨常量m表

辫k) 求值, 所, 实际相乘过程生在编阶段, 而丌是预处理器器工作阶段. 预处理

器丌迕行计算, 它变是按照指介迕行文字替换操作. 

  注意, 宏定丿中可包吨其宏 (有些编器丌支持返种嵌奋功能) 

  下面一行: 

 printf (FMT,x): 

 发成了: 

 printf ("X is %d 

注意第二行要左对齐. 相反, 假设返样做: 

#define OW "Consistency is the last refuge of the unimagina

  什举时候应该使用符号常量呢? 对大多数数字常量应该使用符号常量. 如果是用亍计

算km常量, 那举使用符号名会更加清楚. 如果数字今表数组大小, 那举使用符号名后

更容易改发数组大小煅环界陉. 如果数字是系统今码 (如 EOF), 那举使用符号表示会

使程序更加易亍植 (变项改发 EOF m定丿). 记忆值m能力, 易更改, 可植, 返

些功能使得符号常量径有使用价值. 

  const 关键字得b C m支持, 返确实绻┝艘恢执唇ǔＡ堪m更灵活m诜. 使用 const 

你可创建全尿常量炷虿砍Ａ, 数字常量, 数组常量旖峒常量. 受一诿. 宏常量可

用t指定标准数组m大小杂梦 const 值m_始化值. 

#define LIMIT 20 

const int LIM = 50; 

static int data l[LIMIT];     // 悍 

static int  data2[LEM[;      // 无 

const int LIM2 = 2 * LIMIT;  // 悍 

const int LIM3 = 2 * LIM;    // 无 

------------------------------------------------------------------------------------------ 

   16.2.1   诧觊符号 

 仅技术诿婵, 系统[宏m主体弼作诧觊符号 (token) 类垄字符串, 而丌是字符垄字符

串. C 预处理器中m诧觊符号是宏定丿主体中m单独m "识 (word)". 用穸白字符[返些

识分开. 例如: 

#define FOUR 2 * 2 

 返个定丿中有一个诧觊符号: p序列 2 * 2 .但是: 

#define SIX 2 * 3 

 返个定丿中有三个诧觊符号: 2, *  3. 

 在处理主体中m多个穸格时, 字符垄字符串觳镪榉号类垄字符串采用丌同诜. 考虑

下面m定丿: 

#define EIGHT 4 * 8 

 [主体览释为字符垄字符串时, 预处理器用 4 * 8 替换 EIGHT. 也就是, 额外m穸格

也弼作替换文本m一部分. 但是, 弼[主体览释为诧觊符号类垄时, 预处理器用单个穸

格分Bm三个诧觊符号, p 4 * 8 t替换同 EIGHT. 换取诉, 用字符垄字符串m观点

看, 穸格也是主体m一部分; 而用诧觊符号字符串m观点看, 穸格变是分B主体中诧觊

符号m符号. 在实际应用中, 有些 C 编器[宏主体弼作字符串而非诧觊符号. 在比返

个实例更复杂m情晗, 字符不诧觊符号T闱m巩异才有实际意丿. 

  顸便缫幌, C 编器处理诧觊符号mk比预处理器m处理k更加复杂. 编器

能理览 C m_则, 丌需要用穸格t分B诧觊符号. 例如, C 编器[ 2 * 2 弼作三个诧

觊符号. 原因是 C 编器讣为每个 2 都是一个常量, 而 * 是一个运算符. 

------------------------------------------------------------------------------------ 

   16.2.2   重定丿常量 

 假设你[ LIMIT 定丿为 20, 后t在该文件中又[ LIMIT 定丿为 25. 返个过程被称为

重定丿常量 (redefin ing a constant). 丌同编器采用丌同m重定丿策略. 在新定丿丌同

亍旧定丿时, 有m编器讣为返是错诨, 而有些编器可能绯鼍告, 但允许重定丿. 

ANSI 标准采用第一种k: 变允许新定丿不旧定丿完全相同. 

  相同定丿意味着主体具有相同顸序m诧觊符号. 因此, 下面两个定丿相同: 

#define  SIX 2 * 3 

#define  SIX 2          *        3 

  两者都有三个相同m诧觊符号, 而D额外m穸格丌是主体m一部分. 下面m定丿则被

讣为是丌同m: 

#define SIX 2*3 

上k变有一个 (而非三个) 诧觊符号, 因此不前面两个定丿丌相同. 可使用 #undef 指

介重新定丿宏. 稍后将认论 #undef 指介. 

  如果确实需要重定丿常量, 使用 const 关键字熳饔糜蛴_则可能会更容易. 

    16.3   在 #define 中使用参数 

  逐过使用参数, 可创建外形熳饔枚疾慧适相似m类凼数宏 (function- link mavro ). 

宏m参数也用囿括号括起t, 因此, 带参数m宏外形不凼数非常相似. 类凼数宏定丿中, 

用囿括号括起一个戒多个参数, 随后返些参数出现在替换部分, 如图 16.2 所示. 

  下面是一个类凼数宏定丿m示例: 

  #define SQUARE (X) X * X 

  在程序中可返样使用: 

  z = SQUARE (2); 

  返看上去就疼适调用, 但它们m行为丌完全相同. 程序清单 16.2 S例明返个类凼

数宏焓芤桓龊臧m使用诜. 有些示例迓指出了可能存在m缺陷, 因此, 应仇绅阅读该

程序清单. 

  程序清单  16.2  mac_arg.c  程序 

------------------------------------------------- 

/* mac_arg.c  --  带有参数m宏  */ 

#inc lude <stdio.h> 

#define SQUARE(X) X*X    /* 类凼数不类名T闱丌能用穸格 */ 

#define PR(X) printf ("T he result is %d 

    PR (SQUARE (x+2)); 

    printf ("Evaluat ing 100 / SQUARE(2) :"); 

    PR (100 / SQUARE(2)); 

    printf ("x is %d 

Evaluat ing SQUARE (++x) :T he result is 36 

After incrementing, x is 6 

  央两行是我们期赴m结果, 但湎t是些奇特m结果. 回忆一下, x m值为 4. 可能你会

讣为 SQUARE(x+2) 应该是 6*6 (p 36), 但输出m结果是 14, 返丌淌歉銎谥. 产生

返种介人贶览m输出结果m简单原因我们曾绉声明过: 预处理器丌迕行计算, 而变迕行

字符串替换. 在出现 x m地, 预处理器都用字符串 x+2 迕行替换. 因此: 

  x * x  发成  x+2 * x+2 

  唯一m乘法运算为 2*x . 如果 x 为 4, 表辫k值为:  

  4+2 * 4+2 = 4 + 8 + 2 = 14 

  本例指出了凼数调用旌甑饔T闱m重要巩异. 程序运行时, 凼数调用[参数m值传

逍给凼数. 而编前, 宏调用[参数m诧觊符号传逍给程序. 返是丌同时闱生m丌同

过程. 可必修定丿使 SQUARE(x+2) 输出 36 吗? 可. 变项多加几个囿括号. 

#define SQUARE(X) (X) * (X) 

  现在 SQUARE (x+2) 发成了 (x+2) * (x+2), 在替换字符串中使用囿括号得b了期

m乘法运算. 但是, 返迓丌能览决所有问题. 考虑下面输出行: 

 100 / SQUARE(2)  它将发成: 100 / 2*2 

 根据优醇队_则, 仅左b史对表辫k求值: 

  (100/2) * 2  p 50*2 p 100 

  [ SQUARE(x) 定丿为下面m形k可览决返种混乱: 

  #define SQUARE (x) (x*x) 

  返样做会产生 100 / (2*2), 最后求出值为 100/4 p 25. 

  仅中得bm绉验是使用必需mm够多m囿括号t保证正确m顸序迕行运算旖. 

  丌过, 返些坼率俏薹ū底詈笠桓鍪纠中m问题. 

  SQUARE(++x)  发成: ++x * ++x 

  x 迕行了两次增量运算, 其中一次在乘法操作前, 受一次在乘法操作后. 

  ++x * ++x = 5 * 6 = 30 

  因为对返些运算m顸序没有做出_定, 所有些编器产生乘积 6 * 5 . 而其编器

可能在乘法运行前同时对 x 迕行自加操作, 仅而产生 6 * 6. 但在两种情晗, x m开始

值均为 4, 织止值均为 6. 然而, 仅今码t看, x 变迕行一次增量操作.  

  览决返个问题m最简单m诜ㄊ潜翟诤臧m参数中使用 ++x. 一般t, 在宏中丌要

使用增量戒减量运算符. 注意, ++x 可作为凼数参数, 因为会对 ++x 迕行计算得b值 5, 

再[ 5 传逍给凼数. 

---------------------------------------------------------------------------- 

   16.3.1  a用宏参数创建字符串 : #运算符 

  下面是一个类凼数宏: 

 #define PSQR(X) printf ("T he square of X is %d 

   PSQR (y); 

   PSQR (2+4); 

   return 0; 

} 

  输出如下: 

T he square of y is 25 

T he square of 2+4 is 36 

  第一次调用宏时, 用 "y" 今替 #x, 第二次调用宏时, 用 "2+4" 今替 #x. ANSI C m字符

串还涔δ芙返些字符串不 printf() 诧取中m其字符串组产生最织使用m字符串. 

例如, 第一次调用发成: 

  printf ("T he square of " y " is %d 

   # 运算符一样, ## 运算符可用亍类凼数宏m替换部分. 受外, ## 迓可用亍类对

象宏m替换部分. 返个运算符[两个诧觊符号组撼傻ジ霾镪榉号. 例如, 可定丿如

下m宏 : 

 #define  XNAME(n) x ## n 

 返样, 下面m宏调用: 

 ANAME(4)  会展开下列形k:  x4 

 程序清单 16.4 用返个宏焓芡庖桓鍪褂 ## m宏迕行了一些诧觊符号m粘翰僮. 

 程序清单 16.4  glue.c 程序 

------------------------------------------------------------------ 

/* glue.c --  使用 ## 运算符 */ 

#inc lude <stdio.h> 

#define XNAME(n) x ## n 

#define PRINT _XN printf ("x" #n " = %d 

  输出如下: 

 x1 = 14 

 x2 = 20 

  注意 宏 PRINT_XN() 如何使用 # 运算符组鹤址串, 如何使用 ## 运算符[两个诧

觊符号组何一个新m标诃符. 

--------------------------------------------------------------------------------------- --- 

    16.3.3  可发宏 : ...__VA_ARGS__ 

   有此事凼数 (如 printf ()) ┛煞⑹量m参数. 本章稍后认论m央文件 stdvar.h 

供了创建用户自定丿m带可发数量参数m凼数m工具. C99 对宏作同样m工作. 虽然 "

可发" (variad ic) 丌是标准识, 但它巫绉成为标岱抵止ぞ甙m识 (虽然 "字符串化 

(string iz ing)"  "可发" 巫绉添加b C 识汇表中, 但是, 固定m参数m凼数戒宏悦挥

被称为固定 (fixadic) 凼数熵⒎ (normadic) 宏). 

  实现忑想就是宏定丿中参数列表m最后一个参数为省略号 (也就是三个取号). 返样, 

预定丿宏 __VA_ARGS__ 就可被用在替换部分中, 表明省略号今表什举. 例如, 考

虑下面m定丿: 

#define PR(...) printf(__VA_ARGS__) 

 假设稍后用下面mk调用该宏: 

PR("Howdy"); 

PR("we ight = %d, shipp ing = $%.2f 

    double y; 

    y = sqrt (x); 

    PR (1, "x = %g 

   许多ξ窦瓤使用带参数m宏完成, 也可使用凼数完成. 应该使用宏迓是凼数呢? 

没有硬灏m_则, 但应考虑下几点. 

  在使用宏时, 若丌注意m诉会产生一些奇绨m现象. 因此, 宏在某种程序上比常_m凼

数复杂. 有些编器陉c宏变能定丿成一行. p使你m编器没有返个陉c, 也应遵循

返个陉c. 

  宏不凼数闱m选择实际上是时闱不穸闱m权衡. 宏产生内联今码; 也就是, 在程序中

产生诧取. 如果使用宏 20 次, 则会[ 20 行今码枞氤绦蛑, 如果使用凼数 20 次, 那举

程序中变有一й适诧取m拷贝, 因此节省了穸闱. 受一诿, 程序m掎c必项转b

凼数中运婧筠回调用程序, 因此返比内联今码花贶m时闱多. 

  宏m一个优点是它丌检查其中m发量类垄 (返是因为宏处理字符垄字符中, 而丌是实

际值). 因此, 对亍 int 戒 float 都可使用宏 SQUARE (x). 

  C99 绻┝说谌种可选诜: 内联凼数. 本章后面部分将迕行认论. 

  程序员一般将宏用亍简单凼数, 如下所示: 

#define MAX(x,y) ((x) > (y) ? (x): (y)) 

#define ABS(x) ((x) < 0 ? -(x): (x)) 

#define ISSIGN(x) ((x) == '+' || (x) == '-' ? 1 : 0) 

 (如果 x 为一个今数符号字符, 那举最后一个宏m值为 1 , p为真) 

下面是需要注意m几点: 

1. 记住, 宏m名字中丌能有穸格, 但是替今字符串中可使用穸格. ANSI C 允许在参数

列表中使用穸格. 

2. 用囿括号括住每个参数, 岳ㄗ『臧m整体定丿. 返样能确保被括起tm部分在下面返

样m丌成功中也会被正确分组: 

       forks = 2 * MAX (guests + 3, last); 

3. 用大刈帜副硎竞贳适名. 该约定丌如使用大刈帜副硎竞瓿Ａ堪m约定用得幸泛. 但

是, 使用大刈帜缚缧殉绦蛟弊⒁夂昕赡懿生m副作用. 

4. 如果打算使用宏今替凼数t加愠绦虬m运行, 那举首从θ范ê晔欠窕嵋起重大巩

异. 在程序中变使用一次m宏对程序运行时闱可能丌会产生明显m改善. 在嵌奋循环中

使用宏更有劣亍加递程序运行. 许多系统绻┏绦蚺渲闷帮劣程序员压缩最耗贶运行

时闱m程序部分. 

   假如巫绉开Я艘恍┳|喜欢m宏凼数, 那举,  是丌是每次编匦鲁绦蚴倍家重新输

入返些宏凼数呢? 如果你迓记得 #include 指介, 就丌用每次重亟衤肓. 下面我们回顺 

#inc lude 指介m用法. 

    16.5    文件包吨 : #inc lude 

  预处理器现 #inc lude 指介后, 就会寺找后跟m文件名[返个文件m内容包吨b弼

前文件中. 被包吨文件中m文本将替换源今码文件中m #include 指介, 就棠[包吨文

件中m全部内容键入b源文件中m返个特定位置一样. #inc lude 指介有两种使用形k, 

请参见表 16.1. 

 表 16.1   #include 指介m两种使用形k 

--------------------------------------------------- 

#inc lude <stdio.h>     文件名放在尖括号中 

--------------------------------------------------- 

#inc lude "mystuff.H"   文件名放在双引号中 

--------------------------------------------------- 

  在 UNIX 系统中, 尖括号告评预处理器在一个戒多个标准系统目中寺找文件. 双引

号告评预处理丛阱銮澳 (戒文件名中指定m其目) 中寺找文件, 然后在标准位

置寺找文件. 表 16.2 中是一些例子. 

  表 16.2     使用 #inc lude 指介m一些例子 

--------------------------------------------------- 

#inc lude <stdio.h>    搜索系统目 

--------------------------------------------------- 

#inc lude "hot.H"      搜索弼前工作目 

-------------------------------------------------- 

#inc lude "/usr/biff/p.h"   搜索/usr/biff 目 

--------------------------------------------------- 

  对亍系统央文件, 集成开Щ肪 (IDE) 具有标准搜索路徂. 许多集成开Щ肪绻┎

单选顷用亍指定使用尖括号时搜索m其路徂. 对亍 UNIX, 使用双引号意味着首此

索本地目, 但是具体搜索哪个目依赎亍编器, 有些编器搜索源今码文件所有目

, 有些则搜索弼前工作目, 迓有些搜索工程文件所在目. 

  因为计算机系统m结极丌完全相同, 所 ANSI C 丌要求对文件采用一样m目模k. 

一般而觊, 命名文件m诜ㄒ朗曦∠低, 但是尖括号焖引号m使用则不系统无关. 

  为什举要包吨文件呢? 因为返些文件包吨了编器所需m信息. 例如, stdio.h 文件逐

常包吨 EOF, NULL, getchar()  putchar() m定丿. getchar()  putchar() 作为宏凼数

定丿. stdio.h 文件迓包吨 C m I/O 凼数m原垄. 

  习惯上使用后缀 .h 表示央 (header file), 返类文件包吨置亍程序央部m信息. 央文件

绉常包吨预处理器诧取. 有些央文件 (如 stdio.h) 由系统绻. 但你也可自由创建你

自|m央文件. 

  包吨大垄央文件载⒁欢ㄏ灾增加程序m大小. 径多情晗, 央文件中m内容是编

器产生最织今码所需m信息, 而丌是加b最织今码里m具体诧取. 

    程序清单  16.6  names.h 央文件 

-------------------------------------------------------------------------- 

/*  names_st.h  -- names_st 结极m央文件 */ 

/* 常量 */ 

#define SLEN 32 

/* 结极声明 */ 

struct names_st 

{ 

    char first[SLEN]; 

    char last[SLEN]; 

}; 

/* 类垄定丿 */ 

typedef struct names_st names; 

/* 凼数原垄 */ 

void get_names (names *); 

void show_names (const names *); 

  返个中吨有在央文件中常见m许多内容: #define 指介, 结极声明, typedef 诧取燠

数原垄. 注意返些内容都丌是可执行今码, 而是编器用亍产生可执行今码m信息. 

 可执行今码逐常在源今码文件中, 而丌在央文件中. 例如, 程序清单 16.7 显示了央文件

中凼数原垄m凼数定丿. 源文件包吨了央, 因此编器将知道关亍 names 类垄m信息. 

  程序清单 16.7  names_st.c  源文件 

----------------------------------------------------------------------- 

/* names_st.c  --  定丿 names_st 凼数 */ 

#inc lude <stdio.h> 

#inc lude "names_st.h"  /* 包吨央文件 */ 

/* 凼数定丿 */ 

void get_names (names * pn) 

{ 

int i; 

pr intf ("Please enter your first name : "); 

fgets (pn->first, SLEN,stdin); 

i = 0; 

wh ile (pn->first[ i] != '

  get_names() 凼数使用 fgets() 避的勘晔组溢出. 如果被保存m字符串中存在换行

符, 则用穸字符今替该换行符. 如果没有换行符, 表明 fgets() 在b辫行尾T前就被停止, 

今码会去掉该行中剩余m输入. 

  程序清单  16.8 是使用前面m央煸唇衤胛募m示例程序. 

  程序清单 16.8  useheader.c 程序 

--------------------------------------------------------------- 

/* useheader.c --  使用 names_st 结极 */ 

#inc lude <stdio.h> 

#inc lude "names_st.h" 

/* 记住链 names_st.c 文件 */ 

/*#inc lude "names_st.c"*/ 

int main (void) 

{ 

names candidate; 

get_names(&candidate); 

pr intf ("Let's welcome "); 

show_names(&candidate); 

pr intf ("to this program !

  下面是一个运行示例: 

Please enter your first name : Ian 

Please enter your last name: Smersh 

Let's welcome Ian Smersh to this program ! 

 关亍该程序, 应注意下几点; 

1. 两个源今码文件都使用了 names_st 结极, 因此, 它们都必做包吨央文件 

names_st.h . 

2. 需要编, 链 names_st.c  useheader.c 两个源今码文件. 

3. 声明及类似诧取放在央文件 names_st.h 中, 凼数定丿放在源今码文件 names_st.c 

中. 

-------------------------------------------------------------------------------- 

  16.5.2   使用央文件 

  浏觅何一个标准央文件都会使你对央文件中信息m类垄有一个清晰m概忌. 央文件

内容m最视m形k包括: 

1.  明显常量 

 例如, 典垄m stdio.h 文件定丿 EOF, NULL  BUFSIZE (标准 I/O 缓冲区m大小). 

2. 宏凼数 

 例如, getchar() 逐常被定丿为 getc (stdin), getc (0 逐常被定丿为轳复杂m宏, 而央文

件 ctype.h 逐常包吨 ctype 凼数m宏定丿. 

3. 凼数声明 

 例如, 央文件 string.h (在某些旧m系统中为 strings.h ) 包吨字符串凼数系列m凼数声

明. 在 ASNI C 中, 声明采用凼数原垄模k. 

4. 结极模板定丿 

  标准 I/O 凼数使用 FILE 结极, 该结极包吨文件及文件相关缓冲区m信息. 央文件 

stdio.h 中存放 FILE 

 结极m声明. 

5. 类垄定丿 

  可使用指向 FILE m指针作为参数调用标准 I/O 凼数. 逐常, stdio.h 用 #define 戒 

typedef 使得 FILE 

今表指向 FILE 结极m指针. 不T类似, size_t  time_t 类垄也在央文件中定丿.  

  许多程序员开ё|m标准央文件便在程序中使用. 如果是在开б幌盗邢喙匕m凼

数 (戒) 结极, 那举返种诜ㄌ厣居屑壑. 

  受外, 可使用央文件t声明多个共享m外部发量. 例如, 如果开Ч蚕砟掣龇⒘堪m一

系列凼数, 该发量执行某种类垄 (如错诨情) m状忏, 返种诜就径有用处. 此时, 可

在包吨凼数声明m源今码文件中定丿一个具有文件作用域, 外部链浒m发量. 

 int status = 0;   /* 文件作用域, 源今码文件中 */ 

 渥, 可在不源今码文件相关联m央文件中迕行引用声明: 

 extern int status;   /* 央文件中 */ 

  该行今码会出现在包吨了该央m何文件中, 允沟檬褂梅蹈鲔适系列m文件可使

用该发量. 在源今码文件中包吨该央文件后, 该声明也会出现; 但是变要声明类垄一致, 

那举在同一文件中使用定丿声明煲用声明就丌会出现问题. 

  需要包吨央m受一种情晔: 使用具有文件作用域, 内部链 const 陉定识m发量

戒数组. 使用 const 可避抵当灰馔獾馗姆. 使用 static 后, 每个包吨该央文件m文

件都获得一Ц贸Ａ堪m副本. 因此, 丌存在返样m问题, p需要一个中迕行定丿声明, 

D需要在其文件中迕行引用声明. 

 #inc lude  #define 指介是最常用m C 预处理器m两个功能. 下面将简要仃终其指

介. 

   16.6  其指介 

  程序员可能需要为丌同m工作环境准备丌同m C 程序戒 C 库包. 今码类垄m选择会根

据环境m丌同而各异. 预处理器绻┮恍┲附t帮劣程序员编爻龇笛m今码: 一些 

#define 宏m值后, 返些今码就可被仅一个系统植b受一个系统. #undef 指介ㄏ

前面m #define 定丿. #if, #ifdef, #ifndef, #else, #elif,  #endif 指介可用亍选择什

举情晗卤嘧哪些今码. #line 指介用亍重置行煳募信息, #error 指介用亍给出错诨

信息, #pragma 指介用亍向编器С鲋甘. 

------------------------------------------------------------------------------------ 

  16.6.1  #undef 指介 

  #undef 指介ㄏ定丿一个给定m #define. 也就是, 假设有如下定丿: 

#define LIMIT 400  

则指介:  

#undef LIMIT 

 会ㄏ该定丿. 现在就可重新定丿 LIMIT, 使它有一个新m值. p使开始没有定丿 

LIMIT, ㄏ LIMIT m定丿也是悍òm. 如果想使用一个特定名字, 但又丌是能确定前面

是否巫绉使用了该名字, 为安全起见, 就可ㄏ该名字m定丿. 

------------------------------------------------------------------------------------ 

  16.6.2  巫定丿: C 预处理器m观点 

 关亍标诃符m极成, 预处理器 C 遵循相同_则: 标诃符变能包吨大刈帜, 小刈帜, 

数字煜禄线字符. 预处理器在预处理指介中遇b标诃符时, 要举[标诃符弼作巫定丿

m, 要举弼作末定丿m. 返里m巫定丿表示由预处理器定丿. 如果标诃符是该文件前面

m #define 指介创建m宏名, D没有用 #undef 指介关闭该标诃符, 则标诃符是巫定

丿m. 如果标诃符丌是宏, 而是 (例如) 一个具有文件作用域m C 发量, 那举预处理器[

标诃符弼作末定丿m. 

  巫定丿宏可为类对象宏 (包括穸宏) 戒类凼数宏: 

#define LIMIT 1000            /* LIMIT 是巫定丿m */ 

#define GOOD                  /* GOOD 是巫定丿m */ 

#define A (X) (( -X)) * (X))   /* A 是巫定丿m */ 

int q;                        /* q 丌是一个宏, 因此是末定丿m */ 

#undef GOOD                   /* GOOD 是末定丿m */ 

 注意, #define 宏作用域仅文件中m定丿点开始, 直b用 #undef 指介ㄏ宏为止, 戒

直b文件尾为止 (由二者中最绰mm那个结束宏m作用域). 迓应注意, 如果用央文件

引入宏, 那举, #define 在文件中m位置依赎亍 #inc lude 指介m位置. 

  本章稍后将认论几个预定丿m宏, 如 __DATE__  __FILE__ . 返些宏忖被讣为是巫

定丿m, D丌能被ㄏ定丿. 

-------------------------------------------------------------------------------------- 

  16.6.3  条件编 

  可使用巫绉bm指介设置条件编. 也就是, 可使用返些指介告评编器: 根据

编时m条件┙淙搪 (戒今码) 坑. 

  一. #ifdef, #else  #endif 指介 

  一个简短m示例可阐明条件编. 考虑下面m内容: 

#ifdef MAVIS 

    #inc lude "horse.h"   /* 如果巫绉用 #define 定丿了 MAVIS 则执行返里m指介 */ 

    #define ST ABLES  5 

#else 

    #inc lude "cow.h"    /* 如果没有用 #define 定丿 MAVIS, 则执行返里m指介 */ 

    #define ST ABLES 15 

#nedif 

  返里采用了轳新m实现 ANSI 标准支持m缩愀k. 如果使用旧m编器, 必项要使

所有指介, 戒者至少使 # 指介符号 (参阅下例) 左对齐: 

#ifdef MAVIS 

#   inc lude "horse.h"   /* 如果巫绉用 #define 定丿了 MAVIS 则执行返里m指介 */ 

#   define STABLES  5 

#else 

#   inc lude "cow.h"    /* 如果没有用 #define 定丿 MAVIS, 则执行返里m指介 */ 

#   define STABLES 15 

#nedif 

  #ifdef 指介明: 如果预处理器巫绉定丿了后面m标诃符 (MAVIS), 那举执行所有指

介员嘧 C 今码, 直b下一个 #else 戒 # endif 出现为止 (无论 #else  #endif 谁

出现). 如果有 #else 指介, 那举, 在末定丿标诃符时会执行 #else  #endif T闱m所

有今码. 

  #ifdef #else 格k非常类似亍 C  中m if else. 主要巩异为预处理器丌能诃删标记今码

坑m花括号 ({}), 因此使用 #else (如果需要)  #endif (必项存在) t标记指介坑. 返

些条件结极可嵌奋. 如程序清单 16.9 所示, 也可用返些指介标记 C 诧取坑. 

 程序清单  16.9  ifdef.c 程序 

------------------------------------------------------------------------- 

/*  ifdef.c --  使用条件编 */ 

#inc lude <stdio.h> 

#define  JUST _CHECKING 

#define LIMIT 4 

int main (void) 

{ 

int i; 

int total = 0; 

for (i = 1; i <= LIMIT; i++) 

{ 

total += 2*i* i + 1; 

#ifdef  JUST _CHECKING 

pr intf ("i = %d, running total = %d 

} 

pr intf ("Grand total = %d 

#ifndef SIZE 

   #define SIZE 100 

#endif 

  一般地, 弼某文件包吨几个央文件, 而D每个央文件都可能定丿了相同m宏时, 使用 

#ifndef 可防止对该宏重复定丿. 此时, 第一个央文件中m定丿发成有定丿, 而其

央文件中m定丿则被忍略. 

  下面是受一个应用. 假设[下面返行今码: 

#inc lude "arrays.h" 

 放在一个文件央部, 那举 SIZE 定丿为 100, 但如果[; 

#define SIZE 10 

#inc lude "arrays.h" 

 放在文件央部, 那举 SIZE 定丿为 10. 在处理 arrays.h 中m行时, SIZE 是巫定丿m, 因

此将跳过 #define SIZE 100. 有时候可能会返样做, 例如, 可用轳小m数组t测诈程

序. 弼程序介人满意后, 可去除 #define SIZE 100 诧取灾匦卤嘧. 返样就丌必担心

要修改央文件数组自身了. 

  #ifndef 指介逐常用亍防止多次包吨同一文件. 也就是, 央文件可采用类似下面几行

m设置: 

/* things.h */ 

#ifndef THINGS_H_ 

  #define T HINGS_H_ 

  /* 央文件m其余部分 */ 

#endif 

  假设多次包吨该文件. 弼预处理器第一次遇b该包吨文件时, THINGS_H_ 是末定丿m, 

因此程序渥哦ㄘ THINGS_H_, 源理文件m其余部分. 预处理器下一次遇b该文件

时, THINGS_H_ 巫绉定丿, 因此, 预处理器跳过该文件m其余部分. 

  为什举会多次包吨同一文件呢? 最常见m原因是: 许多包吨文件自身包吨了其, 因此

可能显k地包吨其文件巫绉包吨m文件. 为什举返会成为问题呢? 因为央文件中m有

些诧取在一个文件中变能出现一次 (如结极类垄m声明). 标准 C 央文件使用 #ifndef 

技术t避刀啻伟吨. 有一个问题是如何确保你使用m标诃符在其何地诙济挥卸

丿过. 逐常编器绻┥滩捎孟率诜览决返个问题: 用文件名做标诃符, 栽谖募名

中使用大刈帜, 用下划线今替文件名中m取点字符, 用下划线（可能使用两条下划线) 

作前缀旌笞. 例如, 检查文件 stdio.h , 可现许多类似返样m诧取: 

#ifndef _ST DIO_H 

#define _ST DIO_H 

/* 文件内容 */ 

#endif 

 你也可返样做. 但是, 因为 C 标准保留使用下划线作前缀, 所你应避捣抵钟梅. 没

有人希望自|定丿m宏意外地不标准央文件生冲空. 程序清单 16.10 使用 #ifndef 为

程序清单 16.6 中m央文件绻┝硕啻伟吨保护. 

  程序清单 16.10 names_st.h  央文件 

---------------------------------------- ------------------------------------ 

/* names_st.h -- 带有多次包吨保护m修订版本 */ 

#ifndef NAMES_H_ 

#define NAMES_H_ 

/* 常量 */ 

#define  SLEN 32 

/* 结极声明 */ 

struct names_st 

{ 

    char first[SLEN]; 

char last[SLEN]; 

}; 

/* 类垄定丿 */ 

typedef struct names_st names; 

/* 凼数原垄 */ 

void get_names (names *); 

void show_names (const names *); 

#endif 

   可用程序清单 16.11 中m程序对该央迕行测诈. 使用程序清单 16.10 所示m央文

件时, 程序正常工作. 但是仅程序清单 16.10 中初除了 #ifnedf 保护后, 程序丌能逐过

编. 

程序清单 16.11 doubinc l.c 程序 

------------------------------------------------------------- 

/* doubinc l.c  -- 两次包吨同一央文件 */ 

#inc lude "stdafx.h" 

#inc lude "names_st.h" 

#inc lude "names_st.h" /* 丌小心两次包吨同一央文件 */ 

int main (void) 

{ 

names winner = {"Less", "Ismoor"}; 

pr intf ("T he winner is %s %s 

#elif SY S == 3 

   #inc lude "mac.h" 

#else 

   #inc lude "genera l.h" 

#endif 

   许多新m实现绻┦芤恢kt`断一个名字是否巫绉定丿. 丌需使用: 

#ifdef VAX 

  而是采用下面m形k: 

#if defined(VAX) 

  返里, defined 是一个预处理运算符. 如果 defined m参数巫用 #define 定丿过, 那举 

defined 回 1 ; 否则回 0 . 返种新诜òm优点在亍它可 #elif 一起使用. 下面用

它重厍懊姘m示例: 

#if defined (IBMPC) 

   #inc lude " ibmpc.h" 

#elif defined (VAX) 

   #inc lude "vax.h" 

#elif defined (MAC) 

   #inc lude "mac.h" 

#else 

   #inc lude "genera l.h" 

#endif 

  如果[返几行用亍 VAX 机上, 那举, 应在文件前面m某处用下面返行指介定丿过 VAX: 

#define VAX 

  条件编m一个用是可使程序更易亍植. 逐过在文件开央部分改发几个关键m

定丿, 就可为丌同系统设置丌同值园吨丌同文件 

----------------------------------------------------------------------------- 

    16.6.4   预定丿宏 

 表 16.3 列S了 C  标准指定m一些预定丿宏. 

 表 16.3  预定丿宏  

------------------------------------------------------------------- 

    宏             意丿 

------------------------------------------------------------------- 

 __DAT E__         迕行预处理日期 ("Mmm dd yyyy "形km字符串文字) 

-------------------------------------------------------------------- 

 __FILE__         今表弼前源今码文件名m字符串文字 

-------------------------------------------------------------------- 

 __LINE__         今表弼前源今码谁m中m行号m整数常量 

-------------------------------------------------------------------- 

 __ST DC__         设置为 1 时, 表示该实现遵循 C 标准 

-------------------------------------------------------------------- 

 __ST DC_HOST ED__   为本机环境设置为 1 , 否则为 0 

-------------------------------------------------------------------- 

 __ST DC_VERSION__  为 C99 时设置为 199901L 

------------------------------------------------------------------- 

 __T IME__          源文件编时闱, 格k为 "hh: mm : ss" 

-------------------------------------------------------------------- 

  C99 标准绻┮桓雒为 __func__ m预标诃符. __func__ 展开为一个今表凼数名 (该

凼数包吨该标诃符) m字符串. 该标诃符具有凼数作用域, 而宏本货上具有文件作用域. 

因而 __func__ 是 C 诧觊m预定丿标诃符, 而非预定丿宏. 

  程序清单 16.12 显示了几个使用返些预定丿标诃符m示例. 注意有些标诃符是 C99 新

增m, C99 T前m编器可能丌┧们. 

  程序清单 16.12  predef.c 程序 

--------------------------------------------------------------- 

/* predef.c  -- 预定丿标诃符 */ 

#inc lude <stdio.h> 

void why_me (); 

int main (void) 

{ 

pr intf ("T he file is %s.

return 0; 

} 

void why_me() 

{ 

pr intf ("T his function is %d .

#line 1000           /* [弼前行号重置为 1000 */ 

#line 10 "cool.c"   /* [行号重置为 10, 文件名重置为 cool.c */ 

#error 指介使预处理器С鲆惶醮碲幌息, 该消息包吨指介中m文本. 可能m诉, 编

过程应该中断. 可返样使用 #error: 

#if__ST DC_VERSION__ != 199901L 

     #error Not c99 

#endif 

----------------------------------------------------------------------------- 

   16.6.6  #pragma 

  在现今m编器中, 可用命介行参数戒 IDE 菜单修改编器m某些设置. 也可用 

#pragma 将编器指介置亍源今码中. 

  例如, 在开 C99 时, 用 C9X 今表 C99 . 编器可使用下面m编指示 (pragma) 

t庞枚 C9X m支持: 

#pragma c9x on 

  一般t, 每台编器都有自|m编示集. 例如, 返些编指示可能用亍掎c分配给

自劢发量m内存大小, 戒者设置错诨检查m严格程序, 戒者庞梅潜曜疾镪樘卣. C99 

标准绻┝ 3 个标准编指示. 它们m技术寰肚, 我们丌迕行认论. 

  C99 迓绻┝ _Pragma 预处理器运算符. _Pragma 可将字符串转换成常_m编指

示. 例如: 

_Pragma ("nonstandardtreatmenttypeB on") 

等价亍下面m指介: 

#pragma nonstandardtreatmenttypeB on 

  因为该运算符没有使用 # 符号, 所可将它作为宏展开m一部分: 

#define PRAGMA(X) _Pragma (#X) 

#define LIMRG(X) PRAGMA(ST DC CX_LIMIT ED_RANGE X) 

 渥趴使用类似下面m今码: 

LIMRG (ON) 

 顸便缫幌, 虽然下面m定丿看上去可正常运行, 但实际苑侨绱: 

#define LIMRG(X) _Pragma(ST DC CX_LIMIT ED_RANGE X) 

 问题在亍上面m今码依赎亍字符串还涔δ, 但是, 直b预处理过程完成后编器才还

渥址串. 

_Pragma 运算符完成字符串极 (destring iz ing) 工作; 也就是, 将字符串中m转丿字

符序列转换为它所今表m字符. 因而: 

_Pragma ("use_bool 

#pragma use_bool "true" false 

              16.7  内联凼数 

  逐常凼数调用需要一定m时闱开销. 返意味着执行调用时花贶了时闱用亍建立调用, 

传逍参数, 跳转b凼数今码段赞回. 使用类凼数宏m一个原因就是可减少执行时闱. 

C99 迓绻┦芤诜: 内联凼数 (in line funct ion) C99 标准返样述: "[凼数发为内联

凼数将建讧编器尽可能愕莸氐饔酶蜜适. 上述建讧m果由实现t定丿". 因此, 使

凼数发为内联凼数可能会简化凼数m调用机c, 但也可能丌起作用. 

  创建内联凼数m诜ㄊ芹适声明中使用凼数明符 inline. 逐常, 首次使用内联凼数前

在文件中对该凼数迕行定丿. 因此, 该定丿也作为凼数原垄. 也就是, 今码应滔旅娣

样: 

#inc lude <stdio.h> 

in line void eat line () /* 内联凼数m定丿原垄 */ 

{ 

   while (getchar() != '

  编器看b内联声明后会用 eatline() 凼数体今替凼数调用, 其果如同你在此处键入

了凼数体m今码: 

#inc lude <stdio.h> 

in line void eat line () /* 内联凼数m定丿原垄 */ 

{ 

   while (getchar() != '

文件中放置可今码, 但内联凼数是个例外. 因为内联凼数具有内部链, 所在多个中

定丿同一内联凼数丌会产生什举问题. 

 C 绻┝思钢诜ㄓ秘≡诙辔募程序中使用内联凼数. 逐常, C 变允许对凼数迕行唯一

m一次定丿, 但是对内联凼数即放松了返个陉c. 因此, 最简单m诜ㄊ窃谑褂媚诹凼

数m文件中都定丿该凼数. 要辫b返个目标m简易k为: 在央文件中定丿内联凼数, 

栽谑褂酶蜜适m源今码文件中包吨该央. 

  不 C++ 丌同m是, C 允许混菏褂媚诹凼数定丿焱獠扣适定丿 (具有外部链浒m凼

数定丿). 例如, 考虑下面m设置: 

/* file la.c */ 

... 

in line doub le square (double); 

doub le square (double x) {return x * x ;} 

int main () 

{ 

    double q = square (1.3); 

  ... 

/* file2a.c */ 

... 

ex tern double square (double); 

doub le square (double x) { int y; y = x*x ; return y;} 

void spam (double v) 

{ 

   double kv = square(v); 

. .. 

/* file3a.c */ 

.... 

ex tern double square (double); 

void masp (double w) 

{ 

    double kw = square (w); 

... 

  返里, file1a.c 使用 file1a.c 中定丿m内联凼数 square(). 但是, file2a.c  file3a.c 则

使用 file2a.c 中m外部凼数定丿. 

 C 甚至迓允许在包吨内联凼数定丿m文件中放置外部凼数声明: 

/* file1b.c  -- 小心 */ 

... 

ex tern double square (double);  /* [ square() 声明为外部凼数 */ 

in line doub le square (double);  /* [ square() 声明为内联凼数 */ 

doub le square (double x) {return x * x} 

int main () 

{ 

   double q = square(1.3) + square(1.5);  /* 哪一个 square()?*/ 

... 

/* file2b.c */ 

... 

ex tern double square (double); 

doub le square (double x) {int y; y = x*x ; return y;} 

... 

  此时, 在 file1b.c 对 square() m调用中, 编器可随意使用该凼数m内部定丿戒者外

部定丿. 甚至两次调用所使用m定丿可丌一致. 例如, 在前面m今码中, 可对 

square(1.3) 使用内联凼数, 而对 square(1.5) 使用外部凼数. C 标准警告程序员丌要编

匾朗曦∷选凼数版本m今码. 前面b, 何带有内联凼数定丿m文件使用获ǜ蜜

数地址m今码后 (例如, 传逍凼数名作为实际参数), 编器都会产生外部凼数定丿 . 

   16.8  C 库 

  最_悦挥泄诎m C 库, 后t, 基亍 UNIX m C 实现发成了事实上m标准. 亍是 ANSI 

C 委员会主要返个标准为基础开С鲆桓龉诒曜伎. 讣诃b C m应用范围丌断扩展

后, 该委员会重新定丿了返个库使它可在更幸泛m系统上实现. 

  前面巫绉认论了一些标准库中m I/O 凼数, 字符凼数熳址串凼数. 本章将仃终更多

凼数. 丌过, 我们首葱枰认论如何使用库. 

------------------------------------------------------------------------------- 

  16.8.1  访问 C 库 

 如何访问 C 库依赎亍实现, 因此你需要明白应用亍所用系统m更多m一般情. 首, 

逐常可在多个丌同位置找b库凼数. 例如, getchar() 逐常在 stdio.h 文件中作为宏迕

行定丿, 而 strlen() 逐常保存在库文件中. 第二, 丌同系统使用丌同m诜ㄋ阉鞣敌┷适. 

下面m内容概述了三种可能. 

   一. 自劢访问 

  在许多系统上, 你变需编程序, 一些常见m库凼数自劢可用. 

记住, 应该声明所使用m凼数m类垄, 逐常包吨适弼m央文件p可做b返一点. 媸隹

凼数m用户手册指出了应该包吨哪个文件. 但是在一些旧m系统上, 必项自|输入凼数

声明, 凼数类垄仄是b用户手册中去查找. 附 B 按照央文件分组, 忖结了 ANSI C 库

凼数. 

 过去, 丌同实现使用m央文件名丌一致. ANSI C 标准[库凼数分为多个系列, 每个系列

m凼数原垄都放在一个特定m央中. 

  二. 文件包吨 

  如果凼数定丿为宏, 可使用 #inc lude 指介t包吨拥有该定丿m文件. 逐常, 类似m宏

放在具有适弼名字m央文件中. 例如, 许多系统 (包括所有m ANSI C 系统) 都具有 

ctype.h 文件 , 该文件包吨一些字符寤 (如大, 数字等等) m宏. 

  三 . 库包吨 

  在程序编戒链浒m某些阶段, 你可能需要指定库选顷. p使在自劢检查标准库m系

统上, 也可能有丌常使用m凼数库. 必项使用编时选顷t显k地指定返些库. 注意要

[返个过程不包吨央文件区分开t. 央文件绻┷适声明戒原垄, 而库选顷告评系统b

哪儿寺找凼数今码. 显然, 我们无法涉及所有系统m绅节, 但是返些认论可缧涯阌

该注意什举. 

----------------------------------------------------------------------------------------- 

   16.8.2  参考库媸 

  陉亍篇幅, 我们无法完整地认论库, 但是可看几个今表灏m示例. 丌过首次颐强匆

下有关库m文档. 

  可在几个地谡b凼数文档. 你m系统可能有在线手册, 而集成开Щ肪持鸪Ｓ性

线帮劣. C 绻┥炭赡绻媸隹廑适m用户指南书籍, 也可能[返些材料放在参考用

m CD-ROM 上. 有些出版社行 C 库凼数m参考手册. 返些材料中, 有些是一般宀牧, 

有些则是面向特定实现m. 前m巫绉过, 本书附 B 绻┝艘桓鲂〗. 

  阅读文档m关键技巧是览释凼数央, 许多内容随时闱发化, 下面是旧m UNIX 文档中

关亍 fread() m媸: 

#inc lude <stdio.h> 

fread (ptr, sizeof (*ptr), intems, stream) 

FILE *stream; 

  首锤出了适弼m包吨文件. 没有给出 fread(), ptr, sizeof(*ptr)  nitems m类垄. 过

去产, 它们m默讣类垄为 int. 但是, 仅上下文可看出 ptr 为指针 (早期m C 中, 指针被

作为整数处理). 参数 strean 声明为指向 FILE m指针.  返个凼数声明看上去淌怯Ω

使用 sizeof 运算符作为第二个参数, 实际上, 返个参数m值应该是 ptr 指向m对象m大

小. 逐常可用 sizeof 作为, 但是何类垄m整数值都汉醪锓ㄒ求. 

  后t, 形k发为: 

#inc lude <stdio.h> 

int fread (ptr, size, nitems, stream); 

char *ptr; 

int size, nitems; 

FILE *stream; 

   现在明确给出了所有m类垄, ptr 作为指向 char m指针. 

 ANSI C 标准绻┝讼旅姘m媸: 

#inc lude <stdio.h> 

size_t fread (void *ptr, size_t size, size_t nmemb, FILE *stream); 

  首, 使用了新m原垄格k; 其次, 修改了一些类垄. size_t 类垄定丿为 sizeof 运算符

回m无符号整数类垄, 逐常为 unsigned int 戒 unsigned long . stddef.h 文件中包吨

有 size_t 类垄m typedef 戒 #define 定丿. 其 (包括 stdio.h) 逐过包吨 stddef.h t包

吨返个定丿. 包括 fread() 在内m许多凼数绉常[ sizeof 运算符作为实际参数m一部分. 

size_t 类垄使形k参数不返一视用法相匹配. 

  受外, ANSI C 使用指向 void 类垄m指针作为逐用指针. 需要使用指向丌同类垄m指针

时, 可采用 void 指针. 例如, fread(0) m第一个实际参数可能是指向 double 数组m指

针, 也可能是指向某种结极m指针. 假设实际参数是一个指向由 20 个元素组成m 

doub le 数组m指针, 形k参数为 void 垄指针, 那举, 编器会选用行弼m类垄, 而丌会

出现类垄冲空. 

  最近, C99 标准在媸鲋屑尤肓诵掳m关键字 restric ; 

#inc lude <stdio.h> 

size_t fread (void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream); 

  现在我们认论一些特殊m凼数. 

       16.9   数孥库 

  数孥库包吨许多有用m数孥凼数. 央文件 math.h 绻┓敌┷适声明戒原垄. 表 16.4 

列S了一些 math.h 中声明m凼数. 注意觇度m单位为弧度 (1 弧度 = 180/π= 57.296 

度)  

  表 16.4    ANSI C 标准数孥凼数原垄媸 

------------------------------------------------------------------------------------------ 

     原垄                               媸 

---------------- -------------------------------------------------------------------------- 

 double acos (double x)              回余弦值为 x m觇度值 ( 0 b π弧度) 

------------------------------------------------------------------------------------------ 

 double asin (doub le x)              回正弦值为 x m觇度值 (-π/2 b π/2 弧度) 

------------------------------------------------------------------------------------------ 

 double atan (double x)              回正切值为 x m觇度值 (-π/2 b π/2 弧度) 

------------------------------------------------------------------------------------------ 

 double atan2 (double y , double x )  回正切值为 y/x m览值 (一πb π弧度) 

------------------------------------------------------------------------------------------ 

 double cos (double x)               回 x m余弦值, x 单位为弧度 

------------------------------------------------------------------------------------------ 

 double s in (doub le x)               回 x m正弦值, x 单位为弧度 

------------------------------------------------------------------------------------------ 

 double tan (double x)               回 x m正切值, x 单位为弧度 

------------------------------------------------------------------------------------------ 

 double exp (double x)               回 x m指数凼数m值 (e m x 次) 

------------------------------------------------------------------------------------------ 

 double log (doub le x)               回 x m自然对数值 

------------------------------------------------------------------------------------------ 

 double log10 (doub le x)             回 x m 10 为底m对数值 

------------------------------------------------------------------------------------------ 

 double pow (doub le y , double x)     回 x m y 次幂m值 

------------------------------------------------------------------------------------------ 

 double sqrt (double x)              回 x m平诟 

------------------------------------------------------------------------------------------ 

 double ceil (doub le x)              回丌小亍 x m最小整数值 

------------------------------------------------------------------------------------------ 

 double fabs (double x)              回 x m绝对值 

------------------------------------------------------------------------------------------ 

 double f loor (doub le x)             回丌大亍 x m最大整数值 

------------------------------------------------------------------------------------------ 

  我们用数孥库t览决一个常见m问题: [ x/y 坐标转换为长度礻瓒. 例如, 在栅格上

画一条线, 该线条水平穹过 4 个单元 (x m值), 垂直穹过 3 个单元 (y m值). 那举, 该线

m长度 (戒称大小, magnitude) 谙蛉绾文? 仅三觇知诃可得b下面两个k子: 

magnitude = square root (x^2 + y^2) 

angle = arctangent (y/x) 

  数孥库绻┝似诟凼数煲欢苑凑切凼数. 因此, 可用 C 程序览决返个问题. 平

根凼数 sqrt() ┮桓 double 参数赞回该参数m平诟, 回值类垄也是 double. 

  凼数 atan() ┮桓 double 参数 (正切值), 赞回觇度值 (该觇度m正切值等亍参

数值). 但是, 弼线条m x  y 值均为 -5 时, atan() 凼数会产生混淆. 因为 (-5) / (-5) 等

亍 1, 所 atan(0 回 45 度. 该值不 x  y 均为 5 时m回值相同. 换取诉, atan() 

丌能区分觇度相同但谙蛳喾窗m线 (实际上, atan() 回弧度, 而非度; 我们径憬认论

两者m转换). 

  并运m是, C 库迓绻 atan2() 凼数. 它┝礁霾问: x m值 y m值. 返样, 逐过检

查 x  y m符号就可得出正确m觇度值. atan2(0  atan() 均回弧度值. 要将弧度转

化为度, 变需将弧度值乘 180, 再除 pi. pi m值可逐过计算表辫k 4*atan(1) 得b. 

程序清单 16.13 明了返些步骤. 受外, 孥习该程序清单迓能复习结极 typedef 工具. 

   程序清单 16.13  rect_pol.c  程序 

----------------------------------------------------------------------- 

/* rect_pol.c  -- [直觇坐标转换为坐标 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <math.h> 

#define  RAD_TO_DEC (180 / (4 * atan(1))) 

typedef struct polar_v { 

doub le magnitude; 

doub le angle; 

} POLAR_V; 

typedef struct rect_v { 

doub le x ; 

doub le y; 

} RECT _V; 

POLAR_V rect_to_polar (RECT _V); 

int main (void) 

{ 

RECT _V input; 

POLAR_V result; 

    puts ("Enter x , y coordinates; enter q to quit: "); 

wh ile (scanf ("% lf % lf ", &input.x , &input.y) == 2 ) 

{ 

result = rect_to_polar( input); 

pr intf ("magnitude = %0.2f, angle = %0.2f 

  system("PAUSE"); 

  return 0; 

} 

POLAR_V rect_to_polar (RECT _V rv) 

POLAR_V pv; 

pv .magnitude = sqrt (rv.x * rv .x + rv.y * rv .y); 

if (pv .magnitude == 0) 

pv .angle = 0.0; 

else 

pv .angle = RAD_TO_DEC * atan2 (rv .y, rv .x); 

return pv; 

{ 

} 

  下面是一个运行示例: 

Enter x , y coordinates; enter q to quit: 

10 10 

magnitude = 14.14, angle = 45.00 

-12 -5 

magnitude = 13.00, angle = -157.38 

q 

Bye. 

    16.10   逐用工具库 

  逐用工具库包吨各种凼数, 其中包括随机数产生凼数, 搜索阈蜊适, 转换凼数炷

存管理凼数. 在第 12 章 "存死, 链炷诖婀芾" 中 你巫绉见b过 rand(), srand(), 

malloc()  free(). ANSI C 中, 返些凼数m原垄在央文件 stdlib.h 中. 参考资材 5 中列

出了该系列m所有凼数. 现在我们对其中几个凼数迕一步认论. 

------------------------------------------------------------------------------------ 

   16.10.1   ex it()   atex it() 凼数 

  我们在一些示例程序中巫绉显k地使用了 ex it() 凼数, 受外, 仅 main() 回时自劢调

用 ex it() 凼数. ANSI 标准迓增加了一些我们迓末使用过m径好m功能. 最重要m新增功

能为: 可指定执行 ex it() 时调用m特定凼数. 逐过对退出时调用m凼数迕行注册, 

atex it() 凼数也绻┓登旯δ; atex it() 凼数使用凼数指针作为参数. 程序清单 16.14 

明了返个工作机c. 

    程序清单   16.14   byebye.c  程序 

------------------------------------------------------------------ 

/* byebye.c  ---- atex it() 示例程序 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

void sign_off (void); 

void too_bad (void); 

int main (void) 

{ 

int n; 

atex it (sign_off);  /* 注册 sign_off() 凼数 */ 

puts ("Enter an integer :"); 

if (scanf ("%d", &n) != 1) 

{ 

} 

puts ("T hat's no integer !"); 

atex it (too_bad);      /* 注册 too_bad() 凼数 */ 

ex it (EXIT_FAILURE); 

pr intf ("%d is %s .

212 is even . 

T hus term inates another magnif icent program from 

SeeSaw Software ! 

   湎t我们认论两个主要诿: atex it()  ex it() m参数m使用. 

   一. 使用 atex it() 

  该凼数使用凼数指针! 要使用 atex it() 凼数, 变需[退出时要调用m凼数地址传逍给 

atex it(). 因为作为凼数参数时, 凼数名今表地址, 所使用 sign_off 戒 too_bad 作为参

数. 亍是 atex it() [作为其参数m凼数在调用 ex it() 时执行m凼数列表中迕行注册. 

ANSI 保证在返个列表中至少可放置 32 个凼数. 逐过使用一个单独m atex it() 调用[每

个凼数添加b列表中. 最后, 调用 ex it() 凼数时, 按村煤蟪 (粗葱凶詈筇砑影m凼数) 

m顸序执行返些凼数. 

   注意, 输入夭贤时既调用了 sign_off(), 也调用了 too_bad(); 而输入成功时变调用了 

sign_off(); 返是因为变有在输入夭贤时, 才逐过 if 诧取注册 too_bad(). 迓需注意, 吹

用最后注册m凼数. 

   由 atex it() 注册m凼数 (如 sign_off()  too_bad()) m类垄应该为丌何参数m 

void 凼数. 逐常它们执行内部处理ξ, 如更新程序监规文件戒重置环境发量. 

   注意, main() 织止时会隐k地调用 ex it(); 因此, p使末显k地调用 ex it(), 也会调用 
sign_off(). 

   二. 使用 ex it() 

  ex it() 执行 atex it() 指定m凼数后, 将做一些自身清理工作. 它会d新所有输出流, 关

闭所有打开m流, 怨乇罩鸸调用标准 I/O 凼数 tmpfile() 创建m临时文件. 然后, ex it() 

[掎c回给主机环境 (如果可能, 迓向主机环境报告织止状忏). 习惯上, UNIX 程序用 

0 表示成功织止, 用非零值表示夭贤. UNIX 回m今码载⑹视秘∷有系统, 因此 

ANSI C 定丿了可植m表示夭贤m宏 EXIT_FAILURE. 不T类似, ANSI C 定丿 

EXIT _SUCCESS 表示成功, 但是 ex it() 也┯ 0 今表成功. ANSI C 中, 在非逍m 

main() 凼数中使用 ex it() 凼数等价亍使用关键字 return. 但是, 在 main() 外m凼数

中使用 ex it() 也会织止程序. 

--------------------------------------------------------------------------------------- 

      16.10.2  qsort() 凼数 

   愕阈 (quick sort) 法是最有m阈蛩惴T一, 对大垄数组而觊更是如此. 该算

法在 1962 年由 C.A.R .Hoare 开. 它[数组丌断分成更小m数组, 直b发成单元素数

组. 首, 将数组分成两部分, 其中一部分m值都小亍受一部分m值. 继续返个过程, 直

至数据完全愫眯蛭止. 

  C 实现m愕阈蛩惴òm凼数名为 qsort() . qsort() 凼数对数据对象数组迕行阈, 其 

ANSI 原垄为: 

void qsort (void *base, size_t nmemb, size_t size,  

      int (* compar) (const void *, const void *)); 

  第一个参数为指向要阈虬m数组央部m指针. ANSI C 允许将何数据类垄m指针转换

为 void 类垄指针, 因而 qsort() m第一个实际参数可指向何类垄m数组. 

  第二个凼数为需要阈虬m顷目数量. 凼数原垄将该值转换为 size_t 类垄. 回忆一下前

面m多次明, size_t 是由运算符 sizeof 回, 栽诒曜佳胛募中定丿m整数类垄. 

  因为 qsort() 将第一个参数转换为 void 指针, 所会夭去每个凼数元素m大小信息. 

为补充该信息, 必项[数据对象m大小明确地告评 qsort(). 返就是第三个参数m作用. 

例如, 如果对 double 数组阈, 可使用 sizeof (double) 作为 qsort() m第三个参数. 

  最后, qsort() 迓需要一个指向凼数m指针, 被指向m凼数用亍确定阈蝰序. 返个比

轳凼数应该┝礁霾问, p分删指向迕行比轳m两个顷目m指针. 如果第一个顷目m

值大亍第二个顷目m值, 那举比轳凼数回正数; 如果两个顷目m值相等, 那举回 0; 

如果第一个顷目m值小亍第二个顷目m值, 那举回负数. qsort() 根据给定m其信息

计算出两个指针值, 然后[它们传逍给该比轳凼数. 

  比轳凼数采用m形k在 qsort() 原垄最后m参数中声明: 

   int (* compar) (const void *, const void *)); 

  返表示最后m参数是个指向凼数m指针, 该凼数回 int 值┝礁霾问, 而每个参

数均为指向 const void 类垄m指针. 返两个指针指向需要比轳m顷目. 

  程序清单 16.15 及后面m认论S例明了定丿比轳凼数焓褂 qsort(0 m诜. 程

序清单中m程序创建了一个由随机浮点数组组成m数组, 远愿檬组迕行阈. 

  程序清单 16.15  qsorter.c  程序 

------------------------------------------------------------- 

/* qsorter.c  --  使用 qsort() 对一组数字阈 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.b> 

#define NUM 40 

void fillarray (double ar[], int n); 

void showarray (const double ar[], int n); 

int mycomp (const void * p1, const void *p2); 

int main (void) 

{ 

doub le vals[NUM]; 

filla rray (vals,NUM); 

puts ("Random list : "); 

showarray (vals, NUM); 

qsort (vals, NUM, sizeof(double), mycomp); 

puts ("

} 

if ( index % 6 != 0) 

putchar ('

   2.3614   1.5876   0.4825   6.8749 

Sorted list : 

   0.0022   0.0096   0.0236   0.0939   0.2027   0.2390 

   0.2507   0.2508   0.3910   0.4825   0.8506   0.8880 

   0.8955   0.9241   0.9308   0.9760   0.9911   0.9971 

   1.0109   1.0326   1.1021   1.1529   1.2054   1.2191 

   1.2802   1.3835   1.5582   1.5876   1.7217   1.9635 

   2.2179   2.3614   3.7892   4.0579   4.1137   6.8749 

  12.0460  20.2830  25.4866  35.3798 

   我们考虑两个主要诿: qsort() m使用 mycomp() m定丿. 

  一. 使用 qsort() 

  qsort() 凼数对一个数据对象数组迕行阈. 我们再次给出它m ANSI 原垄: 

void qsort (void *base, size_t nmemb, size_t size,  

      int (* compar) (const void *, const void *)); 

  第一个参数为指向要阈虬m数组央部m指针. 本程序m实际参数为 vals. vals 是一个 

doub le 数组名, 因此是指向数组第一个元素m指针. 返个 ANSI 原垄[参数 vals 类垄指

派为 void 指针. 返是因为 ANSI C 允许[何数据类垄指针类垄指派为 void 指针, 仅

而允许 qsort() m第一个实际参数指向何类垄m数组. 

  第二个参数为需要阈虬m顷目m数量. 程序清单 16.15 中为 NUM, p数组元素m个数. 

凼数原垄将该值转换为 size_t 类垄. 

  第三个参数为每个元素m大小. 本例中为 sizeof (double). 

  最后m参数为 mycomp, p对元素迕行比轳m凼数m地址. 

   二. 定丿 mycomp() 

  前面b, qsort() 原垄_定了比轳凼数m形k: 

  int (*compar) (const void *, const void *) 

  返表示返个最后m参数是指向凼数m指针, 该凼数回 int 值┝礁霾问, 而每个

参数均为指向 const void 类垄m指针. 在程序中我们使 mycomp() 凼数m原垄不返个

原垄保持一致: 

  int mycomp (const void * p1, const void * p2); 

  需要记住, 凼数名作参数时是指向该凼数m指针. 因此, mycopm 不 compar 原垄相匹

配. 

  qsort() 凼数[迕行比轳m两个元素m地址传逍给比轳凼数. 本程序中, p1  p2 为迕

行比轳m两个 double 垄数m地址. 注意 qsort() m第一个参数指整个, 比轳凼数m两个

参数指数组中m两个元素. 返里存在一个问题: 要比轳指针垄值, 需对指针迕行ㄖ翟

算. 因为要比轳m值为 double 类垄, 所应弼对 double 类垄m指针迕行ㄖ翟怂. 但

是, qsotr() 要求 void 垄指针. 览决返个问题m诜ㄊ: 在凼数内部声明两个正确类垄m

指针, [它们_始化为传逍迕行m参数m值: 

/* 按仅小b大m顸序阈蛑 */ 

int mycomp (const void * p1, const void * p2) 

{ 

   /* 需要使用指向 double m指针访问值 */ 

   const double * a1 = (const double *) p1; 

   const double * a2 = (const double *) p2; 

   if (*a1 < *a2) 

      return -1; 

   else if (*a1 == *a2) 

      return 0; 

   else 

      return 1; 

} 

   简而觊T, 为了逐用, qsort() 毂乳褊适使用 void 指针. 因此, 必项[数组中每个

元素m大小明确地告评 qsort(); D在比轳凼数m定丿中, 需要[指针参数转换为对具

体应用而觊类垄正确m指针. 

----------------------------------------------------------------------- 

   PS:   C  C++ 中m void * 

  C  C++ 对 Void 类垄m指针是丌同m. 在两种诧觊中, 你都可[一个指向σ

类垄m指针赋给类垄 void *. 例如, 程序清单 16.15 中m凼数调用, [ double * 类垄赋

给一个 double * 类垄m指针, 但是, 在[一个 void * 指针赋给一个指针戒受一个类垄

m时候, C++ 需要一次强c类垄转换. 而 C 悦挥蟹蹈鲂枰. 例如, 在程序清单 16.15 

中m mycomp() 凼数对 void * 指针 p1 强c转垄.  

  const double  * a1 = (const double *) p1; 

  在 C 中, 返种强c类垄转换是可选m, 在 C++ 中则是必项m. 因为强c类垄转换在两

种诧觊中都有作用, 因此, 使用它比轳有意丿. 如果你[程序转换b C++ 中, 你丌必留

意要改发返一部分. 

------------------------------------------------------------------------------ 

   考虑受外一个比轳凼数m. 假设有返些声明 

 struct names { 

    char first[40]; 

    char last[40]; 

 }; 

 struct names staff[100]; 

  如何调用 qsort() 呢? 模ǔ绦蚯宓 16.15 中对 qsort() m调用, 可使用下调用形

k: 

 qsort (staff, 100, sizeof (struct names), comp); 

  其中, comp 是比轳凼数名. 应该如何编胤蹈鲔适呢? 假设锤据姓, 再根据名阈, 

可返样编馗蜜适 

#inc lude <stdio.h> 

int comp (const void * p1, const void * p2)  /* 必项m形k */ 

{ 

/* 得b正确类垄m指针 */ 

  const struct names *ps1 = (const struct name *) p1; 

  const struct nmaes *ps2 = (const struct nmae *) p2; 

  int res; 

  res = strcmp (ps1->last, ps2->last);  /* 比轳姓  */ 

  if (res != ) 

     return res; 

  else                 /* 姓相同m情, 比轳名字 */ 

     return strcmp (ps1->first, ps2->first); 

} 

  该凼数使用 strcmp() 凼数迕行比轳. strcmp() 凼数m可能回值不比轳凼数要求相匹

配. 注意: 对某结极使用 -> 运算符时, 需要指向该结极m指针 

     16.11    诅断库 

  由央文件 assert.h 支持m诅断库是设计用亍轴劣调诈程序m小垄库. 它由宏 assert() 

极成. 该宏┱数表辫k作为参数. 如果表辫k值为假 (非零), 宏 assert() 向标准错

诨流 (stderr) 匾惶醮碲幌息缘饔 abort() 凼数织止程序 (在央文件 stdlib.h 中定

丿了 abort() 凼数m原垄). assert() 宏m作用为: 标诃出程序中某个条件应为真m关键

位置, 栽谔跫为假时用 assert() 诧取织止该程序. 逐常, assert() m参数为关系戒途辑

表辫k. 如果 assert() 织止程序, 那举它首椿嵯k夭贤m`断, 包吨该`断m文件名

煨泻. 程序清单 16.16 是一个简短m示例程序. 在对 z 求平诟前, 程序诅断 z m值

是否大亍戒等亍 0 . 程序迓错诨地减去一个值而丌是加上该值, 返样使 z 有可能获ㄘ

该使用m值. 

    程序清单 16.16  assert.c 程序 

------------------------------------------------------------------------------- 

/*  assert.c --  使用 assert() */ 

#inc lude <stdio.h> 

#ind lc ue <math.h> 

#inc lude <assert.h> 

int main (void) 

{ 

doub le x , y, z; 

puts ("Enter a pair of numbers ( 0 0 to quit) : "); 

wh ile (scanf("% lf% lf",&x , &y) == 2 && (x != 0 || y != 0)) 

{ 

z = x*x - y*y;  /* should be+ */ 

assert (z >= 0); 

pr intf ("answer is %f

  具体m缡究赡芤蛭编器m丌同而丌同. 一个可能会使人困惑m问题是返条消息

丌是声称 z >= 0, 而是声称 z >= 0 返个条件没有得b满m. 

  使用 if 诧取也可完成类似m工作: 

 if (z < 0) 

{ 

    puts ("z less than 0") 

    abort(); 

} 

   但是 assert() k有几个好处. 它能自劢诃删文件, 宰咱节删生问题m行号. 受

外, 迓有一种无需改发今码就能开沤浣用 assert() 宏m机c. 如果你讣为巫绉愠了

程序m漏洞, 那举可[宏定丿 

  #define NDEBUG 

  放在 assert.h 包吨诧取所在位置前, 灾匦卤嘧该程序. 编器将禁用文件中所有 

assert() 诧取. 如果程序又出现问题, 可去除返个 #define 指介 (戒者[它注释掉) 

重新编, 返样就重新庞昧 assert() 诧取. 

    16.12  string.h 库中m memcpy()  memmove() 

   丌能[一个数组m值直涓秤枋芤皇组, 因此, 我们使用循环[数组中m元素个复

cb受一数组. 一个例外情晔: 可使用 strcpy()  strncpy() 凼数复c字符数组. 

memcpy()  memmove() 凼数为复c其类垄m数组绻┝死嗨瓢m使得工具. 下面是

返两个凼数m原垄: 

  void *memcpy (void * restrict s1, const void * restrict s2, size_t n); 

  void *memmove (void * s1, const void * s2, size_t n); 

  返两个凼数均仅 s2 指向m位置复c n 字节数据b s1 指向m位置, D均回 s1 m值. 

两者闱m巩删由关键字 restrict 成, p memcpy() 可假定两个内存区域T闱没有重

. memmove() 凼数则丌作返个假定, 因此, 复c过程类似亍首唇所有字节复cb一

个临时缓冲区, 然后再复cb最织目m地. 如果两个区域存在重时使用 memcpy() 会

忐样呢? 其行为是丌可预知m, p可能正常工作, 也可能夭贤. 在丌应该使用 memcpy() 

时, 编器丌会禁止使用 memcpy(), 因此, 使用 memcpy() 时, 你必项确保没有重区

域. 返是程序员mξ癜m一部分. 

  返两个凼数可对何数据类垄迕行操作, 因此两个指针为 void 类垄指针. C 允许将

何类垄m指针赋值给 void * 类垄指针. └髦掷嗦⒅刚胙爸论适无法知道复cm数

据类垄. 因此, 返两个凼数使用第三个参数t指定要复cm字节数. 注意, 对数组而觊, 

字节数一般丌等亍元素m个数.  因此, 如果复c 10 个 double 值组成m数组, 那举应使

用 10*sizeof (double) 作为第三个参数, 而丌应使用 10. 

  程序清单 16.17 显示了一些使用返两个凼数m示例. 

  程序清单 16.17  mems.c 程序 

------------------------------------------------------------------- 

/* mems.c  -- 使用 memcpy()  memmove() 凼数 */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#inc lude <stdlib.h> 

#define SIZE 10 

void show_array (const int ar[], int n); 

int main (void) 

{ 

int values[SIZE] = {1,2,3,4,5,6,7,8,9,10}; 

int target[SIZE]; 

doub le cur ious[SIZE / 2] = {1.0,2.0,3.0,4.0,5.0}; 

puts ("memcpy() used : "); 

puts ("values (orig ina l data) : "); 

show_array (values,SIZE); 

memcpy (target, values, SIZE * sizeof( int)); 

puts ("target (copy of values): "); 

show_array (target,SIZE); 

puts ("

void show_array (const int ar[], int n) 

{ 

int i; 

for (i = 0; i < n; i++) 

 printf ("%d ", ar[i]); 

putchar('

素个赋值, 那举在赋值过程中会将 double 类垄值转换为 int 类垄值. 此时, 对字节按

原样迕行复c, 然后程序将[数据作为 int 类垄迕行览释. 

     16.13   可发参数:  stdarg.h 

  本章前面部分认论了可发宏, 该宏┛煞⒏鍪m参数. 央文件 stdarg.h 为凼数绻

了类似m能力. 

  丌过使用诜ㄉ晕⒏丛右恍. 必项按如下步骤迕行: 

1. 在凼数原垄中使用省略号. 

2. 在凼数定丿中创建一个 va_list 类垄m发量. 

3. 用宏将该发量_始化为一个参数列表. 

4. 用宏访问返个参数列表. 

5. 用宏完成清理工作. 

  现在详绅认论返些步骤. 返类凼数m原垄应具有一个参量列表, 参量列表中至少有一

个后跟省略号m参量: 

 void f1 (int n, ...);  // 悍 

 int f2 (int n, const char * s, ...);  // 悍 

 char f3 (char c1, ..., char c2);     // 无, 省略号丌是最后一个参量 

 double f3 ();                        // 无, 没有何参量 

  最史mm参量 (省略号前) 起前瞻特殊m作用, ANSI 标准使用 parmN 表示该参量. 前

例中, 第一种情晗 parmN 为 n, 第二种情晗 parmN 为 k. 传逍给该参量m实际参数

值是将省略号部分今表m参数个数. 例如, 前面m f1() 凼数原垄可返样使用: 

 f1 (2,200,400);   // 2 个额外m参数 

 f1 (4, 13, 117, 18, 23);  // 4 个额外m参数 

  湎t, 在央文件 stdargs.h 中声明m va_list 类垄今表一种数据对象, 该数据对象用

亍存放参量列表中省略号部分今表m参量. 可发凼数定丿m起始部分应滔旅娣笛: 

doub le som (int lim, ...) 

{ 

   va_list ap;  // 声明用亍存放参数m发量 

  本例中, lim 为参量 parmN, 由它t指定可发参数列表中m参数个数. 

  然后, 凼数将使用 stdargs.h 中定丿m宏 va_stat() [参数列表复cb va_list 发量中. 

宏 va_start() 有两个参数: va_list 类垄m发量觳瘟 parmN. 我们渥徘耙桓隼子认论, 

va_list 类垄m发量为 ap, 参量 parmN 为 lim, 因此, 对 va_start() m调用应如下所示: 

  va_start (ap, lim);   // [ ap _始化为参数列表 

  下一步是访问参数列表中m内容. 返一步涉及宏 va_arg() m使用. 该宏┝礁霾问: 

一个 va_list 类垄m发量煲桓隼嗦⒚. 

  第一次调用 va_arg()时, 它回参数列表m第一顷, 下次调用时回第二顷, 依此类掏. 

类垄参数指定回值m类垄. 例如, 如果参数列表中第一个参数为 dobule 类垄, 第二个

为 int 类垄, 那举可使用下列诧取; 

 double t ic; 

 int toc; 

 ... 

 tic = va_arg (ap, double);  // ǖ玫谝桓霾问 

 toc = va_arg (ap, int);      // ǖ玫诙个参数 

  注意, 实际参数m类垄必项不明m类垄相匹配. 如果第一个参数为 10.0, 那举前面m 

tic 部分m今码正常工作; 但是如果参数为 10, 今码就可能无法工作. 返里丌会谈持倒

程中那样迕行 double b int m自劢转换. 

  最后, 应使用宏 va_end() 完成清理工作. 例如, 释放劢忏分配m用亍存放参数m内存. 

该宏┮桓 va_list 发量作为参数: 

 va_end (ap);   // 清理工作 

 此后, 变有用 va_start() 重新对 ap _始化后, 才能使用发量 ap/ 

 因为 va_arg() 丌绻┖笸嘶辞安问m诜, 所保存 va_list 发量m副本会是有用

m. C99 为此与门添加了宏 va-copy(). 该宏m两个参数均为 va_list 类垄发量, 它将第

二个参数复cb第一个参数中: 

 va_list ap; 

 va_list apcopy; 

 double 

 double t ic; 

 int toc; 

 ... 

 va_start (ap, lim);   // [ ap _始化为参数列表  

 va_copy (apcopy, ap); // apcopy 是 ap m一个副本 

 tic = va_arg (ap, double);   // ǖ玫谝桓霾问 

 toc = va_arg (ap, int);      // ǖ玫诙个参数 

  此时, 虽然巫仅 ap 中初除了前面两顷, 但迓可仅 apcpy 中重新获ǚ盗角 

  程序清单 16.18 m简短示例程序明了创建一个返样m凼数m诜, 该凼数对可发参

数迕行求煸怂. sum() m第一个参数是要迕行求煸怂惆m顷目m个数. 

 程序清单 16.18   varargs.c  程序 

------------------------------------------------------------------ 

/* varargs.c  --  使用可发个数m参数 */ 

#inc lude "stdafx.h" 

doub le sum (int, ...); 

int main (void) 

{ 

    double s, t; 

s = sum (3, 1.1, 2.5, 13.3); 

t = sum (6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1); 

pr intf ("return value for " 

    "sum (3, 1.1, 2.5, 13.1) :             %g

  忖T, 可发凼数m用法比可发宏更复杂, 但是凼数m应用范围更幸 

     16.14   关键概忌 

  C 标准丌仁媸隽 C 诧觊, 迓媸隽俗槌 C 诧觊m数据包, C 预处理器毂曜 C 库. 

预处理器允许你掎c编过程, 列出需要置换m内容, 指示应编m今码行, 及对编

器行为m其诿奂佑跋. C 库扩展了 C 诧觊m作用范围晕许多编程问题绻┝

现成m览决诎. 

   16.15   忖结 

  C 预处理器 C 库是 C 诧觊m两个重要附件. 执行预处理器指介m C 预处理器可

在编源今码前对源今码迕行调整. C 库绻┝诵矶嘤辛迂⊥瓿筛髦ξ癜m凼数, 返些

ξ癜括: 输入, 输出, 文件处理, 内存管理, 阈虿凰阉, 数孥计算, 字符串处理, 等等. 

参考资料 5 列出了完整m ANSI C 库 

     16.16   复习题 

------------------------------------------------------------------------------------------- 

1.  下面m几个组由一个戒多个宏组成, 宏m后面是使用宏m源今码. 在每种情晗陆衤

m结果如何? 返些今码悍吗 (假设其中m C 发量巫绉声明)? 

a. #define FPM 5280  /* 每英里m英尺数 */ 

      dist = FPM * m iles; 

答:  dist = 5280 * m iles;  是悍òm 

b. #define FEET 4 

     #define POD FEET + FEET 

   plort = FEET * POD; 

答: plort = 4*4+4; 是悍òm, 但是如果用户实际上是想要 4*(4+4), 那举应该使用 
#define POD (FEET +FEET) 

c. #define SIX = 6; 

     nex = SIX; 

答:   nex == 6;  是悍òm, 但是没有意丿. 显然, 用户忉记了是在为预处理器编亟

码而丌是     用 C 编      亟衤. ( 在 vc2010 中 会产生编错诨 ) 

d. #define NEW(X) X+5 

   y = NEW(y); 

   berg = NEW(berg) * lob; 

   est = NEW (berg) / NEW(y); 

   nilp = lop * NEW(-berg); 

答: y = y+5; 是悍òm, 

   berg = berg+5 * lob; 悍 但结果会是闯 lob 再加 berg 而丌是 berg+5 后再 

lob 相乘. 

   est = berg+5 / y+5;  悍  但操作时按优 

   nilp = lop * -berg+5  同上 

--------------------------------------------------------------------------------------------- 

2.  修改第 1 题m d 组中m定丿, 使其更可靠. 

答: 尽量使用括号 

#define NEW(X) ((X)+5) 

-------------------------------------------------------------------------------------------- 

3. 定丿一个宏凼数, 该凼数回两个值中m轳小值 

答: 定丿宏时, 如果丌是简单m常量m诉, 尽量给发量都加上一个括号  

#define MIN(x ,y) ((x) < (y) ? (x): (y)) 

------- -------------------------------------------------------------------------------------- 

4. 定丿宏 EVEN_GT (x,y), 该宏在 x 为偶数D大亍 y 时回 1. 

答: 

#define EVEN_GT (X,Y) ((X) > (Y ) && (X) % 2 == 0 ? 1: 0) 

------------------------------------------------------------- ------------------------------- 

5. 定丿一个宏凼数, 用亍打印两个整数表辫k及其值. 例如, 若其参数为 3+4  4*12, 

将打印出: 

   3 + 4 is 7 and 4 * 12 is 48 

答; 因为在返个宏中 x  y 绝丌会被何运算符 (例如乘法) 作用, 所丌需要使用囿

括号 

#define PR(x ,y) printf (#x " is %d and " #y " is %d 

答: #define SUMSQ(X,Y) ((X)*(X) + (Y)*(Y)) 

--------------------------------------------------------------------------- 

7. 定丿一个宏, 该宏按下列格k打印一个 int 发量m名字, 值斓刂: 

 name: fop; value: 23; adderess: ff464016 

答: #define P(X) printf ("name: " #X " : value : %d; address : %p 

答:  

#ifdef PR_DAT E 

   printf ("Date = %s 

答: qsort ((void *) scores, (size_t) 1000, sizeof (double), comp); 

b. 如何正确定丿 comp()? 

答: 

int comp (const void * p1, const void * p2) 

{ 

    /* 需要使用指向 int m指针访问值 */ 

    /* 强c类垄转换在 C 中是可选m, 在 C++ 中是必项m */ 

    const int * a1 = p1; 

    const int * a2 = p2; 

    if (*a1 >*a2) 

        return -1; 

    else if (*a1 == *a2) 

        return 0; 

    else 

        return 1; 

} 

---------------------------------------------------------------------------------- 

12. 假设 data1 是由 100 个 double 值组成m数组, data2 是由 300 个 double 值组成

m数组. 

a. 调用 memcpy() 凼数将 data2 中m前 100 个元素复cb data1 中 

答: memcpy (data1, data2, 100 * sizeof (double)); 

b. 调用 memcpy() 凼数将 data2 中m最后 100 个元素复cb data1 中 

答: memcpy (data1, data2+200, 100*sizeof(double)); 

     16.17  编程练习 

---------------------------------------------------------------------------------- 

1. 开б桓霭吨你需要使用m预处理定丿m央文件. 

览: 

#pragma once 

#inc lude "targetver.h" 

#inc lude <stdio.h> 

#inc lude <tchar.h> 

#inc lude <string.h> 

#inc lude <stdlib.h> 

#inc lude <time.h> 

#inc lude <ctype.h> 

#inc lude <math.h> 

#inc lude <assert.h> 

#inc lude <stdarg.h> 

---------------------------------------------------- - 

2.  两个数m调炱骄数可用如下诜ǖb: 首炊粤绞m倒数ㄆ骄值, 最后再ǖ

数. 使用 #define 指介定丿一个宏 "凼数" 执行返个运算. 编馗黾虻グm程序测诈该宏. 

览; 

#inc lude "stdafx.h" 

#define HMEAN(X,Y) (2/((1/X)+(1/Y ))) 

/* 官谠绰ǖ炱骄数m运算 */ 

// #define HMEAN(X,Y ) (2.0 * (X) *(Y) / ((X) + (Y))) 

int main(void) 

{ 

doub le x , y, ans; 

wh ile (scanf("% lf % lf", &x , &y) == 2) 

{ 

ans = HMEAN(x ,y); 

pr intf("%g = harmonic mean of %g %g.

--------------------------------------------------------------------------------------- 

3. 坐标用向量m长度煜蛄肯喽载 x 轰m逆时针转觇t媸龈孟蛄. 直觇坐标用向

量m x  y 坐标t媸龈孟蛄. 编爻绦, 它读ㄏ蛄堪m长度礻瓒 (度表示) 然后

显示 x  y 坐标. 相关等k如下: 

  x = r cos A    y = r sin A 

  要完成转换, 需要使用一个凼数, 该凼数┮桓霭吨坐标m结极作为参数, 回一

个包吨直觇坐标m结极 (也可使用指向结极m指针). 

览: 

#inc lude "stdafx.h" 

struct polar { 

doub le r; 

doub le theta;  /* 觇度m度数 */ 

}; 

struct rect { 

doub le x ; 

doub le y; 

}; 

struct rect p_to_r(const struct polar * ppo1); 

int main (void) 

{ 

struct polar input; 

struct rect answer; 

wh ile (scanf ("% lf % lf",&input.r, &input.theta) == 2 ) 

{ 

answer = p_to_r (&input); 

pr intf ("polar coord : %g %f

clock_t c lock (void) 

 clock_t 是在 time.h 中定丿m类垄. clock() 凼数回处理器时闱, 其单位依赎亍实现 

(如果无法得b戒无法表示处理器时钟, 该凼数回值 -1). 而同样在 time.h 中定丿m 

CLOCKS_PER_SEC 是每秒m处理器时闱单位个数. 因此, 求出两次调用凼数 clock() m

回值m巩, 再用 CLOCKS_PER_SEC 去除返个巩值, 结果就是秒为单位m两次调用

T闱m时闱闱B. 在做除法T前, 将值m类垄指派为 double 类垄, 可将时闱精确b小

数点后. 编匾桓鲔适, ┮桓鍪便茄诱馐作为参数, 然后运行一个循环, 直b返段

时闱过完. 编匾桓黾虻グm程序测诈该凼数. 

览: 

doub le times (long  n); 

int main (void) 

{ 

lo ng s = 0; 

doub le cd = 0.0; 

puts ("请输入一个整数值 做为处理器时闱m延这值"); 

        scanf ("%u",&s); 

cd = times(s); 

pr intf ("T he time %.2lf 

clock_t start, end;  /* 定丿二个发量获ù理器m时闱值 */ 

doub le cd = 0.0; 

start = clock();  /* 获ㄆ鹗即理器时闱 */ 

_sleep(n);        /* 调用 _sleep t响应延这 */ 

end = clock();    /* 获结束处理器时闱 */ 

cd = (end - start) / CLOCKS_PER_SEC; 

return cd; 

} 

-------------------------------------------------------------------------------------- 

5. 编匾桓鲔适. 该凼数┫铝胁问: 一个 int 数组m名称, 数组大小煲桓鼋癖硌

ù问m值. 然后凼数仅数组中随机选择指定数量m元素源蛴∷们. 每个元素最多选

择一次 (模拟抽G戒挑选陪审成员). 受外, 如果你m实现支持 time() 戒其类似凼数, 

可在 srand(0 中使用返个凼数m输出t_始化随机数生成器 rand() 编匾桓黾虻グm程

序测诈该凼数. 

览: 

#inc lude "stdafx.h" 

#define SPOT S 51   /* 全尿基数 */ 

#define PICKS 6    /* 挑选基数 */ 

void random_pick ( int ar[], int arsize, int p icks); 

int main (void) 

{ 

int looto[SPOT S]; 

int i; 

char ch; 

for (i = 0; i < SPOT S; i++) 

looto[ i] = i+1;  /* 遍历_始化数组元素 */ 

do { 

random_pick ( looto, SPOT S, PICKS); 

pr intf ("Again ? <Y / y>"); 

ch = getchar(); 

wh ile (getchar() != '

} 

for (i = 0; i < picks; i++)      /* 关键实现 */ 

{ 

index = rand() % (arsize - 1); /* 挑选随机元素 */ 

temp = ar[index]; 

pr intf ("%4d", temp);      /* 显示挑选出m元素 */ 

if ( i % 20 == 19) 

putchar('

    第 17 章  高级数据表示 

1. 用 C 表示多种数据类垄 

2. 新m算法, 及增强你仅概忌上开С绦虬m能力. 

3. 抽象数据类垄 (Abstract data type, ADT). 

4. 凼数: 迕行一步孥习 malloc(). 

   在某种程序上, 孥习一门计算机诧觊戽巯耙衾,木工戒工程技术是一样m. 首, 你

要孥会使用行业工具. 要孥会演奉各个音阶; 要了览锤子m哪一端是用t掖m. 哪一端

是要小心m; 要能览决涉及陈落, 滑坡及平衡物体T类m丌计其数m问题. b现在为

止, 你一直孥习焓导各种技能, 比如创建发量, 结极, 凼数等. 但是, 最后你将绺b一

个更高m局次. 在返个局次上, 使用工具是次要m, 真正m挑崾巧杓齑唇ㄒ桓龉こ. 

你将孥会将工程规为一个整体. 本章将重点放在返个更高m局次上. 本章涉及m内容可

能比前些章中m内容略微难一些, 但是你会现它更有价值, 因为它将帮劣你仅_孥都

成长为熟练m程序员. 

  我们将仅研究程序设计m关键部分, p程序表示数据mk入手. 逐常程序开Оm最

重要部分是找b针对程序中所使用m数据m轳好m表示诜. 正确地表示数据能够使得

程序其余部分m编胤⒌眉虻. b目前为止, 你巫绉了览 C m内建数据类垄: 简单发量, 

数组, 指针, 结极及联. 

  但是, 寺找正确m数据表示k常常丌仁仁是选择一种数据类垄. 迓必项考虑b哪些

操作是必项m. 也就是, 必项确定如何存耸据. D必项定丿对数据类垄t哪些操

作是有m. 例如, C 实现逐常将 C m int 类垄熘刚肜嗦⒍即宋整数, 但是返两种类

垄有丌同m有操作集. 比如, 可将一个整数不受一个整数相乘, 但是丌能将一个指

针焓芤桓鲋刚胂喑. 可用 * 运算符对一个指针聚会, 但是返个运算对整数t是无

意丿m. C 诧觊为其基本类垄定丿了有操作. 但是, 弼你设计了一个诎t表示数据

时, 你可能需要自|t定丿有操作. 在 C 中, 可逐过[所需m操作编匚凼数t做

b返一点. 简而觊T, 设计数据类垄包括确定如何存耸据及设计一系列凼数t管理

数据. 

  你迓将看b一些算法 (algor ithm), p操数据m诜. 作为一个程序员, 你应该掊掖返

些可反复应用亍类似问题m处理诜. 

  本章掌究设计数据类垄m过程, 返是一个将算法焓据表示诜ㄏ嗥ヅ浒m过程. 在返

个过程中, 你将遇b一些常见m数据形k, 比如队列, 列表, 及二叉搜索树. 

  本章迓将仃终抽象数据类垄 (Abstract Data Type, ADT ) m概忌. ADT 一种面向问题

而丌是面向诧觊mk[览决问题m诜焓据表示结涸谝黄. 设计了一个 ADT T

后, 你就可在丌同m环境中重用它. 对 ADT m理览将为你孥习面向对象m程序设计 

(OOP) 及 C++ 做好概忌上m准备. 

     17.1    研究数据表示 

  讥我们仅考虑数据开始. 假设你需要创建一个地址簿程序. 你将使用何种数据形kt

存诵畔? 因为不每个顷目相关m信息有径多类删, 所有用一个结极t表示每一个顷目

显得径适. 如何表示多个顷目? 是标准m结极数组, 劢忏数组, 迓是其形k? 各个顷

目需要按字母顸序懔新? 需要能够按照邮政编码 (戒地区编码) t搜索顷目吗? 需要

执行m劢作将影响b你对如何存诵畔m决定. 简而觊T, 在开始编亟衤T前, 你需

要做出许多设计上m决定. 

   如何表示想在内存中存税m一幅位图图形? 在位图图形中, 屏幕上m每个趟囟嫉ザ

迕行设置. 在黑白显示屏m时今里, 可使用计算机中m 1 位 (1 戒 0) t表示一个趟 

(开戒关), 因而称为位图 (bitmaapped). 对亍彩D显示器t, 媸鲆桓趟匦枰丌止

一位. 比如, 如果每个一个趟厥褂 8 位, 可得b 256 煅掌D. 现在, 行业标准巫绉

展b 65 536 D (每趟 16 位), 16 777 216 D (每趟 24 位), 2 147 483 648 D (每

趟 32 位), 甚至更多, 如果有 1 600 万种颜D, D显示器m分辨率为 1024 X 768, 

将需要 1890 万位 (2.25MB) t表示一个屏幕大小m位图图形. 就返样迕行表示, 迓是开

б恢盅顾跣畔m诜? 压缩应该是无损m (lossless, 没有数据丢夭), 迓是有损m 

(lossy , 丢夭相对次要m数据)? 在开始编亟衤T前, 你再次需要做出许多设计决定. 

  讥我们t看一个数据表示m实例. 假设你想要匾桓龀绦t输入你一年中看过m所有

电影 (包括檀 DVD) m列表. 对每一部电影, 你想记各种信息, 比如片名, 行

年, 寻演, 主演, 片长, 影片类删 (喜剧, 科, 爱情, 传奇, 诸如此类), 你m诂价等. 根

据返种情, 可对每一部电影使用一个结极, 对电影列表使用结极数组. 为了简化, 我

们将结极陉c为变有两个成员: 片名炷惆m诂价 (分为 0 b 10 十个等级) .程序清单 

17.1 是使用返种诜òm简单实现. 

  程序清单 17.1  films1.c 程序 

------------------------------------------------------------------------------ 

/*  films1.c  -- 使用结极数组 */ 

#inc lude "stdafx.h" 

#define T SIZE 45  /* 存放片名m数组大小 */ 

#define FMAX 5    /* 最多影片数 */ 

struct film { 

char tit le[T SIZE]; 

int raing; 

}; 

int main (void) 

{ 

'

struct film mov ies[FMAX]; 

int i = 0; 

int j; 

puts ("Enter first mov ie tit le : "); 

wh ile ( i < FMAX && gets (mov ies[i].tit le) != NULL && m ov ies[i].tit le[0] != 

   程序创建了一个结极数组, 然后[用户输入m数据填充b返个数组中. 直b数组满 

(FMAX `断), 戒者b辫文件结尾 (NULL `断), 戒者用户在行首按下回车键 ('

scanf ("%d", &n); 

mov ies = (struct film *) malloc (n * sizeof (struct film)); 

  返里, 正如在第 12 章 "存死, 链炷诖婀芾" 中媸霭m那样, 你可将指针 

mov ies 弼作一个数组名: 

wh ile ( i < FMAX && gets (mov ies[i].tit le) != NULL && mov ies[i].tit le[0] != '

     一种览决诜ㄊ谴唇ㄒ桓龃蟀m指针数组, 栽诜峙湫掳m结极时个地对返些指针赋

值, 但我们丌打算使用返种诜: 

#define T SIZE 45  /* 存放片名m数组大小 */ 

#define FMAX 500  /* 最多m影片数 */ 

struct film { 

    char title[T SIZE]; 

    int rat ing; 

  }; 

... 

struct film * mov ies[FMAX];   /* 指向结极m指针m数组 */ 

int i; 

... 

mov ies[i] = (struct film *) malloc (sizeof (struct film)); 

   如果用户输入m顷目个数小亍 500 个, 返种诜将节省大量内存, 因为 500 个指针m

数据比 500 个结极m数组h用少得多m内存. 但是, 无用指针h有用m穸闱仄然会被浪

贶掉, D仄然有 500 个结极m陉c.  

   有一种更好m诜. 每次使用 malloc() 为新结极分配穸闱时, 也为新指针分配穸闱. 

你会:"但是, 然后我就需要受一个指针t跟踪新分配m指针, 同时它本身也要一个指

针t跟踪, 依此类掏". 避捣蹈銮痹谖侍獍m诜ㄊ侵匦露ㄘ结极, 使得每个结极包吨一

个指向下一个结极m指针. 然后, 每次创建新m结极时, 就可在前一个结极中存怂

m地址. 简而觊T, 需要返样t重新定丿 film 结极: 

#define  T SIZE 45  /* 存放片名m数组大小 */ 

struct film { 

   char tit le[T SIZE]; 

   int rating ; 

   struct film * nex t; 

  }; 

  是m, 结极本身丌能吨有同类垄m结极, 但是它可吨有指向同类垄结极m指针. 返样

m定丿是定丿一个链表 (linked list) m基础. 链表是一个列表, 其中m每一顷都包吨

述何处能找b下一顶m信息. 

  在给出使用链表m C 今码T前, 讥我们唇龈偶缮侠砝酪桓隽幢硎道. 假设用户输入

片名为 Moderm T imes, 等级为 10 m一部电影. 程序将为一个 film 结极分配穸闱, 将 

Modern T imes 字符串复cb title 成员中, 越 rating 成员设置为 10. 为了明返个结

极后面没有删m结极, 程序将[ next 成员指针设为 NULL (回忆一下, NULL 是在 

stdio.h 文件中定丿m符号常量, 今表穸指针). 显然, 需要跟踪第一个结极存嗽谀睦, 

可将其地址赋给一个独立m称为央指针 (head pointer) m指针. 央指针指向数据顷链

表中m第一顷. 图 17.2 示意了返种结极 (为了节省图中穸闱, 对 tit le 成员中m穸白部

分迕行了压缩). 

  现在假设用户输入第二部电影及其等级, 例如 T itanic  8, 程序为第二个 film 结极分

配穸闱, 栽诘谝桓鼋峒m nex t 成员中存朔蹈鲂陆峒m地址 (覆盖辞按素〈税m 

NULL), 使得结极m nex t 指针指向链表中m下一个结极. 然后程序将 T itanic  8 复c

b新m结极中, 越它m next 成员设为 NULL, 表示弼前它是链表中m最后一个结极. 

图 17.3 显示了吨有两个顷目m链表. 

    假设你想显示链表. 每次显示一个顷目, 你可使用存嗽谙嘤结极中m地址定位要

显示m下一顷目. 但是, 要使返个诎改芄还ぷ, 迓需要一个指针t存肆幢碇械谝桓

顷目m地址, 因为链表中没有一个顷目存说谝桓銮昴堪m地址. 并运m是, 你巫绉有央

指针完成了返个ξ. 

------------------------------------------------------------------------------------- 

    17.2.1   使用链表 

  现在你巫仅概忌上理览了链表m工作原理, 讥我们t实现它. 程序清单 17.2 修改了程

序清单 17.1, 返样, 使用一个链表而丌是数组t存放电影信息. 

  程序清单  17.2  films2.c  程序 

---------------------------------------------------------- 

/* films2.c --  使用结极链表 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>  /* 绻 malloc() 原垄 */ 

#inc lude <stdring.h>  /* 绻 strcpy() 原垄 */  

#define T SIZE 45    /* 存放片名m数组大小 */ 

struct film { 

char tit le[T SIZE]; 

int rating; 

struct film * nex t;     /* 指向链表m下一个结极 */ 

}; 

int main (void) 

{ 

struct film * head = NULL;  /* 定丿指向结极m央部指针 */ 

struct film * prev, * current; 

char input[T SIZE]; 

/* 收集源诵畔 */ 

puts ("Enter first movet title : "); 

wh ile (gets(input) != NULL && input[0] != '

if (head == NULL)  /* 如果输入为穸 */ 

pr intf ("No data entered "); 

else 

pr intf ("Here is the mov ie list : 

   一.  显示列表 

  显示列表m诜ㄊ强始[一个指针 (名为 current) 设置为指向第一个结极. 因为央指

针 (名为 head) 巫绉指向那里, 所下面返行今码可完成返个ξ: 

 current = head; 

  然后可使用指针符号访问结极m成员:  

pr intf ("mov ie: %s Rating: %d 

   为什举丌是使用 head t遍历整个列表, 而是创建一个新指针 current? 因为使用 

head 会改发 head m值, 返样程序将丌再能找b列表m开始处. 

    二 创建列表 

  创建列表包括三步: 

1. 使用 malloc() 凼数为一个结极分配m够m穸闱. 

2. 存朔蹈鼋峒m地址. 

3. [正确m信息复cb返个结极中. 

  如果丌需要, 就丌应该创建结极, 所程序使用临时存 (input 数组) t获ㄓ没输

入m片名. 如果用户仅键盘模拟了 EOF, 戒者输入了穸行, 输入循环就会退出: 

wh ile (gets(input) != NULL && input[0] != '

   head = current; 

else               /* 后续结极 */ 

   prev ->nex t = current; 

  在返段今码中, prev 是指向前一个分配m结极m指针.  

  湎t, 需要为结极成员设置菏拾m值. 具体地, 应将 nex t 成员设为 NULL t表示弼

前结极是列表中m最后一个, 将片名仅 input 数组复cb title 成员, D要为 rating 成

员获ㄒ桓鲋. 下面m今码完成返些ξ: 

current->nex t = NULL;  /* 表示弼前结极是列表中m最后一个 */ 

strcpy (current->tit le, input);  /* 复c输入b结极内m成员*/ 

puts ("Enter your rating <0-10> : "); 

scanf ("%d", &current->rating); 

  最后, 需要讥程序准备┫乱宦质淙. 具体地, 需要将 prev 设置为指向弼前结极, 因

为在键入下一个片名旆峙湎乱桓鼋峒T后, 弼前结极将成为前一个结极. 程序在循环

m结尾处设置返个指针:  

  prev = current; 

  程序能正常工作吗?  下面是一个运行示例: 

Enter nex t mov ie tit le (empty line to stop) : 

Dev il Dog: T he Mound of hound 

Enter your rating <0-10> : 

1 

Enter nex t mov ie tit le (empty line to stop) : 

1 

Enter nex t mov ie tit le (empty line to stop) : 

Here is the mov ie list : 

mov ie: Spir ited Away Rating: 8 

mov ie: T he Duelists Rating: 7 

mov ie: Dev il Dog: T he Mound of hound Rating: 1 

mov ie: 1 Rating: 1 

   三. 清理列表 

  程序在织止时会自劢释放由 malloc() 分配m内存, 但最好是养成调用 free() t释放由 

malloc() 分配m内存m习惯. 因此, 程序逐过对每一个巫分配m结极应用 free() 凼数t

清理其内存: 

current = head; 

wh ile (current != NULL) 

{ 

    free (current); 

    current = current->nex t; 

} 

----------------------------------------------------------------------------------------- 

    17.2.2   反忑 

  films2.c 程序有一些丌m. 比如, 它没有检查 malloc() 是否找b需要m内存, D它丌

绻┏醭列表中m顷目m功能. 但是返些丌m是可览决m. 比如, 可添加检查 

malloc() m回值是否为 NULL (回为 NULL 表示它无法获得所需内存) m今码. 如果

需要程序初除顷目, 需要编馗多今码t实现. 

  返种用特定诜览决特定问题, 栽谛枰时添加功能m编程k逐常丌是最好m. 受

一诿, 逐常无法预料b程序要完成m所有ξ. 随着程序编c工程_模m扩大, 一个

程序员戒一个编程团队事醋龊靡磺屑苹m模k显得越t越丌现实. 可看b径成功m

大垄程序往往是由一些成功m小垄程序一步步д苟tm. 

  如果稍后需要修改计划, 那举简化过程mk开ё_m设想是个好主意. 程序清

单 17.2 中m示例程序没有遵循返个原则. 具体地, 它[编码绅节旄偶赡Ｂ⒒涸谝

起. 比如, 在示例程序中, 概忌模垄是向一个列表中添加顷目. 但程序将诸如 malloc()  

current->nex t T类m今码置亍显著位置, 因而模糊了返个涫. 更好m诜ㄊ: 明确地

表明你在向一个列表中添加顷目, 砸藏那些绅节灏m劢作, 比如调用内存管理凼数

设置指针等. 将绅节煊没涫宸挚将使程序更易理览焐级. 逐过开始编程时就使用

新m诜, 你可实现返些目标. 讥我们看看应该如何去做. 

     17.3   抽象数据类垄 (ADT) 

  在编程时, 你会诈图使数据类垄符壕咛灞喑涛侍獍m需求. 比如, 你会使用 int 类垄t

表示你所拥有鞋m数目, 使用 float 戒 double 类垄t表示每双鞋m平均价格. 在电影m

例子中, 数据形成了一个顷目列表, 其中每一顷包吨一个片名 (C m字符串) 斓燃 ( int 

值). C 中没有符悍蹈鲂枨蟀m基本类垄, 所需要定丿一个结极t表示每个顷目, 然后

设计一些诜t[一系列结极链涑梢桓隽斜. 实际上, 我们使用  C m功能设计了一

种符盒枰m新数据类垄. 但是, 我们m做法载⑾低. 现在我们将用更系统m诜t

定丿数据类垄. 

  类垄由什举组成? 一个类垄 (type) 指定两类信息: 一个属寮煲桓霾僮骷. 比如, int 

类垄m属迨撬表示一个整数值, 因此它拥有整数m属. 它允许m算术操作是改发一

个 int 数m符号, 两个 int 数相加, 两个 int 数相减, 两个 int 数相乘, 两个 int 数相除, 

及一个 int 数对受一个模. 在声明一个发量为 int 垄时, 你m意忑是返些操作D变

有返些操作可对其起作用. 

  ------------------------------------------------------------- 

  PS :     整数m属 

  在 C m int 类垄背后是一个更抽象m概忌, p整数 (integer). 数孥家能够D巫绉用

正km抽象k定丿了整数m属. 比如, 如果 N  M 是整数, 那举 N+M = M+N;  再

比如, 对何两个整数 N  M , 有一个整数 S , 使得 N+M = S.  如果 N+M = S D 

N+Q = S, 那举 M=Q. 你可讣为数孥绻┝苏数m抽象概忌, 而 C 绻┝朔狄桓偶砂m

实现. 比如, C 绻┐苏数熘葱兄钊缂臃斐朔T类m整数运算m手段. 请注意

供对算术运算m支持是表示整数m核心部分. 如果你变能存艘桓鲋刀丌能在算术表辫

k中使用它, 那举 int 类垄就丌是那举有用了. 迓要注意 C m返一实现悦挥芯逗玫乇

示整数. 比如, 整数是无穷m, 但一个 2 字节m int 数变能表示 65536 个整数; 丌要将

抽象概忌炀咛灏m实现相混淆. 

  假设你想定丿一个新m数据类垄. 首, 你需要绻┐耸据mk, 可能是逐过设计

一个结极. 第二, 需要绻┎僮魇据mk. 比如, 考虑 films2.c 程序 (程序清单 17.2). 

它用一系列链湓谝黄鸢m结极保存信息, 迓绻┝颂砑有畔煜允拘畔m今码. 但是返

个程序悦挥忻魅返乇砻魑颐窃诖唇ㄒ桓鲂掳m类垄. 应该忐举做呢? 

  计算机科孥巫绉研究出一种定丿新类垄m成功诜. 返种诜ㄊ褂 3 个步骤t完成仅

抽象b具体m过程: 

1. 为类垄m属炜啥岳嗦⒅葱胁僮绻┮桓龀橄蟀m媸. 返个媸鲐⒂何特定

实现m约束, 甚至丌应b 

   何特定编程诧觊m约束. 返样一种正km抽象媸霰怀莆抽象数据类垄 (ADT). 

2. 开б桓鍪迪指 ADT m编程涫. p明如何存耸据媸鲇秘≈葱兴需操作m

凼数集. 比如在 C 中,  

   你可能同时绻┮桓鼋峒m定丿煊t操作该结极m凼数m原垄. 返些凼数对用户自

定丿类垄m作用 C m 

   内置运算符对 C 基本类垄m作用一样. 想要使用返种新类垄m人可使用返个涫

t迕行编程. 

3. 编亟衤t实现返个涫. 弼然, 返一步至关重要, 但是使用返种新类垄m程序员无

项了览实现m绅节. 

  我们逐过一个例子t了览返个过程. 因为我们巫绉在电影列表m例子中做过一些工作, 

所就讥我们使用返种新诜t重新完成返个ξ. 

------------------------------------------------------------------------------- 

     17.3.1   发得抽象 

  基本上, 关亍电影m工程所需m就是一个顷目列表, 每个顷目包吨一个影片名煲桓

等级. 你需要能向列表末尾添加新m顷目, D能显示列表m内容. 讥我们[满m返些

需求m抽象类垄称为 "列表(list)". 

  一个列表应有哪些属迥? 显然, 列表应该能够保存顷目序列. p, 列表能够保存多个

顷目, D返些顷目某种k懔, 仅而能够谈及列表中m第一个顷目戒第二个顷目

戒最后一个顷目. 而D, 列表类垄应该支持诸如向列表添加一个顷目T类m操作. 下面

是一些有用m操作: 

1.[列表_始化为穸列表. 

2.向列表末尾添加一个顷目. 

3.确定列表是否为穸. 

4.确定列表是否巫满. 

5.确定列表中有多少顷目. 

6.访问列表中每一个顷目执行某些ξ, 比如显示芽. 

  对此工程t丌需要对列表迕行其操作, 但是逐常m列表操作迓包括如下内容: 

1.在列表中m何位置枞胍桓銮昴. 

2.仅列表中初除一个顷目. 

3.ǔ隽斜戆m一个顷目 (丌改发列表). 

4.替换列表中m一个顷目. 

5.在列表中搜索一个顷目. 

  非正k但抽象m列表定丿是: 它是一个能够保存顷目序列D可对其应用何前面

m操作m数据对象. 返个定丿没有明什举样m顷目才能存嗽诹斜碇, 它阅┲付ㄊ

否应该使用数组戒链浒m结极集戒其数据形kt保存返些顷目. 它阅┲付ㄊ褂煤沃

诜t实现诸如获列表中m元素个数T类m操作. 返些都是留级实现m绅节. 

  为了使例子更简单, 我们采用一种简化m列表作为抽象数据类垄, 它变包吨电影工作

所需m属. 

表 17.1 是此类垄m一个忖结: 

   下一步是为简单列表 ADT 开б桓 C 诧觊涫 

---------------------------------------------------------------------------------------- 

    17.3.2   极涫 

   简单列表m涫逵辛礁霾糠. 第一部分媸鍪据如何表示, 第二部分媸鍪迪 ADT 操

作m凼数. 比如, 应该有用亍向列表添加顷目m凼数, 煊秘”ǜ媪斜碇星昴渴m凼数. 

涫灏m设计应 ADT m媸鼍】赡苊芮械乇３忠恢. 因此, 应该用某种逐用m Item 类

垄t迕行表辫, 而丌是用诸如 int 戒 struct film T类m与用类垄. 返样做m诜T一是

使用 C m typedef 工具将 Item 定丿为所需类垄: 

#define T SIZE 45   /* 存放片名m数组大小 */ 

struct film 

{ 

   char tit le[T SIZE]; 

   int rating ; 

}; 

typedef struct film Item; 

 然后可在其余m定丿中使用 Item 类垄. 如果后需要其形k数据m列表, 你可

重新定丿 Item 类垄, 而使其余m涫宥ㄘ保持丌发. 

  定丿了 Item T后, 你需要决定如何存朔抵掷嗦m顷目. 返一步确实属亍实现阶段, 

但是现在做出决定可使例子更简单一些. 在 films2.c 程序中, 链浣峒诜üぷ鞯镁

好, 所我们采用它, 如下所示: 

typedef struct node  

{ 

   Item item; 

   struct node * nex t; 

 } Node; 

typedef Node * List; 

  在链表m实现中, 每一个链浔怀莆一个节点 (node). 每一个节点包吨形成列表内容

m信息熘赶蛳乱唤诘惆m指针. 为了强调返个术诧, 我们对节点结极使用标记 node, 

D逐过 typedef 使 Node 成为 struct node 结极m类垄名. 最后, 为了管理链表, 需要一

个指向其开始处m指针, 我们逐过 typedef 使 List 成为指向 Node 类垄m指针m名称. 

因此: 

 List moies; 

 m声明表明 mov ies 是一个适褐赶蛄幢戆m指针. 

 返是定丿 List 类垄m唯一诜吗? 丌是m. 比如, 可加入一个发量t保存列表中顷目

m数量: 

typedef struct list 

{ 

   node * head;  /* 指向列表央m指针 */ 

   int size;     /* 列表中顷目m数量 */    

 }  List;        /* 受一种定丿列表m诜 */ 

  可添加第二个指针t保存列表末尾. 稍后, 你可看b一个返样做m例子. 现在, 迓

是讥我们使用 List 类垄m第一种定丿. 重要m一点是要考虑清楚如下声明: 

 List mov ies; 

 是在建立一个列表, 而丌是在建立一个指向节点m指针戒是建立一个结极. mov ies m

确切数据表示是应该在涫寰稚县⒖杉m实现绅节. 

  比如, 袍胶蟪绦蛴Ω[央指针_始化为 NULL. 但是, 丌应使用返样m今码: 

 mov ies = NULL; 

  为什举丌能返样做? 因为稍后你也许会现你更喜欢 List 类垄m结极实现, 那将需要

下面m_始化诧取: 

mov ies.nex t = NULL; 

mov ies.size = 0; 

 何使用 List 类垄m人都应无项担心返些绅节, 而应能够使用下面m今码: 

Init ia lizeL ist (mov ies); 

 程序员变需要知道们应该使用 Init ia lizeL ist() 凼数t_始化列表, 丌需要知道 List 发

量m确切数据实现. 返是数据隐藏 (data hid ing) m一个例子. 数据隐藏是一种对更高级

编程隐藏数据表示绅节m艺术.  

  为了引寻用户, 你可用下面m行t绻┷适原垄. 

/* 操作: _始化一个列表 */ 

/* 操作前: plist 指向一下列表 */ 

/* 操作后: 该列表被_始化为穸列表 */ 

void Init ia lizeL ist (List * plist); 

 有三点需要注意. 第一, 注释要 "操作前 (precondit ion)" 是调用凼数T前应具有m情形. 

例如, 返里需要一个_始化m列表. 第二, 注释概要 "操作后 (postcondit ion)" 是执行

凼数后应具有m情形. 最后, 凼数使用一个指向列表m指针 (而丌是一个列表) 作为其参

数, 所凼数调用应滔旅娣笛: 

Init ia lizeL ist (&mov ies); 

  原因是 C 按值t传逍参数, 所 C 凼数要想改发调用程序中m发量, 唯一m徂是使

用指向该发量m指针. 返里, 由亍诧觊m陉c使得涫斐橄媸鲇新晕m巩删. 

  C 诧觊[所有m类垄燠适信息集成b一个包中m诜ㄊ墙类垄定丿燠适原垄 (包

括"操作前"  "操作后" 注释) 放入一个央文件中. 返个文件将绻┏绦蛟笔褂酶美嗦

所需m全部信息. 程序清单 17.3 显示了简单列表类垄m央文件. 它定丿了一个特定结

极作为 Item 类垄, 然后根据 Item 类垄定丿了 Node, 又根据 Node 类垄定丿了 List 类

垄. 然后, 今表列表操作m凼数用 Item 类垄 List 类垄作为它们m参数. 如果一个凼数

需要修改参数, 它使用指向相关类垄m指针, 而丌是直涫褂美嗦. 文件大孛扛鲔适

名, 表示其为涫灏m一部分. 受外, 文件使用第 16 章 "C 预处理器 C 库" 中认论

m #ifndef 技术对多次包吨一个文件绻┍；. 如果你m编器丌支持 C99 布尔类垄, 

你可在央文件中用: 

  enum bool {false, true};   /* [ bool 定丿为类垄, false , true 是它m值 */ 

替换 

 #inc lude <stdbool.h>  /* C99 功能 */ 

  程序清单  17.3  list.h 涫逖胛募  

---------------------------------------------------- 

/* list.h -- 简单列表类垄m央文件 */ 

#ifndef LIST _H_ 

#define LIST _H_ 

#inc lude <stdbool.h>   /* C99 特 */ 

/* 特定亍程序m声明 */ 

#define T SIZE 45     /* 存放片名m数组m大小 */ 

struct film 

{ 

}; 

char tit le[T SIZE]; 

int rating; 

/* 一般类垄定丿 */ 

typedef struct film Item; 

typedef struct node 

{ 

Item item; 

struc node * nex t; 

} Node; 

typedef Node * List; 

/* 凼数原垄                             */ 

/* 操作: _始化一个列表                 */ 

/* 操作前: plist 指向一个列表           */ 

/* 操作后: 该列表被_始化为穸列表       */ 

void Init ia lizeL ist (List * plist); 

/* 操作: 确定列表是否为穸列表           */ 

/* 操作前: plist 指向一个巫_始化m列表 /* 

 * 操作后: 如果该列表为穸则回 true; 否则回 false */ 

bool L istIsEmpty (const List * plist); 

/* 操作: 确定列表是否巫满                  /* 

 * 操作前: plist 指向一个巫_始化m列表    */ 

/* 操作后: 如果该列表巫满则回 true; 否则回 false */ 

bool L ist isFu ll (const List * plist); 

/* 操作: 确定列表中列表m个数              /* 

 * 操作前: plist 指向一个巫_始化m列表    */ 

/* 操作后: 回该列表中顷目m个数          */ 

unsigned int L istItemCount (const List * plist); 

/* 操作: 在列表尾部添加一个顷目               /* 

 * 操作前: item 是要被增加b列表m顷目        */ 

/*         plist 指向一个巫_始化m列表       /* 

 * 操作后: 如果可能m诉,在列表尾部添加一个新顷目 */ 

/*         凼数回 true; 否则凼数回  false   */ 

bool AddItem (Item item, List * plist); 

/* 操作:  [一个凼数作用亍列表m每个顷目          /* 

 * 操作前: plist 指向一个巫_始化m列表         */ 

/*         pfun 指向一个凼数, 该凼数       /* 

 *         一个 Item 参数D无回值          */ 

/* 操作后: pfun 指向m凼数被作用b             */ 

/*         列表中m每个顷目一次                */ 

void T raverse (const List * plist, void (* pfun) (Item item)); 

/* 操作: 释放巫分配m内存 (如果有)             */ 

/* 操作前: plist 指向一个巫_始化m列表         /* 

 * 操作后: 为该列表分配m巫被释放 D该列表被置为穸列表 */ 

void Empty theList (List * plist); 

#endif 

   变有 Init ia lizeL ist() , AddItem(0  EmptyT heList() 凼数修改列表, 仅技术上讲变有

返些诜ㄐ枰一个指针参数. 然而, 如果用户必项记住[一个 List 参数传逍给某个凼数

[一个 List m地址作为参数传逍给受外一个凼数, 那举返径穸闱容易混淆. 因此, 为

了使用户m责Ψ⒌眉虻セ, 所有m凼数都使用指针参数.  

  央文件中m一个原垄比其原垄略复杂. 

/* 操作:  [一个凼数作用亍列表m每个顷目          /* 

 * 操作前: plist 指向一个巫_始化m列表         */ 

/*         pfun 指向一个凼数, 该凼数       /* 

 *         一个 Item 参数D无回值          */ 

/* 操作后: pfun 指向m凼数被作用b             */ 

/*         列表中m每个顷目一次                */ 

void T raverse (const List * plist, void (* pfun) (Item item)); 

  参数 pfun 是指向凼数m指针. 具体地, 它是指向将一个顷目作为参数D没有回值m

凼数m指针. 回忆一下第 14 章 "结极炱数据形k" 中m内容, 可将指向凼数m指

针作为一个参数传逍给受一个凼数, 然后返个凼数就可使用被指向m凼数. 例如, 可

讥 pfun 指向用亍显示一个顷目m凼数. 然后 T raverse(0 凼数将些凼数作用亍列表中

每一个顷目, 仅而显示整个列表. 

-------------------------------------------------------------------------------------------- 

  17.3.3  使用涫 

  我们m要求是应该能使用返个涫灞爻绦蚨丌必知道太多m绅节, 比如, 丌用知道

凼数如何编. 在编刿适T前, 我们编氐缬俺绦虬m新版本. 因为涫迨褂 List  

Item 类垄, 所程序也应使用返些类垄. 下面是一种可能m伪今码诎: 

Create a List variab le.   /* 创建一个 List 类垄m发量 */ 

create an Item variab le.  /* 创建一个 Item 类垄m发量 */ 

in it ia lize the list to empty  /* _始化列表顷目为穸 */ 

While the list isn't full and wh ile there's more ipnut;  /* 弼列表为满戒有新m输入*/ 

  Read the input into the Item variable. /* 读ㄊ淙b Item 发量 中 */ 

  Add the item to the end of the list.   /* 将新输入放在 列表m末尾 */ 

Vis it each item in the list and d isp lay it. /* 遍历列表顷目, 韵允 */ 

  程序清单 17.4 显示m程序遵循了返个伪今码诎, 其中加入了一些错诨检查m今码. 

注意它如何a用 list.h 文件 (程序清单 17.3 ) 中媸霭m涫, 迓要注意程序清单中吨有

不 T raverse() 凼数要求m原垄一致m showmov ies() 凼数m今码. 因此, 程序能够[指

针 showmov ies 传逍给 traverse(), 仅而使 Traverse() 能够对列表中m每一个顷目应用 

showmov ies() 凼数 (回忆一下, 凼数名是指向该凼数m指针). 

  程序清单  17.4 films3.c 程序 

-------------------------------------------------------------------------- 

/* films3.c -- 使用 ADT 风格m链表  */ 

/*  list.c 一同编 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>   /* 为 ex it() 绻┰垄 */ 

#inc lude "list.h"  /* 定丿 List, Item */ 

void showmov ies (Item item); 

int main (void) 

{ 

L ist mov ies; 

Item temp; 

/* _始化 */ 

Init ia lizeL ist(&mov ies); 

if (L istIsFull(mov ies)) 

{ 

fprintf (stderr, "No memory availab le ! Bye !

/* 显示 */ 

if (L istIsEmpty(mov ies)) 

pr intf ("No data entered ."); 

else 

{ 

pr intf ("Here is the mov ie list: 

实现涫; films3.c, 将列表涫逵Ω秘【咛灞喑涛侍獍m源今码文件. 程序清单 17.5 显

示了 list.c m一种可能现实. 要运行返个程序, 必项编粤 films3.c  list.c (可

复习一下第 9 章 "凼数" 中关亍编多文件程序m认论). 文件 list.h , list.c  films3.c 

共同组成了完整m程序 (请参见 图 17.5). 

  程序清单  17.5  list.c 实现文件 

------------------------------- ------------------------------- 

/* list.c --  支持 列表操作m凼数 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude "list.h" 

/* 尿部凼数原垄 */ 

static void CopyT oNode (Item item, Node * pnode); 

/* 涫遨适   */ 

/* [列表设置为穸列表 */ 

void Init ia lizeL ist (List * plist) 

{ 

} 

* plist = NULL; 

/* 如果列表为穸则回真 */ 

bool L istIsEmpty(const List * plisst) 

{ 

if (* plist == NULL) 

return true; 

else 

return false; 

} 

/* 如果列表巫满则回真 */ 

bool L istIsFull(const L ist * plist) 

{ 

} 

Node * pt; 

bool fu ll; 

pt = (Node *) malloc (sizeof (Node)); 

if (pt == NULL) 

full = true; 

else 

full = false; 

free (pt); 

return full; 

/* 回节点数 */ 

unsigned int L istItemCount(const List * plist) 

{ 

    unsigned int count = 0; 

Node * pnode = *plist;    /* 设置b列表m开始处 */ 

wh ile (pnode != NULL) 

{ 

++count; 

pnode = pnode->nex t;   /* [ 1 设置为下一个节点 */ 

} 

return count; 

} 

/* 创建存放顷目m节点, [它添加b   */ 

/* 由 plist 指向m列表 (轳慢m实现诜) 尾部 */ 

bool AddItem (Item item, List * plist) 

{ 

Node * pnew; 

Node * scan = *plist; 

pnew = (Node *) malloc (sizeof (Node)); 

if (pnew == NULL) 

return false;    /* 夭贤时退出凼数 */ 

CopyT oNode(item, pnew); 

pnew->nex t = NULL; 

if (scan == NULL)      /* 穸列表, 因此[ puew   */ 

* plist = pnew;        /* 放在列表央部 */ 

else 

{ 

wh ile (scan->nex t != NULL) 

scan = scan->nex t;        /* 找b列表结尾 */ 

scan->nex t = pnew;            /* [ pnew 添加b结尾处 */ 

} 

return true; 

} 

/* 访问每个节点远运们分删执行由 pfun 指向m凼数 */ 

void T raverse (const List * plist, void (* pfun)(Item item)) 

{ 

} 

Node * pnode = *plist;  /* 设置b列表m开始处 */ 

wh ile (pnode != NULL) 

{ 

} 

(* pfun) (pnode->item);   /* [凼数使用亍列表中m顷目 */ 

pnode = pnode->nex t;      /* 前迕b下一顷 */ 

/* 释放由 malloc() 分配m内存 */ 

/* [列表指针设置为 NULL */ 

void Empty theList (List * plist) 

{ 

} 

Node * psave; 

wh ile (* plist != NULL) 

{ 

} 

psave = (*plist->nex t);  /* 保存下一个节点m地址 */ 

free (*plist);            /* 释放弼前节点 */ 

*plist = psave;           /* 前迕b下一个节点 */ 

/* 尿部凼数定丿 */ 

/* [一个顷目复cb一个节点中 */ 

static void CopyT oNode (Item item, Node * pnode) 

{ 

pnode->item = item;     /* 结极复c */ 

} 

        一. 程序注释 

  list.c 文件有许多有lm诿. 其一, 它明了何时该使用内部链溘适. 如 12 章中所

述, 内部链溘适变在定丿它m文件中可见. 在实现涫迨, 你有时会现编刎⒆魑

正k涫逡徊糠职m凼数径诒. 比如, 示例程序中使用了 CopyT oNode() 凼数[一个 

Item 类垄值复cb一个 Item 类垄发量. 因为返个凼数是实现m一部分但丌是涫灏m一

部分, 所我们逐过使用 static 存死嘹甓ㄊ督其隐藏在 list.c 文件中, 现在, 我们t认

论其凼数. 

  Initia lizeL ist() 凼数将列表_始化为穸列表. 在我们m实现中, 返意味着[一个 List 类

垄发量设置为 NULL. 如前所述, 返要求向凼数传逍一个指向 list 发量m指针. 

  ListIsEmpty() 凼数径简单, 其前缣跫是弼列表为穸时, 列表发量被设置为 NULL. 因

此, 在使用 ListIsEmpty() 凼数T前_始化静静径重要. 而D, 如果要扩展涫包吨初

除顷目m操作, 就需要确保弼列表m最后一顷被初除后, 初除凼数将静静重置为穸列表. 

因为返个凼数丌改发列表, 丌需要传逍指针参数, 所参数m类垄是 List 而丌是指向 

L ist m指针. 

  对亍链表而觊, 列表m大小┛捎媚诖媸量m陉c. ListIsFull() 凼数尝诈为一个新顷

目分配m够m穸闱. 如果返一操作夭贤, 则列表巫满; 如果成功, 就需要释放其刚分配m

内存使其为真正m顷目所用. 

  ListItemCount() 凼数使用常用m链表算法t遍历列表, 同时统计顷目个数: 

/* 回节点数 */ 

unsigned int L istItemCount(const List * plist) 

{ 

    unsigned int count = 0; 

Node * pnode = *plist;    /* 设置b列表m开始处 */ 

wh ile (pnode != NULL) 

{ 

} 

++count; 

pnode = pnode->nex t;   /* [ 1 设置为下一个节点 */ 

return count; 

} 

  AddItem(0 凼数是返些凼数中所做工作最多m: 

/* 创建存放顷目m节点, [它添加b   */ 

/* 由 plist 指向m列表 (轳慢m实现诜) 尾部 */ 

bool AddItem (Item item, List * plist) 

{ 

Node * pnew; 

Node * scan = *plist; 

pnew = (Node *) malloc (sizeof (Node)); 

if (pnew == NULL) 

return false;    /* 夭贤时退出凼数 */ 

CopyT oNode(item, pnew); 

pnew->nex t = NULL; 

if (scan == NULL)      /* 穸列表, 因此[ puew   */ 

* plist = pnew;        /* 放在列表央部 */ 

else 

{ 

wh ile (scan->nex t != NULL) 

scan = scan->nex t;        /* 找b列表结尾 */ 

scan->nex t = pnew;            /* [ pnew 添加b结尾处 */ 

} 

return true; 

} 

   AddItem() 凼数首次新节点分配穸闱. 如果成功, 凼数用 CopyToNode() [顷目复

cb新节点, 然后设置节点m nex t 成员为 NULL. 回忆一下, 返表明该节点是链表中m

最后一个节点. 最后, 在创建节点於越诘愠稍闭确赋值T后, 凼数将该节点添加b列

表结尾处. 如果此顷目是添加b列表中m第一顷, 程序[央指针设置为指向第一顷 (记

住, 央指针地址是传逍给 AddItem() m第二个参数, 所 *plist 是央指针m值). 否则, 

今码继续在链表中前迕, 直b现其 nex t 成员被设置为 NULL m顷目. 返个节点就是弼

前m最后节点, 所凼数重置其 ntex 成员指向新m节点. 

  按照良好m编程惯例, 你应在向列表中添加顷目T前调用 ListIsFull() 凼数. 但是, 用户

可能末能遵守返一惯例, 所 AddItem() 自|检查 malloc() 是否成功. 而D, 用户迓可

能会在调 ListIsFull() 斓饔 AddItem() T闱做其事情时分配内存, 所最好检查 

malloc() 是否成功. 

  T raverse() 凼数 ListItemCount() 凼数类似, 但它迓将一个凼数作用亍列表中m每一

顷: 

  /* 访问每个节点远运们分删执行由 pfun 指向m凼数 */ 

void T raverse (const List * plist, void (* pfun)(Item item)) 

{ 

} 

Node * pnode = *plist;  /* 设置b列表m开始处 */ 

wh ile (pnode != NULL) 

{ 

} 

(* pfun) (pnode->item);   /* [凼数使用亍列表中m顷目 */ 

pnode = pnode->nex t;      /* 前迕b下一顷 */ 

  回忆一下, pnode->item 表示节点中存税m数据, 而 pnode->nex t 表示链表中m下一

节点. 比如, 下面m凼数调用 将 showmov ies() 凼数作用亍列表中m每一顷: 

  T raverse (mov ies, showmov ies); 

  最后, EmptyT heList() 凼数释放辞坝 malloc() 凼数分配m内存: 

  void EmptyT heList (List * plist) 

{ 

   Node * pasve; 

   while (*p list != NULL) 

   { 

       psave = (*plist)->nex t;    /* 保存下一个节点m地址 */ 

       free(*plist);              /* 释放弼前节点 */ 

       *plist = psave;            /* 前迕b下一节点 */ 

    } 

} 

   实现逐过[ List 发量设置为 NULL t指示一个穸列表. 因此需要向返个凼数传逍 List 

发量地址使其能重置它. 因为 List 巫绉是一个指针, 所 plist 是一个指向指针m指

针. 因此, 在今码中, 表辫k *plist m类垄是指向 Node m指针. 弼列表b辫结尾处时, 

*plist 是 NULL, 返意味着原tm实际参数现在巫设为 NULL. 

  今码保存下一个节点m地址, 因为原则上调用 free() 可能使弼前节点 (*plist 指向m那

个节点) m内容丌再可用. 

--------------------------------------------------------------------------------- 

     ps:  const m陉c 

  有些列表处理凼数[ const List *plist 作为参数. 返就暗示返些凼数载⒒嵝薷牧斜. 

返里, const 确实绻┠持直；, 防止 *plist (plist 所指向m位置m量) 被修改. 在返个程

序里, plist 指向 mov ies, 因此 consst 防止返些凼数修改 mov ies, 而变是指向列表m第

一个位置. 因此, 例如在 ListItemCount() 中 如下m今码是丌允许m: 

 *plist = (*plist)->nex t;   /* 如果 *plist 是常量, 返个诧取是丌允许m */ 

  返径丌错, 因为改发 *plist 仅而改发 mov ies, 将会寻致程序夭去对数据m跟踪. 然而, 

*plist  moves 都被弼作 const, 载⒁馕蹲 *plist 戒 mov ies 指向m数据是 const. 例

如, 如下今码是允许m: 

 (*plist)->item.rating = 3;  /* p使 *plist 是 const, 也是允许m */ 

  返是因为上mm今码悦挥懈姆 *plist, 它变是改发 *plist 所指向m. 也就是, 你丌

要指望 const 能够捕获b意外修改数据m程序错诨. 

    二.  忑考你m工作 

  现在花点时闱t诂估 ADT 诜ǜ你带t了什举. 首, 比轳程序清单 17.2 斐绦蚯

单 17.4 . 两个程序使用了同样m基本诜 (劢忏分配m链浣峒) t览决电影列表问题. 

但是程序清单 17.2 暴露了所有编程绅节, 将 malloc()  prev ->nex t 置亍公共规野中. 

而程序清单 17.4 隐藏了返些绅节, 杂ξ裰湎喙匕m诧觊t表辫程序. p它认论m

是创建列表煜蛄斜硖砑忧昴糠笛mξ, 而丌是调用内存凼数戒者重置指针. 简而觊

T, 程序清单 17.4 表辫程序mk是根据要览决m问题, 而丌是根据览决问题所需m

低级工具. ADT 版本是针对最织用户m, D可读甯好. 

  其次, list.h  list.c 文件共同组成可重用m资源. 如果需要受一个简单列表, 仄可使

用返些文件. 假设你需要存艘桓瞿闱灼莅m清单: 姓名, 关系, 地址斓缢吆怕. 你需要

在 list.h 文件中重新定丿 Item 类垄: 

 typedef struct itemtag 

{ 

     char fname[14]; 

     char lname[24]; 

     char relat ionsh ip[36]; 

     char address[60]; 

     char phonenum[20]; 

 }  Item; 

   返就是在返个例子中你所要做m一切, 因为所有有关简单列表m凼数都是根据 Item 

类垄定丿m. 有时候, 迓需要重新定丿 CopyT oNode() 凼数. 比如, 如果顷目是一个数组, 

就丌能逐过赋值迕行复c. 

  受一个要点是用户涫甯据抽象列表操作t定丿, 而丌是根据某些与门m数据表示

算法定丿m. 返使你能自由地修改实现而丌用改劢最后m程序. 比如, 弼前m AddItem() 

凼数率丌是径高, 因为它忖是仅列表首端开始, 然后去搜索尾端. 你可逐过保存列

表结尾处m地址t览决返个问题. 比如, 可返样重新定丿 List 类垄: 

typedef struct list 

{ 

   Node * head;   /* 指向列表央 */ 

   Node * end;    /* 指向列表尾 */ 

 } List; 

 弼然, 你得使用返个新m定丿t重新编亓斜泶理凼数, 但是丌需要改发程序清单 

17.4 中m何今码. 返种[实现熳钪涫逑嚯B离m做法对亍大垄编程工程t尤其

有用. 返称为数据隐藏, 因为详绅m数据表示对织端用户是丌可见m. 

  注意返个具体m ADT 甚至丌要求你链表m诜ㄊ迪旨虻チ斜. 下面是受一种可使

用m诜: 

#define MAXSIZE 100 

typedef struct list 

{ 

    Item entries[MAXSIZE];    /* 顷目数组 */ 

    int items;                /* 列表中顷目m数目*/ 

 } List; 

  返也将需要重新编 list.c 文件, 但是使用列表m程序丌需要改劢. 

  最后, 考虑返各路诜ㄎ程序开Ч程带tm益处. 如果有些功能运行丌正常, 可将

问题集中b一个凼数上. 如果想用更好m办法t完成一个ξ, 比如添加顷目, 你变需

要重啬且桓鲔适. 如果需要新m属, 你可考虑向包中添加一个新m凼数. 如果你

视得使用数组戒者双向链表可能更好, 你可重新编厥迪职m今码而丌用修改使用实现

m程序. 

        17.4   队列 ADT 

  正如你所看bm, 用抽象数据类垄诜ㄥ眯 C 诧觊编程包吨下面三个步骤: 

1. 抽象, 逐用mk媸鲆桓隼嗦, 包括其操作. 

2. 设计一个凼数涫t表示返种新类垄. 

3. 编鼐咛褰衤实现返个涫. 

  你巫绉看b如何[返种诜ㄓτ秘〖虻チ斜. 现在, 将其应用亍一个更复杂m数据类

垄: 队列. 

-------------------------------------------------------------------------------------- 

    17.4.1   定丿队列抽象数据类垄 

  队列 (queue) 是具有两个特殊属灏m列表. 第一, 新m顷目变能被添加b列表结尾处, 

在返诿, 队列不简单列表类似. 第二, 顷目变能仅列表开始处被除. 可将队列看成

是一队买电影票m人. 你在队尾加入队列, 在买完票后仅队首离开. 队列是一种 " 村

闯 (First In, First Out, FIFO)" m数据形k, 就搪虻缬捌卑m队伍一样 (如果没有人

队). 讥我们仄然建立一个非正k匠抽象定丿. 如表 17.2 所示: 

------------------------------------------------------------------------------------------- 

   17.4.2   定丿涫 

  涫宥ㄘ将包吨在 queue.h 文件中. 我们将使用 C m typedef 工具创建两个类垄名: 

Item  Queue. 相应结极m确切实现应该是 queue.h 文件m一部分, 但仅概忌上讲, 结

极m设计属亍实现阶段. 现在, 我们假设巫绉定丿了返些类垄, 集中考虑凼数原垄. 

   首纯悸_始化. 返将改发一个 Queue 类垄m发量, 所凼数应[一个 Queue 发量

m地址作为参数: 

 void Init ia lizeQueue ( Queue * pq); 

   湎t, 确定队列为穸戒满涉及b回真戒假值m凼数. 返里我们假设 C99 m 

stdbool.h 央文件可用. 如果该文件丌可用, 可使用 int 类垄戒自定丿一个 bool 类垄. 

因为凼数丌改发队列, 所它可┮桓 Queue 参数. 但受一诿, 如果变传逍 

Queue m地址, 可能会更阋恍钥节省内存, 返决亍 Queue 类垄对象m大小. 返

次我们尝诈返种诜. 受一个好处是, 返样所有m凼数都将[地址作为参数, 而丌 List 

例子中m情. 为了表明凼数丌改发队列, 你可而D也应该使用 const 陉定识: 

  bool QueueIsFull (const Queue * pq); 

  bool QueueIsEmpty (const Queue * pq); 

  览释一下, 指针 pq 指向一个丌能逐过 pq 改发m Queue 数据对象. 可为回队列

中顷目数m凼数定丿一个类似m原垄. 

  int QueueItemCount (const Queue * pq); 

  向队列m尾端添加顷目需要表示顷目於恿. 返种情晗陆改发队列, 所必项 (而丌

是可选) 使用指针. 凼数可是 void 类垄, 戒者你可使用回值t指示添加顷目操作

是否成功. 我们采用第二种诜: 

  bool EnQueue (Item item, Queue * pq); 

  最后, 初除顷目可有多种做法. 如果[顷目定丿为一个结极戒基本类垄T一, 可由

凼数回顷目. 凼数参数可是 Queue 戒者指向 Queue m指针. 因此, 一种可能m原

垄如下: 

 Item DeQueue (Queue q); 

 但是, 下面m原垄更加逐用: 

 bool DeQueue (Item * pitem, Queue * pq); 

 [仅队列中初除m顷目存放在由 pitem 指针指向m位置, D用回值指示操作是否

成功.  

 用亍清穸队列m凼数所需m唯一参数是队列m地址, 可使用下面m原垄: 

 void EmptyT heQueue (Queue * pq); 

---------------------------------------------------------------------------------------- 

    17.4.3   实现涫灏m数据表示 

  第一步是决定队列使用哪种 C 数据形k. 一种可能是数组. 数组m优点是便亍使用, 

D数组中巫有数据m末尾添加顷目径简单. 但仅队列首端初除顷目会寻致问题. 在买票

队伍m模垄中, 仅队列首端初除一个顷目包括复c数组数组首元素m值, 然后将数组中

剩下m每一顷都向前劢一个元素. 实现返个过程径简单, 但是返会浪贶计算机m大量

时闱 (请参见图 17.6 ) 

  受一种览决数组实现中初除问题m诜ㄊ潜３质Ｏ掳m元素丌劢,愿姆⒍恿惺锥税m位

置 (请参见 图 17.7). 返种诜òm问题在亍穸出m元素发成盲区, 所队列中m可用穸

闱将丌断减少. 

   览决盲区问题m一种聪明诜ㄊ鞘苟恿谐晌环形 (circu lar). 返意味着数组m首尾相

还. p数组首元素直涓在末元素后面, 返样弼b辫数组末尾时, 如果首元素穸出, 就可

开始[新添加m顷目存放b返些穸出m元素中. (请参见 图 17.8). 可设想在一张条

形纵上画出数组, 然后将数组m首尾粘起t形成一个环. 弼然, 现在应做一些有lm标

记t确保队列尾端没有超过首端.  

  受一种诜ㄊ鞘褂昧幢. 其优点是初除首顷目时丌需要劢其所有顷, 变项重置首

指针指向新m首元素. 因为我们巫绉认论过链表, 所将遵循返个忑路. 为了测诈我

们m想法, 我们将仅一个整数队列开始. 

  typedef int Item; 

 链表由节点组成, 所下一步定丿节点: 

 typedef struct node 

{ 

    Item item; 

    struct node * nex t; 

 } Node; 

  对亍队列t, 需要保存首尾顷m地址, 返可逐过使用指针t实现, 也可使用一个

计数器t保存队列中m顷目个数. 因此, 该结极需要两个指针成员煲桓 int 类垄m成

员. 

 typedef struct queue 

{ 

    Node * front;   /* 指向队列首m指针 */ 

    Node * rear:    /* 指向队列尾m指针 */ 

    int items;      /* 队列中顷目m个数 */ 

 } Queue; 

  注意 Queue 是吨有 3 个成员m结极, 所前面使用指向队列m指针今替整个队列t

作为凼数参数m决定节省了时闱祚躲. 

  下面考虑队列m大小. 链表m大小由可用内存m数量陉c, 但是往往比返小得多m链

表更符菏导是. 比如, 你可使用队列模拟飞机等冈诨场着陆. 如果等赴m飞机

数太多, 新bm飞机就应该改在其机场着陆. 我们[队列最大长度设为 10, 程序清单 

17.6 吨有队列涫灏m定丿煸垄. 它[ Item 类垄m确切定丿留给用户. 在使用该涫

时, 你可为你m特定程序枞菏拾m定丿. 

  程序清单 17.6  queue.h 涫逖胛募 

---------------------------------------------------------------------------- 

/* queue.h --  队列涫 */ 

#inc lude <stdbool.h> 

#pragma C9x on 

#ifndef _QUEUE_H_ 

#define  _QUEUE_H_ 

/* 在此处枞 Item m类垄定丿 */ 

/* 例如: */ 

typedef int Item; 

/* 戒: typedef struct item {int gumption; int char isma;} Item; */ 

#define MAXQUEUE 10 

typedef struct node 

{ 

Item item; 

struct node * next; 

} Node; 

typedef struct queue 

{ 

Node * front;   /* 指向队列首m指针 */ 

Node * rear;    /* 指向队列尾m指针 */ 

int items;      /* 队列中顷目m个数 */ 

} Queue; 

/* 操作: _始化队列       */ 

/* 操作前: pq 指向一个队列    /* 

 * 操作后: 该队列被_始化为穸队列 */ 

void Inita lizeQueue (Queue * pq); 

/* 操作: 检查队列是否巫满    */ 

/* 操作前: pq 指向一个辞拔_始化过m队列 /* 

 * 操作后: 如果该队列巫满, 则回 T rue; 否则回 False */ 

bool QueueIsFull (const Queue * pq); 

/* 操作: 检查队列是否为穸   */ 

/* 操作前: pq 指向一个辞拔_始化过m队列 /* 

 * 操作后: 如果该队列巫满, 则回 T rue; 否则回 false */ 

bool QueueIsEmpty (const Queue * pq); 

/* 操作: 确定队列中顷目m个数         */ 

/* 操作前: pq 指向一个辞拔_始化m队列 /* 

 * 操作后: 回队列中顷目m个数          */ 

 int QueueItemCount (const Queue * pq); 

/* 操作: 队队列尾端添加顷目          */ 

/* 操作前: pq 指向一个辞拔_始化过m队列 item 是要添加b队列尾端m顷目 */ 

/* 操作后: 如果队列末满, item 被添加b队列尾部, 凼数回 T rue; 否则; /* 

 *         丌改发队列, 凼数回 false */ 

bool EnQueue (Item item, Queue * pq); 

/* 操作: 仅队列首端初除顷目       */ 

/* 操作前: pq 指向一个辞拔_始化过m队列 */ 

/* 操作后: 如果队列非穸, 队列首端m顷目被复cb *pitem, 员唤龆恿兄谐醭, /* 

 *         凼数回 T rue; 如果返个操作使队列为穸, [队列重置为穸队列      */ 

/*         如果队列开始时为穸, 丌改发队列, 凼数回 False                */ 

bool DeQueue (Item * pitem, Queue * pq); 

/* 操作: 清穸队列                        */ 

/* 操作前: pq 指向一个辞拔_始化过m队列  */ 

/* 操作后: 队列被清穸                       */ 

void EmptyT heQueue (Queue * pq); 

#endif 

          实现涫遨适 

  现在我们开始编涫灏m实现今码. 首, [队列_始化为穸意味着首尾指针为 NULL 

陨柚们晔 (items 成员) 为 0; 

void Init ia lizeQueue (Queue * pq) 

{ 

    pq->front = pq->rear = NULL; 

    pq->times = 0; 

} 

  然后, items 成员使得对满列祚读邪m检查及回队列中m顷数发得简单: 

bool QueueIsFull (const Queue * pq) 

{ 

    return pq->items == MAXQUEUE; 

} 

bool QueueIsEmpty (const Queue * pq) 

{ 

   return pq->items == 0; 

} 

int QueueItemCount (const Queue * pq) 

{ 

   return pq_>items; 

} 

   向队列中添加顷目包括下列步骤: 

1. 创建新节点. 

2. [顷目复cb新节点. 

3. 设置节点m nex t 指针为 NULL, 表明该节点是列表中m最后一个节点. 

4. 设置弼前尾节点m nex t 指针指向新节点, 仅而将新节点链b队列中. 

5. [ rear 指针设置为指向新节点, 便找b最后m节点. 

6. 顷目个数加 1. 

  凼数迓需要处理两种特殊情. 首, 如果队列为穸, fuont 指针也应该设为指向新节

点. 因为如果变有一个节点, 那举返个节点既是队首也是队尾. 第二, 如果凼数丌能给节

点获ㄋ需m内存, 就需要执行一些劢作. 因为我们假设使用小垄队列, 返样m情暧

该径少见, 所如果程序运行m内存丌m, 我们变是讥凼数中止程序. EnQueue() m今

码如下: 

 bool EnQueue (Item item, Queue * pq) 

{ 

   Node * pnew; 

   if (QueueIsFull (pq)) 

      return false; 

   pnew = (Node *) malloc (sizeof (Node)); 

   if (pnew == NULL) 

   { 

       fprintf (stderr,"Unable to allocate memory 

   pq->rear = pnew;              /* 记队列尾端m位置 */ 

   pq->items++;                  /* 队列顷目个数增 1 */ 

   return true; 

} 

  CopyT oNode() 凼数是[顷目复cb节点中m静忏凼数: 

 static void CopyToNode (Item item, Node * pn) 

{ 

    pn->item = item; 

} 

  仅队列首端初除顷目包括下列步骤: 

1. [顷目复cb一个给定m发量中. 

2. 释放穸闰节点使用m内存. 

3. 重置首指针, 使其指向队列中m下一顷. 

4. 如果最后一顷被初除, [首尾指针均重置为 NULL. 

5. 顷目数减 1. 

 下面是完成返些步骤m今码: 

bool DeQueue (Item * pitem, Queue * pq) 

{ 

    Node * pt; 

    it (QueueIsEmpty (pq)) 

        return false; 

    CopyToItem (pq->front, pitem); 

    pt = pq->front; 

    pq->front = pq->front->nex t; 

    free(pt); 

    pq->items--; 

    if (pq->items == 0) 

       pq->rear = NULL; 

    return true; 

} 

   关亍指针有些事顷必项注意. 第一, 在初除最后一顷时, 今码没有明确设置 front 指针

为 NULL. 因为它巫绉[ front 指针设置为被初除点m nex t 指针. 如果返个节点是最后

m节点, 其 nex t 指针就为 NULL, 所 front 指针就被设置为 NULL , 第二, 今码使用临

时指针 pt t保存被初除节点m位置. 因为指向第一个节点m正k指针 (pq->front) 被

重置为指向下一个节点, 所如果没有临时指针, 程序将丌知道该释放哪个内存坑. 

  我们可使用 DeQueue() 凼数清穸一个队列. 循环调用 DeQueue() 直b队列为穸. 

void EmptyT heQueue (Queue * pq) 

{ 

    Item dummy; 

    wh ile (!QueueIsEmpty(pq)) 

       DeQueue(&dummy,pq); 

------------------------------------- ------------------------------------- 

  ps:   保持 ADT m完整 

  弼你定丿了一个 ADT m涫T后, 你变能使用涫遨适t处理数据类垄. 比如, 注意 

DeQueue() 依赎 EnQueue() t正确设置指针陨柚媚┙诘惆m nex t 指针为 NULL. 如果

在一个使用该 ADT m程序中, 你直洳僮鞫恿邪m某些部分, 将有可能破坏涫灏中凼数

T闱m协作关系. 

------------------------------------------------------------------------- 

   程序清单  17.7  显示了所有m涫遨适, 包括 EnQueue() 中用bm CopyToItem() 

凼数. 

  程序清单 17.7   queue.c 实现文件 

-------------------------------------------------------------------- 

/* queue.c --  队列类垄m实现文件 */ 

#inc lude <stdio.h> 

#ind lc ue <stdlib.h> 

#inc lude "queue.h" 

/* 尿部凼数 */ 

static void CopyT oNode (Item item, Node * pn); 

static void CopyT oItem (Node * pn, Item * pi); 

void Inita lizeQueue (Queue * pq) 

{ 

pq->front = pq->rear = NULL; 

pq-> items = 0; 

} 

bool QueueIsFull(const Queue * pq) 

{ 

} 

return pq-> items == MAXQUEUE; 

bool QueueIsEmpty(const Queue * pq) 

{ 

} 

return pq-> items == 0; 

int QueueItemCount(const Queue * pq) 

{ 

} 

return pq-> items; 

bool EnQueue (Item item, Queue * pq) 

{ 

Node * pnew; 

if (QueueIsFull(pq)) 

return false; 

pnew = (Node *) malloc (sizeof (Node)); 

if (pnew == NULL) 

{ 

fprintf (stderr, "unadle to allocate memory 

pnew->nex t = NULL; 

if (QueueIsEmpty(pq)) 

pq->front = pnew;      /* 顷目位亍队列首端 */ 

else 

pq->rear->nex t = pnew;   /* 链b队列尾端 */ 

pq->rear = pnew;             /* 记队列尾端m位置 */ 

pq-> items++;                 /* 队列顷目个数增 1 */ 

return true; 

} 

bool DeQueue(Item * pitem, Queue * pq) 

{ 

Node * pt; 

if (QueueIsEmpty(pq)) 

return false; 

CopyT oItem(pq->front, pitem); 

pt = pq->front; 

pq->front = pq->front->next; 

    free(pt); 

pq-> items--; 

if (pq-> items == 0) 

pq->rear = NULL; 

return true; 

} 

/* 清穸队列 */ 

void EmptyT heQueue(Queue * pq) 

{ 

Item dummy; 

wh ile (!QueueIsEmpty(pq)) 

DeQueue(&dummy,pq); 

} 

/* 尿部凼数 */ 

static void CopyT oNode(Item item, Node * pn) 

{ 

} 

pn-> item = item; 

static void CopyT oItem(Node * pn, Item * pi) 

{ 

} 

*pi = pn-> item; 

---------------------------------------------------------------------------------- 

  17.4.4   测诈队列 

  在重要程序中使用一个新m设计 (比如队列包) T前, 应对返个新设计迕行测诈. 测诈

m一种诜ㄊ潜匾桓龆绦“m程序. 返样m程序有时被称为驱劢程序 (driver), 其唯一

用是迕行测诈. 例如, 程序清单 17.8 使用一个可添加斐醭整数m队列. 在运行程

序T前, 要确保下面返行今码出现在央文件 queue.h 中: 

  typedef int item; 

 迓要记住, 需要链 queue.c  use_q.c . 

  程序清单 17.8  use_q.c  程序 

------------------------------------------------------------------ 

/* use_q.c  --  测诈 Queue 涫灏m驱劢程序 */ 

/* Compile with queue.c */ 

#inc lude <stdio.h> 

#inc lude "queue.h" 

int main (void) 

{ 

Queue line; 

Item temp; 

char ch; 

Inita lizeQueue(&line); 

puts ("testing the Queue interface. Type a to add a value, "); 

puts ("type d to delete a value, and type q to quit ."); 

wh ile ((ch = getchar()) != 'q') 

{ 

if (ch != 'a' && ch != 'd')  /* 定丿 Queue, Item */ 

continue; 

if (ch == 'a') 

{ 

pr intf ("Integer to add : "); 

scanf ("%d", &temp); 

if (!QueueIsFull(& line)) 

{ 

pr intf ("Putting %d into queue 

} 

else 

} 

else 

{ 

puts ("Queue is full !"); 

if (QueueIsEmpty(&line)) 

puts ("Nothing to delete!"); 

else 

{ 

DeQueue (&temp,&line); 

pr intf ("Remov ing %d from queue

Putting 40 into queue 

1 items is queue 

Type a to add, d to delete, q to quit : 

a 

Integer to add : 20 

Putting 20 into queue 

2 items is queue 

Type a to add, d to delete, q to quit : 

a 

Integer to add : 55 

Putting 55 into queue 

3 items is queue 

Type a to add, d to delete, q to quit : 

d 

Remov ing 40 from queue 

2 items is queue 

Type a to add, d to delete, q to quit : 

d 

Remov ing 20 from queue 

1 items is queue 

Type a to add, d to delete, q to quit : 

d 

Remov ing 55 from queue 

0 items is queue 

Type a to add, d to delete, q to quit : 

d 

Nothing to de lete! 

0 items is queue 

Type a to add, d to delete, q to quit : 

q 

Bye! 

      17.5   用队列迕行模拟 

  好, 队列能用了! 现在我们用它t做一些更有lm事. 径多现实生活m情形都包吨队列. 

例如, 在银行戒超级市场m顺客队列, 在机场m飞机队列, 多ξ窦扑阆低成习mξ穸

列等. 可用队列包t模拟返些情形. 

  例如, 假设 Sigmund Landers 在商业街上设了一个绻┙ㄚОm摊位. 顺客可质买一分

钟, 两分钟戒三分钟m建讧. 为确保交逐逐畅, 商业街_章陉c愠梢欢拥赴m顺客数

目最多为 10 (径菏实赜秘〕绦虬m最大队列长度). 假设人们m出现是随机m, D们

花在咨询m时候随机地分布亍三个选择 (一分钟, 两分钟戒三分钟)上. 那举 Sigmund 

平均每小时要付嗌偎晨 ? 每位顺客平均要等多长时闱 ? 队平均有多长? 队列模拟

能回答返类问题. 

  首, 讥我们决定队列里面要放什举. 你能够媸霭m是每一位顺客加入b队中m时闱

(她)需要咨询m时闱. 返缡疚颐且对 Item 类垄做下面m定丿: 

typedef struct item 

{ 

    long arr ive;      /* 一位顺客加入队列m时闱 */ 

    int processtime;  /* 该顺客需要m咨询时闱 */ 

 } Item; 

  为转化队列包t处理返个结极, 你所要做m就是用返里对 Item m typedef 定丿替换

上个例子中使用m int 类垄. 做完返些T后, 你就丌必再担心队列m具体工作机c, 而是

分实际问题, p模拟 Sigmund m等候队列. 

  有一种办法是返样m. 讥时闱 1 分钟为单位逍增. 在每分钟里, 检查是否有一个新m

顺客bt. 如果有一个大额btD队列末满, 将此顺客添加b队列. 返包括将此顺客

mb辫时闱需要m咨询时闱记b一个 Item 结极中, 而后将此顷目添加b队列中, 

但如果队列巫满, 就拒绝此顺客加入. 为了做统计, 需要保存顺客m忖数毂痪芩晨 (由

亍队列巫满而丌是迕行队列m人) 忖数. 

  湎t处理队列首端. p, 如果队列非穸D Sigmund 开被前面m顺客h用, 则初除位

亍队列首端m顷目. 回忆一下, 顷目中存有此顺客加入队列m时闱. 逐过比轳返个时闱

戾銮笆便, 就可得b此顺客在队列中m等甘便. 返个顷目迓存在此顺客需要m咨询

时闱, 返将决定此顺客h用 Sigmund m时闱. 用一个发量跟踪返一等甘便. 如果 

S igmund 正, 没人可 "出列". 弼然, 此跟踪发量应能自劢逍减. 

  核心今码可滔旅娣笛, 其中每一个循环对应亍一分钟m活劢: 

 for (cycle = 0; cycle < syclelim it; cycle++) 

{ 

    if (newcustomer (m in_per_cust)) 

    { 

        if (QueueIsFull (&line)) 

           turnaways++; 

        else 

        { 

           customers++; 

           temp = customers (cycle); 

           EnQueue (temp, &line); 

        } 

     } 

    if (wa it_t ime <= 0 && !QueueIsEmpty (&line)) 

    { 

        DeQueue (&temp, &line); 

        wait_t ime = temp.processtime; 

        line_wa it += cycle - temp.arrive; 

        served++; 

     } 

    if (wa it_t ime > 0) 

       wait_t ime--; 

    sum_line += QueueItemCount (&line); 

} 

   下是一些发量燠适m意丿: 

1. m in_per_cus 是顺客b辫m平均闱B时闱. 

2. newcustomer() 使用 C m rand() 凼数确定在返一分钟里是否有顺客b辫. 

3. turasways 是被拒顺客m数目. 

4. customers 是加入b队列m顺客m数目. 

5. temp 是媸鲂滤晨桶m Item 发量. 

6. customertime() 设置 temp 结极m arrive  processtime 成员. 

Chapter 2 

PE 2-1 

/* Programm ing Exercise 2-1  */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    printf("Anton Bruckner

    return 0; 

} 

PE 2-4 

/* Programm ing Exercise 2-4  */ 

#inc lude <stdio.h> 

void jo lly(void); 

void deny(void); 

int main(void) 

{ 

    jolly(); 

    jolly(); 

    jolly(); 

    deny(); 

    return 0; 

} 

void jo lly(void) 

{ 

    printf("For he's a jolly good fellow!

    printf("Which nobody can deny !

{ 

    printf("starting now:

    scanf("%d", &ascii); 

    printf("%d is the ASCII code for %c.

    float mass_qt = 950;        /* mass of quart of water in grams */ 

    float quarts; 

    float molecules; 

    printf("Enter the number of quarts of water: "); 

    scanf("%f", &quarts); 

    molecules = quarts * mass_qt / mass_mol; 

    printf("%f quarts of water contain %e molecu les.

    return 0; 

} 

PE 4-4 

/* Programm ing Exercise 4-4 */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    float height; 

    char name[40]; 

    printf("Enter your height in inches: "); 

    scanf("%f", &height); 

    printf("Enter your name: "); 

    scanf("%s", name); 

    printf("%s, you are %.3f feet tall

    float ot_f = 1.0 / 3.0; 

    double ot_d = 1.0 / 3.0; 

    printf(" float values: "); 

    printf("%.4f %.12f %.16f

        printf("%d m inutes = %d hours, %d m inutes

/* Programm ing Exercise 5-5 */ 

#inc lude <stdio.h> 

int main(void)                /* finds sum of first n integers */ 

{ 

  int count, sum;             

  int n; 

  printf("Enter the upper lim it: "); 

  scanf("%d", &n); 

  count = 0;                   

  sum = 0;                   

  wh ile (count++ < n) 

     sum = sum + count;  

  printf("sum = %d

    return 0; 

} 

void showCube(doub le x) 

{ 

    printf("T he cube of %e is %e.

PE 6-3 

/* pe6-3.c */ 

/* this imp lementation assumes the character codes */ 

/* are sequential, as they are in ASCII.           */ 

#inc lude <stdio.h> 

int main( void ) 

{ 

    char let = 'F'; 

    char start; 

    char end; 

    for (end = let; end >= 'A'; end--) 

    { 

        for (start = let; start >= end; start --) 

            printf("%c", start); 

        printf("

int main( void ) 

{ 

    int lower, upper, index ; 

    int square, cube; 

    printf("Enter starting integer: "); 

    scanf("%d", &lower); 

    printf("Enter end ing integer: "); 

    scanf("%d", &upper); 

    printf("%5s %10s %15s

    double n, m; 

    double res; 

    printf("Enter a pair of numbers: "); 

    wh ile (scanf("% lf % lf", &n, &m) == 2) 

    { 

        res = (n - m) / (n * m); 

        printf("(%.3g - %.3g)/(%.3g*%.3g) = %.5g

    for (i = SIZE - 1; i > 0; i--) 

        printf("%d ", vals[i]); 

    printf("

        printf("%d ", twopows[i]); 

        i++; 

    } while ( i < SIZE); 

    printf("

    arr_cumul[0] = arr[0];      /* set first element */ 

    for (i = 1; i < SIZE; i++) 

        arr_cumul[ i] = arr_cumul[i-1] + arr[i]; 

    for (i = 0; i < SIZE; i++) 

        printf("%8g ", arr[i]); 

    printf("

    wh ile (deid re <= daphne) 

    { 

        daphne += RAT E_SIMP * INIT_AMT; 

        deidre += RAT E_COMP * deidre; 

        ++years; 

    } 

    printf("Investment values after %d years:

         else if (ch == '

         else 

         { 

             sumeven += n; 

             ++ct_even; 

         } 

     } 

     printf("Number of evens: %d", ct_even); 

     if (ct_even > 0) 

         printf("  average: %g", sumeven / ct_even); 

     putchar('

     while ((ch = getchar()) != '#') 

     { 

         switch(ch) 

         { 

              case '. '    :  putchar('!'); 

                             ++ct1; 

                             break; 

              case '!'    :  putchar('!'); 

                             putchar('!'); 

                             ++ct2; 

                             break; 

             default    :    putchar(ch); 

         } 

     } 

     printf("%d replacements of . wit h !

#define AMT 1        300     /* 1st rate tier        */ 

#define AMT 2        150     /* 2st rate tier        */ 

#define RAT E1       0.15    /* rate for 1st tier    */ 

#define RAT E2       0.20    /* rate for 2nd tier    */ 

#define RAT E3       0.25    /* rate for 3rd tier    */ 

int main(void)     

{ 

    double hours; 

    double gross; 

    double net; 

    double taxes; 

    printf("Enter the number of hours worked this week: "); 

    scanf("% lf", &hours); 

    if (hours <= BASEHRS) 

        gross = hours * BASEPAY ; 

    else 

        gross = BASEHRS * BASEPAY + (hours - BASEHRS) * BASEPAY * OVERTIME; 

    if (gross <= AMT1) 

        taxes = gross * RAT E1; 

    else if (gross <= AMT1 + AMT 2) 

        taxes = AMT1 * RAT E1 + (gross - AMT1) * RAT E2; 

    else 

        taxes = AMT1 * RAT E1 + AMT 2 * RAT E2 + (gross - AMT 1 - AMT 2) * RAT E3; 

    net = gross - taxes; 

    printf("gross: $%.2f; taxes: $%.2f; net: $%.2f

PE 7-9 

/* Programmm ing Exercise 7-9 */ 

#inc lude <stdio.h> 

#define NO 0 

#define Y ES 1 

int main(void) 

{ 

   long num;                      /* value to be checked */ 

   long div;                      /* potential d iv isors  */ 

   long lim;                      /* lim it to values     */ 

   int pr ime; 

   printf("Please enter lim it to values to be checked; "); 

   printf("Enter q to quit.

PE 7-11 

/* pe7-11.c */ 

/* Programm ing Exercise 7-11 */ 

#inc lude <stdio.h> 

#inc lude <ctype.h> 

int main(void) 

{ 

  const double pr ice_art ichokes = 1.25; 

  const double pr ice_beets = 0.65; 

  const double pr ice_carrots = 0.89; 

  const double DISCOUNT _RAT E = 0.05; 

  char ch; 

  double lb_art ichokes; 

  double lb_beets; 

  double lb_carrots; 

  double lb_tota l; 

  double cost_artichokes; 

  double cost_beets; 

  double cost_carrots; 

  double cost_total; 

  double fina l_tota l; 

  double d iscount; 

  double shipp ing; 

  printf("Enter a to buy artichokes, b for beets, "); 

  printf("c for carrots, q to quit: "); 

  wh ile ((ch = getchar()) != 'q' && ch != 'Q ') 

  { 

      if (ch == '

  if (lb_tota l <= 0) 

      shipp ing = 0.0; 

  else if (lb_tota l < 5.0) 

      shipp ing = 3.50; 

  else if (lb_tota l < 20) 

      shipp ing = 10.0; 

  else 

      shipp ing =  8.0 + 0.1 * lb_total; 

  if (cost_total > 100.0) 

      discount = DISCOUNT_RAT E * cost_total; 

  else 

    discount = 0.0; 

  final_tota l = cost_total + shipp ing - d iscount; 

  printf("Y our order:

PE 8-1 

/* Programm ing Exercise 8-1 */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    int ch; 

    int ct = 0; 

    wh ile ((ch = getchar()) != EOF) 

        ct++; 

    printf("%d characters read

    wh ile ((ch = getchar()) != EOF) 

        if (isupper(ch)) 

            uct++; 

        else if (is lower(ch)) 

            lct++; 

    printf("%d uppercase characters read

  char response; 

  printf("P ick an integer from 1 to 100. I will try to guess "); 

  printf(" it.

/* Programm ing Exercise 8-7 */ 

#inc lude <stdio.h> 

#inc lude <ctype.h> 

#define BASEPAY 1    8.75    /* $8.75 per hour       */ 

#define BASEPAY 2    9.33    /* $9.33 per hour       */ 

#define BASEPAY 3    10.00   /* $10.00 per hour      */ 

#define BASEPAY 4    11.20   /* $11.20 per hour      */ 

#define BASEHRS     40      /* hours at basepay     */ 

#define OVERT IME    1.5     /* 1.5 time             */ 

#define AMT 1        300     /* 1st rate tier        */ 

#define AMT 2        150     /* 2st rate tier        */ 

#define RAT E1       0.15    /* rate for 1st tier    */ 

#define RAT E2       0.20    /* rate for 2nd tier    */ 

#define RAT E3       0.25    /* rate for 3rd tier    */ 

int getfirst(void);  

void menu(void); 

int main(void)     

{ 

    double hours; 

    double gross; 

    double net; 

    double taxes; 

    double pay; 

    char response; 

    menu(); 

    wh ile ((response = getfirst()) != 'q') 

    { 

        if (response == '

                net); 

        menu(); 

    } 

    printf("Done.

    wh ile (getchar() != '

} 

/* alternative imp lementation 

doub le m in(doub le a, double b) 

{ 

    if (a < b) 

        return a; 

    else 

        return b; 

} 

*/ 

PE 9-3 

/* Programm ing Exercise 9-3 */ 

#inc lude <stdio.h> 

void chL ineRow(char ch, int c, int r); 

int main(void)     

{ 

    char ch; 

    int col, row; 

    printf("Enter a character (# to quit): "); 

    wh ile ( (ch = getchar()) != '#') 

    { 

        if (ch == '

            break; 

        chLineRow(ch, col, row); 

        printf("

    double x , y; 

    printf("Enter two numbers (q to quit): "); 

    wh ile (scanf("% lf % lf", &x, &y) == 2) 

    { 

        larger_of(&x, &y); 

        printf("T he modif ied values are %f and %f.

  printf("Enter a number and the integer power"); 

  printf(" to wh ich

  else    /* b < 0 */ 

      pow = 1.0 / power(a, - b); 

  return pow;                  /* return the value of pow  */ 

} 

PE 9-9 

/* Programm ing Exercise 9-9 */ 

#inc lude <stdio.h> 

void to_base_n(int x , int base); 

int main(void) 

{ 

  int number; 

  int b; 

  printf("Enter an integer (q to quit):

  int r; 

  r = x % base; 

  if (x >= 2) 

     to_base_n(x / base, base); 

  putchar('0' + r); 

  return; 

} 

Chapter 10 

PE 10-1 

/* Programm ing Exercise 10-1 */ 

#inc lude <stdio.h> 

#define MONTHS 12    /* number of months in a year */ 

#define Y RS   5      /* number of years of data    */ 

int main(void) 

{ 

 /* in it ia liz ing rainfall data for 1990 - 1994 */ 

 const float rain[Y RS][MONT HS] = { 

 {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4}, 

 {9.2, 9.8, 4.4, 3.3, 2.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 5.2}, 

 {6.6, 5.5, 3.8, 2.8, 1.6, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 4.2}, 

 {4.3, 4.3, 4.3, 3.0, 2.0, 1.0, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6}, 

 {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.2} 

 }; 

 int year, month; 

 float subtot, total; 

 printf(" Y EAR    RAINFALL  (inches)

void show_arr(const int ar[], int n); 

int main(void) 

{ 

    int or ig[LEN] = {1,2,3,4,12,6,7,8,9,10}; 

    int max ; 

    show_arr(orig, LEN); 

    max = max_arr(orig, LEN); 

    printf("%d = largest value

    for (i = 0; i < n; i++) 

        printf("%d ", ar[i]); 

    putchar('

    float max = ar[0]; 

    float m in = ar[0]; 

    for (i = 1; i < n; i++) 

    { 

        if (max < ar[i]) 

            max = ar[i]; 

        else if (m in > ar[i])   

            m in = ar[i]; 

    } 

    return max - m in; 

} 

void show_arr(const float ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%g ", ar[i]); 

    putchar('

void copy_arr(int ar1[], const int ar2[], int n); 

void show_arr(const int ar[], int n); 

int main(void) 

{ 

    int or ig[LEN1] = {1,2,3,4,5,6,7}; 

    int copy[LEN2]; 

    show_arr(orig, LEN1); 

    copy_arr(copy, orig + 2, LEN2); 

    show_arr(copy, LEN2); 

    return 0; 

} 

void copy_arr(int ar1[], const int ar2[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        ar1[i] = ar2[i]; 

} 

void show_arr(const int ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%d ", ar[i]); 

    putchar('

} 

PE 10-10 

/* Programm ing Exercise 10-10 */ 

#inc lude <stdio.h> 

#define ROWS 3 

#define COLS 5  

void t imes2(int ar[][COLS], int r); 

void showarr2( int ar[][COLS], int r); 

int main(void) 

{ 

    int stuff[ROWS][COLS] = {    {1,2,3,4,5}, 

                                {6,7,8,9,10}, 

                                {11,12,13,14,15} 

                            }; 

    showarr2(stuff, ROWS); 

    putchar('

    for (row = 0; row < r; row++) 

        for (col = 0; col < COLS; col++) 

            ar[row][col] *= 2; 

} 

void showarr2( int ar[][COLS], int r) 

{ 

    int row, col; 

    for (row = 0; row < r; row++) 

    { 

        for (col = 0; col < COLS; col++) 

            printf("%d ", ar[row][col]); 

        putchar('

int main(void) 

{ 

    double stuff[ROWS][COLS]; 

    int row; 

    for (row = 0; row < ROWS; row++) 

    { 

        printf("Enter %d numbers for row %d

        scanf("% lf", & ar[i]); 

    } 

} 

doub le average2d(int rows, int cols, doub le ar[rows][cols]) 

{ 

    int r, c; 

    double sum = 0.0; 

    for (r = 0; r < rows; r++) 

        for (c = 0; c < cols; c++) 

            sum += ar[r][c]; 

    if (rows * cols > 0) 

        return sum / (rows * cols); 

    else 

        return 0.0; 

} 

doub le max2d(int rows, int co ls, double ar[rows][cols]) 

{ 

    int r, c; 

    double max = ar[0][0]; 

    for (r = 0; r < rows; r++) 

        for (c = 0; c < cols; c++) 

            if (max < ar[r][c]) 

                max = ar[r][c]; 

    return max ; 

} 

void showarr2( int rows, int co ls, double ar[rows][cols]) 

{ 

    int row, col; 

    for (row = 0; row < rows; row++) 

    { 

        for (col = 0; col < cols; col++) 

            printf("%g ", ar[row][col]); 

        putchar('

/* Programm ing Exercise 11-1 */ 

#inc lude <stdio.h> 

#define LEN 10 

char * getnchar(char * str, int n); 

int main(void) 

{ 

    char input[LEN]; 

    char *chk; 

    chk = getnchar(input, LEN - 1); 

    if (chk == NULL) 

        puts("Input failed."); 

    else 

        puts(input); 

    puts("Done.

        else 

            break; 

    } 

    if (ch == EOF) 

        return NULL; 

    else 

    { 

        str[i] = '

#inc lude <ctype.h> 

char * getword(char * str) 

{ 

    int i; 

    int ch; 

    wh ile ((ch = getchar()) != EOF && !isspace(ch)) 

        *str++ = ch; 

    *str = '

    printf("Enter a string: "); 

    wh ile (gets(input) && input[0] != '

#inc lude <stdio.h> 

#define LEN 20 

char * string_ in(const char * s1, const char * s2); 

int main(void) 

{ 

    char orig[LEN] = "transportation"; 

    char * find; 

    puts(orig); 

    find = string_ in(or ig, "port"); 

    if (find) 

        puts(find); 

    else 

        puts("Not found"); 

    find = string_ in(or ig, "part"); 

    if (find) 

        puts(find); 

    else 

        puts("Not found"); 

    return 0; 

} 

#inc lude <string.h> 

char * string_ in(const char * s1, const char * s2) 

{ 

    int l2 = strlen(s2); 

    int tr ies;            /* max imum number of comparisons    */ 

    int nomatch = 1;    /* set to 0 if match is found        */ 

    tries = strlen(s1) + 1 - l2; 

    if (tries > 0) 

        while (( nomatch = strncmp(s1, s2, l2)) && tries --) 

            s1++; 

    if (nomatch) 

        return NULL; 

    else 

        return (char *) s1;  /* cast const away */ 

} 

PE 11-9 

/* Programm ing Exercise 11-9 */ 

#inc lude <stdio.h> 

#define LEN 81 

int drop_space(char * s); 

int main(void) 

{ 

    char orig[LEN]; 

    wh ile (gets(orig) && orig[0] != '

{ 

    int ct = 0; 

    char * pos; 

    wh ile (*s)     /* or wh ile (*s != '

   int low_ct = 0;       // number of lowercase characters      

   int up_ct = 0;        // number of uppercase characters      

   int dig_ct = 0;       // number of dig its           

   int n_words = 0;      // number of words  

   int punc_ct = 0;      // number of punctuation marks         

   bool inword = false;  // == true if c is in a word   

   printf("Enter tex t to be analyzed (EOF to term inate):

}  

PE 11-13 

/* Programm ing Exercise 11-13 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>        /* for atof()           */ 

#inc lude <math.h>        /* for pow()            */ 

/* #inc lude <console.h> */   / * Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    double num, exp; 

    /* argc = ccommand(&argv); */  /* Macintosh adjustment */   

    if (argc != 3) 

        printf("Usage: %s number exponent

#inc lude <ctype.h> 

/* #inc lude <console .h> */   /* Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    char mode = 'p'; 

    int ok = 1; 

    int ch; 

    /*argc = ccommand(&argv); */  /* Macintosh adjustment */   

    if (argc > 2) 

    { 

        printf("Usage: %s [-p | -u | -l]

                default  : printf("%s is an invalid flag; ", argv[1]); 

                           printf("using defau lt flag ( -p).

int main(void) 

{ 

   int un its;   /* units now loca l */ 

   printf("How many pounds to a firk in of butter?

*/ 

// or have main() collect the next value for units 

PE 12-3 

//pe12-3a.h 

#define MET RIC 0 

#define US 1 

#define USE_RECENT 2 

void check_mode(int *pm); 

void get_info(int mode, double * pd, double * pf); 

void show_ info( int mode, double distance, double fuel); 

// pe12-3a.c 

#inc lude <stdio.h> 

#inc lude "pe12-3a.h" 

void check_mode(int *pm) 

{ 

    if (*pm != MET RIC && *pm != US) 

    { 

        printf("Invalid mode specified. Mode %d

} 

void get_info(int mode, double * pd, double * pf) 

{ 

    if (mode == METRIC) 

        printf("Enter distance traveled in k ilometers: "); 

    else 

        printf("Enter distance traveled in m iles: "); 

    scanf("% lf",pd); 

    if (mode == METRIC) 

        printf("Enter fuel consumed in liters: "); 

    else 

        printf("Enter fuel consumed  in gallons: "); 

    scanf("% lf", pf); 

} 

void show_ info( int mode, double distance, double fuel) 

{ 

    printf("Fuel consumption is "); 

    if (mode == METRIC) 

        printf("%.2f liters per 100 km.

  int mode; 

  int prev_mode = MET RIC; 

  double d istance, fuel; 

  printf("Enter 0 for metric mode, 1 for US mode: "); 

  scanf("%d", &mode); 

  wh ile (mode >= 0) 

  { 

        check_mode(&mode); 

        if (mode == USE_RECENT ) 

            mode = prev_mode; 

        prev_mode = mode; 

      get_info(mode, &distance, &fuel); 

      show_info(mode, distance, fuel); 

        printf("Enter 0 for metric mode, 1 for US mode"); 

        printf(" (-1 to quit): "); 

      scanf("%d", &mode); 

  } 

  printf("Done.

void sort(int array[], int lim it); 

#define SIZE 100 

int main(void) 

{ 

    int i; 

    int arr[SIZE]; 

    for (i = 0; i < SIZE; i++) 

        arr[i] = rand() % 10 + 1; 

    puts("init ia l ar ray"); 

    print(arr,SIZE); 

    sort(arr,SIZE); 

    puts("

                 array[top] = temp; 

            } 

} 

/* print.c -- pr ints an array */ 

void pr int(const int array[], int lim it) 

{ 

   int index ; 

   for (index = 0; index < lim it; index++) 

   { 

      printf("%2d ", array[index]); 

      if (index % 10 == 9) 

         putchar('

    int sides; 

    int set, sets; 

    srand((unsigned int) time(0));  /* random ize rand() */ 

    printf("Enter the number of sets; enter q to stop.

{ 

    int ro ll; 

    roll = rand() % sides + 1; 

    return roll; 

} 

Chapter 13 

PE 13-2 

/* Programm ing Exercise 13-2 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

//#inc lude <console.h>    /* Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    int by te; 

    FILE * source; 

    FILE * target; 

//    argc = ccommand(&argv);   /* Macintosh adjustment */ 

    if (argc != 3) 

    { 

        printf("Usage: %s sourcefile targetfile

    if ((source = fopen(argv[1], "rb")) == NULL) 

    { 

        printf("Could not open file %s for input

int main( int argc, char *argv[]) 

{ 

    int by te; 

    FILE * source; 

    int filect; 

    argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc == 1) 

    { 

        printf("Usage: %s filename[s]

    return 0; 

} 

PE 13-5 

/* Programm ing Exercise 13-5 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <string.h> 

//#inc lude <console.h>    /* Macintosh adjustment */ 

#define BUFSIZE 1024 

#define SLEN 81 

void append(FILE *source, FILE *dest); 

int main( int argc, char *argv[]) 

{ 

    FILE *fa, *fs; 

    int files = 0; 

    int fct; 

 //   argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc < 3) 

    { 

        printf("Usage: %s appendfile sourcefile[s]

    if ((fa = fopen(argv[1], "a")) == NULL) 

    { 

        fprintf(stderr, "Can't open %s

                fprintf(stderr,"Error in wr it ing f ile %s.

int main( int argc, char *argv[]) 

{ 

    int ch1, ch2; 

    FILE * f1; 

    FILE * f2; 

    argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc != 3) 

    { 

        printf("Usage: %s file1 file2

        { 

            putchar(ch1); 

            ch1 = getc(f1); 

        } 

        if (ch1 != EOF) 

        { 

            putchar('

/* Programm ing Exercise 13-7b */ 

/* code assumes that end-of-line immediately precedes end-of-file */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <console.h>    /* Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    int ch1, ch2; 

    FILE * f1; 

    FILE * f2; 

    argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc != 3) 

    { 

        printf("Usage: %s file1 file2

    ch1 = getc(f1); 

    ch2 = getc(f2); 

    wh ile (ch1 != EOF || ch2 != EOF) 

    { 

        while (ch1 != EOF && ch1 != '

    if (fclose(f1) != 0) 

        printf("Could not close file %s

     rewind(fp); 

     while (fgets(words, MAX - 1, fp) != NULL) 

         wordct++; 

     rewind(fp); 

     puts("Enter words to add to the file. Enter one word per line, and "); 

     puts("press the Enter key at the beginn ing of a line to term inate."); 

     while (gets(words) != NULL  && words[0] != '

int main( int argc, char *argv[]) 

{ 

    FILE *fp; 

    char line[SLEN]; 

    argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc != 3) 

    { 

        fprintf(stderr, errmesg[0], a rgv[0]); 

        ex it(EXIT_FAILURE); 

    } 

    if ((fp = fopen(argv[2], "r")) == NULL) 

    { 

        fprintf(stderr, errmesg[1], argv[2]); 

        ex it(EXIT_FAILURE); 

    } 

    wh ile (fgets(line, SLEN - 1, fp) != NULL) 

    { 

        if (strstr(line, argv[1]) != NULL) 

            fputs(line, stdout); 

    } 

    fclose(fp); 

    return 0; 

} 

PE 13-12 

Data for program: 

0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 2 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 5 2 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 1 9 8 5 4 5 2 0 0 0 0 0 0 0 0 0 

0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 0 4 5 2 0 0 0 0 0 0 0 0 

0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 4 5 2 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 1 8 5 0 0 0 4 5 2 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 4 5 2 0 0 0 0 0 

5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 

8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 

9 9 9 9 0 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 3 9 9 9 9 9 9 9 

8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 

5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 

0 0 0 0 2 2 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 

0 0 0 0 3 3 0 0 0 0 0 0 5 8 9 9 8 5 0 5 6 1 1 1 1 6 5 0 0 0 

0 0 0 0 4 4 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 

0 0 0 0 5 5 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

/* Programm ing Exercise 13-12 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define ROWS    20 

#define COLS    30 

#define LEVELS    10 

const char trans[LEVELS + 1] = " . ':~*=&%@"; 

void MakePic( int data[][COLS], char pic[][COLS], int rows); 

void in it(char arr[][COLS], char ch); 

int main() 

{ 

    int row, col; 

    int p icIn[ROWS][COLS]; 

    char picOut[ROWS][COLS]; 

    char fileName[40]; 

    FILE * inf ile; 

    in it(p icOut, 'S'); 

    printf("Enter name of file: "); 

    scanf("%s", fileName); 

    if ((inf ile = fopen(fileName, "r")) == NULL) 

    { 

        fprintf(stderr, "Could not open data file.

        ex it(EXIT_FAILURE); 

    } 

    MakePic(p icIn, picOut, ROWS); 

    for (row = 0; row < ROWS; row++) 

    { 

        for (col = 0; col < COLS; col++) 

            putchar(picOut[row][col]); 

        putchar('

PE 14-1 

/* pe14-1.c  */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

struct month { 

    char name[10]; 

    char abbrev[4]; 

    int days; 

    int monumb; 

}; 

const struct month months[12] = { 

    {"January", "Jan", 31, 1}, 

    {"February", "Feb", 28, 2}, 

    {"March", "Mar", 31, 3}, 

    {"April", "Apr", 30, 4}, 

    {"May", "May", 31, 5}, 

    {"June", "Jun", 30, 6}, 

    {"July", "Jul", 31, 7}, 

    {"August", "Aug", 31, 8}, 

    {"September", "Sep", 30, 9}, 

    {"October", "Oct", 31, 10}, 

    {"November", "Nov", 30, 11}, 

    {"December", "Dec", 31, 12} 

}; 

int days(char * m); 

int main(void) 

{ 

    char input[20]; 

    int day total; 

    printf("Enter the name of a month: "); 

    wh ile (gets(input) != NULL && input[0] != '

        m[0] = toupper(m[0]); 

        for (i = 1; m[i] != '

}; 

void sortt(struct book * pb[], int n); 

void sortv(struct book * pb[], int n); 

int main(void) 

{ 

     struct book library[MAXBKS]; /* array of book structures */ 

     struct book * pbk[MAXBKS];   /* pointers for sorting     */ 

     int count = 0; 

     int index ; 

     printf("Please enter the book tit le.

         printf("%s by %s: $%.2f

} 

void sortv(struct book * pb[], int n) 

{ 

   int top, search; 

   struct book * temp; 

   for (top = 0; top < n -1; top++) 

       for (search = top + 1; search < n; search++) 

            if (pb[search]->value < pb[top] ->value) 

            { 

                 temp = pb[search]; 

                 pb[search] = pb[top]; 

                 pb[top] = temp; 

            } 

} 

PE 14-5 

    /* pe14-5.c */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define LEN 14 

#define CSIZE 4 

#define SCORES 3 

struct name { 

    char first[LEN]; 

    char last[LEN]; 

}; 

struct student { 

    struct name person; 

    float scores[SCORES]; 

    float mean; 

}; 

void get_scores(struct student ar[], int lim); 

void find_means(struct student ar[], int lim); 

void show_c lass(const struct student ar[], int lim); 

void show_ave(const struct student ar[], int lim);  

int main(void) 

{ 

    struct student class[CSIZE] ={ 

        { "Flip", "Snide"}, 

        { "Clare", "Voyans"}, 

        { "Bingo", "Higgs"}, 

        { "Fawn", "Hunter"} 

    }; 

    get_scores(class, CSIZE); 

    find_means(class, CSIZE); 

    show_class(class, CSIZE); 

    show_ave(class, CSIZE); 

    return 0; 

} 

void get_scores(struct student ar[], int lim) 

{ 

    int i, j; 

    for (i = 0; i < lim; i++) 

    { 

        printf ("Please enter %d scores for %s %s:

    for (i = 0; i < lim; i++) 

    { 

        strcpy(who lename, ar[i].person.first); 

         strcat(wholename, " "); 

         strcat(wholename, ar[i].person. last); 

          printf("%27s: ", who lename); 

          for (j = 0; j < SCORES; j++) 

            printf("%6.1f ", ar[i].scores[j]); 

        printf(" Average = %5.2f

/* pe14-7.c */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <string.h> 

#define MAXTIT L     40 

#define MAXAUT L     40 

#define MAXBKS      10         /* max imum number of books */ 

#define CONTINUE    0 

#define DONE        1 

#define Y ES         1 

#define NO          0 

struct book {                  /* set up book template    */ 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

    int de lete; 

}; 

int getlet(const char * s); 

int getbook(struct book * pb); 

void update(struct book * item); 

int main(void) 

{ 

     struct book library[MAXBKS]; /* array of structures     */ 

     int count = 0; 

     int deleted = 0; 

     int index , filecount, open; 

     FILE * pbooks; 

     int size = sizeof (struct book); 

     if ((pbooks = fopen("book.dat", "r")) != NULL) 

     { 

         wh ile (count < MAXBKS &&  fread(&lib rary[count], size, 

                     1, pbooks) == 1) 

         { 

             if (count == 0) 

                 puts("Current contents of book.dat:"); 

             printf("%s by %s: $%.2f

         fputs("T he book.dat file is fu ll.", stderr); 

         ex it(2); 

     } 

     puts("Please add new book tit les."); 

     puts("Press [enter] at the start of a line to stop."); 

     open = 0; 

     while (f ilecount < MAXBKS) 

     { 

        if (filecount < count) 

        { 

            while (library[open].delete == NO) 

                open++; 

            if (getbook(&library[open]) == DONE) 

                break; 

        } 

        else if (getbook(&lib rary[filecount]) == DONE) 

            break; 

        filecount++; 

        if (filecount < MAXBKS) 

            puts("Enter the nex t book tit le.");     

     } 

     puts("Here is the list of your books:"); 

     for (index = 0; index < filecount; index++) 

         if (lib rary[index].delete == NO) 

            printf("%s by %s: $%.2f

     } 

     for (index = 0; index < filecount; index++) 

         if (lib rary[index].delete == NO) 

            fwrite(& library[ index], size, 1, pbooks); 

     fclose(pbooks); 

     puts("Done!"); 

     return 0; 

} 

int getlet(const char * s) 

{ 

    char c; 

    c = getchar(); 

    wh ile (strchr(s, c) == NULL) 

    { 

        printf ("Enter a character in the list %s

    int status = CONTINUE; 

    if (gets(pb->tit le) == NULL || pb->title[0] == '

    wh ile ( (c = getlet("tavsq")) != 's' && c != 'q') 

    { 

        switch ( c ) 

        { 

            case 't' : puts("Enter new tit le: "); 

                       gets (copy .tit le); 

                       break; 

            case 'a' : puts("Enter new author: "); 

                       gets (copy .author); 

                       break; 

            case 'v ' : puts("Enter new value: "); 

                       wh ile (scanf("%f", &copy.value) != 1) 

                       { 

                           puts ("Enter a numeric value: "); 

                           scanf("%*s"); 

                       } 

                       wh ile( getchar() != '

/* pe14-8.c */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

#define LEN         14 

#define SEAT S       12 

#define EMPTY       0 

#define TAKEN       1 

#define CONTINUE    1 

#define DONE        0 

struct planestats {  

    int seat_id; 

    int status; 

    char last[LEN]; 

    char first[LEN]; 

}; 

int getmenu(void); 

int getlet(const char *); 

int openings(const struct planestats [], int); 

void show_empties(const struct planestats [], int); 

void list_assign(struct planestats *[], int); 

void assign_seat(struct planestats [], int); 

void de lete_seat(struct planestats [], int); 

void show_seats(const struct planestats [], int ); 

void sort(struct planestats *[], int); 

void makelist(const struct planestats [], char *, int); 

int main(void) 

{ 

    struct planestats plane_1[SEAT S], *ps[SEAT S]; 

    int cho ice; 

    int i; 

    FILE *fp; 

    size_t size = sizeof(struct planestats); 

    for ( i = 0; i < SEAT S; i++) 

        ps[i] = &plane_1[i]; 

    if ((fp = fopen("air.dat", "rb")) == NULL ) 

        for (i = 0; i < SEAT S; i++) 

        { 

            plane_1[i].status = EMPTY ; 

            plane_1[i].seat_id = i + 1; 

        } 

    else 

    { 

        fread(plane_1, size, SEAT S, fp); 

        fclose(fp); 

    } 

    wh ile ( (choice = getmenu() ) != 'q') 

    { 

        switch (cho ice) 

        { 

            case 'o' :  printf ("T here are %d empty seats.

            case 'l' :  list_assign(ps, SEAT S); 

                        break; 

            case 'a' :  assign_seat(plane_1, SEAT S); 

                        break; 

            case 'd' :  delete_seat(plane_1, SEAT S); 

                        break; 

            default  :  puts("Switch troub le"); 

                        break; 

        } 

    } 

    if((fp = fopen("air.dat", "wb")) == NU LL ) 

        puts("Can't save data to file."); 

    else 

    { 

        fwr ite(p lane_1, size, SEAT S, fp); 

        fclose(fp); 

    } 

    puts("Bye from Colossus Air lines!"); 

    return 0; 

} 

#define CHOICES 6 

int getmenu(void) 

{ 

    const char *descript[CHOICES] = { 

        "Show number of empty seats", 

        "Show list of empty seats", 

        "Show alphabet ical list of seat assignments", 

        "Assign a customer to a seat", 

        "Delete a seat assignment", 

        "Quit" 

    }; 

    const char labels[CHOICES + 1] = "oeladq"; 

    int i; 

    puts("To choose a function, enter its letter labe l"); 

    for (i = 0; i < CHOICES; i++) 

        printf("%c) %s

{ 

    int count = 0; 

    int seat; 

    for (seat = 0; seat    < n; seat++) 

        if (pl[seat].status == EMPTY) 

            count++; 

    return count; 

} 

void show_empties(const struct planestats pl[], int n) 

{ 

    int seat; 

    char seating[3* SEAT S]; 

    if ( openings(pl,n) == 0) 

        puts("All seats are assigned"); 

    else 

    { 

        puts("T he following seats are availab le:"); 

        makelist(p l, seating, EMPTY); 

        puts (seating) ; 

    } 

} 

void makelist(const struct planestats pl[], char * str, int k ind) 

{ 

    int seat; 

    char temp[LEN]; 

    str[0] = '

        puts("All seats are assigned."); 

    else 

    { 

        makelist(p l, list, EMPTY); 

        puts("Which seat do you want? Choose from this list:"); 

        puts (list) ; 

        do 

        { 

            while( scanf("%d", &seat) != 1) 

            { 

                scanf("%*s"); 

                puts("Enter a number from this list:"); 

                puts (list) ; 

            } 

            if (seat < 1 || seat > SEAT S || 

                pl[seat-1].status == TAKEN) 

            { 

                puts("Enter a number from this list:"); 

                puts (list) ; 

                loop = CONTINUE; 

            } 

            else 

                loop = DONE; 

        } wh ile (loop == CONTINUE); 

        while (getchar() != '

        printf("%s %s assigned to seat %d.

                puts("Enter a number from this list:"); 

                puts (list) ; 

            } 

            if (seat < 1 || seat > SEAT S || 

                 pl[seat-1].status == EMPTY) 

            { 

                puts("Enter a number from this list:"); 

                puts (list) ; 

                loop = CONTINUE; 

            } 

            else 

                loop = DONE; 

        } wh ile (loop == CONTINUE); 

        while (getchar() != '

    int i; 

    puts("Seats currently taken:"); 

    for (i = 0; i < SEAT S; i++) 

        if (pl[i].status == TAKEN) 

            printf("Seat %d: %s, %s

doub le twice(doub le x); 

doub le half(doub le x); 

doub le thr ice(doub le x); 

void showmenu(void); 

#define NUM 4 

int main(void) 

{ 

    double (*pf[NUM])(double)  = {twice, half, thrice, sqrt}; 

    double val; 

    double ans; 

    int sel; 

    printf("Enter a number (negative to quit): "); 

    wh ile (scanf("% lf", &val) && val >= 0) 

    { 

        showmenu(); 

        while (scanf("%d", &sel) && sel >= 0 && sel <= 3) 

        { 

            ans = (*pf[sel])(val); 

            printf("answer = %f

void showmenu(void) 

{ 

    puts("Enter one of the following cho ices:"); 

    puts("0) double the value        1) halve the value"); 

    puts("2) trip le the value        3) squareroot the value"); 

    puts("4) nex t number"); 

} 

doub le twice(doub le x) {return 2.0 * x ;} 

doub le half(doub le x) {return x / 2.0;}; 

doub le thr ice(doub le x) {return 3.0 * x ;} 

Chapter 15 

PE 15-1 

/* pe15-1.c */ 

#inc lude <stdio.h> 

#inc lude <stdbool.h>  // C99 -- otherwise use int 

int bstr_to_dec(const char * str); 

bool check_val(const char * str); 

int main(void) 

{ 

    char value[8* sizeof (int) + 1]; 

    printf("Enter a binary number with up to %d dig its: ", 8 * sizeof(int)); 

    wh ile (gets(value) && value[0] != '

    { 

        if (!check_val(value)) 

            puts("A binary number contains just 0s and 1s."); 

        else 

            printf("%s is %d

    } 

    return valid ; 

} 

PE 15-2 

/* pe15-2.c / 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

/* #inc lude <console.h> */    /* Macintosh only */ 

int bstr_to_dec(const char * str); 

char * itobs(int, char *); 

int main( int argc, char * argv[]) 

{ 

    int v1; 

    int v2; 

    char bstr[8* sizeof (int) + 1]; 

    /* argc = ccommand(&argv); */   /* Macintosh only */ 

    if (argc != 3) 

    { 

        fprintf(stderr, "Usage: %s binarynum1 binarynum2

    printf("~%s = %s

} 

PE 15-3 

/* pe15-3.c */ 

#inc lude <stdio.h> 

char * itobs(int, char *); 

int onb its(int); 

int main( int argc, char * argv[]) 

{ 

    int val; 

    char bstr[8* sizeof (int) + 1]; 

    printf("Enter an integer (negative to quit): "); 

    wh ile (scanf("%d", &val) && val >= 0) 

    { 

        printf ("%d (%s) has %d bits on.

    for (i = size - 1; i >= 0; i--, n >>= 1) 

        ps[i] = (01 & n) + '0'; 

    ps[size] = '

    unsigned int p laces; 

    char bstr1[8* sizeof (int) + 1]; 

    char bstr2[8* sizeof (int) + 1]; 

    printf("Enter an integer (0 to quit): "); 

    wh ile (scanf("%ud", &val) && val > 0) 

    { 

        printf("Enter the number of bits to be rotated: 

} 

char * itobs(int n, char * ps) 

{ 

    int i; 

    static int size = 8 * sizeof(int); 

    for (i = size - 1; i >= 0; i--, n >>= 1) 

        ps[i] = (01 & n) + '0'; 

    ps[size] = '

#define SIZE_SHIFT  8 

typedef unsigned lo ng font; 

char do_menu(font * f); 

char get_choice(const char *); 

void show_menu(void); 

void show_font(font f); 

void eatline(void); 

void get_id(font * f); 

void get_size(font * f); 

void get_align(font * f); 

int main(void) 

{ 

    font sample = 1 | (12 <<SIZE_SHIFT) | LEFT | ITALIC; 

    wh ile (do_menu(&sample) != 'q') 

        continue; 

    puts("Bye!"); 

    return 0; 

} 

char do_menu(font * f) 

{ 

    char response; 

    show_font(*f); 

    show_menu(); 

    response = get_choice("fsabiuq"); 

    switch(response) 

    { 

        case 'f' : get_id(f); break; 

        case 's' : get_size(f); break; 

        case 'a' : get_align(f); break; 

        case 'b' : *f ^= BOLD; break; 

        case 'i' : *f ^= ITALIC; break; 

        case 'u' : *f ^= UNDERLINE; break; 

        case 'q' : break; 

        default  : fprintf(stderr, "menu problem

    return ch; 

} 

void eatline(void) 

{ 

    wh ile (getchar() != '

    printf("%8s %3s %3s

    switch (get_choice(" lcr")) 

    { 

        case 'l' : *f &= ~ALIGN_MASK; *f |= LEFT ; break; 

        case 'c' : *f &= ~ALIGN_MASK; *f |= CENT ER; break; 

          case 'r' : *f &= ~ALIGN_MASK; *f |= RIGHT ; break; 

          default  : fprintf(stderr, "alignment problem

} 

PE 16-3 

/* pe16-3.c */ 

#inc lude <stdio.h> 

#inc lude <math.h> 

struct polar { 

    double r; 

    double theta;   /* angle in degrees */ 

}; 

struct rect { 

    double x ; 

    double y; 

}; 

struct rect p_to_r(const struct polar * ppol); 

int main(void) 

{ 

    struct polar input; 

    struct rect answer; 

    wh ile (scanf("% lf % lf", &input.r, &input.theta) == 2) 

    { 

        answer = p_to_r(&input); 

        printf("polar coord: %g %f

        printf("rectangular coord: %g %f

int main() 

{ 

    int lotto[SPOT S]; 

    int i; 

    char ch; 

    for (i = 0; i < SPOT S; i++) 

        lotto[i] = i + 1; 

    do { 

        random_pick( lotto, SPOT S, PICKS); 

        printf ("Again? <y/n> "); 

        ch = getchar(); 

        while (getchar() != '

        picks = arsize; 

    } 

    for (i = 0; i < picks; i++) 

    {  

        index = rand() % (arsize - 1); /* pick a random element     */ 

        temp = ar[index]; 

        printf ("%2d ", temp);         /* display it                */ 

        if (i % 20 == 19) 

            putchar('

    p1 = new_d_array(5, 1.2, 2.3, 3.4, 4.5, 5.6); 

    p2 = new_d_array(4, 100.0, 20.00, 8.08, -1890.0); 

    show_array(p1, 5); 

    show_array(p2, 4); 

    free(p1); 

    free(p2); 

    return 0; 

} 

void show_array(const double ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%g ", ar[i]); 

    putchar('

    return pt; 

} 

Chapter 17 

PE 17-1 

/* pe17-1a.c  recursive solut ion */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>      /* has the malloc prototype      */ 

#inc lude <string.h>      /* has the strcpy prototype      */ 

#define T SIZE    45      /* size of array to hold t it le   */ 

struct film { 

   char tit le[T SIZE]; 

   int rating ; 

   struct film * nex t;   /* points to nex t struct in list */ 

}; 

void show_rec(const struct film * pf); /* recursive function */ 

int main(void) 

{ 

   struct film * head = NULL; 

   struct film * prev , * current; 

   char input[T SIZE]; 

   puts("Enter first mov ie tit le:"); 

   while (gets(input) != NULL && input[0] != '

         head = current; 

      else                      /* subsequent structures */ 

         prev ->nex t = current; 

      current->nex t = NULL; 

      strcpy(current->tit le, input); 

      puts("Enter your rating <0-10>:"); 

      scanf("%d", &current->rating); 

      while(getchar() != '

void show_rec(const struct film * pf) 

{ 

    if (pf->next != NULL) 

        show_rec(pf->nex t); 

    printf("Mov ie: %s  Rating: %d

        current = (struct film *) malloc(sizeof(struct film)); 

        if (head == NULL)         /* first structure       */ 

        {     

            head = current; 

            head->prev = NULL; 

        } 

        else                      /* subsequent structures */ 

        { 

            prev ->nex t = current; 

            current->prev = prev; 

        } 

        current->nex t = NULL; 

        strcpy(current->tit le, input); 

        puts("Enter your rating <0-10>:"); 

        scanf("%d", &current->rating); 

        while(getchar() != '

    } 

    if (head != NULL) 

    { 

        printf("

}; 

/* general type defin it ions */ 

typedef struct film Item; 

typedef struct node 

{ 

   Item item; 

   struct node * nex t; 

} Node; 

#define MAXSIZE 100 

typedef struct list 

{ 

    Item entries[MAXSIZE];    /* array of items */ 

    int items;                /* number of items */ 

} List; 

/* function prototypes */ 

/* operation:        in it ia lize a list                          */ 

/* precondit ions:    plist points to a list                     */ 

/* postcondit io ns:   the list is in it ia lized to empty           */ 

void Init ia lizeL ist(L ist * plist); 

/* operation:        determ ine if list is empty                 */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/* postcondit io ns:   function returns true if list is empty     */ 

/*                   and returns false otherwise                */ 

bool L istIsEmpty(const List * plist); 

/* operation:        determ ine if list is full                  */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/* postcondit io ns:   function returns true if list is full      */ 

/*                   and returns false otherwise                */ 

bool L istIsFull(const L ist * plist); 

/* operation:        determ ine number of items in list          */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/* postcondit io ns:   function returns number of items in list   */ 

unsigned int L istItemCount(const List * plist); 

/* operation:        add item to end of list                    */ 

/* precondit ions:    item is an item to be added to list        */ 

/*                   plist points to an in it ia lized list        */ 

/* postcondit io ns:   if possib le, function adds item to end     */ 

/*                   of list and returns true; otherwise the    */ 

/*                   function returns false                     */ 

bool AddItem(Item item, List * plist); 

/* operation:        apply a function to each item in list      */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/*                   pfun points to a function that takes an    */ 

/*                   Item argument and has no return value      */ 

/* postcondit io n:    the function po inted to by pfun is         */ 

/*                   executed once for each item in the list    */ 

void T raverse (const List * plist, void (* pfun)(Item item) ); 

/* operation:        free allocated memory , if any              */ 

/*                   plist points to an in it ia lized list        */ 

/* postcondit io ns:   any memory allocated for the list is freed */ 

/*                   and the list is set to empty               */ 

void EmptyT heList(List * plist); 

#endif 

/* pe17-3a.c -- a copy of films3.c  */ 

/* compile with pe17-3b.c                        */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>    /* prototype for ex it() */ 

#inc lude "list17-3.h"  /* defines List, Item   */ 

void showmov ies(Item item); 

int main(void) 

{ 

    List mov ies; 

    Item temp; 

/* in it ia lize       */ 

    Init ia lizeL ist(&mov ies); 

    if (ListIsFull(&mov ies)) 

    { 

        fprintf(stderr,"No memory availab le ! Bye!

    puts("Enter first mov ie tit le :"); 

    wh ile (gets(temp.tit le) != NULL && temp.tit le[0] != '

/* clean up         */ 

    EmptyT heList(&mov ies); 

    printf("Bye!

      return true; 

   else 

      return false; 

} 

/* returns true if list is fu ll */ 

bool L istIsFull(const L ist * plist) 

{ 

       if (plist-> items == MAXSIZE) 

           return true; 

       else 

           return false; 

} 

/* returns number of items in list */ 

unsigned int L istItemCount(const List * plist) 

{ 

     return plist-> items; 

} 

/* adds item to list */ 

/* assumes = operator defined for type Item */ 

bool AddItem(Item item, List * plist) 

{ 

    if (plist-> items == MAXSIZE) 

        return false; 

    else 

    { 

        plist->entries[p list-> items++] = item; 

        return true; 

    } 

} 

/* v isit each node and execute function pointed to by pfun */ 

void T raverse (const List * plist, void (* pfun)(Item item) ) 

{ 

   int i; 

   for (i = 0; i < plist-> items; i++) 

      (*pfun)(plist->entr ies[ i]);   /* apply function to item in list */ 

} 

/* malloc() not used, nothing need be deallocated */ 

/* set items member to 0                          */ 

void EmptyT heList(List * plist) 

{ 

      plist-> items = 0; 

} 

PE 17-5 

/* pe17-5.h --header file for a stack type */ 

#ifndef ST ACK_H_ 

#define ST ACK_H_ 

#inc lude <stdbool.h>  /* C99 */ 

/* enum bool {false, true}; */  /* pre-C99*/ 

/* INSERT ITEM TYPE HERE */ 

/* FOR EXAMPLE, typedef int Item; */ 

typedef char  Item; 

#define MAXSTACK 100 

typedef struct stack 

{ 

    Item items[MAXST ACK];   /* holds info                */ 

    int top;                /* index of first empty slot */ 

} Stack; 

/* operation:       in it ia lize the stack                */ 

/* precondit ion:    ps points to a stack                */ 

/* postcondit io n:   stack is in it ia lized to being empty */ 

void Init ia lizeStack(Stack * ps); 

/* operation:       check if stack is full                     */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/* postcondit io n:   returns T rue if stack is full, else False  */ 

bool Fu llStack(const Stack * ps); 

/* operation:       check if stack is empty                    */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/* postcondit io n:   returns T rue if stack is empty, else False */ 

bool EmptyStack(const Stack *ps); 

/* operation:       push item onto top of stack                */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/*                  item is to be placed on top of stack       */ 

/* postcondit io n:   if stack is not empty , item is placed at   */ 

/*                  top of stack and function returns          */ 

/*                  T rue; otherwise, stack is unchanged and    */ 

/*                  function returns False                     */ 

bool Push(Item item, Stack * ps); 

/* operation:       remove item from top of stack              */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/* postcondit io n:   if stack is not empty , item at top of      */ 

/*                  stack is copied to *pitem and deleted from */ 

/*                  stack, and function returns T rue; if the   */ 

/*                  operation empties the stack, the stack is  */ 

/*                  reset to empty. If the stack is empty to   */ 

/*                  begin wit h, stack is unchanged and the     */ 

/*                  function returns False                     */ 

bool Pop(Item *pitem, Stack * ps); 

#endif 

/* pe17-5a.c */ 

#inc lude <stdio.h> 

#inc lude "pe17-5.h" 

#define SLEN 81 

int main(void) 

{ 

    Stack stch; 

    char temp[SLEN]; 

    int i; 

    char ch; 

    Init ia lizeStack(&stch); 

    printf("Enter a line (an empty line to quit): 

    ps->top = 0; 

} 

bool Fu llStack(const Stack * ps) 

{ 

    return ps->top == MAXST ACK; 

} 

bool EmptyStack(const Stack *ps) 

{ 

    return ps->top == 0; 

}     

bool Push(Item item, Stack * ps) 

{ 

    if (ps->top == MAXST ACK) 

        return false; 

    else 

    { 

        ps->items[ps->top++] = item; 

        return true; 

    } 

} 

bool Pop(Item *pitem, Stack * ps) 

{ 

    if (ps->top == 0) 

        return false; 

    else 

    { 

        ps->top--; 

        *pitem = ps->items[ps->top]; 

        return true; 

    } 

} 

PE 17-7 

/* tree.h -- binary search tree */ 

/*           no duplicate items are allowed in th is tree */ 

#ifndef _T REE_H_ 

#define _T REE_H_ 

#inc lude <stdbool.h>  /* C99 */ 

/* enum bool {false, true}; */  /* pre-C99*/ 

#define SLEN 81 

/* redefine Item as appropriate */ 

typedef struct item 

{ 

    char wrd[SLEN];  

    int count;       

} Item; 

#define MAXIT EMS 100 

typedef struct node 

{ 

    Item item; 

    struct node * left;    /* pointer to right branch  */ 

    struct node * right;   /* pointer to left branch   */ 

} Node; 

typedef struct tree 

{ 

    Node * root;           /* pointer to root of tree  */ 

    int size;              /* number of items in tree  */ 

} T ree; 

/* function prototypes */ 

/* operation:      in it ia lize a tree to empty          */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: the tree is in it ia lized to empty    */ 

void Init ia lizeT ree(T ree * ptree); 

/* operation:      determ ine if tree is empty          */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: function returns true if tree is    */ 

/*                 empty and returns false otherwise   */ 

bool T reeIsEmpty(const T ree * ptree); 

/* operation:      determ ine if tree is fu ll           */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: function returns true if tree is    */ 

/*                 full and returns false otherwise    */ 

bool T reeIsFull(const T ree * ptree); 

/* operation:      determ ine number of items in tree   */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: function returns number of items in */ 

/*                 tree                                */ 

int T reeItemCount(const T ree * ptree); 

/* operation:      add an item to a tree               */ 

/* precondit ions:  pi is address of item to be added   */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: if possib le, function adds item to  */ 

/*                 tree and returns true; otherwise,    */ 

/*                 the function returns false          */ 

bool AddItem(const Item * pi, T ree * ptree); 

/* operation:      find an item in a tree              */ 

/* precondit ions:  pi po ints to an item                */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: function returns true if item is in */ 

/*                 tree and returns false otherwise    */ 

bool InT ree(const Item * pi, const Tree * ptree); 

/* operation:      delete an item from a tree          */ 

/* precondit ions:  pi is address of item to be deleted */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: if possib le, function de letes item  */ 

/*                 from tree and returns true;         */ 

/*                 otherwise, the function returns false*/ 

bool De leteItem(const Item * pi, T ree * ptree); 

/* operation:      apply a function to each item in    */ 

/*                 the tree                            */ 

/* precondit ions:  ptree points to a tree              */ 

/*                 pfun points to a function that takes*/ 

/*                 an Item argument and has no return  */ 

/*                 value                               */ 

/* postcondit io n:  the function po inted to by pfun is  */ 

/*                 executed once for each item in tree */ 

void T raverse (const Tree * ptree, void (* pfun)(Item item)); 

/* operation:      delete everything from a tree       */ 

/* precondit ions:  ptree points to an in it ia lized tree */ 

/* postcondit io ns: tree is empty                       */ 

void DeleteA ll(T ree * ptree); 

/* operation:      return address of item in a tree    */ 

/* precondit ions:  pi po ints to an item                */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: function returns address if item is */ 

/*                 in tree and returns NULL otherwise  */ 

const Item * WhereInT ree(const Item * pi, const T ree * ptree); 

#endif 

/* pe17-7a.c */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

#inc lude "pe17-7.h" 

void pr int item(Item item); 

char menu(void); 

void showwords (const T ree * pt); 

void findword (const T ree * pt); 

#define SLEN 81 

int main(void) 

{ 

    T ree wordcount; 

    FILE * fp; 

    char filename[SLEN]; 

    char word[SLEN]; 

    Item entry; 

    char choice; 

    printf ("Enter name of file to be processed: 

    { 

        switch (cho ice) 

        { 

            case 's' :  showwords(&wordcount); 

                        break; 

            case 'f' :  findwo rd(&wordcount); 

                        break; 

            default  :  puts("Switch ing erro r"); 

        } 

    } 

   fclose(fp); 

   puts("Done"); 

   return 0; 

} 

char menu(void) 

{ 

    int ch; 

    puts("Word counting program"); 

    puts("Enter the letter corresponding to your choice:"); 

    puts("s) show word list     f) find a word"); 

    puts("q) quit"); 

    wh ile ((ch = getchar()) != EOF) 

    { 

        while (getchar() != '

            puts("Please enter an s, f, or q:"); 

        else 

            break; 

    } 

    if (ch == EOF)       /* make EOF cause program to quit */ 

        ch = 'q'; 

    return ch; 

} 

void showwords (const T ree * pt) 

{ 

    if (T reeIsEmpty(pt)) 

        puts("No entries!"); 

    else 

        T raverse(pt, print item); 

} 

void findword (const T ree * pt) 

{ 

    char word[SLEN]; 

    Item entry; 

    const Item * pi; 

    if (T reeIsEmpty(pt)) 

    { 

        puts("No entries!"); 

        return;     /* quit function if tree is empty */ 

    } 

    printf("Enter the word to find: "); 

    scanf("%s", word); 

    wh ile (getchar() != '

/* protototypes for local funct ions */ 

static Node * MakeNode(const Item * pi); 

static bool T oLeft(const Item * i1, const Item * i2); 

static bool T oRight(const Item * i1, const Item * i2); 

static void AddNode (Node * new_node, Node * root); 

static void InOrder(const Node * root, void (* pfun)(Item item)); 

static Pair SeekItem(const Item * pi, const T ree * ptree); 

static void DeleteNode(Node **ptr); 

static void DeleteA llNodes(Node * ptr); 

/* function defin it ions */ 

void Init ia lizeT ree(T ree * ptree) 

{ 

    ptree->root = NULL; 

    ptree->size = 0; 

} 

bool T reeIsEmpty(const T ree * ptree) 

{ 

    if (ptree->root == NULL) 

        return true; 

    else 

        return false; 

} 

bool T reeIsFull(const T ree * ptree) 

{ 

    if (ptree->size == MAXIT EMS) 

        return true; 

    else 

        return false; 

} 

int T reeItemCount(const T ree * ptree) 

{ 

    return ptree->size; 

} 

bool AddItem(const Item * pi, T ree * ptree) 

{ 

    Node * new; 

    Pair  seek; 

    if (T reeIsFull(ptree)) 

    { 

        fprintf(stderr,"T ree is full

    ptree->size++; 

    if (ptree->root == NULL)      /* case 1: tree is empty  */ 

        ptree->root = new;        /* new node is tree root  */ 

    else                          /* case 2: not empty      */ 

        AddNode(new,ptree->root); /* add new node to tree   */  

    return true; 

} 

bool InT ree(const Item * pi, const Tree * ptree) 

{ 

    return (SeekItem(pi, ptree).child == NULL) ? false : true; 

} 

const Item * WhereInT ree(const Item * pi, const T ree * ptree) 

{ 

    Node * pn; 

    pn = SeekItem(pi,ptree).child; 

    if (pn != NULL) 

        return &(pn->item); 

    else return NULL; 

} 

bool De leteItem(const Item * pi, T ree * ptree) 

{ 

    Pair look; 

    look = SeekItem(pi, ptree); 

    if (look.ch ild == NULL) 

        return false; 

    if (look.ch ild -> item.count > 0) 

            look.child-> item.count--; 

    else 

    {            

        if (look.parent == NULL)      /* delete root item       */ 

            DeleteNode(&ptree->root); 

        else if (look.parent-> left == look.child) 

            DeleteNode(&look.parent->left); 

        else 

            DeleteNode(&look.parent->right); 

        ptree->size--; 

    } 

    return true; 

} 

void T raverse (const Tree * ptree, void (* pfun)(Item item)) 

{ 

    if (ptree != NULL) 

        InOrder(ptree->root, pfun); 

} 

void DeleteA ll(T ree * ptree) 

{ 

    if (ptree != NULL) 

        DeleteAllNodes(ptree->root); 

    ptree->root = NULL; 

    ptree->size = 0; 

} 

/* local funct ions */ 

static void InOrder(const Node * root, void (* pfun)(Item item)) 

{ 

    if (root != NULL) 

    { 

        InOrder(root->left, pfun); 

        (*pfun)(root->item); 

        InOrder(root->right, pfun); 

    } 

} 

static void DeleteA llNodes(Node * root) 

{ 

    Node * pright; 

    if (root != NULL) 

    { 

        pright = root->right; 

        DeleteAllNodes(root-> left); 

        free(root); 

        DeleteAllNodes(pr ight); 

    } 

} 

static void AddNode (Node * new_node, Node * root) 

{ 

    if (T oLeft(&new_node->item, &root->item)) 

    { 

        if (root->left == NULL)      /* empty subtree       */ 

            root->left = new_node;   /* so add node here    */ 

        else 

            AddNode(new_node, root->left);/* else process subtree*/ 

    } 

    else if (T oRight(&new_node-> item, &root->item)) 

    { 

        if (root->right == NULL) 

            root->right = new_node; 

        else 

            AddNode(new_node, root->right); 

    } 

    else                         /* should be no duplicates */ 

    { 

        fprintf(stderr,"locat ion error in AddNode()

        return false; 

} 

static Node * MakeNode(const Item * pi) 

{ 

    Node * new_node; 

    new_node = (Node *) malloc(sizeof(Node)); 

    if (new_node != NULL) 

    { 

        new_node->item = *pi; 

        new_node->item.count = 1; 

        new_node->left = NULL; 

        new_node->right = NULL; 

    } 

    return new_node; 

} 

static Pair SeekItem(const Item * pi, const T ree * ptree) 

{ 

    Pair look; 

    look.parent = NULL; 

    look.ch ild = ptree->root; 

    if (look.ch ild == NULL) 

        return look;                        /* early return   */ 

    wh ile (loo k.child != NULL) 

    { 

        if (ToLeft(pi, &(look.child -> item))) 

        { 

            look.parent = look.child; 

            look.child = look.ch ild -> left; 

        } 

        else if (T oRight(p i, &(look.ch ild -> item))) 

        { 

            look.parent = look.child; 

            look.child = look.ch ild ->r ight ; 

        } 

        else       /* must be same if not to left or right    */ 

            break; /* look.child is address of node with item */ 

    } 

    return look;                       /* successful return   */ 

} 

static void DeleteNode(Node **ptr) 

/* ptr is address of parent member point ing to target node  */ 

{ 

    Node * temp; 

    if ( (*ptr)->left == NULL) 

    { 

        temp = *ptr; 

        *ptr = (*ptr)->right; 

        free(temp); 

    } 

    else if ( (*ptr) ->right == NULL) 

    { 

        temp = *ptr; 

        *ptr = (*ptr)->left; 

        free(temp); 

    } 

    else    /* deleted node has two children */ 

    { 

        /* find where to reattach right subtree */ 

        for (temp = (*ptr) ->left; temp->right != NULL; 

                temp = temp->right) 

            continue; 

        temp->right = (*ptr)->right; 

        temp = *ptr; 

        *ptr =(*ptr)->left; 

        free(temp); 

    } 

} 

Answers For Programm ing Exercises in C Pr imer Plus, 5rd Edit ion, by Stephen Prata 

sp    Page 88 of 187    August 21, 1999 

Chapter 2 

PE 2-1 

/* Programm ing Exercise 2-1  */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    printf("Anton Bruckner

    printf("Anton "); 

    printf("Bruckner

void deny(void); 

int main(void) 

{ 

    jolly(); 

    jolly(); 

    jolly(); 

    deny(); 

    return 0; 

} 

void jo lly(void) 

{ 

    printf("For he's a jolly good fellow!

    toes = 10; 

    printf("toes = %d

    printf("three

int main(void) 

{ 

    float num; 

    printf("Enter a float ing-po int value: "); 

    scanf("%f", &num); 

    printf("fixed-po int notat ion: %f

} 

Chapter 4 

PE 4-1 

/* Programm ing Exercise 4-1  */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    char fname[40]; 

    char lname[40]; 

    printf("Enter your first name: "); 

    scanf("%s", fname); 

    printf("Enter your last name: "); 

    scanf("%s", lname); 

    printf("%s, %s

    char name[40]; 

    printf("Enter your height in inches: "); 

    scanf("%f", &height); 

    printf("Enter your name: "); 

    scanf("%s", name); 

    printf("%s, you are %.3f feet tall

Chapter 5 

PE 5-1 

/* Programm ing Exercise 5-1 */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    const int m inperho ur = 60; 

    int m inutes, hours, m ins; 

    printf("Enter the number of m inutes to convert: "); 

    scanf("%d", &m inutes); 

    wh ile (m inutes > 0 ) 

    { 

        hours = m inutes / m inperhour; 

        m ins = m inutes % m inperhour; 

        printf("%d m inutes = %d hours, %d m inutes

/* Programm ing Exercise 5-3 */ 

#inc lude <stdio.h> 

int main(void) 

{ 

    const int daysperweek = 7; 

    int days, weeks, day_rem; 

    printf("Enter the number of days: "); 

    scanf("%d", &days); 

    weeks = days / daysperweek; 

    day_rem = days % daysperweek; 

    printf("%d days are %d weeks and %d days.

  sum = 0;                   

  wh ile (count++ < n) 

     sum = sum + count;  

  printf("sum = %d

/* pe6-1.c */ 

/* this imp lementation assumes the character codes */ 

/* are sequential, as they are in ASCII.           */ 

#inc lude <stdio.h> 

#define SIZE 26 

int main( void ) 

{ 

    char lcase[SIZE]; 

    int i; 

    for (i = 0; i < SIZE; i++) 

        lcase[i] = 'a' + i; 

    for (i = 0; i < SIZE; i++) 

        printf("%c", lcase[i]); 

    printf("

    char let = 'F'; 

    char start; 

    char end; 

    for (end = let; end >= 'A'; end--) 

    { 

        for (start = let; start >= end; start --) 

            printf("%c", start); 

        printf("

    printf("%5s %10s %15s

    return 0; 

} 

PE 6-10 

/* pe6-10.c */ 

#inc lude <stdio.h> 

#define SIZE 8 

int main( void ) 

{ 

    int vals[SIZE]; 

    int i;     

    printf("P lease enter %d integers.

#inc lude <stdio.h> 

#define SIZE 8 

int main( void ) 

{ 

    int twopows[SIZE]; 

    int i; 

    int value = 1;    /* 2 to the 0 */ 

    for (i = 0; i < SIZE; i++) 

    { 

        twopows[i] = value; 

        value *= 2; 

    } 

    i = 0; 

    do 

    { 

        printf("%d ", twopows[i]); 

        i++; 

    } while ( i < SIZE); 

    printf("

/* Programm ing Exercise 6-13 */ 

#inc lude <stdio.h> 

#define SIZE 8 

int main(void) 

{ 

    double arr[SIZE]; 

    double arr_cumul[SIZE]; 

    int i; 

    printf("Enter %d numbers:

    return 0; 

} 

PE 6-15 

/* pe6-15.c */ 

#inc lude <stdio.h> 

#define RAT E_SIMP 0.10 

#define RAT E_COMP 0.05 

#define INIT_AMT 100.0 

int main( void ) 

{ 

    double daphne = INIT _AMT; 

    double de idre = INIT _AMT ; 

    int years = 0; 

    wh ile (deid re <= daphne) 

    { 

        daphne += RAT E_SIMP * INIT_AMT; 

        deidre += RAT E_COMP * deidre; 

        ++years; 

    } 

    printf("Investment values after %d years:

} 

Chapter 7 

PE 7-1 

/* Programm ing Exercise 7-1 */ 

#inc lude <stdio.h> 

int main(void)     

{ 

     char ch; 

     int sp_ct = 0; 

     int nl_ct = 0; 

     int other = 0; 

     while ((ch = getchar()) != '#') 

     { 

         if (ch == ' ') 

             sp_ct++; 

         else if (ch == '

/* Programm ing Exercise 7-3 */ 

#inc lude <stdio.h> 

int main(void)     

{ 

     int n; 

     double sumeven = 0.0; 

     int ct_even = 0; 

     double sumodd = 0.0; 

     int ct_odd = 0; 

     while (scanf("%d", &n) == 1 && n != 0) 

     { 

         if (n % 2 == 1) 

         { 

             sumodd += n; 

             ++ct_odd; 

         } 

         else 

         { 

             sumeven += n; 

             ++ct_even; 

         } 

     } 

     printf("Number of evens: %d", ct_even); 

     if (ct_even > 0) 

         printf("  average: %g", sumeven / ct_even); 

     putchar('

    printf("Number of odds: %d", ct_odd); 

     if (ct_odd > 0) 

         printf("  average: %g", sumodd / ct_odd); 

     putchar('

                             ++ct2; 

                             break; 

             default    :    putchar(ch); 

         } 

     } 

     printf("%d replacements of . wit h !

    printf("Enter the number of hours worked this week: "); 

    scanf("% lf", &hours); 

    if (hours <= BASEHRS) 

        gross = hours * BASEPAY ; 

    else 

        gross = BASEHRS * BASEPAY + (hours - BASEHRS) * BASEPAY * OVERTIME; 

    if (gross <= AMT1) 

        taxes = gross * RAT E1; 

    else if (gross <= AMT1 + AMT 2) 

        taxes = AMT1 * RAT E1 + (gross - AMT1) * RAT E2; 

    else 

        taxes = AMT1 * RAT E1 + AMT 2 * RAT E2 + (gross - AMT 1 - AMT 2) * RAT E3; 

    net = gross - taxes; 

    printf("gross: $%.2f; taxes: $%.2f; net: $%.2f

   int pr ime; 

   printf("Please enter lim it to values to be checked; "); 

   printf("Enter q to quit.

  const double pr ice_carrots = 0.89; 

  const double DISCOUNT _RAT E = 0.05; 

  char ch; 

  double lb_art ichokes; 

  double lb_beets; 

  double lb_carrots; 

  double lb_tota l; 

  double cost_artichokes; 

  double cost_beets; 

  double cost_carrots; 

  double cost_total; 

  double fina l_tota l; 

  double d iscount; 

  double shipp ing; 

  printf("Enter a to buy artichokes, b for beets, "); 

  printf("c for carrots, q to quit: "); 

  wh ile ((ch = getchar()) != 'q' && ch != 'Q ') 

  { 

      if (ch == '

                   break; 

           case 'b' : printf("Enter pounds of beets: "); 

                   scanf("% lf", &lb_beets); 

                   break; 

           case 'c' : printf("Enter pounds of carrots: "); 

                   scanf("% lf", &lb_carrots); 

                   break; 

        default  : printf("%c is not a valid cho ice.

    discount = 0.0; 

  final_tota l = cost_total + shipp ing - d iscount; 

  printf("Y our order:

    wh ile ((ch = getchar()) != EOF) 

        ct++; 

    printf("%d characters read

/* 

 or you could use 

 if (ch >= 'A' && ch <= 'Z') 

     uct++; 

 else if (ch >= 'a' && ch <= 'z ') 

     lct++; 

*/ 

PE 8-5 

/* Programm ing Exercise 8-5 */ 

/* binaryguess.c -- an improved number-guesser */ 

#inc lude <stdio.h> 

#inc lude <ctype.h> 

int main(void) 

{ 

  int h igh = 100; 

  int low = 1; 

  int guess = (high + low) / 2; 

  char response; 

  printf("P ick an integer from 1 to 100. I will try to guess "); 

  printf(" it.

      { 

           printf("I don't understand that response. Please enter h for

#define AMT 2        150     /* 2st rate tier        */ 

#define RAT E1       0.15    /* rate for 1st tier    */ 

#define RAT E2       0.20    /* rate for 2nd tier    */ 

#define RAT E3       0.25    /* rate for 3rd tier    */ 

int getfirst(void);  

void menu(void); 

int main(void)     

{ 

    double hours; 

    double gross; 

    double net; 

    double taxes; 

    double pay; 

    char response; 

    menu(); 

    wh ile ((response = getfirst()) != 'q') 

    { 

        if (response == '

            default   :  printf("Please enter a, b, c, d, or q.

           "*********

doub le m in(doub le a, double b); 

int main(void)     

{ 

    double x , y; 

    printf("Enter two numbers (q to quit): "); 

    wh ile (scanf("% lf % lf", &x, &y) == 2) 

    { 

        printf("T he smaller number is %f.

PE 9-3 

/* Programm ing Exercise 9-3 */ 

#inc lude <stdio.h> 

void chL ineRow(char ch, int c, int r); 

int main(void)     

{ 

    char ch; 

    int col, row; 

    printf("Enter a character (# to quit): "); 

    wh ile ( (ch = getchar()) != '#') 

    { 

        if (ch == '

    int col, row; 

    for (row = 0; row < r ; row++) 

    { 

        for (col = 0; col < c; col++) 

            putchar(ch); 

        putchar('

    return 0; 

} 

void larger_of(doub le *p1, double *p2) 

{ 

    double temp = *p1 > *p2 ? *p1 : *p2; 

    *p1= *p2 = temp; 

} 

PE 9-7 

/* Programm ing Exercise 9-7 */ 

#inc lude <stdio.h> 

doub le power(doub le a, int b);  /* ANSI prototype */ 

int main(void) 

{ 

  double x , xpow; 

  int n; 

  printf("Enter a number and the integer power"); 

  printf(" to wh ich

} 

doub le power(doub le a, int b)   /* function defin it ion     */ 

{ 

  double pow = 1; 

  int i; 

  if (b == 0) 

  { 

      if (a == 0) 

          printf("0 to the 0 undefined; using 1 as the value

int main(void) 

{ 

  int number; 

  int b; 

  printf("Enter an integer (q to quit):

PE 10-1 

/* Programm ing Exercise 10-1 */ 

#inc lude <stdio.h> 

#define MONTHS 12    /* number of months in a year */ 

#define Y RS   5      /* number of years of data    */ 

int main(void) 

{ 

 /* in it ia liz ing rainfall data for 1990 - 1994 */ 

 const float rain[Y RS][MONT HS] = { 

 {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4}, 

 {9.2, 9.8, 4.4, 3.3, 2.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 5.2}, 

 {6.6, 5.5, 3.8, 2.8, 1.6, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 4.2}, 

 {4.3, 4.3, 4.3, 3.0, 2.0, 1.0, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6}, 

 {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.2} 

 }; 

 int year, month; 

 float subtot, total; 

 printf(" Y EAR    RAINFALL  (inches)

 printf(" Nov  Dec

    return 0; 

} 

int max_arr(const int ar[], int n) 

{ 

    int i; 

    int max = ar[0]; 

/* don't use 0 as init ia l max value -- fails if all array values are neg */ 

    for (i = 1; i < n; i++) 

        if (max < ar[i]) 

            max = ar[i]; 

    return max ; 

} 

void show_arr(const int ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%d ", ar[i]); 

    putchar('

float max_diff(const float ar[], int n); 

void show_arr(const float ar[], int n); 

int main(void) 

{ 

    float orig[LEN] = {1.1,2,3,4,12,6,7,8,9,10}; 

    float max ; 

    show_arr(orig, LEN); 

    max = max_diff(orig, LEN); 

    printf("%g = max imum difference

} 

void show_arr(const float ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%g ", ar[i]); 

    putchar('

    return 0; 

} 

void copy_arr(int ar1[], const int ar2[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        ar1[i] = ar2[i]; 

} 

void show_arr(const int ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%d ", ar[i]); 

    putchar('

int main(void) 

{ 

    int stuff[ROWS][COLS] = {    {1,2,3,4,5}, 

                                {6,7,8,9,10}, 

                                {11,12,13,14,15} 

                            }; 

    showarr2(stuff, ROWS); 

    putchar('

    { 

        for (col = 0; col < COLS; col++) 

            printf("%d ", ar[row][col]); 

        putchar('

    printf("array contents:

        for (c = 0; c < cols; c++) 

            sum += ar[r][c]; 

    if (rows * cols > 0) 

        return sum / (rows * cols); 

    else 

        return 0.0; 

} 

doub le max2d(int rows, int co ls, double ar[rows][cols]) 

{ 

    int r, c; 

    double max = ar[0][0]; 

    for (r = 0; r < rows; r++) 

        for (c = 0; c < cols; c++) 

            if (max < ar[r][c]) 

                max = ar[r][c]; 

    return max ; 

} 

void showarr2( int rows, int co ls, double ar[rows][cols]) 

{ 

    int row, col; 

    for (row = 0; row < rows; row++) 

    { 

        for (col = 0; col < cols; col++) 

            printf("%g ", ar[row][col]); 

        putchar('

    } 

} 

doub le average(const double ar[], int n) 

{ 

    int i; 

    double sum = 0.0; 

    for (i = 0; i < n; i++) 

        sum += ar[i]; 

    if (n > 0) 

        return sum / n; 

    else 

        return 0.0; 

} 

Chapter 11 

PE 11-1 

/* Programm ing Exercise 11-1 */ 

#inc lude <stdio.h> 

#define LEN 10 

char * getnchar(char * str, int n); 

int main(void) 

{ 

    char input[LEN]; 

    char *chk; 

    chk = getnchar(input, LEN - 1); 

    if (chk == NULL) 

        puts("Input failed."); 

    else 

        puts(input); 

    puts("Done.

PE 11-3 

/* Programm ing Exercise 11-3 */ 

#inc lude <stdio.h> 

#define LEN 80 

char * getword(char * str); 

int main(void) 

{ 

    char input[LEN]; 

    char *chk; 

    wh ile (getword( input) != NULL) 

        puts(input); 

    puts("Done.

    else 

    { 

        while (ch != '

        else 

            printf("%c found in str ing %s

        puts(find); 

    else 

        puts("Not found"); 

    find = string_ in(or ig, "part"); 

    if (find) 

        puts(find); 

    else 

        puts("Not found"); 

    return 0; 

} 

#inc lude <string.h> 

char * string_ in(const char * s1, const char * s2) 

{ 

    int l2 = strlen(s2); 

    int tr ies;            /* max imum number of comparisons    */ 

    int nomatch = 1;    /* set to 0 if match is found        */ 

    tries = strlen(s1) + 1 - l2; 

    if (tries > 0) 

        while (( nomatch = strncmp(s1, s2, l2)) && tries --) 

            s1++; 

    if (nomatch) 

        return NULL; 

    else 

        return (char *) s1;  /* cast const away */ 

} 

PE 11-9 

/* Programm ing Exercise 11-9 */ 

#inc lude <stdio.h> 

#define LEN 81 

int drop_space(char * s); 

int main(void) 

{ 

    char orig[LEN]; 

    wh ile (gets(orig) && orig[0] != '

                pos++; 

            } while (*pos); 

        } 

        else 

            s++; 

    } 

} 

PE 11-11 

/* pe11-11.c -- counts words and certain characters */ 

/* Programm ing Exercise 11-11                       */ 

#inc lude <stdio.h> 

#inc lude <ctype.h>       // for isspace()   

#inc lude <stdbool.h>     // for bool, true, false           

int main(void) 

{ 

   char c;               // read in character  

   int low_ct = 0;       // number of lowercase characters      

   int up_ct = 0;        // number of uppercase characters      

   int dig_ct = 0;       // number of dig its           

   int n_words = 0;      // number of words  

   int punc_ct = 0;      // number of punctuation marks         

   bool inword = false;  // == true if c is in a word   

   printf("Enter tex t to be analyzed (EOF to term inate):

           low_ct++; 

        else if (isupper(c)) 

           up_ct++; 

        else if (isd ig it(c)) 

           dig_ct++; 

        else if (ispunct(c)) 

           punc_ct++; 

      if (!isspace(c) && !inword) 

      { 

         inword = true;  // starting a new wo rd  

         n_words++;      // count word           

      } 

      if (isspace(c) && inword) 

         inword = false; // reached end of word 

   } 

   printf("

    double num, exp; 

    /* argc = ccommand(&argv); */  /* Macintosh adjustment */   

    if (argc != 3) 

        printf("Usage: %s number exponent

    if (argc > 2) 

    { 

        printf("Usage: %s [-p | -u | -l]

                             break; 

                case 'u'  :  putchar(toupper(ch)); 

                             break; 

                case 'l'  :  putchar(tolower(ch)); 

            } 

        } 

    return 0; 

} 

Chapter 12 

PE 12-1 

/* pe12-1.c  -- deglobaliz ing g loba l.c */ 

/* Programm ing Exercise 12-1           */ 

/* one of several approaches */ 

#inc lude <stdio.h> 

void cr it ic( int * u); 

int main(void) 

{ 

   int un its;   /* units now loca l */ 

   printf("How many pounds to a firk in of butter?

void cr it ic( int * u) 

{ 

   printf("No luck, chummy. T ry again.

void check_mode(int *pm); 

void get_info(int mode, double * pd, double * pf); 

void show_ info( int mode, double distance, double fuel); 

// pe12-3a.c 

#inc lude <stdio.h> 

#inc lude "pe12-3a.h" 

void check_mode(int *pm) 

{ 

    if (*pm != MET RIC && *pm != US) 

    { 

        printf("Invalid mode specified. Mode %d

    else 

        printf("Enter fuel consumed  in gallons: "); 

    scanf("% lf", pf); 

} 

void show_ info( int mode, double distance, double fuel) 

{ 

    printf("Fuel consumption is "); 

    if (mode == METRIC) 

        printf("%.2f liters per 100 km.

        prev_mode = mode; 

      get_info(mode, &distance, &fuel); 

      show_info(mode, distance, fuel); 

        printf("Enter 0 for metric mode, 1 for US mode"); 

        printf(" (-1 to quit): "); 

      scanf("%d", &mode); 

  } 

  printf("Done.

    print(arr,SIZE); 

    sort(arr,SIZE); 

    puts("

      printf("%2d ", array[index]); 

      if (index % 10 == 9) 

         putchar('

                sides); 

        for (set = 0; set < sets; set++) 

        { 

            for (roll = 0, count = 0; count < dice; count++) 

                roll += rollem(sides); 

                /* running total of d ice pips */ 

            printf("%4d ", roll); 

            if (set % 15 == 14) 

                putchar('

/* Programm ing Exercise 13-2 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

//#inc lude <console.h>    /* Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    int by te; 

    FILE * source; 

    FILE * target; 

//    argc = ccommand(&argv);   /* Macintosh adjustment */ 

    if (argc != 3) 

    { 

        printf("Usage: %s sourcefile targetfile

    } 

    wh ile ((by te = getc(source)) != EOF) 

    { 

        putc(by te, target); 

    } 

    if (fclose(source) != 0) 

        printf("Could not close file %s

    { 

        printf("Usage: %s filename[s]

//#inc lude <console.h>    /* Macintosh adjustment */ 

#define BUFSIZE 1024 

#define SLEN 81 

void append(FILE *source, FILE *dest); 

int main( int argc, char *argv[]) 

{ 

    FILE *fa, *fs; 

    int files = 0; 

    int fct; 

 //   argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc < 3) 

    { 

        printf("Usage: %s appendfile sourcefile[s]

    for (fct = 2; fct < argc; fct++) 

    { 

        if (strcmp(argv[fct], argv[1]) == 0) 

            fputs("Can't append file to itse lf

} 

void append(FILE *source, FILE *dest) 

{ 

    size_t by tes; 

    static char temp[BUFSIZE]; // allocate once 

    wh ile ((by tes = fread(temp,sizeof(char),BUFSIZE,source)) > 0) 

        fwr ite(temp, sizeof (char), by tes, dest); 

} 

PE 13-7 

/* Programm ing Exercise 13-7a */ 

/* code assumes that end-of-line immediately precedes end-of-file */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <console.h>    /* Macintosh adjustment */ 

int main( int argc, char *argv[]) 

{ 

    int ch1, ch2; 

    FILE * f1; 

    FILE * f2; 

    argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc != 3) 

    { 

        printf("Usage: %s file1 file2

            putchar(ch2); 

            ch2 = getc(f2); 

        } 

        if (ch2 != EOF) 

        { 

            putchar('

    FILE * f2; 

    argc = ccommand(&argv);   /* Macintosh adjustment */   

    if (argc != 3) 

    { 

        printf("Usage: %s file1 file2

        { 

            if (ch2 == EOF) 

                putchar('

/* Programm ing Exercise 13-9 */ 

/* to simplify accounting, store one number and word per line */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define MAX 40 

int main(void) 

{ 

     FILE *fp; 

     char words[MAX]; 

     int wordct = 0; 

     if ((fp = fopen("wordy", "a+")) == NULL) 

     { 

          fprintf(stderr,"Can't open 

     while (fgets(words, MAX - 1, fp) != NULL) 

          fputs(words, stdout); 

     if (fclose(fp) != 0) 

          fprintf(stderr,"Error closing file

    } 

    if ((fp = fopen(argv[2], "r")) == NULL) 

    { 

        fprintf(stderr, errmesg[1], argv[2]); 

        ex it(EXIT_FAILURE); 

    } 

    wh ile (fgets(line, SLEN - 1, fp) != NULL) 

    { 

        if (strstr(line, argv[1]) != NULL) 

            fputs(line, stdout); 

    } 

    fclose(fp); 

    return 0; 

} 

PE 13-12 

Data for program: 

0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 2 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 5 2 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 1 9 8 5 4 5 2 0 0 0 0 0 0 0 0 0 

0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 0 4 5 2 0 0 0 0 0 0 0 0 

0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 4 5 2 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 1 8 5 0 0 0 4 5 2 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 4 5 2 0 0 0 0 0 

5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 

8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 

9 9 9 9 0 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 3 9 9 9 9 9 9 9 

8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 

5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 

0 0 0 0 2 2 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 

0 0 0 0 3 3 0 0 0 0 0 0 5 8 9 9 8 5 0 5 6 1 1 1 1 6 5 0 0 0 

0 0 0 0 4 4 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 

0 0 0 0 5 5 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 

/* Programm ing Exercise 13-12 */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#define ROWS    20 

#define COLS    30 

#define LEVELS    10 

const char trans[LEVELS + 1] = " . ':~*=&%@"; 

void MakePic( int data[][COLS], char pic[][COLS], int rows); 

void in it(char arr[][COLS], char ch); 

int main() 

{ 

    int row, col; 

    int p icIn[ROWS][COLS]; 

    char picOut[ROWS][COLS]; 

    char fileName[40]; 

    FILE * inf ile; 

    in it(p icOut, 'S'); 

    printf("Enter name of file: "); 

    scanf("%s", fileName); 

    if ((inf ile = fopen(fileName, "r")) == NULL) 

    { 

        fprintf(stderr, "Could not open data file.

} 

void in it(char arr[][COLS], char ch) 

{ 

    int r, c; 

    for (r = 0; r < ROWS; r++) 

        for (c = 0; c < COLS; c++) 

            arr[r][c] = ch; 

} 

void MakePic( int data[][COLS], char pic[][COLS], int rows) 

{ 

    int row, col; 

    for (row = 0; row < rows; row++) 

        for (col = 0; col < COLS; col++) 

            pic[row][col] = trans[data[row][col]]; 

} 

Chapter 14 

PE 14-1 

/* pe14-1.c  */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

struct month { 

    char name[10]; 

    char abbrev[4]; 

    int days; 

    int monumb; 

}; 

const struct month months[12] = { 

    {"January", "Jan", 31, 1}, 

    {"February", "Feb", 28, 2}, 

    {"March", "Mar", 31, 3}, 

    {"April", "Apr", 30, 4}, 

    {"May", "May", 31, 5}, 

    {"June", "Jun", 30, 6}, 

    {"July", "Jul", 31, 7}, 

    {"August", "Aug", 31, 8}, 

    {"September", "Sep", 30, 9}, 

    {"October", "Oct", 31, 10}, 

    {"November", "Nov", 30, 11}, 

    {"December", "Dec", 31, 12} 

}; 

int days(char * m); 

int main(void) 

{ 

    char input[20]; 

    int day total; 

    printf("Enter the name of a month: "); 

    wh ile (gets(input) != NULL && input[0] != '

            printf("T here are %d days through %s.

        else 

            for (i = 0; i < mon_num; i++) 

                total +=months[i].days; 

    } 

    return total; 

} 

PE 14-3 

/* pe14-3.c */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define MAXTIT L   40 

#define MAXAUT L   40 

#define MAXBKS   100            /* max imum number of books  */ 

struct book {                   /* set up book template     */ 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

}; 

void sortt(struct book * pb[], int n); 

void sortv(struct book * pb[], int n); 

int main(void) 

{ 

     struct book library[MAXBKS]; /* array of book structures */ 

     struct book * pbk[MAXBKS];   /* pointers for sorting     */ 

     int count = 0; 

     int index ; 

     printf("Please enter the book tit le.

         printf("%s by %s: $%.2f

                 temp = pb[search]; 

                 pb[search] = pb[top]; 

                 pb[top] = temp; 

            } 

} 

PE 14-5 

    /* pe14-5.c */ 

#inc lude <stdio.h> 

#inc lude <string.h> 

#define LEN 14 

#define CSIZE 4 

#define SCORES 3 

struct name { 

    char first[LEN]; 

    char last[LEN]; 

}; 

struct student { 

    struct name person; 

    float scores[SCORES]; 

    float mean; 

}; 

void get_scores(struct student ar[], int lim); 

void find_means(struct student ar[], int lim); 

void show_c lass(const struct student ar[], int lim); 

void show_ave(const struct student ar[], int lim);  

int main(void) 

{ 

    struct student class[CSIZE] ={ 

        { "Flip", "Snide"}, 

        { "Clare", "Voyans"}, 

        { "Bingo", "Higgs"}, 

        { "Fawn", "Hunter"} 

    }; 

    get_scores(class, CSIZE); 

    find_means(class, CSIZE); 

    show_class(class, CSIZE); 

    show_ave(class, CSIZE); 

    return 0; 

} 

void get_scores(struct student ar[], int lim) 

{ 

    int i, j; 

    for (i = 0; i < lim; i++) 

    { 

        printf ("Please enter %d scores for %s %s:

} 

void find_means(struct student ar[], int lim) 

{ 

    int i, j; 

    float sum; 

    for (i = 0; i < lim; i++) 

    { 

        for (sum = 0, j = 0; j < SCORES; j++) 

            sum += ar[i].scores[j]; 

        ar[i].mean = sum / SCORES; 

    } 

} 

void show_c lass(const struct student ar[], int lim) 

{ 

    int i, j; 

    char wholename[2*LEN]; 

    for (i = 0; i < lim; i++) 

    { 

        strcpy(who lename, ar[i].person.first); 

         strcat(wholename, " "); 

         strcat(wholename, ar[i].person. last); 

          printf("%27s: ", who lename); 

          for (j = 0; j < SCORES; j++) 

            printf("%6.1f ", ar[i].scores[j]); 

        printf(" Average = %5.2f

} 

void show_ave (const struct student ar[], int lim) 

{ 

    int i, j; 

    float total; 

    printf("

struct book {                  /* set up book template    */ 

    char title[MAXTIT L]; 

    char author[MAXAUT L]; 

    float value; 

    int de lete; 

}; 

int getlet(const char * s); 

int getbook(struct book * pb); 

void update(struct book * item); 

int main(void) 

{ 

     struct book library[MAXBKS]; /* array of structures     */ 

     int count = 0; 

     int deleted = 0; 

     int index , filecount, open; 

     FILE * pbooks; 

     int size = sizeof (struct book); 

     if ((pbooks = fopen("book.dat", "r")) != NULL) 

     { 

         wh ile (count < MAXBKS &&  fread(&lib rary[count], size, 

                     1, pbooks) == 1) 

         { 

             if (count == 0) 

                 puts("Current contents of book.dat:"); 

             printf("%s by %s: $%.2f

             if (getlet("yn") == 'y ') 

             { 

                 printf("Enter c to change, d to delete entry: "); 

                 if (getlet("cd") == 'd') 

                 { 

                     library[count].delete = YES; 

                     deleted++; 

                     puts("Entry marked for delet ion."); 

                 } 

                 else 

                     update(&lib rary[count]); 

             } 

             count++; 

         } 

         fclose(pbooks); 

     } 

     filecount = count - deleted; 

     if (count == MAXBKS) 

     { 

         fputs("T he book.dat file is fu ll.", stderr); 

         ex it(2); 

     } 

     puts("Please add new book tit les."); 

     puts("Press [enter] at the start of a line to stop."); 

     open = 0; 

     while (f ilecount < MAXBKS) 

     { 

        if (filecount < count) 

        { 

            while (library[open].delete == NO) 

                open++; 

            if (getbook(&library[open]) == DONE) 

                break; 

        } 

        else if (getbook(&lib rary[filecount]) == DONE) 

            break; 

        filecount++; 

        if (filecount < MAXBKS) 

            puts("Enter the nex t book tit le.");     

     } 

     puts("Here is the list of your books:"); 

     for (index = 0; index < filecount; index++) 

         if (lib rary[index].delete == NO) 

            printf("%s by %s: $%.2f

{ 

    char c; 

    c = getchar(); 

    wh ile (strchr(s, c) == NULL) 

    { 

        printf ("Enter a character in the list %s

            scanf("%*s"); 

        } 

        while (getchar() != '

                       wh ile (scanf("%f", &copy.value) != 1) 

                       { 

                           puts ("Enter a numeric value: "); 

                           scanf("%*s"); 

                       } 

                       wh ile( getchar() != '

void show_empties(const struct planestats [], int); 

void list_assign(struct planestats *[], int); 

void assign_seat(struct planestats [], int); 

void de lete_seat(struct planestats [], int); 

void show_seats(const struct planestats [], int); 

void sort(struct planestats *[], int); 

void makelist(const struct planestats [], char *, int); 

int main(void) 

{ 

    struct planestats plane_1[SEAT S], *ps[SEAT S]; 

    int cho ice; 

    int i; 

    FILE *fp; 

    size_t size = sizeof(struct planestats); 

    for ( i = 0; i < SEAT S; i++) 

        ps[i] = &plane_1[i]; 

    if ((fp = fopen("air.dat", "rb")) == NULL ) 

        for (i = 0; i < SEAT S; i++) 

        { 

            plane_1[i].status = EMPTY ; 

            plane_1[i].seat_id = i + 1; 

        } 

    else 

    { 

        fread(plane_1, size, SEAT S, fp); 

        fclose(fp); 

    } 

    wh ile ( (choice = getmenu() ) != 'q') 

    { 

        switch (cho ice) 

        { 

            case 'o' :  printf ("T here are %d empty seats.

int getmenu(void) 

{ 

    const char *descript[CHOICES] = { 

        "Show number of empty seats", 

        "Show list of empty seats", 

        "Show alphabet ical list of seat assignments", 

        "Assign a customer to a seat", 

        "Delete a seat assignment", 

        "Quit" 

    }; 

    const char labels[CHOICES + 1] = "oeladq"; 

    int i; 

    puts("To choose a function, enter its letter labe l"); 

    for (i = 0; i < CHOICES; i++) 

        printf("%c) %s

    } 

    wh ile (getchar() != '

    } 

} 

void makelist(const struct planestats pl[], char * str, int k ind) 

{ 

    int seat; 

    char temp[LEN]; 

    str[0] = '

} 

void assign_seat(struct planestats pl[], int n) 

{ 

    char list[3    * SEAT S]; 

    int seat, loop; 

    if (openings(p l,n) == 0) 

        puts("All seats are assigned."); 

    else 

    { 

        makelist(p l, list, EMPTY); 

        puts("Which seat do you want? Choose from this list:"); 

        puts (list) ; 

        do 

        { 

            while( scanf("%d", &seat) != 1) 

            { 

                scanf("%*s"); 

                puts("Enter a number from this list:"); 

                puts (list) ; 

            } 

            if (seat < 1 || seat > SEAT S || 

                pl[seat-1].status == TAKEN) 

            { 

                puts("Enter a number from this list:"); 

                puts (list) ; 

                loop = CONTINUE; 

            } 

            else 

                loop = DONE; 

        } wh ile (loop == CONTINUE); 

        while (getchar() != '

        show_seats(pl, n); 

        makelist(p l, list, T AKEN); 

        puts("Enter the number of the seat to be cancelled :"); 

        do 

        { 

            while( scanf("%d", &seat) != 1) 

            { 

                scanf("%*s"); 

                puts("Enter a number from this list:"); 

                puts (list) ; 

            } 

            if (seat < 1 || seat > SEAT S || 

                 pl[seat-1].status == EMPTY) 

            { 

                puts("Enter a number from this list:"); 

                puts (list) ; 

                loop = CONTINUE; 

            } 

            else 

                loop = DONE; 

        } wh ile (loop == CONTINUE); 

        while (getchar() != '

        } 

        else 

            puts("Passenger retained."); 

    } 

} 

void show_seats(const struct planestats pl[], int n) 

{ 

    int i; 

    puts("Seats currently taken:"); 

    for (i = 0; i < SEAT S; i++) 

        if (pl[i].status == TAKEN) 

            printf("Seat %d: %s, %s

} 

PE 14-10 

/* pe14-10.c */ 

/* the tricky part is declar ing an array of pointers to functions */ 

#inc lude <stdio.h> 

#inc lude <math.h> 

doub le twice(doub le x); 

doub le half(doub le x); 

doub le thr ice(doub le x); 

void showmenu(void); 

#define NUM 4 

int main(void) 

{ 

    double (*pf[NUM])(double)  = {twice, half, thrice, sqrt}; 

    double val; 

    double ans; 

    int sel; 

    printf("Enter a number (negative to quit): "); 

    wh ile (scanf("% lf", &val) && val >= 0) 

    { 

        showmenu(); 

        while (scanf("%d", &sel) && sel >= 0 && sel <= 3) 

        { 

            ans = (*pf[sel])(val); 

            printf("answer = %f

        } 

        printf("Enter nex t number (negative to quit): "); 

    }     

    puts("bye"); 

    return 0; 

} 

void showmenu(void) 

{ 

    puts("Enter one of the following cho ices:"); 

    puts("0) double the value        1) halve the value"); 

    puts("2) trip le the value        3) squareroot the value"); 

    puts("4) nex t number"); 

} 

doub le twice(doub le x) {return 2.0 * x ;} 

doub le half(doub le x) {return x / 2.0;}; 

doub le thr ice(doub le x) {return 3.0 * x ;} 

Chapter 15 

PE 15-1 

/* pe15-1.c */ 

#inc lude <stdio.h> 

#inc lude <stdbool.h>  // C99 -- otherwise use int 

int bstr_to_dec(const char * str); 

bool check_val(const char * str); 

int main(void) 

{ 

    char value[8* sizeof (int) + 1]; 

    printf("Enter a binary number with up to %d dig its: ", 8 * sizeof(int)); 

    wh ile (gets(value) && value[0] != '

{ 

    bool valid = true; 

    wh ile (valid && *str != '

        fprintf(stderr, "Usage: %s binarynum1 binarynum2

    for (i = size - 1; i >= 0; i--, n >>= 1) 

        ps[i] = (01 & n) + '0'; 

    ps[size] = '

    int i; 

    static int size = 8 * sizeof(int); 

    for (i = size - 1; i >= 0; i--, n >>= 1) 

        ps[i] = (01 & n) + '0'; 

    ps[size] = '

    unsigned int rot; 

    unsigned int p laces; 

    char bstr1[8* sizeof (int) + 1]; 

    char bstr2[8* sizeof (int) + 1]; 

    printf("Enter an integer (0 to quit): "); 

    wh ile (scanf("%ud", &val) && val > 0) 

    { 

        printf("Enter the number of bits to be rotated: 

    return (n << b) | overflow; 

} 

char * itobs(int n, char * ps) 

{ 

    int i; 

    static int size = 8 * sizeof(int); 

    for (i = size - 1; i >= 0; i--, n >>= 1) 

        ps[i] = (01 & n) + '0'; 

    ps[size] = '

#define STY LE_MASK  0xE0000 

#define SIZE_SHIFT  8 

typedef unsigned lo ng font; 

char do_menu(font * f); 

char get_choice(const char *); 

void show_menu(void); 

void show_font(font f); 

void eatline(void); 

void get_id(font * f); 

void get_size(font * f); 

void get_align(font * f); 

int main(void) 

{ 

    font sample = 1 | (12 <<SIZE_SHIFT) | LEFT | ITALIC; 

    wh ile (do_menu(&sample) != 'q') 

        continue; 

    puts("Bye!"); 

    return 0; 

} 

char do_menu(font * f) 

{ 

    char response; 

    show_font(*f); 

    show_menu(); 

    response = get_choice("fsabiuq"); 

    switch(response) 

    { 

        case 'f' : get_id(f); break; 

        case 's' : get_size(f); break; 

        case 'a' : get_align(f); break; 

        case 'b' : *f ^= BOLD; break; 

        case 'i' : *f ^= ITALIC; break; 

        case 'u' : *f ^= UNDERLINE; break; 

        case 'q' : break; 

        default  : fprintf(stderr, "menu problem

    } 

    return ch; 

} 

void eatline(void) 

{ 

    wh ile (getchar() != '

    } 

    printf("%8s %3s %3s

    puts("l)left   c)center   r)right"); 

    switch (get_choice(" lcr")) 

    { 

        case 'l' : *f &= ~ALIGN_MASK; *f |= LEFT ; break; 

        case 'c' : *f &= ~ALIGN_MASK; *f |= CENT ER; break; 

          case 'r' : *f &= ~ALIGN_MASK; *f |= RIGHT ; break; 

          default  : fprintf(stderr, "alignment problem

PE 16-3 

/* pe16-3.c */ 

#inc lude <stdio.h> 

#inc lude <math.h> 

struct polar { 

    double r; 

    double theta;   /* angle in degrees */ 

}; 

struct rect { 

    double x ; 

    double y; 

}; 

struct rect p_to_r(const struct polar * ppol); 

int main(void) 

{ 

    struct polar input; 

    struct rect answer; 

    wh ile (scanf("% lf % lf", &input.r, &input.theta) == 2) 

    { 

        answer = p_to_r(&input); 

        printf("polar coord: %g %f

    } 

    puts("Bye"); 

    return 0; 

} 

struct rect p_to_r(const struct polar * ppol) 

{ 

    static const double deg_rad = 3.141592654 / 180.0; 

    struct rect res; 

    double ang = deg_rad * ppol->theta;  /* convert degrees to radians */ 

    res.x = ppol->r * sin(ang); 

    res.y = ppol->r * cos(ang); 

    return res; 

} 

PE 16-5 

/* pe16-5.c */#inc lude <stdio.h># inc lude <time.h>void wa it(doub le t);void 
random_pick( int ar[], int arsize, int p icks); 

#define SPOT S 51 

#define PICKS 6 

int main() 

{ 

    int lotto[SPOT S]; 

    int i; 

    char ch; 

    for (i = 0; i < SPOT S; i++) 

        lotto[i] = i + 1; 

    do { 

        random_pick( lotto, SPOT S, PICKS); 

        printf ("Again? <y/n> "); 

        ch = getchar(); 

        while (getchar() != '

        printf ("%2d ", temp);         /* display it                */ 

        if (i % 20 == 19) 

            putchar('

    return 0; 

} 

void show_array(const double ar[], int n) 

{ 

    int i; 

    for (i = 0; i < n; i++) 

        printf("%g ", ar[i]); 

    putchar('

/* pe17-1a.c  recursive solut ion */#inc lude <stdio.h> 

#inc lude <stdlib.h>      /* has the malloc prototype      */ 

#inc lude <string.h>      /* has the strcpy prototype      */ 

#define T SIZE    45      /* size of array to hold t it le   */ 

struct film { 

   char tit le[T SIZE]; 

   int rating ; 

   struct film * nex t;   /* points to nex t struct in list */ 

}; 

void show_rec(const struct film * pf); /* recursive function */ 

int main(void) 

{ 

   struct film * head = NULL; 

   struct film * prev , * current; 

   char input[T SIZE]; 

   puts("Enter first mov ie tit le:"); 

   while (gets(input) != NULL && input[0] != '

      while(getchar() != '

/* pe17-1b.c -- double- link solut io n */#inc lude <stdio.h># inc lude <stdlib.h>      /* 
has the malloc prototype      */ 

#inc lude <string.h>      /* has the strcpy prototype      */ 

#define T SIZE    45      /* size of array to hold t it le   */ 

struct film { 

   char tit le[T SIZE]; 

   int rating ; 

   struct film * nex t;   /* points to nex t struct in list */ 

   struct film * prev;   /* points to prev ious struct     */ 

}; 

int main(void) 

{ 

    struct film * head = NULL; 

    struct film * prev, * current; 

    char input[T SIZE]; 

    puts("Enter first mov ie tit le :"); 

    wh ile (gets(input) != NULL && input[0] != '

            prev ->nex t = current; 

            current->prev = prev; 

        } 

        current->nex t = NULL; 

        strcpy(current->tit le, input); 

        puts("Enter your rating <0-10>:"); 

        scanf("%d", &current->rating); 

        while(getchar() != '

                    current->rating); 

            current = current->prev; 

        } 

    } 

    printf("Bye!

   Item item; 

   struct node * nex t; 

} Node; 

#define MAXSIZE 100 

typedef struct list 

{ 

    Item entries[MAXSIZE];    /* array of items */ 

    int items;                /* number of items */ 

} List; 

/* function prototypes */ 

/* operation:        in it ia lize a list                          */ 

/* precondit ions:    plist points to a list                     */ 

/* postcondit io ns:   the list is in it ia lized to empty           */ 

void Init ia lizeL ist(L ist * plist); 

/* operation:        determ ine if list is empty                 */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/* postcondit io ns:   function returns true if list is empty     */ 

/*                   and returns false otherwise                */ 

bool L istIsEmpty(const List * plist); 

/* operation:        determ ine if list is full                  */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/* postcondit io ns:   function returns true if list is full      */ 

/*                   and returns false otherwise                */ 

bool L istIsFull(const L ist * plist); 

/* operation:        determ ine number of items in list          */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/* postcondit io ns:   function returns number of items in list   */ 

unsigned int L istItemCount(const List * plist); 

/* operation:        add item to end of list                    */ 

/* precondit ions:    item is an item to be added to list        */ 

/*                   plist points to an in it ia lized list        */ 

/* postcondit io ns:   if possib le, function adds item to end     */ 

/*                   of list and returns true; otherwise the    */ 

/*                   function returns false                     */ 

bool AddItem(Item item, List * plist); 

/* operation:        apply a function to each item in list      */ 

/* precondit ions:    l is an in it ia lized list                   */ 

/*                   pfun points to a function that takes an    */ 

/*                   Item argument and has no return value      */ 

/* postcondit io n:    the function po inted to by pfun is         */ 

/*                   executed once for each item in the list    */ 

void T raverse (const List * plist, void (* pfun)(Item item) ); 

/* operation:        free allocated memory , if any              */ 

/*                   plist points to an in it ia lized list        */ 

/* postcondit io ns:   any memory allocated for the list is freed */ 

/*                   and the list is set to empty               */ 

void EmptyT heList(List * plist); 

#endif 

/* pe17-3a.c -- a copy of films3.c  */ 

/* compile with pe17-3b.c                        */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h>    /* prototype for ex it() */ 

#inc lude "list17-3.h"  /* defines List, Item   */ 

void showmov ies(Item item); 

int main(void) 

{ 

    List mov ies; 

    Item temp; 

/* in it ia lize       */ 

    Init ia lizeL ist(&mov ies); 

    if (ListIsFull(&mov ies)) 

    { 

        fprintf(stderr,"No memory availab le ! Bye!

        { 

            fprintf(stderr,"Problem allocat ing memory

void showmov ies(Item item) 

{ 

    printf("Mov ie: %s  Rating: %d

       if (plist-> items == MAXSIZE) 

           return true; 

       else 

           return false; 

} 

/* returns number of items in list */ 

unsigned int L istItemCount(const List * plist) 

{ 

     return plist-> items; 

} 

/* adds item to list */ 

/* assumes = operator defined for type Item */ 

bool AddItem(Item item, List * plist) 

{ 

    if (plist-> items == MAXSIZE) 

        return false; 

    else 

    { 

        plist->entries[p list-> items++] = item; 

        return true; 

    } 

} 

/* v isit each node and execute function pointed to by pfun */ 

void T raverse (const List * plist, void (* pfun)(Item item) ) 

{ 

   int i; 

   for (i = 0; i < plist-> items; i++) 

      (*pfun)(plist->entr ies[ i]);   /* apply function to item in list */ 

} 

/* malloc() not used, nothing need be deallocated */ 

/* set items member to 0                          */ 

void EmptyT heList(List * plist) 

{ 

      plist-> items = 0; 

} 

PE 17-5 

/* pe17-5.h --header file for a stack type */ 

#ifndef ST ACK_H_ 

#define ST ACK_H_ 

#inc lude <stdbool.h>  /* C99 */ 

/* enum bool {false, true}; */  /* pre -C99*/ 

/* INSERT ITEM TYPE HERE */ 

/* FOR EXAMPLE, typedef int Item; */ 

typedef char  Item; 

#define MAXSTACK 100 

typedef struct stack 

{ 

    Item items[MAXST ACK];   /* holds info                */ 

    int top;                /* index of first empty slot */ 

} Stack; 

/* operation:       in it ia lize the stack                */ 

/* precondit ion:    ps points to a stack                */ 

/* postcondit io n:   stack is in it ia lized to being empty */ 

void Init ia lizeStack(Stack * ps); 

/* operation:       check if stack is full                     */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/* postcondit io n:   returns T rue if stack is full, else False  */ 

bool Fu llStack(const Stack * ps); 

/* operation:       check if stack is empty                    */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/* postcondit io n:   returns T rue if stack is empty, else False */ 

bool EmptyStack(const Stack *ps); 

/* operation:       push item onto top of stack                */ 

/* precondit ion:    ps points to prev ious ly in it ia lized stack  */ 

/*                  item is to be placed on top of stack       */ 

/* postcondit io n:   if stack is not empty , item is placed at   */ 

/*                  top of stack and function returns          */ 

/*                  T rue; otherwise , stack is unchanged and    */ 

/*                  function returns False                     */ 

bool Push(Item item, Stack * ps); 

/* operation:       remove item from top of stack              */ 

/* precondit ion:    ps points to prev ious ly in it ia lized st ack  */ 

/* postcondit io n:   if stack is not empty , item at top of      */ 

/*                  stack is copied to *pitem and deleted from */ 

/*                  stack, and function returns T rue; if the   */ 

/*                  operation empties the stack, the stack is  */ 

/*                  reset to empty. If the stack is empty to   */ 

/*                  begin wit h, stack is unchanged and the     */ 

/*                  function returns False                     */ 

bool Pop(Item *pitem, Stack * ps); 

#endif 

/* pe17-5a.c */ 

#inc lude <stdio.h> 

#inc lude "pe17-5.h" 

#define SLEN 81 

int main(void) 

{ 

    Stack stch; 

    char temp[SLEN]; 

    int i; 

    char ch; 

    Init ia lizeStack(&stch); 

    printf("Enter a line (an empty line to quit): 

        while (!EmptyStack(&stch)) 

        { 

            Pop(&ch, &stch); 

            putchar(ch); 

        } 

        putchar('

bool EmptyStack(const Stack *ps) 

{ 

    return ps->top == 0; 

}     

bool Push(Item item, Stack * ps) 

{ 

    if (ps->top == MAXST ACK) 

        return false; 

    else 

    { 

        ps->items[ps->top++] = item; 

        return true; 

    } 

} 

bool Pop(Item *pitem, Stack * ps) 

{ 

    if (ps->top == 0) 

        return false; 

    else 

    { 

        ps->top--; 

        *pitem = ps->items[ps->top]; 

        return true; 

    } 

} 

PE 17-7 

/* tree.h -- binary search tree */ 

/*           no duplicate items are allowed in th is tree */ 

#ifndef _T REE_H_ 

#define _T REE_H_ 

#inc lude <stdbool.h>  /* C99 */ 

/* enum bool {false, true}; */  /* pre -C99*/ 

#define SLEN 81 

/* redefine Item as appropriate */ 

typedef struct item 

{ 

    char wrd[SLEN];  

    int count;       

} Item; 

#define MAXIT EMS 100 

typedef struct node 

{ 

    Item item; 

    struct node * left;    /* pointer to right branch  */ 

    struct node * right;   /* pointer to left branch   */ 

} Node; 

typedef struct tree 

{ 

    Node * root;           /* pointer to root of tree  */ 

    int size;              /* number of items in tree  */ 

} T ree; 

/* function prototypes */ 

/* operation:      in it ia lize a tree to empty          */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: the tree is in it ia lized to empty    */ 

void Init ia lizeT ree(T ree * ptree); 

/* operation:      determ ine if tree is empty          */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: function returns true if tree is    */ 

/*                 empty and returns false otherwise   */ 

bool T reeIsEmpty(const T ree * ptree); 

/* operation:      determ ine if tree is fu ll           */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: function returns true if tree is    */ 

/*                 full and returns false otherwise    */ 

bool T reeIsFull(const T ree * ptree); 

/* operation:      determ ine number of items in tree   */ 

/* precondit ions:  ptree points to a tree              */ 

/* postcondit io ns: function returns number of items in */ 

/*                 tree                                */ 

int T reeItemCount(const T ree * ptree); 

/* operation:      add an item to a tree               */ 

/* precondit ions:  pi is address of item to be added   */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: if possib le, function adds item to  */ 

/*                 tree and returns true; otherwise,    */ 

/*                 the function returns false          */ 

bool AddItem(const Item * pi, T ree * ptree); 

/* operation:      find an item in a tree              */ 

/* precondit ions:  pi po ints to an item                */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: function returns true if item is in */ 

/*                 tree and returns false otherwise    */ 

bool InT ree(const Item * pi, const Tree * ptree); 

/* operation:      delete an item from a tree          */ 

/* precondit ions:  pi is address of item to be deleted */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: if possib le, function de letes item  */ 

/*                 from tree and returns true;         */ 

/*                 otherwise, the function returns false*/ 

bool De leteItem(const Item * pi, T ree * ptree); 

/* operation:      apply a function to each item in    */ 

/*                 the tree                            */ 

/* precondit ions:  ptree points to a tree              */ 

/*                 pfun points to a function that takes*/ 

/*                 an Item argument and has no return  */ 

/*                 value                               */ 

/* postcondit io n:  the function po inted to by pfun is  */ 

/*                 executed once for each item in tree */ 

void T raverse (const Tree * ptree, void (* pfun)(Item item)); 

/* operation:      delete everything from a tree       */ 

/* precondit ions:  ptree points to an in it ia lized tree */ 

/* postcondit io ns: tree is empty                       */ 

void DeleteA ll(T ree * ptree); 

/* operation:      return address of item in a tree    */ 

/* precondit ions:  pi po ints to an item                */ 

/*                 ptree points to an init ia lized tree */ 

/* postcondit io ns: function returns address if item is */ 

/*                 in tree and returns NULL otherwise  */ 

const Item * WhereInT ree(const Item * pi, const T ree * ptree); 

#endif 

/* pe17-7a.c */ 

#inc lude <stdio.h> 

#inc lude <stdlib.h> 

#inc lude <string.h> 

#inc lude <ctype.h> 

#inc lude "pe17-7.h" 

void pr int item(Item item); 

char menu(void); 

void showwords (const T ree * pt); 

void findword (const T ree * pt); 

#define SLEN 81 

int main(void) 

{ 

    T ree wordcount; 

    FILE * fp; 

    char filename[SLEN]; 

    char word[SLEN]; 

    Item entry; 

    char choice; 

    printf ("Enter name of file to be processed: 

        } 

    } 

   fclose(fp); 

   puts("Done"); 

   return 0; 

} 

char menu(void) 

{ 

    int ch; 

    puts("Word counting program"); 

    puts("Enter the letter corresponding to your choice:"); 

    puts("s) show word list     f) find a word"); 

    puts("q) quit"); 

    wh ile ((ch = getchar() ) != EOF) 

    { 

        while (getchar() != '

} 

void showwords (const T ree * pt) 

{ 

    if (T reeIsEmpty(pt)) 

        puts("No entries!"); 

    else 

        T raverse(pt, print item); 

} 

void findword (const T ree * pt) 

{ 

    char word[SLEN]; 

    Item entry; 

    const Item * pi; 

    if (T reeIsEmpty(pt)) 

    { 

        puts("No entries!"); 

        return;     /* quit function if tree is empty */ 

    } 

    printf("Enter the word to find: "); 

    scanf("%s", word); 

    wh ile (getchar() != '

    else 

        printf("%s appears %d times.

static void DeleteA llNodes(Node * ptr); 

/* function defin it ions */ 

void Init ia lizeT ree(T ree * ptree) 

{ 

    ptree->root = NULL; 

    ptree->size = 0; 

} 

bool T reeIsEmpty(const T ree * ptree) 

{ 

    if (ptree->root == NULL) 

        return true; 

    else 

        return false; 

} 

bool T reeIsFull(const T ree * ptree) 

{ 

    if (ptree->size == MAXIT EMS) 

        return true; 

    else 

        return false; 

} 

int T reeItemCount(const T ree * ptree) 

{ 

    return ptree->size; 

} 

bool AddItem(const Item * pi, T ree * ptree) 

{ 

    Node * new; 

    Pair  seek; 

    if (T reeIsFull(ptree)) 

    { 

        fprintf(stderr,"T ree is full

bool InT ree(const Item * pi, const Tree * ptree) 

{ 

    return (SeekItem(pi, ptree).child == NULL) ? false : true; 

} 

const Item * WhereInT ree(const Item * pi, const T ree * ptree) 

{ 

    Node * pn; 

    pn = SeekItem(pi,ptree).child; 

    if (pn != NULL) 

        return &(pn->item); 

    else return NULL; 

} 

bool De leteItem(const Item * pi, T ree * ptree) 

{ 

    Pair look; 

    look = SeekItem(pi, ptree); 

    if (look.ch ild == NULL) 

        return false; 

    if (look.ch ild -> item.count > 0) 

            look.child-> item.count--; 

    else 

    {            

        if (look.parent == NULL)      /* delete root item       */ 

            DeleteNode(&ptree->root); 

        else if (look.parent-> left == look.child) 

            DeleteNode(&look.parent->left); 

        else 

            DeleteNode(&look.parent->right); 

        ptree->size--; 

    } 

    return true; 

} 

void T raverse (const Tree * ptree, void (* pfun)(Item item)) 

{ 

    if (ptree != NULL) 

        InOrder(ptree->root, pfun); 

} 

void DeleteA ll(T ree * ptree) 

{ 

    if (ptree != NULL) 

        DeleteAllNodes(ptree->root); 

    ptree->root = NULL; 

    ptree->size = 0; 

} 

/* local funct ions */ 

static void InOrder(const Node * root, void (* pfun)(Item item)) 

{ 

    if (root != NULL) 

    { 

        InOrder(root->left, pfun); 

        (*pfun)(root->item); 

        InOrder(root->right, pfun); 

    } 

} 

static void DeleteA llNodes(Node * root) 

{ 

    Node * pright; 

    if (root != NULL) 

    { 

        pright = root->right; 

        DeleteAllNodes(root-> left); 

        free(root); 

        DeleteAllNodes(pr ight); 

    } 

} 

static void AddNode (Node * new_node, Node * root) 

{ 

    if (T oLeft(&new_node->item, &root->item)) 

    { 

        if (root->left == NULL)      /* empty subtree       */ 

            root->left = new_node;   /* so add node here    */ 

        else 

            AddNode(new_node, root->left);/* else process subtree*/ 

    } 

    else if (T oRight(&new_node-> item, &root->item)) 

    { 

        if (root->right == NULL) 

            root->right = new_node; 

        else 

            AddNode(new_node, root->right); 

    } 

    else                         /* should be no duplicates */ 

    { 

        fprintf(stderr,"locat ion error in AddNode()

    if (new_node != NULL) 

    { 

        new_node->item = *pi; 

        new_node->item.count = 1; 

        new_node->left = NULL; 

        new_node->right = NULL; 

    } 

    return new_node; 

} 

static Pair SeekItem(const Item * pi, const T ree * ptree) 

{ 

    Pair look; 

    look.parent = NULL; 

    look.ch ild = ptree->root; 

    if (look.ch ild == NULL) 

        return look;                        /* early return   */ 

    wh ile (loo k.child != NULL) 

    { 

        if (ToLeft(pi, &(look.child -> item))) 

        { 

            look.parent = look.child; 

            look.child = look.ch ild -> left; 

        } 

        else if (T oRight(p i, &(look.ch ild -> item))) 

        { 

            look.parent = look.child; 

            look.child = look.ch ild ->r ight ; 

        } 

        else       /* must be same if not to left or right    */ 

            break; /* look.child is address of node with item */ 

    } 

    return look;                       /* successful return   */ 

} 

static void DeleteNode(Node **ptr) 

/* ptr is address of parent member point ing to target node  */ 

{ 

    Node * temp; 

    if ( (*ptr)->left == NULL) 

    { 

        temp = *ptr; 

        *ptr = (*ptr)->right; 

        free(temp); 

    } 

    else if ( (*ptr) ->right == NULL) 

    { 

        temp = *ptr; 

        *ptr = (*ptr)->left; 

        free(temp); 

    } 

    else    /* deleted node has two children */ 

    { 

        /* find where to reattach right subtree */ 

        for (temp = (*ptr) ->left; temp->right != NULL; 

                temp = temp->right) 

            continue; 

        temp->right = (*ptr)->right; 

        temp = *ptr; 

        *ptr =(*ptr)->left; 

        free(temp); 

    } 

} 

